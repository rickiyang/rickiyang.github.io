<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rickiyang&#39;s blog</title>
  
  <subtitle>java,大数据,分布式组件</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.rickiyang.cn/"/>
  <updated>2019-01-08T01:50:48.503Z</updated>
  <id>http://blog.rickiyang.cn/</id>
  
  <author>
    <name>Rickiyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux时间配置同步</title>
    <link href="http://blog.rickiyang.cn/posts/f1a04f3f.html"/>
    <id>http://blog.rickiyang.cn/posts/f1a04f3f.html</id>
    <published>2019-01-08T15:15:45.000Z</published>
    <updated>2019-01-08T01:50:48.503Z</updated>
    
    <content type="html"><![CDATA[<p>在家里玩虚拟机，不时发现因为多台机器时间不同步问题导致Hbase无法使用，所以查询了一下linux配置同步互联网时间。</p><p>在系统中查看时间可以使用date命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoopmaster conf]$ date</span><br><span class="line">2019年 01月 08日 星期二 00:12:52 CST</span><br></pre></td></tr></table></figure><p>date显示的是系统时间，那如何让硬件，比如CPU也去同步这个时间呢，linux提供了hwclock命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示硬件时间</span></span><br><span class="line">[root@hadoopmaster conf]# hwclock</span><br><span class="line">2019年01月08日 星期二 00时15分54秒  -0.756066 seconds</span><br><span class="line"><span class="meta">#</span><span class="bash">将系统时间写入到硬件中去</span></span><br><span class="line">[root@hadoopmaster conf]# hwclock -w</span><br></pre></td></tr></table></figure><p>linux提供了同步互联网时间的工具：ntpdate。ntpdate是一个linux时间同步工具，安装ntpdate：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ntpdate</span><br></pre></td></tr></table></figure><p>使用ntpdate同时时间：</p><p>输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoopmaster conf]# ntpdate ntp1.aliyun.com</span><br><span class="line"> 8 Jan 00:19:41 ntpdate[24074]: adjust time server 120.25.115.20 offset -0.014956 sec</span><br></pre></td></tr></table></figure><p>这是阿里云提供的授时中心，还有一些可以用的：</p><p><span class="exturl" data-url="aHR0cDovL3RpbWUubnVyaS5uZXQ=" title="http://time.nuri.net">time.nuri.net<i class="fa fa-external-link"></i></span></p><p>同步完成以后，将时间写入硬件中:</p><p>hwclock -w</p><p>执行以后你可以查看系统时间是否是当前最新时间：date。</p><p>以上就是更新系统时间的方法，当然，如果我们想省事，可以写个定时任务去拉最新时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>打开定时任务列表，添加我们的定时任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * root ntpdate ntp1.aliyun.com;hwclock -w</span><br></pre></td></tr></table></figure><p>上面的定时任务表示：每一小时去阿里云授时中心同步一次，然后写入硬件。当然你也可以将频次调的更快一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在家里玩虚拟机，不时发现因为多台机器时间不同步问题导致Hbase无法使用，所以查询了一下linux配置同步互联网时间。&lt;/p&gt;
&lt;p&gt;在系统中查看时间可以使用date命令：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="linux系统维护" scheme="http://blog.rickiyang.cn/categories/linux%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="系统维护" scheme="http://blog.rickiyang.cn/tags/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>html转图片-wkhtmltopdf使用</title>
    <link href="http://blog.rickiyang.cn/posts/4ceb55a2.html"/>
    <id>http://blog.rickiyang.cn/posts/4ceb55a2.html</id>
    <published>2019-01-02T08:19:22.000Z</published>
    <updated>2019-01-04T01:52:36.434Z</updated>
    
    <content type="html"><![CDATA[<p>目前java将html转为图片的可用方法不是很多，有如下工具可以使用：</p><p>html2image: 坑太多，不会加载第三方的css样式；</p><p>cssbox：使用起来相对会好一些，但是如果网页内样式比较多的情况下，部分样式会乱掉；其次，如果网页内包含图片，图片会损失很多细节；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wkhtmltopdf：本来是设计用于html转pdf的，但是也可以转图片。这个使用起来各方面良好，唯一不好的地方就是他是一个软件，必须的安装才能使用。</span><br></pre></td></tr></table></figure><p>因为目前使用的是wkhtmltopdf这个方案，下面就介绍这个方案的使用方式吧。</p><h4 id="1安装"><a class="markdownIt-Anchor" href="#1安装"></a> 1.安装</h4><p>官网地址如下：<br><span class="exturl" data-url="aHR0cHM6Ly93a2h0bWx0b3BkZi5vcmcv" title="https://wkhtmltopdf.org/">https://wkhtmltopdf.org/<i class="fa fa-external-link"></i></span></p><p><img src="https://i.imgur.com/ZWv1EvT.png" alt=""></p><p>需要去其官网下载对应环境的软件，支持windows，linux，mac。</p><p><strong>特别注意：</strong></p><p><strong>linux一定要注意系统版本，是什么系统一定要安装对应系统的包，否则gg。centos一定注意区分是6还是7，安装对应的包。</strong></p><p>查看系统版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop /data/service]# cat /etc/os-release</span><br><span class="line">NAME="CentOS Linux"</span><br><span class="line">VERSION="7 (Core)"</span><br><span class="line">ID="centos"</span><br><span class="line">ID_LIKE="rhel fedora"</span><br><span class="line">VERSION_ID="7"</span><br><span class="line">PRETTY_NAME="CentOS Linux 7 (Core)"</span><br><span class="line">ANSI_COLOR="0;31"</span><br><span class="line">CPE_NAME="cpe:/o:centos:centos:7"</span><br><span class="line">HOME_URL="https://www.centos.org/"</span><br><span class="line">BUG_REPORT_URL="https://bugs.centos.org/"</span><br><span class="line"> </span><br><span class="line">CENTOS_MANTISBT_PROJECT="CentOS-7"</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION="7"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT="centos"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION="7"</span><br></pre></td></tr></table></figure><h4 id="2-下载对应的包去安装"><a class="markdownIt-Anchor" href="#2-下载对应的包去安装"></a> 2. 下载对应的包去安装</h4><p>wkhtmltox-0.12.5-1.centos7.x86_64.rpm</p><p>安装：</p><p>rpm -ivh wkhtmltox-0.12.5-1.centos7.x86_64.rpm</p><p>然后你会发现如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop ~]# rpm -ivh wkhtmltox-0.12.5-1.centos7.x86_64.rpm</span><br><span class="line">错误：依赖检测失败：</span><br><span class="line">    fontconfig 被 wkhtmltox-1:0.12.5-1.centos7.x86_64 需要</span><br><span class="line">    libX11 被 wkhtmltox-1:0.12.5-1.centos7.x86_64 需要</span><br><span class="line">    libXext 被 wkhtmltox-1:0.12.5-1.centos7.x86_64 需要</span><br><span class="line">    libXrender 被 wkhtmltox-1:0.12.5-1.centos7.x86_64 需要</span><br><span class="line">    libjpeg 被 wkhtmltox-1:0.12.5-1.centos7.x86_64 需要</span><br><span class="line">    libpng 被 wkhtmltox-1:0.12.5-1.centos7.x86_64 需要</span><br><span class="line">    xorg-x11-fonts-75dpi 被 wkhtmltox-1:0.12.5-1.centos7.x86_64 需要</span><br><span class="line">    xorg-x11-fonts-Type1 被 wkhtmltox-1:0.12.5-1.centos7.x86_64 需要</span><br><span class="line">[root@hadoop ~]#</span><br></pre></td></tr></table></figure><p>缺少相关包，所以你需要将缺失的包补充完整。当然机器不同，包缺失的情况也不一样，随机应变。</p><p>安装包使用如下命令：yum install packageName</p><p>所有的依赖安装完成以后，接着执行rpm命令应该是可以的，安装完毕你可以检测是否可用，使用如下命令看是否存在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop ]# wkhtmltoimage</span><br><span class="line">You need to specify at least one input file, and exactly one output file</span><br><span class="line">Use - for stdin or stdout</span><br><span class="line"> </span><br><span class="line">Name:</span><br><span class="line">  wkhtmltoimage 0.12.5 (with patched qt)</span><br><span class="line"> </span><br><span class="line">Synopsis:</span><br><span class="line">  wkhtmltoimage [OPTIONS]... &lt;input file&gt; &lt;output file&gt;</span><br><span class="line"> </span><br><span class="line">Description:</span><br><span class="line">  Converts an HTML page into an image,</span><br><span class="line"> </span><br><span class="line">General Options:</span><br><span class="line">      --crop-h &lt;int&gt;                  Set height for cropping</span><br><span class="line">      --crop-w &lt;int&gt;                  Set width for cropping</span><br><span class="line">      --crop-x &lt;int&gt;                  Set x coordinate for cropping</span><br><span class="line">      --crop-y &lt;int&gt;                  Set y coordinate for cropping</span><br><span class="line">  -H, --extended-help                 Display more extensive help, detailing</span><br><span class="line">                                      less common command switches</span><br><span class="line">  -f, --format &lt;format&gt;               Output file format</span><br><span class="line">      --height &lt;int&gt;                  Set screen height (default is calculated</span><br><span class="line">                                      from page content) (default 0)</span><br><span class="line">  -h, --help                          Display help</span><br><span class="line">      --license                       Output license information and exit</span><br><span class="line">      --log-level &lt;level&gt;             Set log level to: none, error, warn or</span><br><span class="line">                                      info (default info)</span><br><span class="line">      --quality &lt;int&gt;                 Output image quality (between 0 and 100)</span><br><span class="line">                                      (default 94)</span><br><span class="line">  -q, --quiet                         Be less verbose, maintained for backwards</span><br><span class="line">                                      compatibility; Same as using --log-level</span><br><span class="line">                                      none</span><br><span class="line">  -V, --version                       Output version information and exit</span><br><span class="line">      --width &lt;int&gt;                   Set screen width, note that this is used</span><br><span class="line">                                      only as a guide line. Use</span><br><span class="line">                                      --disable-smart-width to make it strict.</span><br><span class="line">                                      (default 1024)</span><br><span class="line"> </span><br><span class="line">Contact:</span><br><span class="line">  If you experience bugs or want to request new features please visit</span><br><span class="line">  &lt;https://github.com/wkhtmltopdf/wkhtmltopdf/issues&gt;</span><br></pre></td></tr></table></figure><p>这样说明已经 安装成功了。该命令是将网页生成图片的命令。</p><p>你可以直接测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wkhtmltoimage https://guagua-workplatform.guazi.com/jobEmail.html /data/www/account/aaa.jpg</span><br></pre></td></tr></table></figure><p>去/data/www/目录下看是否生成照片。</p><h4 id="3使用java调用"><a class="markdownIt-Anchor" href="#3使用java调用"></a> 3.使用java调用</h4><p>接下来我们写java代码吧。其实java代码也只是使用exec去调用linux命令，所以代码很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 上午8:28 2018/12/31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 使用wkhtmltopdf将html生成图片</span></span><br><span class="line"><span class="comment"> * ------------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * api请参见：https://wkhtmltopdf.org/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *******使用之前需要安装该软件*******</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ------------------------------</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomwkhtmltopdfmlToPicUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OS_NAME = <span class="string">"os.name"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINUX = <span class="string">"Linux"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAC = <span class="string">"Mac OS X"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXEC_SUFFIX = <span class="string">"wkhtmltoimage --width 851 --quality 95 "</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EMAIL_TEMPLATE_URL = <span class="string">"http://www.baidu.com"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成照片</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">generatePic</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String picPath = Constant.PIC_ADDRESS + fileName + Constant.PIC_SUFFIX;</span><br><span class="line">            String command = getCommand(EMAIL_TEMPLATE_URL, picPath);</span><br><span class="line">            Process process = Runtime.getRuntime().exec(command);</span><br><span class="line">            process.waitFor();  <span class="comment">//这个调用比较关键，就是等当前命令执行完成后再往下执行</span></span><br><span class="line">            LoggerUtils.info(<span class="string">"---执行完成-----"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            LoggerUtils.error(<span class="string">"生成照片出错，&#123;&#125;"</span>,e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拼装系统命令字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceFilePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetFilePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getCommand</span><span class="params">(String sourceFilePath, String targetFilePath)</span> </span>&#123;</span><br><span class="line">        String system = System.getProperty(OS_NAME);</span><br><span class="line">        <span class="keyword">if</span> (system.contains(LINUX) || system.contains(MAC)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EXEC_SUFFIX + sourceFilePath + <span class="string">" "</span> + targetFilePath;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(system.contains(<span class="string">"Windows"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> WINDOWS_PATH + sourceFilePath + <span class="string">" "</span> + targetFilePath;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以执行这段java代码，会在你指定的目录生成网页对应的图片。</p><h4 id="4使用参数来做更多"><a class="markdownIt-Anchor" href="#4使用参数来做更多"></a> 4.使用参数来做更多</h4><p>我们注意到上面其实是在执行命令：“wkhtmltoimage --width 851 --quality 95 ”</p><p>上面的&quot;–width&quot;是表示截图的宽，“–quality”表示图片的质量，默认是94%。</p><p>如果你还需要指定别的参数，那么你可以参看官方给的wiki：</p><p><span class="exturl" data-url="aHR0cHM6Ly93a2h0bWx0b3BkZi5vcmcvdXNhZ2Uvd2todG1sdG9wZGYudHh0" title="https://wkhtmltopdf.org/usage/wkhtmltopdf.txt">https://wkhtmltopdf.org/usage/wkhtmltopdf.txt<i class="fa fa-external-link"></i></span></p><h4 id="5遇到乱码怎么办"><a class="markdownIt-Anchor" href="#5遇到乱码怎么办"></a> 5.遇到乱码怎么办</h4><p>以上就是wkhtmltopdf的使用，当然可能你还会遇到别的问题，比如部署在服务器上的时候生成的照片是乱码。生成的图片中所有的中文全部都显示为 方块  这种乱码，一般会有两种可能：</p><p>1.查看你需要转图的网页字体： <meta charset="utf-8">。如果不是utf-8你可以将其改为utf-8;</p><p>2.服务器没有安装中文字体,这个也好确认，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fc-list</span><br><span class="line">[root@hadoop /data/service]# fc-list</span><br><span class="line">/usr/share/fonts/dejavu/DejaVuSansCondensed-Oblique.ttf: DejaVu Sans,DejaVu Sans Condensed:style=Condensed Oblique,Oblique</span><br><span class="line">/usr/share/fonts/dejavu/DejaVuSansCondensed-Bold.ttf: DejaVu Sans,DejaVu Sans Condensed:style=Condensed Bold,Bold</span><br><span class="line">/usr/share/fonts/zh_CN/MSYH.TTF: Microsoft YaHei:style=Regular,Normal</span><br><span class="line">/usr/share/X11/fonts/Type1/c0611bt_.pfb: Courier 10 Pitch:style=Bold Italic</span><br><span class="line">/usr/share/X11/fonts/Type1/UTBI____.pfa: Utopia:style=Bold Italic</span><br><span class="line">/usr/share/X11/fonts/Type1/c0419bt_.pfb: Courier 10 Pitch:style=Regular</span><br><span class="line">/usr/share/fonts/dejavu/DejaVuSans.ttf: DejaVu Sans:style=Book</span><br><span class="line">/usr/share/X11/fonts/Type1/c0648bt_.pfb: Bitstream Charter:style=Regular</span><br><span class="line">/usr/share/fonts/dejavu/DejaVuSans-Bold.ttf: DejaVu Sans:style=Bold</span><br><span class="line">/usr/share/X11/fonts/Type1/cursor.pfa: Cursor:style=Regular</span><br><span class="line">/usr/share/X11/fonts/Type1/UTB_____.pfa: Utopia:style=Bold</span><br><span class="line">/usr/share/X11/fonts/Type1/c0583bt_.pfb: Courier 10 Pitch:style=Bold</span><br><span class="line">/usr/share/X11/fonts/Type1/UTI_____.pfa: Utopia:style=Italic</span><br><span class="line">/usr/share/X11/fonts/Type1/c0582bt_.pfb: Courier 10 Pitch:style=Italic</span><br><span class="line">/usr/share/fonts/dejavu/DejaVuSansCondensed.ttf: DejaVu Sans,DejaVu Sans Condensed:style=Condensed,Book</span><br><span class="line">/usr/share/fonts/dejavu/DejaVuSans-ExtraLight.ttf: DejaVu Sans,DejaVu Sans Light:style=ExtraLight</span><br><span class="line">/usr/share/fonts/dejavu/DejaVuSansCondensed-BoldOblique.ttf: DejaVu Sans,DejaVu Sans Condensed:style=Condensed Bold Oblique,Bold Oblique</span><br><span class="line">/usr/share/X11/fonts/Type1/c0633bt_.pfb: Bitstream Charter:style=Bold Italic</span><br><span class="line">/usr/share/X11/fonts/Type1/c0649bt_.pfb: Bitstream Charter:style=Italic</span><br><span class="line">/usr/share/fonts/dejavu/DejaVuSans-Oblique.ttf: DejaVu Sans:style=Oblique</span><br><span class="line">/usr/share/X11/fonts/Type1/c0632bt_.pfb: Bitstream Charter:style=Bold</span><br><span class="line">/usr/share/fonts/dejavu/DejaVuSans-BoldOblique.ttf: DejaVu Sans:style=Bold Oblique</span><br><span class="line">/usr/share/X11/fonts/Type1/UTRG____.pfa: Utopia:style=Regular</span><br></pre></td></tr></table></figure><p>会显示你已经安装的字体，如果网页没有问题，你可以尝试安装中文字体，以微软雅黑字体为例：msyh.ttf 。自行下载，将该字体文件上传至服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装中文字体：</span><br><span class="line">    0、查看目前安装字体：fc-list</span><br><span class="line">    1、下载所需字体,例如msyh.ttf</span><br><span class="line">    2、mkdir /usr/share/fonts/zh_CN</span><br><span class="line">    3、mv msyh.ttf /usr/share/fonts/zh_CN</span><br><span class="line">    4、执行fc-cache -fv</span><br><span class="line">    5、查看是否安装成功：fc-list，查看是已安装</span><br></pre></td></tr></table></figure><p>稍后你再执行java程序，应该就正常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前java将html转为图片的可用方法不是很多，有如下工具可以使用：&lt;/p&gt;
&lt;p&gt;html2image: 坑太多，不会加载第三方的css样式；&lt;/p&gt;
&lt;p&gt;cssbox：使用起来相对会好一些，但是如果网页内样式比较多的情况下，部分样式会乱掉；其次，如果网页内包含图片，
      
    
    </summary>
    
      <category term="java开发工具类" scheme="http://blog.rickiyang.cn/categories/java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="工具类" scheme="http://blog.rickiyang.cn/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Linux 查看文件夹大小，磁盘剩余空间（du/df）</title>
    <link href="http://blog.rickiyang.cn/posts/24a4bcf2.html"/>
    <id>http://blog.rickiyang.cn/posts/24a4bcf2.html</id>
    <published>2018-12-23T02:11:22.000Z</published>
    <updated>2018-12-24T03:06:25.079Z</updated>
    
    <content type="html"><![CDATA[<p>du查看目录大小，df查看磁盘使用情况。</p><h4 id="du"><a class="markdownIt-Anchor" href="#du"></a> du</h4><p>（1）基本功能<br>递归查看文件夹下所有文件的大小<br>（2）常用参数：<br>-h, –human-readable 以可读性较好的方式显示尺寸(例如：1K 234M 2G)<br>-s, –summarize 只分别计算命令列中每个参数所占的总用量<br>（3）其它参数说明：<br>-a, –all 输出所有文件的磁盘用量，不仅仅是目录<br>–apparent-size 显示表面用量，而并非是磁盘用量；虽然表面用量通常会小一些，但有时它会因为稀疏文件间的”洞”、内部碎片、非直接引用的块等原因而变大。<br>-B, –block-size=大小 使用指定字节数的块<br>-b, –bytes 等于–apparent-size –block-size=1<br>-c, –total 显示总计信息<br>-D, –dereference-args 解除命令行中列出的符号连接<br>–files0-from=F 计算文件F 中以NUL 结尾的文件名对应占用的磁盘空间如果F 的值是”-“，则从标准输入读入文件名<br>-H 等于–dereference-args (-D)<br>-h, –human-readable 以可读性较好的方式显示尺寸(例如：1K 234M 2G)<br>–si 类似-h，但在计算时使用1000 为基底而非1024<br>-k 等于–block-size=1K<br>-l, –count-links 如果是硬连接，就多次计算其尺寸<br>-m 等于–block-size=1M<br>-L, –dereference 找出任何符号链接指示的真正目的地<br>-P, –no-dereference 不跟随任何符号链接(默认)<br>-0, –null 将每个空行视作0 字节而非换行符<br>-S, –separate-dirs 不包括子目录的占用量<br>-s, –summarize 只分别计算命令列中每个参数所占的总用量<br>-x, –one-file-system 跳过处于不同文件系统之上的目录<br>-X, –exclude-from=文件 排除与指定文件中描述的模式相符的文件<br>–exclude=PATTERN 排除与PATTERN 中描述的模式相符的文件<br>–max-depth=N 显示目录总计(与–all 一起使用计算文件)<br>当N 为指定数值时计算深度为N；<br>–max-depth=0 等于–summarize<br>–time 显示目录或该目录子目录下所有文件的最后修改时间<br>–time=WORD 显示WORD 时间，而非修改时间：atime，access，use，ctime 或status<br>–time-style=样式 按照指定样式显示时间(样式解释规则同”date”命令)：<br>full-iso，long-iso，iso，+FORMAT<br>–help 显示此帮助信息并退出<br>–version 显示版本信息并退出</p><h4 id="df"><a class="markdownIt-Anchor" href="#df"></a> df</h4><p>df -hl 查看磁盘剩余空间<br>df -h 查看每个根路径的分区大小<br>du -sh [目录名] 返回该目录的大小<br>du -sm [文件夹] 返回该文件夹总M数</p><h4 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h4><p>du是面向文件的命令，只计算被文件占用的空间，不计算文件系统 metadata 占用的空间。<br>df则是基于文件系统总体来计算，通过文件系统中未分配空间来确定系统中已经分配空间的大小。df命令可以获取硬盘占用了多少空间，还剩下多少空间，它也可以显示所有文件系统对i节点和磁盘块的使用情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;du查看目录大小，df查看磁盘使用情况。&lt;/p&gt;
&lt;h4 id=&quot;du&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#du&quot;&gt;&lt;/a&gt; du&lt;/h4&gt;
&lt;p&gt;（1）基本功能&lt;br&gt;
递归查看文件夹下所有文件的大小&lt;br&gt;
（2）常用参数：&lt;br&gt;
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.rickiyang.cn/categories/linux/"/>
    
    
      <category term="linux编程" scheme="http://blog.rickiyang.cn/tags/linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>tomcat部署和日志维护</title>
    <link href="http://blog.rickiyang.cn/posts/a996d8cf.html"/>
    <id>http://blog.rickiyang.cn/posts/a996d8cf.html</id>
    <published>2018-12-17T01:34:12.000Z</published>
    <updated>2018-12-20T11:30:25.603Z</updated>
    
    <content type="html"><![CDATA[<p>一、解压上传的tomcat包</p><p>二、修改tomcat bin目录下的catalina.sh文件。</p><pre><code>   在JAVA_OPTS=&quot;$JAVA_OPTS -Djava.protocol.handler.pkgs=org.apache.catalina.webresources&quot;下面增加如下一行数据：   JAVA_OPTS=&quot;$JAVA_OPTS -Xms5120m -Xmx5120m -XX:+UseG1GC -XX:+PrintGCDetails -XX:ParallelGCThreads=15 -XX:ConcGCThreads=4&quot;   tomcat内存根据机器具体内存情况进行分配，8G的机器JVM可以配置5G内存，4G的机器可以配置2G内存</code></pre><p>三、catalina.out日志按日期切割</p><p>vim /etc/logrotate.d/tomcat 创建配置文件，文件内容如下，其中tomcat-app1是部署工程的tomcat的名字，这个名字可以根据实际工程名字情况进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/data/service/tomcat-app1/logs/catalina.out&#123;</span><br><span class="line">    copytruncate daily</span><br><span class="line">    dateformat .%Y-%m-%d.log</span><br><span class="line">    rotate 3</span><br><span class="line">    missingok</span><br><span class="line">    dateext</span><br><span class="line">    compress</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>执行logrotate -f /etc/logrotate.d/tomcat检查catalina.out文件是否已经清零，并且生成了类似的catalina.out.2018-01-19.gz文件</p></li><li><p>如果查看.gz文件内容，可以使用zcat命令</p></li></ol><p>四. 修改tomcat线程数，编辑server.xml：<br>1.取消56,57行注释，并修改线程数：</p><pre><code>&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;maxThreads=&quot;250&quot; minSpareThreads=&quot;30&quot;/&gt;                   (瞬时流量波动比较大的服务，这个minSpareThreads要设置大一些，比如100.否则会出现ListenOverflows,导致请求得不到处理)</code></pre><p>2.注释68,70行：</p><p><connector port="8080" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443"></connector></p><p>3.取消73,76行注释，并增加相应配置（如果一个服务器上部署多个不同服务，注意服务的启动端口一定不要重复）</p><pre><code>&lt;Connector executor=&quot;tomcatThreadPool&quot;       port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;       connectionTimeout=&quot;20000&quot;       acceptCount=&quot;800&quot;       enableLookups=&quot;false&quot;       compression=&quot;on&quot;       compressionMinSize=&quot;2048&quot;       compressableMimeType=&quot;text/csv,text/html,text/xml,text/css,text/plain,text/javascript,application/javasc     ript,application/x-javascript,application/json,application/xml&quot;     maxConnections=&quot;20000&quot;     redirectPort=&quot;8443&quot; /&gt;</code></pre><p>如果一个服务器上部署多个不同服务，注意服务之间的shutdown端口和AJP协议端口一定不要重复</p>   <server port="8015" shutdown="SHUTDOWN">   <listener classname="org.apache.catalina.startup.VersionLoggerListener">   <connector port="8029" protocol="AJP/1.3" redirectport="8443"><p>最后配置上access日志的处理时间：（%D表示处理时间）</p><p><valve classname="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &quot;%r&quot; %s %b %D"></valve></p><p>五. 配置日志压缩和定时删除：</p><p>应用日志定期打包压缩脚本：<br>cron_gz.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cd  /data/service_logs/app1</span><br><span class="line">date=`date -d -2day +%Y%m%di |awk &apos;BEGIN&#123;FS=&quot;&quot;&#125;&#123;print $1$2$3$4&quot;-&quot;$5$6&quot;-&quot;$7$8&#125;&apos;`</span><br><span class="line">hour=`date -d &quot;1 hour ago&quot; +&quot;%Y-%m-%d-%H&quot;`</span><br><span class="line">gzip $(ls |grep $date | grep -v &apos;info&apos;)</span><br><span class="line">gzip $(ls | grep $hour)</span><br><span class="line">find /data/service_logs/app/ -mtime +2 -name &quot;*.log.gz&quot; -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure></connector></listener></server>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、解压上传的tomcat包&lt;/p&gt;
&lt;p&gt;二、修改tomcat bin目录下的catalina.sh文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   在JAVA_OPTS=&amp;quot;$JAVA_OPTS -Djava.protocol.handler.pkgs=org.apa
      
    
    </summary>
    
      <category term="shell" scheme="http://blog.rickiyang.cn/categories/shell/"/>
    
    
      <category term="工具类" scheme="http://blog.rickiyang.cn/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Log4j日志追踪中加入tracedId</title>
    <link href="http://blog.rickiyang.cn/posts/f8249caa.html"/>
    <id>http://blog.rickiyang.cn/posts/f8249caa.html</id>
    <published>2018-12-12T02:24:32.000Z</published>
    <updated>2019-01-08T02:14:33.310Z</updated>
    
    <content type="html"><![CDATA[<p>Java应用开发过程中，每一次请求从头到尾流转的过程如何通过一个唯一标识标记处来整个调用链路上的所有日志记录，对于我们去追踪当前次请求发生的问题是非常有益的。在我们的应用中一般使用Log4J去收集日志，Log4J中提供了MDC类来存放对象，MDC中的对象，可以被同一线程中执行的代码访问到，当前线程的子线程会继承其父线程中MDC的内容。</p><blockquote><p>MDC 介绍<br>MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。MDC 可以看成是一个与当前线程绑定的Map，可以往其中添加键值对。MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。</p></blockquote><p>在 log4j 和 logback 的取值方式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%X&#123;traceid&#125;</span><br></pre></td></tr></table></figure><p>实现：</p><p>在进入真正的业务逻辑代码之前，我需要生成traceId，那就可以在拦截器中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.guazi.org.monitor.MonitorConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截所有请求，在请求的开始阶段放入生成的traceId，在请求处理结束后</span></span><br><span class="line"><span class="comment"> * 将MDC中的traceId清理掉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangyue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse reponse, Object arg2, Exception arg3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MDC.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object arg2, ModelAndView arg3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object arg2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String traceId = UUID.randomUUID().toString();</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotBlank(traceId))&#123;</span><br><span class="line">MDC.put(<span class="string">"traceId"</span>, traceId);</span><br><span class="line">&#125;</span><br><span class="line">MonitorConfig.VISIT.count();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的Log4J日志文件配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"myConsole"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;MM-dd HH:mm:ss,SSS&#125; %-5p] [traceId:%X&#123;traceId&#125;] [%t] %c&#123;2.&#125; - %m%n%ex"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"infoAppender"</span> <span class="attr">fileName</span>=<span class="string">"/data/service_logs/hadoop/info.log"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">"/data/service_logs/hadoop/info.log.%d&#123;yyyy-MM-dd-HH&#125;.log"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>[%d&#123;MM-dd HH:mm:ss SSS&#125; %-5level] [traceId:%X&#123;traceId&#125;] [%t] %c - %m%n%ex<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"errorAppender"</span> <span class="attr">fileName</span>=<span class="string">"/data/service_logs/hadoop/error.log"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">"/data/service_logs/hadoop/error.log.%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>[%d&#123;MM-dd HH:mm:ss SSS&#125; %-5level] [traceId:%X&#123;traceId&#125;] [%t] %c - %m%n%ex<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"error"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"remoteAppender"</span> <span class="attr">fileName</span>=<span class="string">"/data/service_logs/hadoop/process_remote.log"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">"/data/service_logs/hadoop/process_remote.log.%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>[%d&#123;MM-dd HH:mm:ss SSS&#125; %-5level] [traceId:%X&#123;traceId&#125;] [%t] %c - %m%n%ex<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"infoAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"info.do"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"error.do"</span> <span class="attr">level</span>=<span class="string">"ERROR"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"errorAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"remote.do"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"remoteAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外要说的是，MDC中的内容只是在当前线程中可见，如果你再当前线程中新开了子线程，或者在当前线程中使用了线程池，MDC中的内容对于他们而言都是不可见的。这时候就需要你去手动做透传。另一种方法就是你重新包装一下线程池类，将tracedId作为参数传入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java应用开发过程中，每一次请求从头到尾流转的过程如何通过一个唯一标识标记处来整个调用链路上的所有日志记录，对于我们去追踪当前次请求发生的问题是非常有益的。在我们的应用中一般使用Log4J去收集日志，Log4J中提供了MDC类来存放对象，MDC中的对象，可以被同一线程中执
      
    
    </summary>
    
      <category term="java开发工具类" scheme="http://blog.rickiyang.cn/categories/java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="工具类" scheme="http://blog.rickiyang.cn/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>tomcat重启脚本</title>
    <link href="http://blog.rickiyang.cn/posts/adc3306d.html"/>
    <id>http://blog.rickiyang.cn/posts/adc3306d.html</id>
    <published>2018-12-11T03:20:04.000Z</published>
    <updated>2018-12-21T03:12:02.405Z</updated>
    
    <content type="html"><![CDATA[<p>写了一个tomcat服务重启的脚本，因为挂载nginx，所有需要摘除healthCheck.html,服务重启完毕之后挂上ng。另外在重启过程中去检查服务是否启动成功，<br>如果不成功则不挂载ng。<br>tomcat重启脚本：</p><pre><code>#!/bin/sh#检查服务状态，判断是否可以挂到ngdudgeMountHealthCheckFile(){        for i in `seq 1 10`        do          echo 'i=' $i          httpStatus=$(curl -I -s -w &quot;%{http_code}\n&quot; -o /dev/null 127.0.0.1:8080/index.jsp)          if [ $httpStatus -ne 200 ]                then                  sleep 20                  echo 'htppCode is: ' $httpStatus          else                  echo 'htppCode is: ' $httpStatus                  touch /data/service/tomcat/webapps/ROOT/healthcheck.html                  echo 'add healthcheck.html'                  break          fi        done}rm -rf /data/service/tomcat/webapps/ROOT/healthcheck.htmlecho 'remove healthcheck.html'sleep 15p='/data/service/tomcat'tomcatpath=${p}'/bin'echo 'operate restart tomcat: '$tomcatpathpid=`ps aux | grep $tomcatpath | grep -v grep | grep -v retomcat | awk '{print $2}'`echo 'exist pid:'$pidif [ -n &quot;$pid&quot; ]then{   echo ===========shutdown================   $tomcatpath'/shutdown.sh'   sleep 5   pid=`ps aux | grep $tomcatpath | grep -v grep | grep -v retomcat | awk '{print $2}'`   if [ -n &quot;$pid&quot; ]   then    {      sleep 3      echo ========kill tomcat begin==============      echo $pid      kill -9 $pid      echo ========kill tomcat end==============    }   fi   sleep 3   echo ===========startup.sh==============   $tomcatpath'/startup.sh'   sleep 10   dudgeMountHealthCheckFile }elseecho ===========startup.sh==============$tomcatpath'/startup.sh'sleep 10dudgeMountHealthCheckFilefi</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写了一个tomcat服务重启的脚本，因为挂载nginx，所有需要摘除healthCheck.html,服务重启完毕之后挂上ng。另外在重启过程中去检查服务是否启动成功，&lt;br&gt;
如果不成功则不挂载ng。&lt;br&gt;
tomcat重启脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/b
      
    
    </summary>
    
      <category term="shell" scheme="http://blog.rickiyang.cn/categories/shell/"/>
    
    
      <category term="工具类" scheme="http://blog.rickiyang.cn/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>使用table标签生成页面出现大量空白的解决办法</title>
    <link href="http://blog.rickiyang.cn/posts/e4afcbeb.html"/>
    <id>http://blog.rickiyang.cn/posts/e4afcbeb.html</id>
    <published>2018-12-06T03:56:43.000Z</published>
    <updated>2018-12-06T10:20:49.321Z</updated>
    
    <content type="html"><![CDATA[<p>写博客的时候，就发现Hexo中插入HTML表格会留出大量空白。如下所示：</p><table>  <tr>    <th>姓名</th>    <th>性别</th>  </tr>  <tr>    <td>xiaoming</td>    <td>1</td>  </tr></table><p>虽然markdown语法也是可以生成表格的，但是写的时候特别麻烦，所以我一直是直接插入的HTML表格的，仅仅是因为简单高效。<br>后来在hexo的issue中发现这个问题，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcy8yMzkx" title="https://github.com/hexojs/hexo/issues/2391">issue<i class="fa fa-external-link"></i></span>,有两种解决办法：</p><p>解决方法1</p><p>将代码改为紧凑模式，修改代码如下</p><table><tr><th>姓名</th><th>性别</th></tr><tr><td>xiaoming</td><td>1</td></tr></table><p>也就是说代码标签之间不要留白，全部改为紧贴着的。</p><table><tr><th>姓名</th><th>性别</th></tr><tr><td>xiaoming</td><td>1</td></tr></table><p>我一般都是使用<span class="exturl" data-url="aHR0cDovL3d3dy50YWJsZXNnZW5lcmF0b3IuY29tLw==" title="http://www.tablesgenerator.com/">tablesgenerator<i class="fa fa-external-link"></i></span>来生成表格的。</p><p>解决方法2(推荐)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">html tags &amp; content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>  <table>  <tr>    <th>姓名</th>    <th>性别</th>  </tr>  <tr>    <td>xiaoming</td>    <td>1</td>  </tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写博客的时候，就发现Hexo中插入HTML表格会留出大量空白。如下所示：&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;姓名&lt;/th&gt;
    &lt;th&gt;性别&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;xiaoming&lt;/td&gt;
    &lt;td&gt;1&lt;/t
      
    
    </summary>
    
      <category term="hexo" scheme="http://blog.rickiyang.cn/categories/hexo/"/>
    
    
      <category term="hexo优化" scheme="http://blog.rickiyang.cn/tags/hexo%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java重试工具类:spring-retry和guava-retryer</title>
    <link href="http://blog.rickiyang.cn/posts/73e3dbd9.html"/>
    <id>http://blog.rickiyang.cn/posts/73e3dbd9.html</id>
    <published>2018-12-05T15:20:04.000Z</published>
    <updated>2018-12-05T06:13:34.121Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发中经常遇到调用外部接口失败的情况，这时候我们需要去设置失败重试机制，正常情况我们的重试机制是：如果出错了，一般是网络抖动或者延迟的情况，设置重试一次，或者几次，可能是如下方案：<br>try-catch-redo简单重试模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    redo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想定制什么时候重试，重试几次，就需要我们自己定义重试策略，那么我们的代码就稍微复杂一些，可能是如下方案：<br>try-catch-redo-retry strategy策略重试模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    redo(retryTime,interval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上是我们一般的处理方案，由上我们大致可以看出如果想要实现一个优雅的重试方案，需要我们详细的去考虑重试机制，重试策略，重试失败措施，重试代码如何做到不侵入业务代码等等。所以，这样的一个小功能我们也是可以做成很有意思的小组件的。现代分布式系统中系统调用如此频繁，重试机制也是大家开发中的重复性劳动，所以这种不必要的代码已经有人给我们写好了，分别是Java中的Spring-Retry和Guava-Retrying。</p><p>其中Spring-Retry是基于Throwable类型的重试机制，即针对可捕获异常执行重试策略，并提供相应的回滚策略；而Guava-Retrying提供了更为丰富的重试源定义，譬如多个异常或者多个返回值。</p><p>Spring-Retry:</p><p>引入jar包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>通过构造一个重试模板来执行重试策略，在重试模板中可以设置重试次数，重试间隔和回退策略。我们通过一段代码来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retryDoSomething</span><span class="params">(<span class="keyword">final</span> Map&lt;String, Object&gt; map)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 构建重试模板实例</span></span><br><span class="line">        RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">// 设置重试策略，主要设置重试次数</span></span><br><span class="line">        SimpleRetryPolicy policy = <span class="keyword">new</span> SimpleRetryPolicy(<span class="number">3</span>, Collections.singletonMap(Exception.class, <span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// 设置重试回退操作策略，主要设置重试间隔时间</span></span><br><span class="line">        FixedBackOffPolicy fixedBackOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">        fixedBackOffPolicy.setBackOffPeriod(<span class="number">100</span>);</span><br><span class="line">        retryTemplate.setRetryPolicy(policy);</span><br><span class="line">        retryTemplate.setBackOffPolicy(fixedBackOffPolicy);</span><br><span class="line">        <span class="comment">// 通过RetryCallback 重试回调实例包装正常逻辑逻辑，第一次执行和重试执行执行的都是这段逻辑</span></span><br><span class="line">        <span class="keyword">final</span> RetryCallback&lt;Object, Exception&gt; retryCallback = <span class="keyword">new</span> RetryCallback&lt;Object, Exception&gt;() &#123;</span><br><span class="line">            <span class="comment">//RetryContext 重试操作上下文约定，统一spring-try包装</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"do some thing"</span>);</span><br><span class="line">                Exception e = doSomething(map);</span><br><span class="line">                System.out.println(context.getRetryCount());</span><br><span class="line">                <span class="keyword">throw</span> e;<span class="comment">//这个点特别注意，重试的根源通过Exception返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 通过RecoveryCallback 重试流程正常结束或者达到重试上限后的退出恢复操作实例</span></span><br><span class="line">        <span class="keyword">final</span> RecoveryCallback&lt;Object&gt; recoveryCallback = <span class="keyword">new</span> RecoveryCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"do recory operation"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 由retryTemplate 执行execute方法开始逻辑执行</span></span><br><span class="line">            retryTemplate.execute(retryCallback, recoveryCallback);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>spring-retry是通过RetryTemplate的execute方法来执行重试代码的，execute方法是线程安全的，实现中他将retry的餐参数对象保存在ThreadLocal中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RetryContext context = <span class="keyword">this</span>.open(retryPolicy, state);</span><br><span class="line"><span class="comment">//ThreadLocal中保存context对象</span></span><br><span class="line">RetrySynchronizationManager.register(context);</span><br></pre></td></tr></table></figure><p>以上代码需要注意的是重试的执行逻辑是在RetryCallback类中实现的，触发重试逻辑是在doWithRetry方法中抛出泛型异常。这就意味着如果你的代码并没有异常抛出但是仍然需要在某种返回值的条件下触发重试逻辑的时候，你需要手动的判断该返回值然后抛出异常。这个操作有点强人所难。</p><p>所以在此基础之上，guava-retryer重新做了设计，在支持重试次数和重试频度的基础上，能够兼容支持多个异常或者自定义实体对象的重试源定义。</p><p>引入jar：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.rholder&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava-retrying&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LedgerResult <span class="title">requestRestry</span><span class="params">(NrRequestParams nrRequestParams)</span> </span>&#123;</span><br><span class="line">        Retryer&lt;LedgerResult&gt; retryer = RetryerBuilder.&lt;LedgerResult&gt;newBuilder()</span><br><span class="line">                .retryIfExceptionOfType(BizException.class)</span><br><span class="line">                .retryIfException()</span><br><span class="line">                .retryIfResult(result -&gt; result == <span class="keyword">null</span>)</span><br><span class="line">                .withWaitStrategy(WaitStrategies.fixedWait(<span class="number">5</span>, TimeUnit.MINUTES))</span><br><span class="line">                .withStopStrategy(StopStrategies.stopAfterAttempt(<span class="number">10</span>))</span><br><span class="line">                .withRetryListener(<span class="keyword">new</span> RetryListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">onRetry</span><span class="params">(Attempt&lt;V&gt; attempt)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">long</span> attemptNumber = attempt.getAttemptNumber();</span><br><span class="line">                        <span class="keyword">if</span> (attemptNumber &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                            logger.info(<span class="string">"&lt;=====重试次数:&#123;&#125;,params:&#123;&#125;"</span>, attemptNumber - <span class="number">1</span>, nrRequestParams);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> retryer.call(() -&gt; requestLedger(nrRequestParams));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"&lt;&lt;&lt;&lt;&lt;=====重试失败====参数：&#123;&#125;"</span>, nrRequestParams, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RetryException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"&lt;&lt;&lt;&lt;&lt;=====重试失败====参数：&#123;&#125;"</span>, nrRequestParams, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过RetryerBuilder来构造工厂对象，设置重试策略，比如支持特定异常类型，支持检测返回值类型判定，一个全局的监控方法，更加优雅的重试策略和停止策略设置等等。</p><p>guava的api对于用户来说更加的友好，大家会选择哪一个用于日常开发不言自明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;日常开发中经常遇到调用外部接口失败的情况，这时候我们需要去设置失败重试机制，正常情况我们的重试机制是：如果出错了，一般是网络抖动或者延迟的情况，设置重试一次，或者几次，可能是如下方案：&lt;br&gt;
try-catch-redo简单重试模式：&lt;/p&gt;
&lt;figure class=
      
    
    </summary>
    
      <category term="java开发工具类" scheme="http://blog.rickiyang.cn/categories/java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="工具类" scheme="http://blog.rickiyang.cn/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>hive高级操作</title>
    <link href="http://blog.rickiyang.cn/posts/92142135.html"/>
    <id>http://blog.rickiyang.cn/posts/92142135.html</id>
    <published>2018-11-28T14:04:15.000Z</published>
    <updated>2019-01-07T01:48:18.200Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1复杂数据类型表创建"><a class="markdownIt-Anchor" href="#1复杂数据类型表创建"></a> 1.复杂数据类型表创建</h4><p>有如下建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> cdt(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>, </span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>, </span><br><span class="line">work_location <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;, </span><br><span class="line">piaofang <span class="keyword">map</span>&lt;<span class="keyword">string</span>,<span class="built_in">bigint</span>&gt;, </span><br><span class="line">address <span class="keyword">struct</span>&lt;location:<span class="keyword">string</span>,zipcode:<span class="built_in">int</span>,phone:<span class="keyword">string</span>,<span class="keyword">value</span>:<span class="built_in">int</span>&gt;) </span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> </span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">"\t"</span> </span><br><span class="line">collection items <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">","</span> </span><br><span class="line"><span class="keyword">map</span> <span class="keyword">keys</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">":"</span> </span><br><span class="line"><span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11      huangbo         guangzhou,xianggang,shenzhen    a1:30,a2:20,a3:100      beijing,112233,13522334455,500</span><br><span class="line">22      xuzheng         xianggang       b2:50,b3:40     tianjin,223344,13644556677,600</span><br><span class="line">33      wangbaoqiang    beijing,zhejinag        c1:200          chongqinjg,334455,15622334455,20</span><br></pre></td></tr></table></figure><p>建表以后导入数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> load data <span class="built_in">local</span> inpath <span class="string">"/usr/local/hive/user.txt"</span> into table cdt;</span></span><br><span class="line">Loading data to table t1.cdt</span><br><span class="line">OK</span><br><span class="line">Time taken: 2.861 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select * from cdt;</span></span><br><span class="line">OK</span><br><span class="line">11huangbo[]&#123;"guangzhou":null,"xianggang":null,"shenzhen":null&#125;&#123;"location":"a1:30","zipcode":null,"phone":"a3:100","value":null&#125;</span><br><span class="line">22xuzheng[]&#123;"xianggang":null&#125;&#123;"location":"b2:50","zipcode":null,"phone":null,"value":null&#125;</span><br><span class="line">33wangbaoqiang["beijing","zhejinag"]&#123;"c1":200&#125;&#123;"location":"","zipcode":null,"phone":null,"value":null&#125;</span><br><span class="line">Time taken: 0.841 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure><p>查询Array类型的第一个数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select work_location[0] from cdt;</span></span><br><span class="line">OK</span><br><span class="line">NULL</span><br><span class="line">NULL</span><br><span class="line">beijing</span><br><span class="line">Time taken: 157.351 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure><p>查询map类型的某一个key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select piaofang[<span class="string">'c1'</span>] from cdt;</span></span><br><span class="line">OK</span><br><span class="line">NULL</span><br><span class="line">NULL</span><br><span class="line">200</span><br><span class="line">Time taken: 4.907 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure><p>查询struct类型中的某一个字段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select address from cdt;</span></span><br><span class="line">OK</span><br><span class="line">&#123;"location":"a1:30","zipcode":null,"phone":"a3:100","value":null&#125;</span><br><span class="line">&#123;"location":"b2:50","zipcode":null,"phone":null,"value":null&#125;</span><br><span class="line">&#123;"location":"","zipcode":null,"phone":null,"value":null&#125;</span><br><span class="line">Time taken: 0.853 seconds, Fetched: 3 row(s)</span><br><span class="line"></span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select address.location from cdt;</span></span><br><span class="line">OK</span><br><span class="line">a1:30</span><br><span class="line">b2:50</span><br><span class="line"></span><br><span class="line">Time taken: 10.742 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure><h4 id="2视图"><a class="markdownIt-Anchor" href="#2视图"></a> 2.视图</h4><p>和关系型数据库一样，Hive 也提供了视图的功能，不过请注意，Hive 的视图和关系型数据库的数据还是有很大的区别：</p><p>（1）只有逻辑视图，没有物化视图；</p><p>（2）视图只能查询，不能 Load/Insert/Update/Delete 数据；</p><p>（3）视图在创建时候，只是保存了一份元数据，当查询视图的时候，才开始执行视图对应的 那些子查询</p><p>1.创建视图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> create view view_users as select * from users;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 4.517 seconds</span><br></pre></td></tr></table></figure><p>2.查看视图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show views;</span></span><br><span class="line">OK</span><br><span class="line">view_users</span><br><span class="line">Time taken: 0.094 seconds, Fetched: 1 row(s)</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> desc view_users;</span></span><br><span class="line">OK</span><br><span class="line">name                string</span><br><span class="line">age                 int</span><br><span class="line">sex                 int</span><br><span class="line">Time taken: 0.133 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure><p>3.视图的使用</p><p>跟普通表的查询一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * from view_users;</span><br><span class="line">OK</span><br><span class="line">小明121</span><br><span class="line">小红140</span><br><span class="line">小紫110</span><br><span class="line">小李151</span><br><span class="line">小豆130</span><br><span class="line">&apos;李隆基&apos;121</span><br><span class="line">&apos;王阳明&apos;231</span><br><span class="line">&apos;李逵&apos;331</span><br><span class="line">&apos;欧阳拉拉&apos;121</span><br><span class="line">&apos;杨过&apos;541</span><br><span class="line">&apos;小龙女&apos;120</span><br><span class="line">&apos;周芷若&apos;320</span><br><span class="line">&apos;李小龙&apos;321</span><br><span class="line">&apos;陈龙&apos;621</span><br><span class="line">&apos;范冰冰&apos;420</span><br><span class="line">Time taken: 1.15 seconds, Fetched: 15 row(s)</span><br></pre></td></tr></table></figure><p>删除视图：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> drop view view_users;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 2.962 seconds</span><br></pre></td></tr></table></figure><h4 id="3函数"><a class="markdownIt-Anchor" href="#3函数"></a> 3.函数</h4><p>hive的内置函数有很多，并且很有用，查看所有函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> drop view view_users;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 2.962 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show <span class="built_in">functions</span>;</span></span><br><span class="line">OK</span><br><span class="line">!</span><br><span class="line">!=</span><br><span class="line"><span class="meta">$</span><span class="bash">sum0</span></span><br><span class="line"><span class="meta">%</span><span class="bash"></span></span><br><span class="line">&amp;</span><br><span class="line">...</span><br><span class="line">xpath_short</span><br><span class="line">xpath_string</span><br><span class="line">year</span><br><span class="line">|</span><br><span class="line">~</span><br><span class="line">Time taken: 0.087 seconds, Fetched: 271 row(s)</span><br></pre></td></tr></table></figure><p>一共是271个内置函数。</p><p>查看函数的详细说明:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> desc <span class="keyword">function</span> to_date;</span></span><br><span class="line">OK</span><br><span class="line">to_date(expr) - Extracts the date part of the date or datetime expression expr</span><br><span class="line">Time taken: 0.12 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure><p>hive除了提供内置函数功能以外，还支持自定义函数，当业务比较复杂，用户可以将自定义的函数导入hive库中使用。hive提供了三种类型的自定义函数接口：</p><ul><li>UDF （user-defined function）作用于单个数据行，产生一个数据行作为输出。（数学函数，字 符串函数）</li><li>UDAF （用户定义聚集函数 User- Defined Aggregation Funcation）：接收多个输入数据行，并产 生一个输出数据行。（count，max）</li><li>UDTF （表格生成函数 User-Defined Table Functions）：接收一行输入，输出多行（explode）</li></ul><p>自定义函数：</p><p>下面我们来写一个自定义UDF函数，函数的作用是将存储在数据库中的数字映射为对应的中文：</p><p>看一下你所使用的hive版本引入对应版本的jar包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写UDF函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SexUDF</span> <span class="keyword">extends</span> <span class="title">UDF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">evaluate</span><span class="params">(Integer sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sex == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"女"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sex == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"男"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"未知"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个类打成jar包传入服务器，在hive中引入jar包，然后创建一个自定义函数，你就可以使用这个函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> add jar /usr/<span class="built_in">local</span>/hive/hadoop.jar;</span></span><br><span class="line">Added [/usr/local/hive/hadoop.jar] to class path</span><br><span class="line">Added resources: [/usr/local/hive/hadoop.jar]</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> create temporary <span class="keyword">function</span> sexUDF as <span class="string">'cn.edu.hust.demo1.hive.SexUDF'</span>;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 0.514 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select sexUDF(1);</span></span><br><span class="line">OK</span><br><span class="line">男</span><br><span class="line">Time taken: 2.415 seconds, Fetched: 1 row(s)</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select sexUDF(0);</span></span><br><span class="line">OK</span><br><span class="line">女</span><br><span class="line">Time taken: 0.522 seconds, Fetched: 1 row(s)</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select sexUDF(2);</span></span><br><span class="line">OK</span><br><span class="line">未知</span><br><span class="line">Time taken: 0.265 seconds, Fetched: 1 row(s)</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1复杂数据类型表创建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1复杂数据类型表创建&quot;&gt;&lt;/a&gt; 1.复杂数据类型表创建&lt;/h4&gt;
&lt;p&gt;有如下建表语句：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hive" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hive/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>hive SQL练习</title>
    <link href="http://blog.rickiyang.cn/posts/cd8871b9.html"/>
    <id>http://blog.rickiyang.cn/posts/cd8871b9.html</id>
    <published>2018-11-24T03:30:01.000Z</published>
    <updated>2019-01-04T01:52:36.433Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1库操作相关"><a class="markdownIt-Anchor" href="#1库操作相关"></a> 1.库操作相关</h4><p>语法：</p><blockquote><p>CREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name</p><p>[COMMENT database_comment]　　　　　　//关于数据块的描述</p><p>[LOCATION hdfs_path]　　　　　　　　　　//指定数据库在HDFS上的存储位置</p><p>[WITH DBPROPERTIES (property_name=property_value, …)];　　　　//指定数据块属性</p></blockquote><h5 id="11-创建库相关"><a class="markdownIt-Anchor" href="#11-创建库相关"></a> 1.1 创建库相关</h5><p>创建库语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> create database t1;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 16.029 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">mydb2</span><br><span class="line">t1</span><br><span class="line">Time taken: 0.743 seconds, Fetched: 3 row(s)</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>创建库的时候检查库是否存在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash">  create database <span class="keyword">if</span> not exists t1;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 0.16 seconds</span><br></pre></td></tr></table></figure><p>创建库带注释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> create database <span class="keyword">if</span> not exists t2 comment <span class="string">'hive is ok'</span>;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 0.636 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> desc database t2;</span></span><br><span class="line">OK</span><br><span class="line">t2hive is okhdfs://ns1/user/hive/warehouse/t2.dbhadoopUSER</span><br><span class="line">Time taken: 3.94 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure><h5 id="12-查看库相关"><a class="markdownIt-Anchor" href="#12-查看库相关"></a> 1.2 查看库相关</h5><p>展示所有库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">mydb2</span><br><span class="line">t1</span><br><span class="line">t2</span><br><span class="line">Time taken: 0.049 seconds, Fetched: 4 row(s)</span><br></pre></td></tr></table></figure><p>展示库详细信息：</p><blockquote><p>desc database [extended] dbname;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> desc database extended t2;</span></span><br><span class="line">OK</span><br><span class="line">t2hive is okhdfs://ns1/user/hive/warehouse/t2.dbhadoopUSER</span><br><span class="line">Time taken: 0.421 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure><p>查看当前正在使用的库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> select current_database();</span></span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">Time taken: 31.444 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure><p>查看创建库的详细语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show create database t2;</span></span><br><span class="line">OK</span><br><span class="line">CREATE DATABASE `t2`</span><br><span class="line">COMMENT</span><br><span class="line">  'hive is ok'</span><br><span class="line">LOCATION</span><br><span class="line">  'hdfs://ns1/user/hive/warehouse/t2.db'</span><br><span class="line">Time taken: 0.926 seconds, Fetched: 5 row(s)</span><br></pre></td></tr></table></figure><h5 id="13-删除库相关"><a class="markdownIt-Anchor" href="#13-删除库相关"></a> 1.3 删除库相关</h5><p>默认情况下hive不允许删除包含表的数据库，有两种办法解决这个问题：</p><p>1.手动删除数据库下所有的表，然后删除库；</p><p>2.使用cascade关键字。</p><p><strong>drop database if exists dbname cascade;</strong></p><p>删除不含表的数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show tables <span class="keyword">in</span> t2;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 27.882 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> drop database t2;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 78.301 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"></span></span><br><span class="line">    &gt; show databases;</span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">mydb2</span><br><span class="line">t1</span><br><span class="line">Time taken: 0.799 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure><p>删除含表的数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">mydb2</span><br><span class="line">t1</span><br><span class="line">Time taken: 1.435 seconds, Fetched: 3 row(s)</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show tables <span class="keyword">in</span> t1;</span></span><br><span class="line">OK</span><br><span class="line">users</span><br><span class="line">Time taken: 0.209 seconds, Fetched: 1 row(s)</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> drop database <span class="keyword">if</span> exists t1 cascade;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 40.105 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">mydb2</span><br><span class="line">Time taken: 0.066 seconds, Fetched: 2 row(s)</span><br></pre></td></tr></table></figure><h5 id="14-切换库"><a class="markdownIt-Anchor" href="#14-切换库"></a> 1.4 切换库</h5><p>use database_name;</p><h4 id="2表操作"><a class="markdownIt-Anchor" href="#2表操作"></a> 2.表操作</h4><h5 id="21-创建表"><a class="markdownIt-Anchor" href="#21-创建表"></a> 2.1 创建表</h5><blockquote><p><strong>CREATE</strong> [EXTERNAL] <strong>TABLE</strong> [IF NOT EXISTS] table_name</p><p>[(col_name data_type [COMMENT col_comment], …)]</p><p>[<strong>COMMENT</strong> table_comment]</p><p>[<strong>PARTITIONED BY</strong> (col_name data_type [COMMENT col_comment], …)]</p><p>[<strong>CLUSTERED BY</strong> (col_name, col_name, …)</p><p>[<strong>SORTED BY</strong> (col_name [ASC|DESC], …)] <strong>INTO</strong> num_buckets <strong>BUCKETS</strong>]</p><p>[<strong>ROW FORMAT</strong> row_format]</p><p>[<strong>STORED AS</strong> file_format]</p><p>[<strong>LOCATION</strong> hdfs_path]</p></blockquote><p>关键字说明：</p><hr><p><strong>EXTERNAL</strong> ：关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION）</p><p><strong>LIKE</strong>: 允许用户复制现有的表结构，但是不复制数据</p><p><strong>COMMENT</strong>: 可以为表与字段增加描述</p><p><strong>PARTITIONED BY</strong> :  指定分区</p><p><strong>ROW FORMAT</strong> : DELIMITED [FIELDS TERMINATED BY char][COLLECTION ITEMS TERMINATED BY char]<br>　　　　MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]<br>　　　　| SERDE serde_name [WITH SERDEPROPERTIES<br>　　　　(property_name=property_value, property_name=property_value, …)]</p><p>用户在建表的时候可以自定义 SerDe 或者使用自带的 SerDe。如果没有指定 ROW FORMAT 或者 ROW FORMAT DELIMITED，将会使用自带的 SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的 SerDe，Hive 通过 SerDe 确定表的具体的列的数据。</p><p><strong>STORED AS</strong> : SEQUENCEFILE //序列化文件<br>　　| TEXTFILE //普通的文本文件格式<br>　　| RCFILE　　//行列存储相结合的文件<br>　　| INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname //自定义文件格式<br>　　如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCE 。</p><p><strong>LOCATION</strong>  : 指定表在HDFS的存储路径</p><hr><p>如果一份数据已经存储在HDFS上，并且要被多个用户或者客户端使用，最好创建外部表;反之，最好创建内部表。</p><p>如果不指定，就按照默认的规则存储在默认的仓库路径中。</p><p>1.创建一张默认的内部表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table users (name string, age int, sex int) row format delimited fields terminated by &quot;,&quot;;</span><br><span class="line">OK</span><br><span class="line">Time taken: 13.577 seconds</span><br><span class="line">hive&gt; desc users;</span><br><span class="line">OK</span><br><span class="line">name                string</span><br><span class="line">age                 int</span><br><span class="line">sex                 int</span><br><span class="line">Time taken: 1.12 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure><p>2.外部表:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> create external table user_bank_info_ext(id int,bank_no string,bank_name string) row format delimited fields terminated by <span class="string">","</span> location <span class="string">"/usr/local/hive/data/user_bank"</span>;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 1.049 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show tables;</span></span><br><span class="line">OK</span><br><span class="line">user_bank_info_ext</span><br><span class="line">users</span><br><span class="line">Time taken: 0.397 seconds, Fetched: 2 row(s)</span><br></pre></td></tr></table></figure><p>3.分区表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> create external table goods_sale_book(id int,goods_id int,purchaser_id int) partitioned by (city_id string) row format delimited fields terminated by <span class="string">","</span> location <span class="string">"/usr/local/hive/data/goods_book"</span>;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 0.639 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show tables;</span></span><br><span class="line">OK</span><br><span class="line">goods_sale_book</span><br><span class="line">user_bank_info_ext</span><br><span class="line">users</span><br><span class="line">Time taken: 0.118 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure><p>添加分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table goods_sale_book add partition(city_id=111);</span><br></pre></td></tr></table></figure><p>4.桶表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create external table books (id int,name string,isbn string,author string,warehouse_id int) clustered by (id) sorted by (warehouse_id,id) into 4 buckets row format delimited fields terminated by &quot;,&quot; location &quot;/usr/local/hive/data/books&quot;;</span><br><span class="line">OK</span><br><span class="line">Time taken: 78.249 seconds</span><br><span class="line">hive&gt; show tables;</span><br><span class="line">OK</span><br><span class="line">books</span><br><span class="line">goods_sale_book</span><br><span class="line">user_bank_info_ext</span><br><span class="line">users</span><br><span class="line">Time taken: 4.183 seconds, Fetched: 4 row(s)</span><br></pre></td></tr></table></figure><p>5.查询另一个表的结果作为一张新表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; load data local inpath &quot;/usr/local/hive/user.txt&quot; into table users;</span><br><span class="line">Loading data to table t1.users</span><br><span class="line">OK</span><br><span class="line">Time taken: 5.979 seconds</span><br><span class="line">hive&gt; select * from users;</span><br><span class="line">OK</span><br><span class="line">小明121</span><br><span class="line">小红140</span><br><span class="line">小紫110</span><br><span class="line">小李151</span><br><span class="line">小豆130</span><br><span class="line">&apos;李隆基&apos;121</span><br><span class="line">&apos;王阳明&apos;231</span><br><span class="line">&apos;李逵&apos;331</span><br><span class="line">&apos;欧阳拉拉&apos;121</span><br><span class="line">&apos;杨过&apos;541</span><br><span class="line">&apos;小龙女&apos;120</span><br><span class="line">&apos;周芷若&apos;320</span><br><span class="line">&apos;李小龙&apos;321</span><br><span class="line">&apos;陈龙&apos;621</span><br><span class="line">&apos;范冰冰&apos;420</span><br><span class="line">Time taken: 6.565 seconds, Fetched: 15 row(s)</span><br><span class="line">hive&gt; create table users_bak as select * from users where sex=0;</span><br><span class="line">hive&gt; select * from users_bak;</span><br><span class="line">OK</span><br><span class="line">小红140</span><br><span class="line">小紫110</span><br><span class="line">小豆130</span><br><span class="line">&apos;小龙女&apos;120</span><br><span class="line">&apos;周芷若&apos;320</span><br><span class="line">&apos;范冰冰&apos;420</span><br><span class="line">Time taken: 2.185 seconds, Fetched: 6 row(s)</span><br></pre></td></tr></table></figure><p>6.复制表结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> create table users_copy like users;</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 3.016 seconds</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>如果在table的前面没有加external关键字，那么复制出来的新表。无论如何都是内部表</strong><br><strong>如果在table的前面有加external关键字，那么复制出来的新表。无论如何都是外部表</strong></p><h5 id="22-修改表"><a class="markdownIt-Anchor" href="#22-修改表"></a> 2.2 修改表</h5><p>1.修改表名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> alter table user_copy rename to new_user_copy;</span></span><br><span class="line">FAILED: SemanticException [Error 10001]: Table not found t1.user_copy</span><br></pre></td></tr></table></figure><p>2.新增字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> alter table users_copy add columns(mobile_phone string);</span></span><br><span class="line">OK</span><br><span class="line">Time taken: 2.344 seconds</span><br><span class="line"><span class="meta">hive&gt;</span><span class="bash"> desc users_copy;</span></span><br><span class="line">OK</span><br><span class="line">name                string</span><br><span class="line">age                 int</span><br><span class="line">sex                 int</span><br><span class="line">mobile_phone        string</span><br><span class="line">Time taken: 1.515 seconds, Fetched: 4 row(s)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1库操作相关&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1库操作相关&quot;&gt;&lt;/a&gt; 1.库操作相关&lt;/h4&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CREATE (DATABASE|SCHEMA) [IF NOT EX
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hive" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hive/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>hiveserver2使用以及java连接方式</title>
    <link href="http://blog.rickiyang.cn/posts/d946acf8.html"/>
    <id>http://blog.rickiyang.cn/posts/d946acf8.html</id>
    <published>2018-11-22T15:12:33.000Z</published>
    <updated>2019-01-02T11:42:40.843Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道hive的数据是存储在HDFS上的，hive只是充当一个客户端，实际上是去HDFS执行mapReduce命令。在我们第一次安装hive的时候，介绍过使用bin目录下的&quot;hive&quot;命令去启动hive客户端程序：</p><p><img src="https://i.imgur.com/35wBVQ1.png" alt=""></p><p>那么生产环境下我们肯定不能在服务器上使用命令行的方式去操作hive，在hive的bin目录下提供了hiveserver2命令，HiveServer2(HS2)是一种能使客户端执行Hive查询的服务。 HiveServer2是HiveServer1的改进版，HiveServer1已经被废弃。HiveServer2可以支持多客户端并发和身份认证。旨在为开放API客户端（如JDBC和ODBC）提供更好的支持。 HiveServer2单进程运行，提供组合服务，包括基于Thrift的Hive服务（TCP或HTTP）和用于Web UI的Jetty Web服务器。</p><p>Hiveserver2提供了客户端连接hive的服务，用户并不是直接连接的，bin目录下还有另外一个命令，beeline。它是基于SQLLine CLI的JDBC客户端 。</p><p>Beeline支持嵌入模式(embedded mode)和远程模式(remote mode)。在嵌入式模式下，运行嵌入式的Hive(类似Hive CLI)，而远程模式可以通过Thrift连接到独立的HiveServer2进程上。从Hive 0.14版本开始，Beeline使用HiveServer2工作时，它也会从HiveServer2输出日志信息到STDERR。</p><h4 id="1hiveserver2服务配置"><a class="markdownIt-Anchor" href="#1hiveserver2服务配置"></a> 1.hiveserver2服务配置</h4><p>下面我们来配置通过beeline连接hiveserver2服务，在远程连接hive服务。</p><h5 id="11-修改hadoop的hdfs-sitexml文件"><a class="markdownIt-Anchor" href="#11-修改hadoop的hdfs-sitexml文件"></a> 1.1 修改hadoop的hdfs-site.xml文件：</h5><p>加入一条配置信息，启用webhdfs,因为我们需要远程访问HDFS：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.webhdfs.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="12-修改hadoop的core-sitexml文件"><a class="markdownIt-Anchor" href="#12-修改hadoop的core-sitexml文件"></a> 1.2 修改hadoop的core-site.xml文件：</h5><p>需要允许hadoop集群可以被任一代理用户访问：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hadoop.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hadoop.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改完成之后同步两个文件至集群所有机器，然后重启集群。</p><h5 id="13-hadoop重启完成之后我们可以开始启动hiveserver2服务输入命令hvieserver2然后jps一下会多出一个进程"><a class="markdownIt-Anchor" href="#13-hadoop重启完成之后我们可以开始启动hiveserver2服务输入命令hvieserver2然后jps一下会多出一个进程"></a> 1.3 hadoop重启完成之后，我们可以开始启动hiveserver2服务，输入命令：hvieserver2,然后jps一下会多出一个进程：</h5><p><img src="https://i.imgur.com/roScdjR.png" alt=""></p><p>当然这种方式启动hiveserver2服务，你关闭窗口服务就挂了，我们可以使用后台的方式来启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nohup hiveserver2 1&gt;/usr/local/hive/log/hiveserver.log 2&gt;/usr/local/hive/log/hiveserver.err &amp;</span><br><span class="line">或者：</span><br><span class="line">nohup hiveserver2 1&gt;/dev/null 2&gt;/dev/null &amp;</span><br><span class="line">或者：</span><br><span class="line">nohup hiveserver2 &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>以上3个命令是等价的，第一个表示记录日志，第二个和第三个不记录日志。</p><p>其中第一个命令中的1 和 2 的含义分别是：</p><p>1：表示标准输出日志</p><p>2：表示错误日志输出，如果你没有配置错误输出目录，则会在当前工作目录下生成目录，默认日志名叫做：<span class="exturl" data-url="aHR0cDovL25vaHVwLnh4eA==" title="http://nohup.xxx">nohup.xxx<i class="fa fa-external-link"></i></span></p><p><strong>命令学习：nohup 命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束， 那么可以使用 nohup 命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。 nohup 就是不挂起的意思(no hang up)。 该命令的一般形式为：nohup command &amp;</strong></p><h5 id="14-启动完毕hiveserver2服务之后我们可以开始启用beeline客户端去连接"><a class="markdownIt-Anchor" href="#14-启动完毕hiveserver2服务之后我们可以开始启用beeline客户端去连接"></a> 1.4 启动完毕hiveserver2服务之后，我们可以开始启用beeline客户端去连接：</h5><p><img src="https://i.imgur.com/GlYevQi.png" alt=""></p><p>输入beeline命令之后需要你手动的输入连接串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!connect jdbc:hive2://hadoopmaster:10000 -n root</span><br></pre></td></tr></table></figure><p>当然我们也直接将连接串拼接在beeline命令后面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beeline -u jdbc:hive2://hadoopmaster:10000 -n root --color=true --silent=false</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/wWO94c9.png" alt=""></p><h5 id="15-以下为beeline常用的参数解释"><a class="markdownIt-Anchor" href="#15-以下为beeline常用的参数解释"></a> 1.5 以下为beeline常用的参数解释：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The Beeline CLI 支持以下命令行参数:    </span><br><span class="line">Option    </span><br><span class="line">Description    </span><br><span class="line">--autoCommit=[true/false] ---进入一个自动提交模式：beeline --autoCommit=true    </span><br><span class="line">--autosave=[true/false]   ---进入一个自动保存模式：beeline --autosave=true    </span><br><span class="line">--color=[true/false]    ---显示用到的颜色：beeline --color=true    </span><br><span class="line">--delimiterForDSV= DELIMITER ---分隔值输出格式的分隔符。默认是“|”字符。    </span><br><span class="line">--fastConnect=[true/false]  ---在连接时，跳过组建表等对象：beeline --fastConnect=false    </span><br><span class="line">--force=[true/false]    ---是否强制运行脚本：beeline--force=true    </span><br><span class="line">--headerInterval=ROWS   ---输出的表间隔格式，默认是100: beeline --headerInterval=50    </span><br><span class="line">--help ---帮助  beeline --help    </span><br><span class="line">--hiveconf property=value  ---设置属性值，以防被hive.conf.restricted.list重置：beeline --hiveconf prop1=value1     </span><br><span class="line">--hivevar name=value   ---设置变量名：beeline --hivevar var1=value1    </span><br><span class="line">--incremental=[true/false]  ---输出增量  </span><br><span class="line">--isolation=LEVEL  ---设置事务隔离级别：beeline --isolation=TRANSACTION_SERIALIZABLE    </span><br><span class="line">--maxColumnWidth=MAXCOLWIDTH ---设置字符串列的最大宽度：beeline --maxColumnWidth=25    </span><br><span class="line">--maxWidth=MAXWIDTH ---设置截断数据的最大宽度：beeline --maxWidth=150    </span><br><span class="line">--nullemptystring=[true/false]  ---打印空字符串：beeline --nullemptystring=false    </span><br><span class="line">--numberFormat=[pattern]     ---数字使用DecimalFormat：beeline --numberFormat="#,###,##0.00"    </span><br><span class="line">--outputformat=[table/vertical/csv/tsv/dsv/csv2/tsv2] ---输出格式：beeline --outputformat=tsv     </span><br><span class="line">--showHeader=[true/false]   ---显示查询结果的列名：beeline --showHeader=false    </span><br><span class="line">--showNestedErrs=[true/false] ---显示嵌套错误：beeline --showNestedErrs=true    </span><br><span class="line">--showWarnings=[true/false] ---显示警告：beeline --showWarnings=true    </span><br><span class="line">--silent=[true/false]  ---减少显示的信息量：beeline --silent=true    </span><br><span class="line">--truncateTable=[true/false] ---是否在客户端截断表的列       </span><br><span class="line">--verbose=[true/false]  ---显示详细错误信息和调试信息：beeline --verbose=true    </span><br><span class="line">-d &lt;driver class&gt;  ---使用一个驱动类：beeline -d driver_class    </span><br><span class="line">-e &lt;query&gt;  ---使用一个查询语句：beeline -e "query_string"    </span><br><span class="line">-f &lt;file&gt;  ---加载一个文件：beeline -f filepath  多个文件用-e file1 -e file2  </span><br><span class="line">-n &lt;username&gt;  ---加载一个用户名：beeline -n valid_user    </span><br><span class="line">-p &lt;password&gt;  ---加载一个密码：beeline -p valid_password</span><br></pre></td></tr></table></figure><p>使用java连接hiveserver2服务</p><p>既然hiveserver2就是为了提供远程连接hive服务的功能，我们直接使用java来操作一下，首先必须的启动hiveserver2服务。</p><h4 id="2-基于java的hive访问"><a class="markdownIt-Anchor" href="#2-基于java的hive访问"></a> 2. 基于java的hive访问</h4><p>如下所示工程基于maven搭建，需要引入如下jar包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.hust.demo1.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiveClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverName = <span class="string">"org.apache.hive.jdbc.HiveDriver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Connection con = DriverManager.getConnection(<span class="string">"jdbc:hive2://hadoopmaster:10000/default"</span>, <span class="string">"hadoop"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        Statement stmt = con.createStatement();</span><br><span class="line">        String sql = <span class="string">"select * from t2"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Running: "</span> + sql);</span><br><span class="line">        ResultSet res = stmt.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">            System.out.println(res.getString(<span class="number">1</span>)+ <span class="string">" "</span> +res.getString(<span class="number">2</span>) + <span class="string">" "</span> + res.getString(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        String insertSql = <span class="string">"insert into t2 (id,name,age) values(4,\"xiaocun\",13)"</span>;</span><br><span class="line">        stmt.execute(insertSql);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Running: "</span> + sql);</span><br><span class="line">        ResultSet res1 = stmt.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (res1.next()) &#123;</span><br><span class="line">            System.out.println(res1.getString(<span class="number">1</span>)+ <span class="string">" "</span> +res1.getString(<span class="number">2</span>) + <span class="string">" "</span> + res1.getString(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行完毕结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Running: select * from t2</span><br><span class="line"><span class="number">1</span> xiaoming <span class="number">12</span></span><br><span class="line"><span class="number">2</span> xiaohong <span class="number">13</span></span><br><span class="line"><span class="number">3</span> xiaohei <span class="number">15</span></span><br><span class="line">-----------------------</span><br><span class="line">Running: select * from t2</span><br><span class="line"><span class="number">1</span> xiaoming <span class="number">12</span></span><br><span class="line"><span class="number">2</span> xiaohong <span class="number">13</span></span><br><span class="line"><span class="number">3</span> xiaohei <span class="number">15</span></span><br><span class="line"><span class="number">4</span> xiaocun <span class="number">13</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道hive的数据是存储在HDFS上的，hive只是充当一个客户端，实际上是去HDFS执行mapReduce命令。在我们第一次安装hive的时候，介绍过使用bin目录下的&amp;quot;hive&amp;quot;命令去启动hive客户端程序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hive" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hive/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>hive元数据存储-MYSQL数据库表</title>
    <link href="http://blog.rickiyang.cn/posts/dfd44a4f.html"/>
    <id>http://blog.rickiyang.cn/posts/dfd44a4f.html</id>
    <published>2018-11-22T09:15:55.000Z</published>
    <updated>2019-01-02T11:42:40.842Z</updated>
    
    <content type="html"><![CDATA[<p>hive默认本地存储是将元数据存储在内嵌的Derby数据库中，但是生产环境中没有人会用本地模式，一般remote模式使用MYSQL数据库，我们在hive-site.xml中也是配置的MYSQL数据库来存储元数据，下面就来看一下在MYSQL中是如何存储这些元数据信息的。</p><p>在本地我们连接MYSQL可以看到hive元数据存储创建的表还真的不少：</p><p><img src="https://i.imgur.com/n08NQD4.jpg" alt=""></p><h4 id="1hive表和视图相关的元数据表"><a class="markdownIt-Anchor" href="#1hive表和视图相关的元数据表"></a> 1.hive表和视图相关的元数据表</h4><p><strong>主要有TBLS、TABLE_PARAMS、TBL_PRIVS，这三张表通过TBL_ID关联。</strong></p><ul><li>TBLS：存储Hive表、视图、索引表的基本信息</li><li>TABLE_PARAMS：该表存储表/视图的属性信息</li><li>TBL_PRIVS： 该表存储表/视图的授权信息</li></ul><p>TBLS表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>TBL_ID</strong></td><td>表ID</td><td>1</td></tr><tr><td><strong>CREATE_TIME</strong></td><td>创建时间</td><td>1546336624</td></tr><tr><td><strong>DB_ID</strong></td><td>数据库ID</td><td>2，对应DBS中的DB_ID</td></tr><tr><td><strong>LAST_ACCESS_TIME</strong></td><td>上次访问时间</td><td>1546336624</td></tr><tr><td><strong>OWNER</strong></td><td>所有者</td><td>hadoop</td></tr><tr><td><strong>RETENTION</strong></td><td>保留字段</td><td>0</td></tr><tr><td><strong>SD_ID</strong></td><td>序列化配置信息</td><td>12，对应SDS表中的SD_ID</td></tr><tr><td><strong>TBL_NAME</strong></td><td>表名</td><td>t2</td></tr><tr><td><strong>TBL_TYPE</strong></td><td>表类型</td><td>MANAGED_TABLE、EXTERNAL_TABLE、INDEX_TABLE、VIRTUAL_VIEW</td></tr><tr><td><strong>VIEW_EXPANDED_TEXT</strong></td><td>视图的详细HQL语句</td><td>select  name,age from t2</td></tr><tr><td><strong>VIEW_ORIGINAL_TEXT</strong></td><td>视图的原始HQL语句</td><td>select * from t2</td></tr></tbody></table><p>TABLE_PARAMS表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>TBL_ID</strong></td><td>表ID</td><td>1</td></tr><tr><td><strong>PARAM_KEY</strong></td><td>属性名</td><td>totalSize、numFiles、EXTERNAL</td></tr><tr><td><strong>PARAM_VALUE</strong></td><td>属性值</td><td>1536169128、1536170730、TRUE</td></tr></tbody></table><p>TBL_PRIVS表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>TBL_GRANT_ID</strong></td><td>授权ID</td><td>1</td></tr><tr><td><strong>CREATE_TIME</strong></td><td>授权时间</td><td>1536169128</td></tr><tr><td><strong>GRANT_OPTION</strong></td><td>描述信息</td><td></td></tr><tr><td><strong>GRANTOR</strong></td><td>授权执行用户</td><td>hadoop</td></tr><tr><td><strong>GRANTOR_TYPE</strong></td><td>授权者类型</td><td>USER</td></tr><tr><td><strong>PRINCIPAL_NAME</strong></td><td>被授权用户</td><td>root</td></tr><tr><td><strong>PRINCIPAL_TYPE</strong></td><td>被授权用户类型</td><td>USER</td></tr><tr><td><strong>TBL_PRIV</strong></td><td>权限</td><td>Select、Alter</td></tr><tr><td><strong>TBL_ID</strong></td><td>表ID</td><td>1，对应TBLS表中的TBL_ID</td></tr></tbody></table><h4 id="2hive表字段相关的表"><a class="markdownIt-Anchor" href="#2hive表字段相关的表"></a> 2.hive表字段相关的表：</h4><p>hive会将所有表的字段信息都维护到这张表中：COLUMNS_V2 。</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>CD_ID</strong></td><td>字段信息ID</td><td>1</td></tr><tr><td><strong>COMMENT</strong></td><td>字段注释</td><td></td></tr><tr><td><strong>COLUMN_NAME</strong></td><td>字段名</td><td>name</td></tr><tr><td><strong>TYPE_NAME</strong></td><td>字段类型</td><td>string</td></tr><tr><td><strong>INTEGER_IDX</strong></td><td>字段顺序</td><td>3</td></tr></tbody></table><h4 id="3hive表分区相关的表"><a class="markdownIt-Anchor" href="#3hive表分区相关的表"></a> 3.hive表分区相关的表：</h4><p>主要有PARTITIONS、PARTITION_KEYS、PARTITION_KEY_VALS、PARTITION_PARAMS ：</p><ul><li>PARTITIONS： 该表存储表分区的基本信息 ；</li><li>PARTITION_KEYS：该表存储分区的字段信息；</li><li>PARTITION_KEY_VALS：该表存储分区字段值；</li><li>PARTITION_PARAMS ：该表存储分区的属性信息 。</li></ul><p>PARTITIONS表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>PART_ID</strong></td><td>分区ID</td><td>1</td></tr><tr><td><strong>CREATE_TIME</strong></td><td>分区创建时间</td><td>1536169128</td></tr><tr><td><strong>LAST_ACCESS_TIME</strong></td><td>最后一次访问时间</td><td>1636163126</td></tr><tr><td><strong>PART_NAME</strong></td><td>分区名</td><td>pt=2018-04-15</td></tr><tr><td><strong>SD_ID</strong></td><td>分区存储ID</td><td>33</td></tr><tr><td><strong>TBL_ID</strong></td><td>表ID</td><td>1</td></tr></tbody></table><p>PARTITION_KEYS表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>TBL_ID</strong></td><td>表ID</td><td>1</td></tr><tr><td><strong>PKEY_COMMENT</strong></td><td>分区字段说明</td><td></td></tr><tr><td><strong>PKEY_NAME</strong></td><td>分区字段名</td><td>area_id</td></tr><tr><td><strong>PKEY_TYPE</strong></td><td>分区字段类型</td><td>int</td></tr><tr><td><strong>INTEGER_IDX</strong></td><td>分区字段顺序</td><td>1</td></tr></tbody></table><p>PARTITION_KEY_VALS表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>PART_ID</strong></td><td>分区ID</td><td>1</td></tr><tr><td><strong>PART_KEY_VAL</strong></td><td>分区字段值</td><td>2018-04-20</td></tr><tr><td><strong>INTEGER_IDX</strong></td><td>分区字段值顺序</td><td>0</td></tr></tbody></table><p>PARTITION_PARAMS 表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>PART_ID</strong></td><td>分区ID</td><td>1</td></tr><tr><td><strong>PARAM_KEY</strong></td><td>分区属性名</td><td>numFiles、numRows</td></tr><tr><td><strong>PARAM_VALUE</strong></td><td>分区属性值</td><td>33、554222112</td></tr></tbody></table><h4 id="4-hive文件存储相关的表"><a class="markdownIt-Anchor" href="#4-hive文件存储相关的表"></a> 4.  hive文件存储相关的表：</h4><p>主要有SDS、SD_PARAMS、SERDES、SERDE_PARAMS 。</p><ul><li>SDS:该表保存文件存储的基本信息，如INPUT_FORMAT、OUTPUT_FORMAT、是否压缩等 ;</li><li>SD_PARAMS:该表存储Hive存储的属性信息，在创建表时候使用 ;</li><li>SERDES: 该表存储序列化使用的类信息 ;</li><li>SERDE_PARAMS : 该表存储序列化的一些属性、格式信息,比如：行、列分隔符 。</li></ul><p>SDS表：</p><table><thead><tr><th>表字段</th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>SD_ID</strong></td><td>存储信息ID</td><td>1</td></tr><tr><td><strong>CD_ID</strong></td><td>字段信息ID</td><td>1，对应CDS表</td></tr><tr><td><strong>INPUT_FORMAT</strong></td><td>文件输入格式</td><td>org.apache.hadoop.mapred.TextInputFormat</td></tr><tr><td><strong>IS_COMPRESSED</strong></td><td>是否压缩</td><td>0</td></tr><tr><td><strong>IS_STOREDASSUBDIRECTORIES</strong></td><td>是否以子目录存储</td><td>0</td></tr><tr><td><strong>LOCATION</strong></td><td>HDFS路径</td><td>hdfs://hadoopmaster:9000/user/hive/warehouse/t2</td></tr><tr><td><strong>NUM_BUCKETS</strong></td><td>分桶数量</td><td>3</td></tr><tr><td><strong>OUTPUT_FORMAT</strong></td><td>文件输出格式</td><td>org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat</td></tr><tr><td><strong>SERDE_ID</strong></td><td>序列化类ID</td><td>3，对应SERDES表</td></tr></tbody></table><p>SD_PARAMS表：</p><table><thead><tr><th><strong>表字段</strong></th><th>说明</th><th>示例数据</th></tr></thead><tbody><tr><td><strong>SD_ID</strong></td><td>存储配置ID</td><td>1</td></tr><tr><td><strong>PARAM_KEY</strong></td><td>存储属性名</td><td>serialization.format</td></tr><tr><td><strong>PARAM_VALUE</strong></td><td>存储属性值</td><td>1</td></tr></tbody></table><p>SERDES表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>SERDE_ID</strong></td><td>序列化类配置ID</td><td>1</td></tr><tr><td><strong>PARAM_KEY</strong></td><td>属性名</td><td></td></tr><tr><td><strong>PARAM_VALUE</strong></td><td>属性值</td><td>org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</td></tr></tbody></table><p>SERDE_PARAMS 表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>SERDE_ID</strong></td><td>序列化类配置ID</td><td>1</td></tr><tr><td><strong>PARAM_KEY</strong></td><td>属性名</td><td>serialization.format</td></tr><tr><td><strong>PARAM_VALUE</strong></td><td>属性值</td><td>1</td></tr></tbody></table><h4 id="5hive数据库相关基本信息"><a class="markdownIt-Anchor" href="#5hive数据库相关基本信息"></a> 5.hive数据库相关基本信息</h4><p>VERSION,DBS,DATABASE_PARAMS,主要描述hive版本以及hive用户相关信息。</p><ul><li>VERSION ：查询版本信息 ；</li><li>DBS：存储Hive中所有数据库的基本信息；</li><li>DATABASE_PARAMS：存储数据库的相关参数，在CREATE DATABASE时候用 。</li></ul><p>VERSION 表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>VER_ID</strong></td><td>ID主键</td><td>1</td></tr><tr><td><strong>SCHEMA_VERSION</strong></td><td>Hive版本</td><td>2.3.0</td></tr><tr><td><strong>VERSION_COMMENT</strong></td><td>版本说明</td><td>Hive release version 2.3.0</td></tr></tbody></table><p>DBS表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>DB_ID</strong></td><td>数据库ID</td><td>2</td></tr><tr><td><strong>DESC</strong></td><td>数据库描述</td><td>测试库</td></tr><tr><td><strong>DB_LOCATION_URI</strong></td><td>数据库HDFS路径</td><td>hdfs://hadoopmaster:9000/user/hive/warehouse</td></tr><tr><td><strong>NAME</strong></td><td>数据库名</td><td>default</td></tr><tr><td><strong>OWNER_NAME</strong></td><td>数据库所有者用户名</td><td>public</td></tr><tr><td><strong>OWNER_TYPE</strong></td><td>所有者角色</td><td>ROLE</td></tr></tbody></table><p>DATABASE_PARAMS表：</p><table><thead><tr><th><strong>表字段</strong></th><th><strong>说明</strong></th><th><strong>示例数据</strong></th></tr></thead><tbody><tr><td><strong>DB_ID</strong></td><td>数据库ID</td><td></td></tr><tr><td><strong>PARAM_KEY</strong></td><td>参数名</td><td></td></tr><tr><td><strong>PARAM_VALUE</strong></td><td>参数值</td><td></td></tr></tbody></table><h4 id="6其他一些不常用的表"><a class="markdownIt-Anchor" href="#6其他一些不常用的表"></a> 6.其他一些不常用的表：</h4><ul><li><p><strong>DB_PRIVS</strong>：数据库权限信息表。通过GRANT语句对数据库授权后，将会在这里存储;</p></li><li><p><strong>FUNCS</strong>：用户注册的函数信息;</p></li><li><p><strong>FUNC_RU</strong>：用户注册函数的资源信息;</p></li><li><p><strong>IDXS</strong>：索引表，存储Hive索引相关的元数据;</p></li><li><p><strong>INDEX_PARAMS</strong>：索引相关的属性信息;</p></li><li><p><strong>PART_PRIVS</strong>：分区的授权信息;</p></li><li><p><strong>PART_COL_STATS</strong>：分区字段的统计信息;</p></li><li><p><strong>PART_COL_PRIVS</strong>：分区字段的权限信息;</p></li><li><p><strong>TAB_COL_STATS</strong>：表字段的统计信息,使用ANALYZE语句对表字段分析后记录在这里;</p></li><li><p><strong>TBL_COL_PRIVS</strong>：表字段的授权信息</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hive默认本地存储是将元数据存储在内嵌的Derby数据库中，但是生产环境中没有人会用本地模式，一般remote模式使用MYSQL数据库，我们在hive-site.xml中也是配置的MYSQL数据库来存储元数据，下面就来看一下在MYSQL中是如何存储这些元数据信息的。&lt;/p
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hive" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hive/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>序列化--Avro</title>
    <link href="http://blog.rickiyang.cn/posts/62981c04.html"/>
    <id>http://blog.rickiyang.cn/posts/62981c04.html</id>
    <published>2018-11-20T08:23:08.000Z</published>
    <updated>2019-01-07T01:55:42.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="avro"><a class="markdownIt-Anchor" href="#avro"></a> avro</h1><p>Avro是一种序列化的方法。常见的序列化有Java的Serializable,google的protobuf，以及Doug Cutting的Avro。</p><h4 id="avro的schema"><a class="markdownIt-Anchor" href="#avro的schema"></a> Avro的Schema</h4><p>Avro的Schema用JSON表示。Schema定义了简单数据类型和复杂数据类型。</p><h4 id="avro基本数据类型"><a class="markdownIt-Anchor" href="#avro基本数据类型"></a> Avro基本数据类型</h4><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>null</td><td>没有值</td></tr><tr><td>boolean</td><td>布尔值</td></tr><tr><td>int</td><td>32位有符号整数</td></tr><tr><td>long</td><td>64位有符号整数</td></tr><tr><td>float</td><td>单精度（32位）的IEEE 754浮点数</td></tr><tr><td>double</td><td>双精度（64位）的IEEE 754浮点数</td></tr><tr><td>bytes</td><td>8位无符号字节序列</td></tr><tr><td>string</td><td>字符串</td></tr></tbody></table><p>基本类型没有属性，基本类型的名字也就是类型的名字，比如：</p><pre><code>{&quot;type&quot;: &quot;string&quot;}</code></pre><p>​</p><h4 id="复杂类型"><a class="markdownIt-Anchor" href="#复杂类型"></a> 复杂类型</h4><p>Avro提供了6种复杂类型。分别是Record，Enum，Array，Map，Union和Fixed。<br>​</p><h5 id="record"><a class="markdownIt-Anchor" href="#record"></a> Record</h5><p>Record类型使用的类型名字是 “record”，还支持其它属性的设置：</p><ol><li>name：record类型的名字(必填)</li><li>namespace：命名空间(可选)</li><li>doc：这个类型的文档说明(可选)</li><li>aliases：record类型的别名，是个字符串数组(可选)</li><li>fields：record类型中的字段，是个对象数组(必填)。每个字段需要以下属性：<ul><li><pre><code>name：字段名字(必填)</code></pre></li><li><pre><code>doc：字段说明文档(可选)</code></pre></li><li><pre><code>type：一个schema的json对象或者一个类型名字(必填)</code></pre></li><li><pre><code>default：默认值(可选)</code></pre></li><li><pre><code>order：排序(可选)，只有3个值ascending(默认)，descending或ignore</code></pre></li><li><pre><code>aliases：别名，字符串数组(可选)</code></pre></li></ul></li></ol><p>一个Record类型例子，定义一个元素类型是Long的链表：</p><pre><code>{  &quot;type&quot;: &quot;record&quot;,   &quot;name&quot;: &quot;LongList&quot;,  &quot;aliases&quot;: [&quot;LinkedLongs&quot;],                      // old name for this  &quot;fields&quot; : [    {&quot;name&quot;: &quot;value&quot;, &quot;type&quot;: &quot;long&quot;},             // each element has a long    {&quot;name&quot;: &quot;next&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;LongList&quot;]} // optional next element  ]}</code></pre><p>​</p><h5 id="enum"><a class="markdownIt-Anchor" href="#enum"></a> Enum</h5><p>枚举类型的类型名字是”enum”，还支持其它属性的设置：</p><ol><li>name：枚举类型的名字(必填)</li><li>namespace：命名空间(可选)</li><li>aliases：字符串数组，别名(可选)</li><li>doc：说明文档(可选)</li><li>symbols：字符串数组，所有的枚举值(必填)，不允许重复数据。</li></ol><p>一个枚举类型的例子：</p><pre><code>{ &quot;type&quot;: &quot;enum&quot;,  &quot;name&quot;: &quot;Suit&quot;,  &quot;symbols&quot; : [&quot;SPADES&quot;, &quot;HEARTS&quot;, &quot;DIAMONDS&quot;, &quot;CLUBS&quot;]}</code></pre><h5 id="array"><a class="markdownIt-Anchor" href="#array"></a> Array</h5><p>数组类型的类型名字是”array”并且只支持一个属性：</p><p>items：数组元素的schema</p><p>一个数组例子：</p><pre><code>{&quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &quot;string&quot;}</code></pre><h5 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h5><p>Map类型的类型名字是”map”并且只支持一个属性：</p><p>values：map值的schema</p><p>Map的key必须是字符串。</p><p>一个Map例子：</p><pre><code>{&quot;type&quot;: &quot;map&quot;, &quot;values&quot;: &quot;long&quot;}</code></pre><h5 id="union"><a class="markdownIt-Anchor" href="#union"></a> Union</h5><p>组合类型，表示各种类型的组合，使用数组进行组合。比如[“null”, “string”]表示类型可以为null或者string。</p><p>组合类型的默认值是看组合类型的第一个元素，因此如果一个组合类型包括null类型，那么null类型一般都会放在第一个位置，这样子的话这个组合类型的默认值就是null。</p><p>组合类型中不允许同一种类型的元素的个数不会超过1个，除了record，fixed和enum。比如组合类中有2个array类型或者2个map类型，这是不允许的。</p><p>组合类型不允许嵌套组合类型。</p><h5 id="fixed"><a class="markdownIt-Anchor" href="#fixed"></a> Fixed</h5><p>混合类型的类型名字是fixed，支持以下属性：</p><ol><li>name：名字(必填)</li><li>namespace：命名空间(可选)</li><li>aliases：字符串数组，别名(可选)</li><li>size：一个整数，表示每个值的字节数(必填)</li></ol><p>比如16个字节数的fixed类型例子如下：</p><pre><code>{&quot;type&quot;: &quot;fixed&quot;, &quot;size&quot;: 16, &quot;name&quot;: &quot;md5&quot;}</code></pre><h4 id="avro序列化方式"><a class="markdownIt-Anchor" href="#avro序列化方式"></a> Avro序列化方式</h4><p>Avro使用Json来声明Schema，这个预先定义的模式作为通信两端数据协议，在网络传输前后对目标数据进行二进制处理。</p><h5 id="定义schema"><a class="markdownIt-Anchor" href="#定义schema"></a> 定义schema</h5><p>首先定义一个schema，user.avsc：</p><pre><code>{&quot;namespace&quot;: &quot;com.rickiyang.avro&quot;, &quot;type&quot;: &quot;record&quot;, &quot;name&quot;: &quot;User&quot;, &quot;fields&quot;: [     {&quot;name&quot;: &quot;name&quot;, &quot;type&quot;: &quot;string&quot;},     {&quot;name&quot;: &quot;age&quot;,  &quot;type&quot;: [&quot;int&quot;, &quot;null&quot;]},     {&quot;name&quot;: &quot;sex&quot;, &quot;type&quot;: [&quot;int&quot;, &quot;null&quot;]} ]}</code></pre><p>上面schema中使用的是record类型，里面的各个字段上面都有解释。</p><h5 id="编译schema"><a class="markdownIt-Anchor" href="#编译schema"></a> 编译schema</h5><p>根据schema生成相应的java类对象，用户set值。</p><p>编译schema有两种方式，一种是通过maven插件生成，一种是命令行的方式。</p><p>命令行方式：<br>需要额外的jar包：avro-tools-1.8.1.jar,(<span class="exturl" data-url="aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS9hcnRpZmFjdC9vcmcuYXBhY2hlLmF2cm8vYXZyby1tYXZlbi1wbHVnaW4=" title="https://mvnrepository.com/artifact/org.apache.avro/avro-maven-plugin">https://mvnrepository.com/artifact/org.apache.avro/avro-maven-plugin<i class="fa fa-external-link"></i></span>)</p><p>将该jar包和user.avsc文件放在同一目录下，执行如下命令：</p><pre><code>java -jar avro-tools-1.8.1.jar compile schema user.avsc .</code></pre><p>注意最后有个“.”,表示在当前目录下生成java文件。</p><p>执行完之后在当前目录下就会生成User类。接下来我们就可以使用刚才定义的对象去set值了。关于maven插件的方式就不多做说明，请参考这一篇博文(<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtYXBhY2hlLWF2cm8=" title="https://www.baeldung.com/java-apache-avro">https://www.baeldung.com/java-apache-avro<i class="fa fa-external-link"></i></span>)，在你的IDE中安装maven插件，set source path 和 target path，然后执行“mvn clean install” 即可。</p><h4 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h4><p>上面编译schema生成java对象，我们拿到java对象可以去set相应的值。当然也有一种不通过使用生成的User对象的方式去序列化，我们一一介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.avro.Schema;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.file.DataFileReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.file.DataFileWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.generic.GenericData;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.generic.GenericDatumReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.generic.GenericDatumWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.generic.GenericRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.io.DatumReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.io.DatumWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.specific.SpecificDatumReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.specific.SpecificDatumWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 上午10:20 2018/11/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        encode();</span><br><span class="line">        decode();</span><br><span class="line">        nonCoding();</span><br><span class="line">        nonCodingDecode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User user1 = <span class="keyword">new</span> User();</span><br><span class="line">            user1.setName(<span class="string">"Tom"</span>);</span><br><span class="line">            user1.setAge(<span class="number">7</span>);</span><br><span class="line">            user1.setSex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            DatumWriter&lt;User&gt; userDatumWriter = <span class="keyword">new</span> SpecificDatumWriter&lt;&gt;(User.class);</span><br><span class="line">            DataFileWriter&lt;User&gt; dataFileWriter = <span class="keyword">new</span> DataFileWriter&lt;&gt;(userDatumWriter);</span><br><span class="line">            dataFileWriter.create(user1.getSchema(), <span class="keyword">new</span> File(<span class="string">"user.avro"</span>));</span><br><span class="line">            dataFileWriter.append(user1);</span><br><span class="line">            dataFileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DatumReader&lt;User&gt; userDatumReader = <span class="keyword">new</span> SpecificDatumReader&lt;&gt;(User.class);</span><br><span class="line">            DataFileReader&lt;User&gt; dataFileReader = <span class="keyword">new</span> DataFileReader&lt;&gt;(<span class="keyword">new</span> File(<span class="string">"user.avro"</span>), userDatumReader);</span><br><span class="line">            User user = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (dataFileReader.hasNext()) &#123;</span><br><span class="line">                user = dataFileReader.next(user);</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用对象的序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonCoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Serialization.class.getClassLoader();</span><br><span class="line">            String avscFilePath = classLoader.getClass().getResource(<span class="string">"/user.avsc"</span>).getPath();</span><br><span class="line">            Schema schema = <span class="keyword">new</span> Schema.Parser().parse(<span class="keyword">new</span> File(avscFilePath));</span><br><span class="line"></span><br><span class="line">            GenericRecord user1 = <span class="keyword">new</span> GenericData.Record(schema);</span><br><span class="line">            user1.put(<span class="string">"name"</span>, <span class="string">"Tony"</span>);</span><br><span class="line">            user1.put(<span class="string">"age"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">            GenericRecord user2 = <span class="keyword">new</span> GenericData.Record(schema);</span><br><span class="line">            user2.put(<span class="string">"name"</span>, <span class="string">"Ben"</span>);</span><br><span class="line">            user2.put(<span class="string">"age"</span>, <span class="number">3</span>);</span><br><span class="line">            user2.put(<span class="string">"sex"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"user.avro"</span>);</span><br><span class="line">            DatumWriter&lt;GenericRecord&gt; datumWriter = <span class="keyword">new</span> GenericDatumWriter&lt;&gt;(schema);</span><br><span class="line">            DataFileWriter&lt;GenericRecord&gt; dataFileWriter = <span class="keyword">new</span> DataFileWriter&lt;&gt;(datumWriter);</span><br><span class="line">            dataFileWriter.create(schema, file);</span><br><span class="line">            dataFileWriter.append(user1);</span><br><span class="line">            dataFileWriter.append(user2);</span><br><span class="line">            dataFileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用对象的反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonCodingDecode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Serialization.class.getClassLoader();</span><br><span class="line">            String avscFilePath = classLoader.getClass().getResource(<span class="string">"/user.avsc"</span>).getPath();</span><br><span class="line">            Schema schema = <span class="keyword">new</span> Schema.Parser().parse(<span class="keyword">new</span> File(avscFilePath));</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"user.avro"</span>);</span><br><span class="line">            DatumReader&lt;GenericRecord&gt; datumReader = <span class="keyword">new</span> GenericDatumReader&lt;&gt;(schema);</span><br><span class="line">            DataFileReader&lt;GenericRecord&gt; dataFileReader = <span class="keyword">new</span> DataFileReader&lt;&gt;(file, datumReader);</span><br><span class="line">            GenericRecord user = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (dataFileReader.hasNext()) &#123;</span><br><span class="line">                user = dataFileReader.next(user);</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为序列化和反序列化的两种方式，注意到序列化的文件都输出到根目录下的user.avro这个文件中，输出序列化文件，使用于写数据到HDFS中存储使用。</p><h4 id="avro实战"><a class="markdownIt-Anchor" href="#avro实战"></a> Avro实战</h4><h5 id="kafka与avro"><a class="markdownIt-Anchor" href="#kafka与avro"></a> Kafka与Avro</h5><p>上面已经生成User类，我们可以用该对象去发送avro消息。</p><p>引进pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建Consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 下午4:17 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">import</span> org.apache.avro.specific.SpecificRecordBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.StringDeserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.StreamSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SpecificRecordBase</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> KafkaConsumer&lt;String, T&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(getProperties());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">receive</span><span class="params">(Topic topic)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        TopicPartition partition = new TopicPartition(topic.topicName, 0);</span></span><br><span class="line">        consumer.subscribe(Collections.singletonList(topic.topicName));</span><br><span class="line"><span class="comment">//        consumer.assign(Collections.singletonList(partition));</span></span><br><span class="line">        ConsumerRecords&lt;String, T&gt; records = consumer.poll(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(records.spliterator(), <span class="keyword">false</span>)</span><br><span class="line">                .map(ConsumerRecord::value).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"DemoConsumer"</span>);</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                AvroDeserializer.class.getName());</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Avro 对象的反序列化类 AvroDeserializer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 下午4:17 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.encoding.soap.DeserializationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.io.BinaryDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.io.DatumReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.io.DecoderFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.specific.SpecificDatumReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.specific.SpecificRecordBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.Deserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvroDeserializer</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SpecificRecordBase</span>&gt; <span class="keyword">implements</span> <span class="title">Deserializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs, <span class="keyword">boolean</span> isKey)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deserialize</span><span class="params">(String topic, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DatumReader&lt;T&gt; userDatumReader = <span class="keyword">new</span> SpecificDatumReader&lt;&gt;(Topic.matchFor(topic).topicType.getSchema());</span><br><span class="line">        BinaryDecoder binaryEncoder = DecoderFactory.get().directBinaryDecoder(<span class="keyword">new</span> ByteArrayInputStream(data), <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> userDatumReader.read(<span class="keyword">null</span>, binaryEncoder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DeserializationException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Consumer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 下午4:17 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">import</span> org.apache.avro.specific.SpecificRecordBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.StringDeserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.StreamSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SpecificRecordBase</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> KafkaConsumer&lt;String, T&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(getProperties());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">receive</span><span class="params">(Topic topic)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        TopicPartition partition = new TopicPartition(topic.topicName, 0);</span></span><br><span class="line">        consumer.subscribe(Collections.singletonList(topic.topicName));</span><br><span class="line"><span class="comment">//        consumer.assign(Collections.singletonList(partition));</span></span><br><span class="line">        ConsumerRecords&lt;String, T&gt; records = consumer.poll(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(records.spliterator(), <span class="keyword">false</span>)</span><br><span class="line">                .map(ConsumerRecord::value).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"DemoConsumer"</span>);</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                AvroDeserializer.class.getName());</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<br>创建序列化avro对象的解析器AvroSerializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 下午4:16 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">import</span> org.apache.avro.io.BinaryEncoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.io.DatumWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.io.EncoderFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.specific.SpecificDatumWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.specific.SpecificRecordBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.errors.SerializationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.Serializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvroSerializer</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SpecificRecordBase</span>&gt; <span class="keyword">implements</span> <span class="title">Serializer</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs, <span class="keyword">boolean</span> isKey)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String topic, T data) &#123;</span><br><span class="line">        DatumWriter&lt;T&gt; userDatumWriter = <span class="keyword">new</span> SpecificDatumWriter&lt;&gt;(data.getSchema());</span><br><span class="line">        ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        BinaryEncoder binaryEncoder = EncoderFactory.get().directBinaryEncoder(outputStream, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userDatumWriter.write(data, binaryEncoder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个topic：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 下午4:17 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">import</span> com.rickiyang.avro.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.avro.specific.SpecificRecordBase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Topic &#123;</span><br><span class="line">    USER(<span class="string">"user-info-topic"</span>, <span class="keyword">new</span> User());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String topicName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SpecificRecordBase topicType;</span><br><span class="line"></span><br><span class="line">    Topic(String topicName, SpecificRecordBase topicType) &#123;</span><br><span class="line">        <span class="keyword">this</span>.topicName = topicName;</span><br><span class="line">        <span class="keyword">this</span>.topicType = topicType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Topic <span class="title">matchFor</span><span class="params">(String topicName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumSet.allOf(Topic.class).stream()</span><br><span class="line">                .filter(topic -&gt; topic.topicName.equals(topicName))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们可以运行一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rickiyang.avro.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 下午4:18 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Producer&lt;User&gt; producer = <span class="keyword">new</span> Producer&lt;&gt;();</span><br><span class="line">        Consumer&lt;User&gt; consumer = <span class="keyword">new</span> Consumer&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Please input 'send', 'receive', or 'exit'"</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String input = scanner.next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (input) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"send"</span>:</span><br><span class="line">                    producer.sendData(Topic.USER, <span class="keyword">new</span> User(<span class="string">"xiaoming"</span>, <span class="number">12</span>, <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"receive"</span>:</span><br><span class="line">                    List&lt;User&gt; users = consumer.receive(Topic.USER);</span><br><span class="line">                    <span class="keyword">if</span> (users.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Received nothing"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        users.forEach(user -&gt; System.out.println(<span class="string">"Received user: "</span> + user));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">"Please input 'send', 'receive', or 'exit'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;avro&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#avro&quot;&gt;&lt;/a&gt; avro&lt;/h1&gt;
&lt;p&gt;Avro是一种序列化的方法。常见的序列化有Java的Serializable,google的protobuf，以及Doug Cutt
      
    
    </summary>
    
      <category term="kafka" scheme="http://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hbase和HDFS之间互相操作数据</title>
    <link href="http://blog.rickiyang.cn/posts/d23070f0.html"/>
    <id>http://blog.rickiyang.cn/posts/d23070f0.html</id>
    <published>2018-10-22T13:32:18.000Z</published>
    <updated>2019-01-15T09:44:15.888Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1读取hdfs中的数据存入hbase"><a class="markdownIt-Anchor" href="#1读取hdfs中的数据存入hbase"></a> 1.读取HDFS中的数据存入Hbase</h4><p>现在在HDFS中有一个user.txt文件，格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">225694,林碧万,1,32,10000001</span><br><span class="line">224478,于震海,1,24,13060007</span><br><span class="line">224458,杨海兵,1,25,10054005</span><br><span class="line">224340,周旺沛,1,21,10034076</span><br><span class="line">225691,孙庆江,1,27,10000154</span><br><span class="line">224282,汪鹏名,1,22,10000001</span><br><span class="line">224285,郑博,1,26,10000154</span><br><span class="line">225699,孙天宇,2,23,10054005</span><br><span class="line">225708,徐飞,1,24,10054005</span><br><span class="line">225703,李风广,1,21,10000001</span><br><span class="line">224462,武静静,2,27,10000154</span><br><span class="line">225710,曾轲,1,28,13060007</span><br><span class="line">225715,刘通,1,26,10054005</span><br><span class="line">223720,赛林林,1,26,10000154</span><br><span class="line">224489,文俊龙,1,29,13060007</span><br><span class="line">225050,陈奔,1,26,10000154</span><br><span class="line">223728,吴迪,2,22,10054005</span><br><span class="line">225066,杨铭,1,24,10000001</span><br><span class="line">223745,刘靖文,1,26,10000154</span><br><span class="line">223755,杨佳鹏,1,24,10032049</span><br></pre></td></tr></table></figure><p>上面字段为别为：userid，name，gender，部门。</p><p>将数据存入HDFS，在HDFS中新建目录，/data，传入数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop dfs -put /usr/local/user.txt /data/</span><br></pre></td></tr></table></figure><p>将hdfs中的数据写入hbase,在hbase中建表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create 'users','info'</span><br></pre></td></tr></table></figure><p>下面写我们的hadoop代码，读取hadoop中的数据传入到Hbase。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configured;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableReducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从hdfs中读取数据插入到hbase</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadHDFSDataToHbaseMR</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> run = ToolRunner.run(<span class="keyword">new</span> ReadHDFSDataToHbaseMR(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] arg0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        conf.set(<span class="string">"fs.defaultFS"</span>, <span class="string">"hdfs://hadoopmaster:9000/"</span>);</span><br><span class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"hadoopmaster:2181,hadoopslaver1:2181,hadoopslaver2:2181"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"HADOOP_USER_NAME"</span>, <span class="string">"hadoop"</span>);</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line">       </span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line"></span><br><span class="line">        job.setJarByClass(ReadHDFSDataToHbaseMR.class);</span><br><span class="line">        job.setMapperClass(HDFSToHbaseMapper.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(NullWritable.class);</span><br><span class="line"></span><br><span class="line">        TableMapReduceUtil.initTableReducerJob(<span class="string">"users"</span>, HDFSToHbaseReducer.class, job, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        job.setOutputKeyClass(NullWritable.class);</span><br><span class="line">        job.setOutputValueClass(Put.class);</span><br><span class="line"></span><br><span class="line">        Path inputPath = <span class="keyword">new</span> Path(<span class="string">"/data/"</span>);</span><br><span class="line">        Path outputPath = <span class="keyword">new</span> Path(<span class="string">"/users/output/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fs.exists(outputPath)) &#123;</span><br><span class="line">            fs.delete(outputPath, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileInputFormat.addInputPath(job, inputPath);</span><br><span class="line">        FileOutputFormat.setOutputPath(job, outputPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isDone = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isDone ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HDFSToHbaseMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            context.write(value, NullWritable.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reduce处理的数据给到hbase，组装hbase的column</span></span><br><span class="line"><span class="comment">     * 225050,陈奔,1,34,10000154</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HDFSToHbaseReducer</span> <span class="keyword">extends</span> <span class="title">TableReducer</span>&lt;<span class="title">Text</span>, <span class="title">NullWritable</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;NullWritable&gt; values, Context context)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">            String[] split = key.toString().split(<span class="string">","</span>);</span><br><span class="line">            Put put = <span class="keyword">new</span> Put(split[<span class="number">0</span>].getBytes());</span><br><span class="line">            put.addColumn(<span class="string">"info"</span>.getBytes(), <span class="string">"name"</span>.getBytes(), split[<span class="number">1</span>].getBytes());</span><br><span class="line">            put.addColumn(<span class="string">"info"</span>.getBytes(), <span class="string">"sex"</span>.getBytes(), split[<span class="number">2</span>].getBytes());</span><br><span class="line">            put.addColumn(<span class="string">"info"</span>.getBytes(), <span class="string">"age"</span>.getBytes(), split[<span class="number">3</span>].getBytes());</span><br><span class="line">            put.addColumn(<span class="string">"info"</span>.getBytes(), <span class="string">"department"</span>.getBytes(), split[<span class="number">4</span>].getBytes());</span><br><span class="line">           </span><br><span class="line">            context.write(NullWritable.get(), put);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):018:0&gt; scan 'users'</span><br><span class="line">ROW                                   COLUMN+CELL</span><br><span class="line"> 223720                               column=info:age, timestamp=1547044148652, value=26</span><br><span class="line"> 223720                               column=info:department, timestamp=1547044148652, value=10000154</span><br><span class="line"> 223720                               column=info:name, timestamp=1547044148652, value=\xE8\xB5\x9B\xE6\x9E\x97\xE6\x9E\x97</span><br><span class="line"> 223720                               column=info:sex, timestamp=1547044148652, value=1</span><br><span class="line"> 223728                               column=info:age, timestamp=1547044148652, value=22</span><br><span class="line"> 223728                               column=info:department, timestamp=1547044148652, value=10054005</span><br><span class="line"> 223728                               column=info:name, timestamp=1547044148652, value=\xE5\x90\xB4\xE8\xBF\xAA</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"> 225710                               column=info:sex, timestamp=1547044148652, value=1</span><br><span class="line"> 225715                               column=info:age, timestamp=1547044148652, value=26</span><br><span class="line"> 225715                               column=info:department, timestamp=1547044148652, value=10054005</span><br><span class="line"> 225715                               column=info:name, timestamp=1547044148652, value=\xE5\x88\x98\xE9\x80\x9A</span><br><span class="line"> 225715                               column=info:sex, timestamp=1547044148652, value=1</span><br><span class="line"> 20 row(s) in 1.2050 seconds</span><br></pre></td></tr></table></figure><p>scan的结果可以看到中文的姓名在hbase中其实是转为ascii编码的16进制形式存储的。如果你想看这个值是什么，你可以使用Hbase的客户端，比如Hue，另外shell中支持直接查看，使用echo命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e '\xE5\x88\x98\xE9\x80\x9A'</span><br></pre></td></tr></table></figure><h4 id="2读取hbase数据存hdfs"><a class="markdownIt-Anchor" href="#2读取hbase数据存hdfs"></a> 2.读取Hbase数据存HDFS</h4><p>将hbase中的数据读取出来做运算，然后存入hdfs。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configured;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.Cell;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.CellUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Result;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Scan;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.DoubleWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从hbase中取出数据，计算平均年龄存入hdfs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadHbaseDataToHDFS</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> run = ToolRunner.run(<span class="keyword">new</span> ReadHbaseDataToHDFS(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] arg0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        conf.set(<span class="string">"fs.defaultFS"</span>, <span class="string">"hdfs://hadoopmaster:9000/"</span>);</span><br><span class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"hadoopmaster:2181,hadoopslaver1:2181,hadoopslaver2:2181"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"HADOOP_USER_NAME"</span>, <span class="string">"hadoop"</span>);</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(ReadHbaseDataToHDFS.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取对业务有用的数据 info,age</span></span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        scan.addColumn(<span class="string">"info"</span>.getBytes(), <span class="string">"age"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        TableMapReduceUtil.initTableMapperJob(</span><br><span class="line">                <span class="string">"student"</span>.getBytes(), <span class="comment">// 指定表名</span></span><br><span class="line">                scan, <span class="comment">// 指定扫描数据的条件</span></span><br><span class="line">                HbaseToHDFSMapper.class, <span class="comment">// 指定mapper class</span></span><br><span class="line">                Text.class,     <span class="comment">// outputKeyClass mapper阶段的输出的key的类型</span></span><br><span class="line">                IntWritable.class, <span class="comment">// outputValueClass mapper阶段的输出的value的类型</span></span><br><span class="line">                job, <span class="comment">// job对象</span></span><br><span class="line">                <span class="keyword">false</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        job.setReducerClass(HbaseToHDFSReducer.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(DoubleWritable.class);</span><br><span class="line"></span><br><span class="line">        Path outputPath = <span class="keyword">new</span> Path(<span class="string">"/data/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fs.exists(outputPath)) &#123;</span><br><span class="line">            fs.delete(outputPath, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputFormat.setOutputPath(job, outputPath);</span><br><span class="line">        <span class="keyword">boolean</span> isDone = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> isDone ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HbaseToHDFSMapper</span> <span class="keyword">extends</span> <span class="title">TableMapper</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        Text outKey = <span class="keyword">new</span> Text(<span class="string">"age"</span>);</span><br><span class="line">        IntWritable outValue = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key是hbase中的行键</span></span><br><span class="line">        <span class="comment">// value是hbase中的所行键的所有数据</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(ImmutableBytesWritable key, Result value, Context context)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isContainsColumn = value.containsColumn(<span class="string">"info"</span>.getBytes(), <span class="string">"age"</span>.getBytes());</span><br><span class="line">            <span class="keyword">if</span> (isContainsColumn) &#123;</span><br><span class="line">                List&lt;Cell&gt; listCells = value.getColumnCells(<span class="string">"info"</span>.getBytes(), <span class="string">"age"</span>.getBytes());</span><br><span class="line">                System.out.println(<span class="string">"listCells:\t"</span> + listCells);</span><br><span class="line">                Cell cell = listCells.get(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="string">"cells:\t"</span> + cell);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] cloneValue = CellUtil.cloneValue(cell);</span><br><span class="line">                String ageValue = Bytes.toString(cloneValue);</span><br><span class="line">                outValue.set(Integer.parseInt(ageValue));</span><br><span class="line"></span><br><span class="line">                context.write(outKey, outValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HbaseToHDFSReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">DoubleWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        DoubleWritable outValue = <span class="keyword">new</span> DoubleWritable();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                sum += value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> avgAge = sum * <span class="number">1.0</span> / count;</span><br><span class="line">            outValue.set(avgAge);</span><br><span class="line">            context.write(key, outValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序可以去hdfs中查看结果 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoopmaster hadoop]$ hdfs dfs -ls /data</span><br><span class="line">19/01/08 23:56:41 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">Found 2 items</span><br><span class="line">-rw-r--r--   3 hadoop supergroup          0 2019-01-08 23:55 /data/_SUCCESS</span><br><span class="line">-rw-r--r--   3 hadoop supergroup          0 2019-01-08 23:55 /data/part-r-00000</span><br><span class="line"></span><br><span class="line">[hadoop@hadoopmaster hadoop]$ hdfs dfs -cat /data/part-r-00000</span><br><span class="line">19/01/09 00:01:06 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">age25.15</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1读取hdfs中的数据存入hbase&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1读取hdfs中的数据存入hbase&quot;&gt;&lt;/a&gt; 1.读取HDFS中的数据存入Hbase&lt;/h4&gt;
&lt;p&gt;现在在HDFS中有一个user.txt文件，格
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hbase" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hbase/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hbase基本API操作</title>
    <link href="http://blog.rickiyang.cn/posts/106a4f35.html"/>
    <id>http://blog.rickiyang.cn/posts/106a4f35.html</id>
    <published>2018-10-15T14:43:11.000Z</published>
    <updated>2019-01-09T04:53:28.353Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲过Hbase的shell操作，那么在开发过程中我们如何用代码去操作Hbase呢，下面说一下关于Java操作Hbase的使用方式，以下代码使用IDEA搭建环境和运行。</p><p>工程目录结构如下，主要是引入core-site.xml和hbase-site.xml文件。</p><p><img src="https://i.imgur.com/Kzg9SZm.png" alt=""></p><p>core-site.xml如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoopmaster:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hbase-site.xml如下，将你自己服务器中hbase配置文件拷贝过来就行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.master<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoopmaster:60000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.master.maxclockskew<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>180000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoopmaster:9000/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hbase/tmp/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoopmaster,hadoopslaver1,hadoopslaver2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/zookeeper<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们就可以编写测试类：HbaseApiTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.hust.demo1.hbase;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.filter.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 下午7:57 2018/10/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> by:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HbaseApiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Configuration conf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> HBaseAdmin admin = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> Table table = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建conf对象</span></span><br><span class="line">        conf = HBaseConfiguration.create();</span><br><span class="line">        <span class="comment">//通过连接工厂创建连接对象</span></span><br><span class="line">        connection = ConnectionFactory.createConnection(conf);</span><br><span class="line">        <span class="comment">//通过连接查询tableName对象</span></span><br><span class="line">        TableName tname = TableName.valueOf(<span class="string">"user_info"</span>);</span><br><span class="line">        <span class="comment">//获得table</span></span><br><span class="line">        table = connection.getTable(tname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过bytes工具类创建字节数组(将字符串)</span></span><br><span class="line">        <span class="keyword">byte</span>[] rowid = Bytes.toBytes(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建put对象</span></span><br><span class="line">        Put put = <span class="keyword">new</span> Put(rowid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] f1 = Bytes.toBytes(<span class="string">"base_info"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] id = Bytes.toBytes(<span class="string">"sex"</span>) ;</span><br><span class="line">        <span class="keyword">byte</span>[] value = Bytes.toBytes(<span class="string">"0"</span>);</span><br><span class="line">        put.addColumn(f1,id,value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行插入</span></span><br><span class="line">        table.put(put);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过bytes工具类创建字节数组(将字符串)</span></span><br><span class="line">        Get get = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">"1"</span>));</span><br><span class="line">        Result r = table.get(get);</span><br><span class="line">        <span class="keyword">byte</span>[] idvalue = r.getValue(Bytes.toBytes(<span class="string">"base_info"</span>),Bytes.toBytes(<span class="string">"name"</span>));</span><br><span class="line">        System.out.println(Bytes.toString(idvalue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteTable</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        admin.disableTable(<span class="string">"base_info"</span>);</span><br><span class="line">        admin.deleteTable(<span class="string">"base_info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertSingleRecord</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Put rk1 = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">"2"</span>));</span><br><span class="line">        rk1.addColumn(Bytes.toBytes(<span class="string">"base_info"</span>), Bytes.toBytes(<span class="string">"name"</span>), Bytes.toBytes(<span class="string">"NikoBelic"</span>));</span><br><span class="line">        table.put(rk1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertMultipleRecords</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Put&gt; rowKeyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Put rk = <span class="keyword">new</span> Put(Bytes.toBytes(i+<span class="string">""</span>));</span><br><span class="line">            rk.addColumn(Bytes.toBytes(<span class="string">"base_info"</span>), Bytes.toBytes(<span class="string">"name"</span>), Bytes.toBytes(<span class="string">"Name"</span> + i));</span><br><span class="line">            rk.addColumn(Bytes.toBytes(<span class="string">"base_info"</span>), Bytes.toBytes(<span class="string">"sex"</span>), Bytes.toBytes(<span class="string">"sex"</span> + i));</span><br><span class="line">            rowKeyList.add(rk);</span><br><span class="line">        &#125;</span><br><span class="line">        table.put(rowKeyList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteRecord</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Delete delete = <span class="keyword">new</span> Delete(Bytes.toBytes(<span class="number">2</span>));</span><br><span class="line">        table.delete(delete);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetSingleRecord</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Get get = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="number">4</span>));</span><br><span class="line">        Result result = table.get(get);</span><br><span class="line">        printRow(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码讲过运行没有问题，可以在Hbase shell 中查看结果,当然，运行的前提是你有一张user_info表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):005:0&gt; create 'user_info','base_info','extra_info'</span><br><span class="line">0 row(s) in 3.3010 seconds</span><br><span class="line">hbase(main):021:0&gt; get 'user_info',1</span><br><span class="line">COLUMN                                CELL</span><br><span class="line"> base_info:name                       timestamp=1546873586767, value=xiaoming</span><br><span class="line"> base_info:sex                        timestamp=1546876032203, value=0</span><br><span class="line">1 row(s) in 0.0730 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):022:0&gt; get 'user_info',2</span><br><span class="line">COLUMN                                CELL</span><br><span class="line"> base_info:name                       timestamp=1546876130497, value=NikoBelic</span><br><span class="line"> base_info:sex                        timestamp=1546875961805, value=0</span><br><span class="line">1 row(s) in 0.0530 seconds</span><br><span class="line">hbase(main):033:0&gt; scan 'user_info'</span><br><span class="line">ROW                                   COLUMN+CELL</span><br><span class="line"> 0                                    column=base_info:name, timestamp=1546876537680, value=Name0</span><br><span class="line"> 0                                    column=base_info:sex, timestamp=1546876537680, value=sex0</span><br><span class="line"> 1                                    column=base_info:name, timestamp=1546876537680, value=Name1</span><br><span class="line"> 1                                    column=base_info:sex, timestamp=1546876537680, value=sex1</span><br><span class="line"> 2                                    column=base_info:name, timestamp=1546876537680, value=Name2</span><br><span class="line"> 2                                    column=base_info:sex, timestamp=1546876537680, value=sex2</span><br><span class="line"> 3                                    column=base_info:name, timestamp=1546876537680, value=Name3</span><br><span class="line"> 3                                    column=base_info:sex, timestamp=1546876537680, value=sex3</span><br><span class="line"> 4                                    column=base_info:name, timestamp=1546876537680, value=Name4</span><br><span class="line"> 4                                    column=base_info:sex, timestamp=1546876537680, value=sex4</span><br><span class="line"> 5                                    column=base_info:name, timestamp=1546876537680, value=Name5</span><br><span class="line"> 5                                    column=base_info:sex, timestamp=1546876537680, value=sex5</span><br><span class="line"> 6                                    column=base_info:name, timestamp=1546876537680, value=Name6</span><br><span class="line"> 6                                    column=base_info:sex, timestamp=1546876537680, value=sex6</span><br><span class="line"> 7                                    column=base_info:name, timestamp=1546876537680, value=Name7</span><br><span class="line"> 7                                    column=base_info:sex, timestamp=1546876537680, value=sex7</span><br><span class="line"> 8                                    column=base_info:name, timestamp=1546876537680, value=Name8</span><br><span class="line"> 8                                    column=base_info:sex, timestamp=1546876537680, value=sex8</span><br><span class="line"> 9                                    column=base_info:name, timestamp=1546876537680, value=Name9</span><br><span class="line"> 9                                    column=base_info:sex, timestamp=1546876537680, value=sex9</span><br><span class="line">10 row(s) in 0.2310 seconds</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面讲过Hbase的shell操作，那么在开发过程中我们如何用代码去操作Hbase呢，下面说一下关于Java操作Hbase的使用方式，以下代码使用IDEA搭建环境和运行。&lt;/p&gt;
&lt;p&gt;工程目录结构如下，主要是引入core-site.xml和hbase-site.xml文件
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hbase" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hbase/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>hbase初识</title>
    <link href="http://blog.rickiyang.cn/posts/e64b3d3a.html"/>
    <id>http://blog.rickiyang.cn/posts/e64b3d3a.html</id>
    <published>2018-10-13T07:12:55.000Z</published>
    <updated>2019-01-18T06:10:37.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hbase基本知识学习"><a class="markdownIt-Anchor" href="#hbase基本知识学习"></a> hbase基本知识学习</h2><p>数据在 HBase 中的排布（逻辑上）</p> <table>    <tr>        <th>Row-Key</th>        <th>Value（CF、Qualifier、Version</th>    </tr>    <tr>        <th>1</th>        <th>info{'姓': '张'，'名':'三'}             pwd{'密码': '111'}</th>    </tr>    <tr>        <th>2</th>        <th>Info{'姓': '李'}</th>    </tr></table><p>我们可以看出，在HBase中首先会有 Column Family 的概念，简称为CF。CF 一般用于将相关的列（Column）组合起来。在物理上 HBase其实是按 CF 存储的，只是按照 Row-key 将相关 CF 中的列关联起来。</p><p>数据在hbase中的物理分布如下：</p> <table>    <tr>        <th>Row-Key</th>        <th>CF:Column-Key</th>        <th>时间戳</th>        <th>Cell Value</th>    </tr>    <tr>        <th>1</th>        <th>info:fn</th>        <th>123456789</th>        <th>三</th>    </tr>    <tr>        <th>1</th>        <th>Info:fn</th>        <th>123456789</th>        <th>张</th>    </tr>    <tr>        <th>2</th>        <th>Info:fn</th>        <th>123456789</th>        <th>四</th>    </tr>    <tr>        <th>2</th>        <th>Info:fn</th>        <th>123456789</th>        <th>李</th>    </tr></table><p>如果要用很短的一句话总结 HBase，我们可以认为 HBase 就是一个有序的多维 Map，其中每一个 Row-key 映射了许多数据，这些数据存储在 CF 中的 Column。我们可以用下图来表示这句话。</p><p>HBase是一个面向列的数据库，在表中它由行排序。 表模式定义只能列族，也就是键值对。 一个表有多个列族以及每一个列族可以有任意数量的列。 后续列的值连续地存储在磁盘上。 表中的每个单元格值都具有时间戳。在一个hbase中：</p><pre><code>表是行的集合。行是列族的集合。列族是列的集合。列是键值对的集合。</code></pre><p>Row key</p><hr><ol><li>row key 是用来检索记录的主键；</li><li>row key 可以使用任意字符串；</li><li>存储时，数据按照row key 的字典顺序存储；</li><li>设计key时，要充分考虑排序存储这个特性，将经常一起读取的行存储在一起。</li></ol><p>Column Family</p><hr><ol><li>hbase中的每个列都归属于某个列族；</li><li>列族是schema的一部分(列并不是),必须在使用表之前定义；</li><li>列表都以列族为前缀，例如：course:math,course:English都属于course这个列族。</li></ol><p>Column</p><hr><p>属于某一个columnfamily。通过列族:单元格修饰符访问，可以具体到某个列。可以把单元格修饰符认为是实际的列名。</p><p>只要有列族存在，客户端随时可以把列添加到列族。</p><p>Cell</p><hr><ol><li>由 rowKey + columnFamily + version 唯一确定的单元；</li><li>字节码形式存储。cell中的数据是没有类型的，全部是字节码(Byte Array)形式存储。</li></ol><p>TimeStamp</p><hr><ol><li>每个cell都保存着一份数据的多个版本；</li><li>版本通过时间戳来索引，时间戳的类型是64类整型；</li><li>时间戳可以由HBASE(在数据写入时自动)赋值,此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显式赋值。如果应用程序要避免数据版本冲突,就必须自己生成具有唯一性的时间戳。每个cell中,不同版本的数据按照时间倒序排序,即最新的数据排在最前面；</li><li>为了避免数据存在过多版本造成的的管理(包括存贮和索引)负担,HBASE提供了两种数据版本回收方式。一是保存数据的最后n个版本,二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</li></ol><p>Region</p><hr><p>HBase自动把表水平划分成多个区域(region)，每个region会保存一个表里面某段连续的数据。</p><p>每个表一开始只有一个region，随着数据不断插入表，region不断增大，当增大到一个阀值的时候，region就会等分会两个新的region。</p><p>当table中的行不断增多，就会有越来越多的region。这样一张完整的表被保存在多个Region 上。</p><p>Region是Hbase中“分布式存储”和“负载均衡”的最小单元。最小单元就表示不同的region可以分布在不同的Region server上。但一个Region是不会拆分到多个server上的。</p><p>HBase存储和HDFS存储的关系:</p><ul><li>HDFS: Client -&gt; NameNode -&gt; DataNode</li><li>HBase: Client -&gt; HMaster -&gt; HRegionServer -&gt; Zookeeper(元数据) -&gt; HDFS(数据文件)<ul><li><pre><code>每条数据线缓存到HRegionServer的内存中,当达到Block大小时再写入HDFS。</code></pre></li><li><pre><code>HBase中只有表结构和列族,其他都是数据。</code></pre></li><li><pre><code>1个列族中有多个列,被存储到1个文件中。</code></pre></li><li><pre><code>Hbase中不能删除数据,如果对一个相同的行键插入数据（不同时间戳）,就认为是修改。</code></pre></li></ul></li></ul><p>habse命令：</p> <table><thead><tr><th>名称</th><th>命令行表达式</th></tr></thead><tbody><tr><td>创建表</td><td>create ‘表名’,’列族1’,’列族2’,’列族N’</td></tr><tr><td>查看所有表</td><td>list</td></tr><tr><td>描述表</td><td>describe ‘表名’</td></tr><tr><td>判断表存在</td><td>exists ‘表名’</td></tr><tr><td>判断是否禁用启用表</td><td>is_enabled/is_disable ‘表名’</td></tr><tr><td>添加记录</td><td>put ‘表名’,’rowKey’,’列族:列’,’值’</td></tr><tr><td>查看记录rowkey下的所有数据</td><td>get ‘表名’,’rowkey’</td></tr><tr><td>查看表中记录总数</td><td>count 表名</td></tr><tr><td>获取某个列族</td><td>get ‘表名’,’rowkey’,’列族’</td></tr><tr><td>获取某个列族的某个列</td><td>get ‘表名’,’rowkey’,’列族’,’列’</td></tr><tr><td>删除记录</td><td>delete ‘表名’,’行名’,’列族:列’</td></tr><tr><td>删除整行</td><td>deleteall ‘表名’,’rowkey’</td></tr><tr><td>删除一张表</td><td>1. disable ‘表名’ 2. drop ‘表名’</td></tr><tr><td>清空表</td><td>truncate ‘表名’</td></tr><tr><td>查看所有记录</td><td>scan ‘表名’</td></tr><tr><td>查看某个表某个列中的所有数据</td><td>scan ‘表名’,{COLUMNS=&gt; ‘列族名:列名’}</td></tr><tr><td>更新记录</td><td>就是重写一遍，进行覆盖，hbase没有修改，都是追加</td></tr></tbody></table><p>ZK在HBase中的功能：</p><ul><li>保存HMaster的地址和 backup-master 地址</li><li>HMaster的功能：<ul><li>管理HRegionServer</li><li>做CRUD的节点</li><li>管理HRegionServer中的表分配</li></ul></li><li>保存 表-ROOT- 的地址 （Hbase默认的根表，检索表）</li><li>HRegionServer列表<ul><li>表的CRUD数据</li><li>和HDFS交互，读写数据</li></ul></li></ul><h2 id="hbase体系结构"><a class="markdownIt-Anchor" href="#hbase体系结构"></a> Hbase体系结构</h2><p><img src="https://i.loli.net/2019/01/07/5c32bff8c77b2.jpg" alt=""></p><h3 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h3><p>HBase以表的形式存储数据。表由行和列组成。行划分为若干个列族。</p><p>最基本的单位是列（column），一列或者多列组成一行（row），并且由唯一的行键（row key）来确定存储。一个表中有很多行，每一列可能有多个版本，在每一个单元格（Cell）中存储了不同的值。</p><p>HBase的行与行之间是有序的，按照row key的字典序进行排序，行键是唯一的，在一个表里只出现一次，否则就是在更新同一行，行键可以是任意的字节数组。一行由若干列组成，其中的某些列又可以构成一个列族（column family），一个列族的所有列存储在同一个底层的存储文件里，这个文件称之为HFile。</p><p>列族需要在创建表的时候就定义好，数量也不宜过多。列族名必须由可打印字符组成，创建表的时候不需要定义好列。对列的引用格式通常为family：qualifier，qualifier也可以是任意的字节数组。同一个列族里qualifier的名称应该唯一，否则就是在更新同一列，列的数量没有限制，可以有数百万个。列值也没有类型和长度限定。HBase会对row key的长度做检查，默认应该小于65536。</p><p>HBase的存取模式如下（表，行键，列族，列，时间戳）-&gt; 值。即一个表中的某一行键的某一列族的某一列的某一个版本的值唯一。</p><p>行数据的存取操作是原子的，可以读取任意数目的列。目前还不支持跨行事务和跨表事务。</p><p>同一列族下的数据压缩在一起，访问控制磁盘和内存都在列族层面进行。</p><h3 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h3><p>HBase包含3个重要组件：Zookeeper、HMaster和HRegionServer。</p><p>Zookeeper</p><p>Zookeeper为整个HBase提供协助服务，包括：</p><p>存放整个HBase集群的元数据以及集群的状态信息。<br>实现HMaster主从节点的failover。<br>ZooKeeper为HBase集群提供协调服务，它管理着HMaster和HRegionServer的状态(available/alive等)，并且会在它们宕机时通知给HMaster，从而HMaster可以实现HMaster之间的failover，或对宕机的HRegionServer中的HRegion集合的修复(将它们分配给其他的HRegionServer)。ZooKeeper集群本身使用一致性协议(PAXOS协议)保证每个节点状态的一致性。</p><p>HMaster</p><p>HMaster主要用于监控和操作集群中的所有HRegionServer。HMaster没有单点问题，HBase中可以启动多个HMaster，通过Zookeeper的MasterElection机制保证总有一个Master在运行。</p><p>管理所有的HRegionServer，告诉其需要维护哪些HRegion，并监控所有HRegionServer的运行状态。当一个新的HRegionServer登录到HMaster时，HMaster会告诉它等待分配数据；而当某个HRegion死机时，HMaster会把它负责的所有HRegion标记为未分配，然后再把它们分配到其他HRegionServer中。HMaster没有单点问题，HBase可以启动多个HMaster，通过Zookeeper的选举机制保证集群中总有一个HMaster运行，从而提高了集群的可用性。</p><p>HMaster主要负责Table和Region的管理工作：</p><p>管理用户对表的增删改查操作。<br>管理HRegionServer的负载均衡，调整Region分布。<br>Region Split后，负责新Region的分布。<br>在HRegionServer停机后，负责失效HRegionServer上Region迁移。<br>HRegionServer</p><p>HRegionServer是HBase中最核心的模块，主要负责响应用户I/O请求，向HDFS文件系统读写数据。HBase中的所有数据从底层来说一般都是保存在HDFS中的，用户通过一系列HRegionServer获取这些数据。集群一个节点上一般只运行一个HRegionServer，且每一个区段的HRegion只会被一个HRegionServer维护。HRegionServer主要负责响应用户I/O请求，向HDFS文件系统读写数据，是HBase中最核心的模块。HRegionServer内部管理了一系列HRegion对象，每个HRegion对应了逻辑表中的一个连续数据段。HRegion由多个HStore组成，每个HStore对应了逻辑表中的一个列族的存储，可以看出每个列族其实就是一个集中的存储单元。因此，为了提高操作效率，最好将具备共同I/O特性的列放在一个列族中。</p><p>存放和管理本地HRegion。<br>读写HDFS，管理Table中的数据。<br>Client直接通过HRegionServer读写数据（从HMaster中获取元数据，找到RowKey所在的HRegion/HRegionServer后）。<br>另外，Hbase架构中还包括以下几个部分：</p><p>HRegion</p><p>当表的大小超过预设值的时候，HBase会自动将表划分为不同的区域，每个区域包含表中所有行的一个子集。对用户来说，每个表是一堆数据的集合，靠主键（RowKey）来区分。从物理上来说，一张表被拆分成了多块，每一块就是一个HRegion。我们用表名+开始/结束主键，来区分每一个HRegion，一个HRegion会保存一个表中某段连续的数据，一张完整的表数据是保存在多个HRegion中的。</p><p>HStore</p><p>它是HBase存储的核心，由MemStore和StoreFiles两部分组成。MemStore是内存缓冲区，用户写入的数据首先会放入MemStore，当MemStore满了以后会Flush成一个StoreFile（底层实现是HFile），当StoreFile的文件数量增长到一定阈值后，会触发Compact合并操作，将多个StoreFiles合并成一个StoreFile，合并过程中会进行版本合并和数据删除操作。因此，可以看出HBase其实只有增加数据，所有的更新和删除操作都是在后续的Compact过程中进行的，这样使得用户的写操作只要进入内存就可以立即返回，保证了HBaseI/O的高性能。当StoreFiles Compact后，会逐步形成越来越大的StoreFile，当单个StoreFile大小超过一定阈值后，会触发Split操作，同时把当前的HRegion Split成2个HRegion，父HRegion会下线，新分出的2个子HRegion会被HMaster分配到相应的HRegionServer，使得原先1个HRegion的负载压力分流到2个HRegion上。</p><p>HLog</p><p>每个HRegionServer中都有一个HLog对象，它是一个实现了Write Ahead Log的预写日志类。在每次用户操作将数据写入MemStore的时候，也会写一份数据到HLog文件中，HLog文件会定期滚动刷新，并删除旧的文件（已持久化到StoreFile中的数据）。当HMaster通过Zookeeper感知到某个HRegionServer意外终止时，HMaster首先会处理遗留的 HLog文件，将其中不同HRegion的HLog数据进行拆分，分别放到相应HRegion的目录下，然后再将失效的HRegion重新分配，领取到这些HRegion的HRegionServer在加载 HRegion的过程中，会发现有历史HLog需要处理，因此会Replay HLog中的数据到MemStore中，然后Flush到StoreFiles，完成数据恢复。</p><h3 id="写数据流程"><a class="markdownIt-Anchor" href="#写数据流程"></a> 写数据流程：</h3><ol><li>Client向HRegionServer发送写请求</li><li>HRegionServer将数据写到Hlog(write ahead log)。为了数据的持久化和恢复</li><li>HRegionServer将数据写到内存(memstore)</li><li>反馈Client写成功</li></ol><h3 id="数据flush过程"><a class="markdownIt-Anchor" href="#数据flush过程"></a> 数据Flush过程</h3><ol><li>当memstore数据达到阀值（默认64M），将数据刷到硬盘，将内存中的数据删除，同时删除HLog中的历史数据。</li><li>将数据存储到HDFS中</li><li>在Hlog中做标记点</li></ol><h3 id="数据合并过程"><a class="markdownIt-Anchor" href="#数据合并过程"></a> 数据合并过程</h3><ol><li>当数据块达到4块，HMaster将数据加载到本地，进行合并</li><li>当合并的数据超过256M，进行拆分，将拆分后的region分配给不同的HRegionServer管理</li><li>当HRegionServer宕机后，将HRegionServer上的Hlog拆分，然后分配给不同的HRegionServer加载，修改 .META.</li><li>注意：Hlog会同步到HDFS</li></ol><h3 id="hbase的读流程"><a class="markdownIt-Anchor" href="#hbase的读流程"></a> HBase的读流程</h3><ol><li>通过ZK和 -ROOT- .META. 表定位HRegionServer</li><li>数据从内存和硬盘合并后返回给Client</li><li>数据块会缓存</li></ol><h3 id="hmaster的职责"><a class="markdownIt-Anchor" href="#hmaster的职责"></a> HMaster的职责</h3><ol><li>管理用户对Table的CRUD操作</li><li>记录Region在哪台HRegionServer上</li><li>在Region Split后，负责新Region的分配</li><li>新机器加入时，管理HRegionServer的负载均衡，调整Region分布</li><li>在HRegionServer宕机后，负责失效HRegionServer上的Regions迁移</li></ol><h3 id="hregionserver的职责"><a class="markdownIt-Anchor" href="#hregionserver的职责"></a> HRegionServer的职责</h3><ol><li>HRegionServer主要负责响应用户的IO请求，向HDFS文件系统中读写数据，是HBase中最核心的模块</li><li>HRegionServer管理了很多table的分区，也就是Region</li></ol><h3 id="client的职责"><a class="markdownIt-Anchor" href="#client的职责"></a> Client的职责</h3><p>HBase Client 使用HBase的RPC机制与HMaster和HRegionServer进行通信</p><pre><code>1. 管理类操作： Client与HMaster进行RPC2. 数据读写类操作：Client与HRegionServer进行RPC</code></pre><p>Hbase为什么能实现快速的查询？</p><p>如果快速查询（从磁盘读数据），hbase是根据rowkey查询的，只要能快速的定位rowkey，就能实现快速的查询，主要是以下因素：</p><p>hbase是可划分成多个region，可以简单的理解为关系型数据库的多个分区。<br>键是排好序了的。<br>按列存储的。<br>首先，能快速找到行所在的region(分区)，假设表有10亿条记录，占空间1TB，分裂成了500个region，1个region占2个G。最多读取2G的记录，就能找到对应记录；<br>其次，是按列存储的，其实是列族，假设分为3个列族，每个列族就是666M，如果要查询的东西在其中1个列族上，1个列族包含1个或者多个HStoreFile，假设一个HStoreFile是128M，该列族包含5个HStoreFile在磁盘上. 剩下的在内存中。<br>再次，是排好序了的，要的记录有可能在最前面，也有可能在最后面，假设在中间，我们只需遍历2.5个HStoreFile共300M。<br>最后，每个HStoreFile(HFile的封装)，是以键值对（key-value）方式存储，只要遍历一个个数据块中的key的位置，并判断符合条件可以了。一般key是有限的长度，假设跟value是1:19（忽略HFile上其它块），最终只需要15M就可获取的对应的记录，按照磁盘的访问100M/S，只需0.15秒。加上块缓存机制（LRU原则），会取得更高的效率。<br>HBase的实时查询</p><p>实时查询，可以认为是从内存中查询，一般响应时间在1秒内。HBase的机制是数据先写入到内存中，当数据量达到一定的量（如128M），再写入磁盘中，在内存中，是不进行数据的更新或合并操作的，只增加数据，这使得用户的写操作只要进入内存中就可以立即返回，保证了HBase I/O的高性能。<br>实时查询即反映当前时间的数据，可以认为这些数据始终是在内存的，保证了数据的实时响应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hbase基本知识学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hbase基本知识学习&quot;&gt;&lt;/a&gt; hbase基本知识学习&lt;/h2&gt;
&lt;p&gt;数据在 HBase 中的排布（逻辑上）&lt;/p&gt;
 
&lt;table&gt;
    &lt;tr&gt;
  
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hbase" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hbase/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>hbase基本shell命令</title>
    <link href="http://blog.rickiyang.cn/posts/ebc35787.html"/>
    <id>http://blog.rickiyang.cn/posts/ebc35787.html</id>
    <published>2018-10-07T15:56:43.000Z</published>
    <updated>2018-12-06T02:53:23.041Z</updated>
    
    <content type="html"><![CDATA[<p>启动HBASE，进入shell，退出shell：</p><pre><code>start-hbase.sh hbase shell quit </code></pre><p>进入shell之后遇到命令不知道怎么使用的话，使用’help’命令：</p><p><img src="https://i.imgur.com/kpCjU8M.jpg" alt=""></p><p>help的使用方式：</p><pre><code>help '命令' #命令需要加引号</code></pre><p><strong>需要注意的事： 不知道为什么hbase的shell界面输入字符之后如果想回退按backspace是不行的，我使用的shell客户端是Xshell，同时按住：ctrl+space+backspace可以。</strong></p><p>1.创建表：</p><pre><code>create '表名', '列族名1','列族名2','列族名N'</code></pre><p><img src="https://i.imgur.com/CB15x3K.jpg" alt=""></p><p>2.查看表：</p><p><img src="https://i.imgur.com/fGfpYLD.jpg" alt=""></p><p>3.判断表是否启用或禁用：</p><p><img src="https://i.imgur.com/KgrWJqe.jpg" alt=""></p><p>4.添加表数据：</p><pre><code>put  '表名','rowKey','列族:列','值'</code></pre><p><img src="https://i.imgur.com/TN2piuK.jpg" alt=""></p><p>注意到表名后面的rowkey，其实就相当于是行号的概念。</p><p>5.查看rowkey下的所有数据：</p><pre><code>get  '表名','rowKey'</code></pre><p><img src="https://i.imgur.com/WhwgiwF.jpg" alt=""></p><p>6.查看表中的记录总数：</p><pre><code>count '表名'</code></pre><p><img src="https://i.imgur.com/yWhFm9C.jpg" alt=""></p><p>7.获取某行数据：</p><pre><code>get '表名','rowkey'</code></pre><p><img src="https://i.imgur.com/M6nFyeB.jpg" alt=""></p><p>8.获取某个列族和获取列族的某个列：</p><pre><code>get '表名','rowkey','列族'get '表名','rowkey','列族：列'</code></pre><p><img src="https://i.imgur.com/UWNssfq.jpg" alt=""></p><p>9.删除记录(某一行中的某一个值)：</p><pre><code>delete '表名','rowkey','列族：列'</code></pre><p><img src="https://i.imgur.com/WLuhLWD.jpg" alt=""></p><p>10.删除整行：</p><pre><code>deleteall '表名','rowkey'</code></pre><p><img src="https://i.imgur.com/oHwjo2y.jpg" alt=""></p><p>11.删除表：</p><pre><code>先要屏蔽该表，才能对该表进行删除第一步 disable ‘表名’ ，第二步  drop '表名'</code></pre><p><img src="https://i.imgur.com/eMdft4V.jpg" alt=""></p><p>12.清空表：</p><pre><code>truncate '表名'</code></pre><p><img src="https://i.imgur.com/J1bL43f.jpg" alt=""></p><p>13.查看表中某个列的所有数据：</p><pre><code>scan &quot;表名&quot;,{COLUMNS=&gt;'列族名:列名'}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;启动HBASE，进入shell，退出shell：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start-hbase.sh 
hbase shell 
quit 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入shell之后遇到命令不知道怎么使用的话，使用’help’命令：&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hbase" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hbase/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据倾斜的解决方案</title>
    <link href="http://blog.rickiyang.cn/posts/d4452255.html"/>
    <id>http://blog.rickiyang.cn/posts/d4452255.html</id>
    <published>2018-09-22T14:41:13.000Z</published>
    <updated>2018-12-13T02:14:20.614Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1数据倾斜是怎么出现的"><a class="markdownIt-Anchor" href="#1数据倾斜是怎么出现的"></a> 1.数据倾斜是怎么出现的</h4><p>在执行shuffle操作的时候，是按照key，来进行values的数据的输出、拉取和聚合的。同一个key的values，一定是分配到一个reduce task进行处理的。多个key对应的values，比如一共是100万。可能某个key对应了98万数据，被分配到一个task上去面去执行，另外两个task，可能各分配到了1万数据，可能是数百个key，对应的1万条数据，这样就会出现数据倾斜问题。</p><p>这两个task，各分配到了1万数据，可能同时在10分钟内都运行完了。另外一个task有98万条，98 * 10 =  980分钟 = 16.3个小时。</p><p>大家看，本来另外两个task很快就运行完毕了（10分钟），但是由于一个拖后腿的家伙，第三个task，要16.3个小时才能运行完，就导致整个spark作业，也得16.3个小时才能运行完。所以一旦出现数据倾斜后果是很可怕的。解决数据倾斜问题类似与性能调优哈。</p><h4 id="2数据倾斜发生的表象"><a class="markdownIt-Anchor" href="#2数据倾斜发生的表象"></a> 2.数据倾斜发生的表象</h4><ul><li><p>绝大多数task执行得都非常快，但个别task执行极慢(你要用client模式，standalone client，yarn client，本地机器一执行spark-submit脚本，就会开始打印log）。比如，总共有1000个task，997个task都在1分钟之内执行完了，但是剩余两三个task却要一两个小时。这种情况很常见。</p></li><li><p>原本能够正常执行的Spark作业，某天突然报出OOM（内存溢出）异常，观察异常栈，是我们写的业务代码造成的。这种情况比较少见。</p></li></ul><h4 id="3定位数据倾斜出现的原因与出现问题的位置"><a class="markdownIt-Anchor" href="#3定位数据倾斜出现的原因与出现问题的位置"></a> 3.定位数据倾斜出现的原因与出现问题的位置</h4><p>出现数据倾斜的原因，基本只可能是因为发生了shuffle操作，在shuffle的过程中，出现了数据倾斜的问题。因为某个或者某些key对应的数据，远远的高于其他的key。</p><ol><li>数据倾斜只会发生在shuffle过程中。这里给大家罗列一些常用的并且可能会触发shuffle操作的算子：distinct、groupByKey、reduceByKey、aggregateByKey、join、cogroup、repartition等。出现数据倾斜时，可能就是你的代码中使用了这些算子中的某一个所导致的；</li><li>看log；</li></ol><p>log一般会报是在你的哪一行代码，导致了OOM异常。或者看log，看看是执行到了第几个stage。spark代码，是怎么划分成一个一个的stage的。哪一个stage生成的task特别慢，就能够自己用肉眼去对你的spark代码进行stage的划分，就能够通过stage定位到你的代码，到底哪里发生了数据倾斜。</p><p>如果是用yarn-client模式提交，那么本地是直接可以看到log的，可以在log中找到当前运行到了第几个stage；如果是用yarn-cluster模式提交，则可以通过Spark Web UI来查看当前运行到了第几个stage。此外，无论是使用yarn-client模式还是yarn-cluster模式，我们都可以在Spark Web UI上深入看一下当前这个stage各个task分配的数据量，从而进一步确定是不是task分配的数据不均匀导致了数据倾斜。</p><p>知道数据倾斜发生在哪一个stage之后，接着我们就需要根据stage划分原理，推算出来发生倾斜的那个stage对应代码中的哪一部分，这部分代码中肯定会有一个shuffle类算子。精准推算stage与代码的对应关系，需要对Spark的源码有深入的理解，这里我们可以介绍一个相对简单实用的推算方法：只要看到Spark代码中出现了一个shuffle类算子或者是Spark SQL的SQL语句中出现了会导致shuffle的语句（比如group by语句），那么就可以判定，以那个地方为界限划分出了前后两个stage。</p><p>这里我们就以Spark最基础的入门程序——单词计数来举例，如何用最简单的方法大致推算出一个stage对应的代码。如下示例，在整个代码中，只有一个reduceByKey是会发生shuffle的算子，因此就可以认为，以这个算子为界限，会划分出前后两个stage。</p><ol><li>stage0，主要是执行从textFile到map操作，以及执行shuffle write操作。shuffle write操作，我们可以简单理解为对pairs RDD中的数据进行分区操作，每个task处理的数据中，相同的key会写入同一个磁盘文件内。</li><li>stage1，主要是执行从reduceByKey到collect操作，stage1的各个task一开始运行，就会首先执行shuffle read操作。执行shuffle read操作的task，会从stage0的各个task所在节点拉取属于自己处理的那些key，然后对同一个key进行全局性的聚合或join等操作，在这里就是对key的value值进行累加。stage1在执行完reduceByKey算子之后，就计算出了最终的wordCounts RDD，然后会执行collect算子，将所有数据拉取到Driver上，供我们遍历和打印输出。</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lines = sc.textFile(<span class="string">"hdfs://..."</span>)</span><br><span class="line"><span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"><span class="keyword">val</span> pairs = words.map((_, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> wordCounts = pairs.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">wordCounts.collect().foreach(println(_))</span><br></pre></td></tr></table></figure><p>通过对单词计数程序的分析，希望能够让大家了解最基本的stage划分的原理，以及stage划分后shuffle操作是如何在两个stage的边界处执行的。然后我们就知道如何快速定位出发生数据倾斜的stage对应代码的哪一个部分了。比如我们在Spark Web UI或者本地log中发现，stage1的某几个task执行得特别慢，判定stage1出现了数据倾斜，那么就可以回到代码中定位出stage1主要包括了reduceByKey这个shuffle类算子，此时基本就可以确定是由educeByKey算子导致的数据倾斜问题。比如某个单词出现了100万次，其他单词才出现10次，那么stage1的某个task就要处理100万数据，整个stage的速度就会被这个task拖慢。</p><h4 id="4查看导致数据倾斜的key的数据分布情况"><a class="markdownIt-Anchor" href="#4查看导致数据倾斜的key的数据分布情况"></a> 4.查看导致数据倾斜的key的数据分布情况</h4><p>知道了数据倾斜发生在哪里之后，通常需要分析一下那个执行了shuffle操作并且导致了数据倾斜的RDD/Hive表，查看一下其中key的分布情况。这主要是为之后选择哪一种技术方案提供依据。针对不同的key分布与不同的shuffle算子组合起来的各种情况，可能需要选择不同的技术方案来解决。</p><p>此时根据你执行操作的情况不同，可以有很多种查看key分布的方式：</p><ol><li>如果是Spark SQL中的group by、join语句导致的数据倾斜，那么就查询一下SQL中使用的表的key分布情况。</li><li>如果是对Spark RDD执行shuffle算子导致的数据倾斜，那么可以在Spark作业中加入查看key分布的代码，比如RDD.countByKey()。然后对统计出来的各个key出现的次数，collect/take到客户端打印一下，就可以看到key的分布情况。</li></ol><p>举例来说，对于上面所说的单词计数程序，如果确定了是stage1的reduceByKey算子导致了数据倾斜，那么就应该看看进行reduceByKey操作的RDD中的key分布情况，在这个例子中指的就是pairs RDD。如下示例，我们可以先对pairs采样10%的样本数据，然后使用countByKey算子统计出每个key出现的次数，最后在客户端遍历和打印样本数据中各个key的出现次数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sampledPairs = pairs.sample(<span class="literal">false</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">val</span> sampledWordCounts = sampledPairs.countByKey()</span><br><span class="line">sampledWordCounts.foreach(println(_))</span><br></pre></td></tr></table></figure><h4 id="5数据倾斜的解决方案"><a class="markdownIt-Anchor" href="#5数据倾斜的解决方案"></a> 5.数据倾斜的解决方案</h4><h5 id="51-方案一使用hive-etl预处理数据"><a class="markdownIt-Anchor" href="#51-方案一使用hive-etl预处理数据"></a> 5.1 方案一：使用Hive ETL预处理数据</h5><p>方案适用场景：导致数据倾斜的是Hive表。如果该Hive表中的数据本身很不均匀（比如某个key对应了100万数据，其他key才对应了10条数据），而且业务场景需要频繁使用Spark对Hive表执行某个分析操作，那么比较适合使用这种技术方案。</p><p>方案实现思路：此时可以评估一下，是否可以通过Hive来进行数据预处理（即通过Hive ETL预先对数据按照key进行聚合，或者是预先和其他表进行join），然后在Spark作业中针对的数据源就不是原来的Hive表了，而是预处理后的Hive表。此时由于数据已经预先进行过聚合或join操作了，那么在Spark作业中也就不需要使用原先的shuffle类算子执行这类操作了。</p><p>方案实现原理：这种方案从根源上解决了数据倾斜，因为彻底避免了在Spark中执行shuffle类算子，那么肯定就不会有数据倾斜的问题了。但是这里也要提醒一下大家，这种方式属于治标不治本。因为毕竟数据本身就存在分布不均匀的问题，所以Hive ETL中进行group by或者join等shuffle操作时，还是会出现数据倾斜，导致Hive ETL的速度很慢。我们只是把数据倾斜的发生提前到了Hive ETL中，避免Spark程序发生数据倾斜而已。</p><p>方案优点：实现起来简单便捷，效果还非常好，完全规避掉了数据倾斜，Spark作业的性能会大幅度提升。</p><p>方案缺点：治标不治本，Hive ETL中还是会发生数据倾斜。</p><p>方案实践经验：在一些Java系统与Spark结合使用的项目中，会出现Java代码频繁调用Spark作业的场景，而且对Spark作业的执行性能要求很高，就比较适合使用这种方案。将数据倾斜提前到上游的Hive ETL，每天仅执行一次，只有那一次是比较慢的，而之后每次Java调用Spark作业时，执行速度都会很快，能够提供更好的用户体验。</p><h5 id="52-方案二过滤少数导致倾斜的key"><a class="markdownIt-Anchor" href="#52-方案二过滤少数导致倾斜的key"></a> 5.2 方案二：过滤少数导致倾斜的key</h5><p>方案适用场景：如果发现导致倾斜的key就少数几个，而且对计算本身的影响并不大的话，那么很适合使用这种方案。比如99%的key就对应10条数据，但是只有一个key对应了100万数据，从而导致了数据倾斜。</p><p>方案实现思路：如果我们判断那少数几个数据量特别多的key，对作业的执行和计算结果不是特别重要的话，那么干脆就直接过滤掉那少数几个key。比如，在Spark SQL中可以使用where子句过滤掉这些key或者在Spark Core中对RDD执行filter算子过滤掉这些key。如果需要每次作业执行时，动态判定哪些key的数据量最多然后再进行过滤，那么可以使用sample算子对RDD进行采样，然后计算出每个key的数量，取数据量最多的key过滤掉即可。</p><p>方案实现原理：将导致数据倾斜的key给过滤掉之后，这些key就不会参与计算了，自然不可能产生数据倾斜。</p><p>方案优点：实现简单，而且效果也很好，可以完全规避掉数据倾斜。</p><p>方案缺点：适用场景不多，大多数情况下，导致倾斜的key还是很多的，并不是只有少数几个。</p><p>方案实践经验：在项目中我们也采用过这种方案解决数据倾斜。有一次发现某一天Spark作业在运行的时候突然OOM了，追查之后发现，是Hive表中的某一个key在那天数据异常，导致数据量暴增。因此就采取每次执行前先进行采样，计算出样本中数据量最大的几个key之后，直接在程序中将那些key给过滤掉。</p><h5 id="53-方案三提高shuffle操作的并行度"><a class="markdownIt-Anchor" href="#53-方案三提高shuffle操作的并行度"></a> 5.3 方案三：提高shuffle操作的并行度</h5><p>方案适用场景：如果我们必须要对数据倾斜迎难而上，那么建议优先使用这种方案，因为这是处理数据倾斜最简单的一种方案。</p><p>方案实现思路：在对RDD执行shuffle算子时，给shuffle算子传入一个参数，比如reduceByKey(1000)，该参数就设置了这个shuffle算子执行时shuffle read task的数量。对于Spark SQL中的shuffle类语句，比如group by、join等，需要设置一个参数，即spark.sql.shuffle.partitions，该参数代表了shuffle read task的并行度，该值默认是200，对于很多场景来说都有点过小。</p><p>方案实现原理：增加shuffle read task的数量，可以让原本分配给一个task的多个key分配给多个task，从而让每个task处理比原来更少的数据。举例来说，如果原本有5个key，每个key对应10条数据，这5个key都是分配给一个task的，那么这个task就要处理50条数据。而增加了shuffle read task以后，每个task就分配到一个key，即每个task就处理10条数据，那么自然每个task的执行时间都会变短了。</p><p>方案优点：实现起来比较简单，可以有效缓解和减轻数据倾斜的影响。</p><p>方案缺点：只是缓解了数据倾斜而已，没有彻底根除问题，根据实践经验来看，其效果有限。</p><p>方案实践经验：该方案通常无法彻底解决数据倾斜，因为如果出现一些极端情况，比如某个key对应的数据量有100万，那么无论你的task数量增加到多少，这个对应着100万数据的key肯定还是会分配到一个task中去处理，因此注定还是会发生数据倾斜的。所以这种方案只能说是在发现数据倾斜时尝试使用的第一种手段，尝试去用最简单的方法缓解数据倾斜而已，或者是和其他方案结合起来使用。</p><h5 id="54-方案四两阶段聚合局部聚合全局聚合"><a class="markdownIt-Anchor" href="#54-方案四两阶段聚合局部聚合全局聚合"></a> 5.4 方案四：两阶段聚合（局部聚合+全局聚合）</h5><p>方案适用场景：对RDD执行reduceByKey等聚合类shuffle算子或者在Spark SQL中使用group by语句进行分组聚合时，比较适用这种方案。</p><p>方案实现思路：这个方案的核心实现思路就是进行两阶段聚合。第一次是局部聚合，先给每个key都打上一个随机数，比如10以内的随机数，此时原先一样的key就变成不一样的了，比如(hello, 1) (hello, 1) (hello, 1) (hello, 1)，就会变成(1_hello, 1) (1_hello, 1) (2_hello, 1) (2_hello, 1)。接着对打上随机数后的数据，执行reduceByKey等聚合操作，进行局部聚合，那么局部聚合结果，就会变成了(1_hello, 2) (2_hello, 2)。然后将各个key的前缀给去掉，就会变成(hello,2)(hello,2)，再次进行全局聚合操作，就可以得到最终结果了，比如(hello, 4)。</p><p>方案实现原理：将原本相同的key通过附加随机前缀的方式，变成多个不同的key，就可以让原本被一个task处理的数据分散到多个task上去做局部聚合，进而解决单个task处理数据量过多的问题。接着去除掉随机前缀，再次进行全局聚合，就可以得到最终的结果。具体原理见下图。</p><p>方案优点：对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。</p><p>方案缺点：仅仅适用于聚合类的shuffle操作，适用范围相对较窄。如果是join类的shuffle操作，还得用其他的解决方案。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步，给RDD中的每个key都打上一个随机前缀。</span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">String</span>, <span class="type">Long</span>&gt; randomPrefixRdd = rdd.mapToPair(</span><br><span class="line"><span class="keyword">new</span> <span class="type">PairFunction</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>,<span class="type">Long</span>&gt;, <span class="type">String</span>, <span class="type">Long</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Long</span>&gt; call(<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; tuple)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="type">Random</span> random = <span class="keyword">new</span> <span class="type">Random</span>();</span><br><span class="line">        int prefix = random.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Long</span>&gt;(prefix + <span class="string">"_"</span> + tuple._1, tuple._2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，对打上随机前缀的key进行局部聚合。</span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">String</span>, <span class="type">Long</span>&gt; localAggrRdd = randomPrefixRdd.reduceByKey(</span><br><span class="line"><span class="keyword">new</span> <span class="type">Function2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Long</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Long</span> call(<span class="type">Long</span> v1, <span class="type">Long</span> v2) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步，去除RDD中每个key的随机前缀。</span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; removedRandomPrefixRdd = localAggrRdd.mapToPair(</span><br><span class="line"><span class="keyword">new</span> <span class="type">PairFunction</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>,<span class="type">Long</span>&gt;, <span class="type">Long</span>, <span class="type">Long</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; call(<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Long</span>&gt; tuple)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        long originalKey = <span class="type">Long</span>.valueOf(tuple._1.split(<span class="string">"_"</span>)[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt;(originalKey, tuple._2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四步，对去除了随机前缀的RDD进行全局聚合。</span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; globalAggrRdd = removedRandomPrefixRdd.reduceByKey(</span><br><span class="line"><span class="keyword">new</span> <span class="type">Function2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Long</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Long</span> call(<span class="type">Long</span> v1, <span class="type">Long</span> v2) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="55-方案五将reduce-join转为map-join"><a class="markdownIt-Anchor" href="#55-方案五将reduce-join转为map-join"></a> 5.5 方案五：将reduce join转为map join</h5><p>方案适用场景：<br>如果两个RDD要进行join，其中一个RDD是比较小的。比如一个RDD是100万数据，一个RDD是1万数据。（一个RDD是1亿数据，一个RDD是100万数据）。</p><p>其中一个RDD必须是比较小的，broadcast出去那个小RDD的数据以后，就会在每个executor的block manager中都保存一份。要确保你的内存足够存放那个小RDD中的数据。这种方式下，根本不会发生shuffle操作，肯定也不会发生数据倾斜。从根本上杜绝了join操作可能导致的数据倾斜的问题。</p><p>方案实现思路：不使用join算子进行连接操作，而使用Broadcast变量与map类算子实现join操作，进而完全规避掉shuffle类的操作，彻底避免数据倾斜的发生和出现。将较小RDD中的数据直接通过collect算子拉取到Driver端的内存中来，然后对其创建一个Broadcast变量；接着对另外一个RDD执行map类算子，在算子函数内，从Broadcast变量中获取较小RDD的全量数据，与当前RDD的每一条数据按照连接key进行比对，如果连接key相同的话，那么就将两个RDD的数据用你需要的方式连接起来。</p><p>方案实现原理：普通的join是会走shuffle过程的，而一旦shuffle，就相当于会将相同key的数据拉取到一个shuffle read task中再进行join，此时就是reduce join。但是如果一个RDD是比较小的，则可以采用广播小RDD全量数据+map算子来实现与join同样的效果，也就是map join，此时就不会发生shuffle操作，也就不会发生数据倾斜。具体原理如下图所示。</p><p>方案优点：对join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜。</p><p>方案缺点：适用场景较少，因为这个方案只适用于一个大表和一个小表的情况。毕竟我们需要将小表进行广播，此时会比较消耗内存资源，driver和每个Executor内存中都会驻留一份小RDD的全量数据。如果我们广播出去的RDD数据比较大，比如10G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先将数据量比较小的RDD的数据，collect到Driver中来。  </span></span><br><span class="line"><span class="type">List</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Row</span>&gt;&gt; rdd1Data = rdd1.collect()</span><br><span class="line"><span class="comment">// 然后使用Spark的广播功能，将小RDD的数据转换成广播变量，这样每个Executor就只有一份RDD的数据。  </span></span><br><span class="line"><span class="comment">// 可以尽可能节省内存空间，并且减少网络传输性能开销。  </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Broadcast</span>&lt;<span class="type">List</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Row</span>&gt;&gt;&gt; rdd1DataBroadcast = sc.broadcast(rdd1Data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对另外一个RDD执行map类操作，而不再是join类操作。  </span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">String</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt; joinedRdd = rdd2.mapToPair(</span><br><span class="line"><span class="keyword">new</span> <span class="type">PairFunction</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>,<span class="type">String</span>&gt;, <span class="type">String</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt; call(<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; tuple)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="comment">// 在算子函数中，通过广播变量，获取到本地Executor中的rdd1数据。  </span></span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Row</span>&gt;&gt; rdd1Data = rdd1DataBroadcast.value();</span><br><span class="line">        <span class="comment">// 可以将rdd1的数据转换为一个Map，便于后面进行join操作。  </span></span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">Long</span>, <span class="type">Row</span>&gt; rdd1DataMap = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="type">Long</span>, <span class="type">Row</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Row</span>&gt; data : rdd1Data) &#123;</span><br><span class="line">            rdd1DataMap.put(data._1, data._2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前RDD数据的key以及value。  </span></span><br><span class="line">        <span class="type">String</span> key = tuple._1;</span><br><span class="line">        <span class="type">String</span> value = tuple._2;</span><br><span class="line">        <span class="comment">// 从rdd1数据Map中，根据key获取到可以join到的数据。  </span></span><br><span class="line">        <span class="type">Row</span> rdd1Value = rdd1DataMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;(key, <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;(value, rdd1Value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里得提示一下。  </span></span><br><span class="line"><span class="comment">// 上面的做法，仅仅适用于rdd1中的key没有重复，全部是唯一的场景。  </span></span><br><span class="line"><span class="comment">// 如果rdd1中有多个相同的key，那么就得用flatMap类的操作，在进行join的时候不能用map，而是得遍历rdd1所有数据进行join。  </span></span><br><span class="line"><span class="comment">// rdd2中每条数据都可能会返回多条join后的数据。</span></span><br></pre></td></tr></table></figure><h5 id="56-方案六采样倾斜key并分拆join操作"><a class="markdownIt-Anchor" href="#56-方案六采样倾斜key并分拆join操作"></a> 5.6 方案六：采样倾斜key并分拆join操作</h5><p>方案适用场景：两个RDD/Hive表进行join的时候，如果数据量都比较大，无法采用“解决方案五”，那么此时可以看一下两个RDD/Hive表中的key分布情况。如果出现数据倾斜，是因为其中某一个RDD/Hive表中的少数几个key的数据量过大，而另一个RDD/Hive表中的所有key都分布比较均匀，那么采用这个解决方案是比较合适的。</p><p>方案实现思路：</p><ul><li>对包含少数几个数据量过大的key的那个RDD，通过sample算子采样出一份样本来，然后统计一下每个key的数量，计算出来数据量最大的是哪几个key。</li><li>然后将这几个key对应的数据从原来的RDD中拆分出来，形成一个单独的RDD，并给每个key都打上n以内的随机数作为前缀，而不会导致倾斜的大部分key形成另外一个RDD。</li><li>接着将需要join的另一个RDD，也过滤出来那几个倾斜key对应的数据并形成一个单独的RDD，将每条数据膨胀成n条数据，这n条数据都按顺序附加一个0~n的前缀，不会导致倾斜的大部分key也形成另外一个RDD。</li><li>再将附加了随机前缀的独立RDD与另一个膨胀n倍的独立RDD进行join，此时就可以将原先相同的key打散成n份，分散到多个task中去进行join了。</li><li>而另外两个普通的RDD就照常join即可。</li><li>最后将两次join的结果使用union算子合并起来即可，就是最终的join结果。</li></ul><p>方案实现原理：对于join导致的数据倾斜，如果只是某几个key导致了倾斜，可以将少数几个key分拆成独立RDD，并附加随机前缀打散成n份去进行join，此时这几个key对应的数据就不会集中在少数几个task上，而是分散到多个task进行join了。具体原理见下图。</p><p>方案优点：对于join导致的数据倾斜，如果只是某几个key导致了倾斜，采用该方式可以用最有效的方式打散key进行join。而且只需要针对少数倾斜key对应的数据进行扩容n倍，不需要对全量数据进行扩容。避免了占用过多内存。</p><p>方案缺点：如果导致倾斜的key特别多的话，比如成千上万个key都导致数据倾斜，那么这种方式也不适合。</p><p><img src="https://i.imgur.com/r1UN2Vw.jpg" alt=""></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先从包含了少数几个导致数据倾斜key的rdd1中，采样10%的样本数据。  </span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; sampledRDD = rdd1.sample(<span class="literal">false</span>, <span class="number">0.1</span>);</span><br><span class="line"><span class="comment">// 对样本数据RDD统计出每个key的出现次数，并按出现次数降序排序。  </span></span><br><span class="line"><span class="comment">// 对降序排序后的数据，取出top 1或者top 100的数据，也就是key最多的前n个数据。  </span></span><br><span class="line"><span class="comment">// 具体取出多少个数据量最多的key，由大家自己决定，我们这里就取1个作为示范。  </span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; mappedSampledRDD = sampledRDD.mapToPair(</span><br><span class="line"><span class="keyword">new</span> <span class="type">PairFunction</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>,<span class="type">String</span>&gt;, <span class="type">Long</span>, <span class="type">Long</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; call(<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; tuple)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt;(tuple._1, <span class="number">1</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; countedSampledRDD = mappedSampledRDD.reduceByKey(</span><br><span class="line"><span class="keyword">new</span> <span class="type">Function2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Long</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Long</span> call(<span class="type">Long</span> v1, <span class="type">Long</span> v2) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; reversedSampledRDD = countedSampledRDD.mapToPair(</span><br><span class="line"><span class="keyword">new</span> <span class="type">PairFunction</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>,<span class="type">Long</span>&gt;, <span class="type">Long</span>, <span class="type">Long</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; call(<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt; tuple)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Long</span>&gt;(tuple._2, tuple._1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">final</span> <span class="type">Long</span> skewedUserid = reversedSampledRDD.sortByKey(<span class="literal">false</span>).take(<span class="number">1</span>).get(<span class="number">0</span>)._2;</span><br><span class="line"><span class="comment">// 从rdd1中分拆出导致数据倾斜的key，形成独立的RDD。  </span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; skewedRDD = rdd1.filter(</span><br><span class="line"><span class="keyword">new</span> <span class="type">Function</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>,<span class="type">String</span>&gt;, <span class="type">Boolean</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Boolean</span> call(<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; tuple) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple._1.equals(skewedUserid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 从rdd1中分拆出不导致数据倾斜的普通key，形成独立的RDD。  </span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; commonRDD = rdd1.filter(</span><br><span class="line"><span class="keyword">new</span> <span class="type">Function</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>,<span class="type">String</span>&gt;, <span class="type">Boolean</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Boolean</span> call(<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; tuple) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !tuple._1.equals(skewedUserid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// rdd2，就是那个所有key的分布相对较为均匀的rdd。  </span></span><br><span class="line"><span class="comment">// 这里将rdd2中，前面获取到的key对应的数据，过滤出来，分拆成单独的rdd，并对rdd中的数据使用flatMap算子都扩容100倍。  </span></span><br><span class="line"><span class="comment">// 对扩容的每条数据，都打上0～100的前缀。  </span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt; skewedRdd2 = rdd2.filter(</span><br><span class="line"><span class="keyword">new</span> <span class="type">Function</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>,<span class="type">Row</span>&gt;, <span class="type">Boolean</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Boolean</span> call(<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Row</span>&gt; tuple) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple._1.equals(skewedUserid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).flatMapToPair(<span class="keyword">new</span> <span class="type">PairFlatMapFunction</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>,<span class="type">Row</span>&gt;, <span class="type">String</span>, <span class="type">Row</span>&gt;() &#123;</span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public <span class="type">Iterable</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt; call(</span><br><span class="line">    <span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Row</span>&gt; tuple) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line"><span class="type">Random</span> random = <span class="keyword">new</span> <span class="type">Random</span>();</span><br><span class="line"><span class="type">List</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt; list = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;(i + <span class="string">"_"</span> + tuple._1, tuple._2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 将rdd1中分拆出来的导致倾斜的key的独立rdd，每条数据都打上100以内的随机前缀。  </span></span><br><span class="line"><span class="comment">// 然后将这个rdd1中分拆出来的独立rdd，与上面rdd2中分拆出来的独立rdd，进行join。  </span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt; joinedRDD1 = skewedRDD.mapToPair(</span><br><span class="line"><span class="keyword">new</span> <span class="type">PairFunction</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">Long</span>,<span class="type">String</span>&gt;, <span class="type">String</span>, <span class="type">String</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; call(<span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; tuple)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="type">Random</span> random = <span class="keyword">new</span> <span class="type">Random</span>();</span><br><span class="line">        int prefix = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;(prefix + <span class="string">"_"</span> + tuple._1, tuple._2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.join(skewedUserid2infoRDD)</span><br><span class="line">.mapToPair(<span class="keyword">new</span> <span class="type">PairFunction</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>,<span class="type">Tuple2</span>&lt;<span class="type">String</span>,<span class="type">Row</span>&gt;&gt;, <span class="type">Long</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt; call(</span><br><span class="line">            <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt; tuple)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        long key = <span class="type">Long</span>.valueOf(tuple._1.split(<span class="string">"_"</span>)[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;<span class="type">Long</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt;(key, tuple._2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 将rdd1中分拆出来的包含普通key的独立rdd，直接与rdd2进行join。  </span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt; joinedRDD2 = commonRDD.join(rdd2);</span><br><span class="line"><span class="comment">// 将倾斜key join后的结果与普通key join后的结果，uinon起来。  </span></span><br><span class="line"><span class="comment">// 就是最终的join结果。  </span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Row</span>&gt;&gt; joinedRDD = joinedRDD1.union(joinedRDD2);</span><br></pre></td></tr></table></figure><h5 id="57-方案七使用随机前缀和扩容rdd进行join"><a class="markdownIt-Anchor" href="#57-方案七使用随机前缀和扩容rdd进行join"></a> 5.7 方案七：使用随机前缀和扩容RDD进行join</h5><p>方案适用场景：如果在进行join操作时，RDD中有大量的key导致数据倾斜，那么进行分拆key也没什么意义，此时就只能使用最后一种方案来解决问题了。</p><p>方案实现思路：</p><ul><li>该方案的实现思路基本和“解决方案六”类似，首先查看RDD/Hive表中的数据分布情况，找到那个造成数据倾斜的RDD/Hive表，比如有多个key都对应了超过1万条数据。</li><li>然后将该RDD的每条数据都打上一个n以内的随机前缀。</li><li>同时对另外一个正常的RDD进行扩容，将每条数据都扩容成n条数据，扩容出来的每条数据都依次打上一个0~n的前缀。</li><li>最后将两个处理后的RDD进行join即可。</li></ul><p>方案实现原理：将原先一样的key通过附加随机前缀变成不一样的key，然后就可以将这些处理后的“不同key”分散到多个task中去处理，而不是让一个task处理大量的相同key。该方案与“解决方案六”的不同之处就在于，上一种方案是尽量只对少数倾斜key对应的数据进行特殊处理，由于处理过程需要扩容RDD，因此上一种方案扩容RDD后对内存的占用并不大；而这一种方案是针对有大量倾斜key的情况，没法将部分key拆分出来进行单独处理，因此只能对整个RDD进行数据扩容，对内存资源要求很高。</p><p>方案优点：对join类型的数据倾斜基本都可以处理，而且效果也相对比较显著，性能提升效果非常不错。</p><p>方案缺点：该方案更多的是缓解数据倾斜，而不是彻底避免数据倾斜。而且需要对整个RDD进行扩容，对内存资源要求很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先将其中一个key分布相对较为均匀的RDD膨胀100倍。</span></span><br><span class="line">JavaPairRDD&lt;String, Row&gt; expandedRDD = rdd1.flatMapToPair(</span><br><span class="line"><span class="keyword">new</span> PairFlatMapFunction&lt;Tuple2&lt;Long,Row&gt;, String, Row&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Tuple2&lt;String, Row&gt;&gt; call(Tuple2&lt;Long, Row&gt; tuple)</span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Tuple2&lt;String, Row&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Tuple2&lt;String, Row&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Tuple2&lt;String, Row&gt;(<span class="number">0</span> + <span class="string">"_"</span> + tuple._1, tuple._2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次，将另一个有数据倾斜key的RDD，每条数据都打上100以内的随机前缀。</span></span><br><span class="line">JavaPairRDD&lt;String, String&gt; mappedRDD = rdd2.mapToPair(</span><br><span class="line"><span class="keyword">new</span> PairFunction&lt;Tuple2&lt;Long,String&gt;, String, String&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tuple2&lt;String, String&gt; <span class="title">call</span><span class="params">(Tuple2&lt;Long, String&gt; tuple)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> prefix = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;String, String&gt;(prefix + <span class="string">"_"</span> + tuple._1, tuple._2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个处理后的RDD进行join即可。</span></span><br><span class="line">JavaPairRDD&lt;String, Tuple2&lt;String, Row&gt;&gt; joinedRDD = mappedRDD.join(expandedRDD);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1数据倾斜是怎么出现的&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1数据倾斜是怎么出现的&quot;&gt;&lt;/a&gt; 1.数据倾斜是怎么出现的&lt;/h4&gt;
&lt;p&gt;在执行shuffle操作的时候，是按照key，来进行values的数据的输出、拉取和聚合
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="spark" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/spark/"/>
    
    
      <category term="spark学习" scheme="http://blog.rickiyang.cn/tags/spark%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper中的分布式一致性协议</title>
    <link href="http://blog.rickiyang.cn/posts/e3052d18.html"/>
    <id>http://blog.rickiyang.cn/posts/e3052d18.html</id>
    <published>2018-08-15T12:42:41.000Z</published>
    <updated>2018-12-13T02:14:20.616Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-zookeeper中的一致性协议-zab协议"><a class="markdownIt-Anchor" href="#1-zookeeper中的一致性协议-zab协议"></a> 1. zookeeper中的一致性协议-ZAB协议</h4><p>在深入了解ZK之前，相信很多同学都会认为ZK就是Paxos算法的一个实现。但事实上，ZK并没有完全采用Paxos算法，而是使用了一种称为ZooKeeper Atomic Broadcast(ZAB,ZooKeeper原子消息广播协议)的协议作为其数据一致性的核心算法。</p><p>ZAB协议是为分布式协调服务ZooKeeper专门设计的一种支持崩渍恢复的原子广播协议。ZAB协议的开发设计人员在协议设计之初并没有要求其具有很好的扩展性，最初只是为雅虎公司内部那些高吞吐量、低延迟、健壮、简单的分布式系统场景设计的。在ZooKeeper的官方文档中也指出，ZAB协议并不像Paxos算法那样，是一种通用的分布式一致性算法，它是一种特别为ZooKeeper设计的崩溃可恢复的原子消息广播算法。</p><p>ZAB 协议的核心是定义了对于那些会改变ZooKeeper服务器数据状态的事务请求的处理方式，即：</p><p><em>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，而余下的其他服务器则成为Follower服务器。Leader服务器负责将一个客户端事务请求转换成一个事务Proposal(提议),并将该Proposal分发给集群中所有的Follower服务器。之后Leader 服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower 服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower<br>服务器分发Commit消息，要求其将前一个Proposal进行提交。</em></p><h5 id="11-zab协议的两种基本模式"><a class="markdownIt-Anchor" href="#11-zab协议的两种基本模式"></a> 1.1 ZAB协议的两种基本模式</h5><p>ZAB协议包括两种基本的模式，分别是崩愤恢复和消息广播。</p><p><strong>消息广播：</strong></p><p>ZAB 协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交过程。针对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal，并将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交。</p><p>在ZAB协议的二阶段提交过程中，移除了中断逻辑，所有的Follower服务器要么正常反馈Leader提出的事务Proposal，要么就抛弃Leader服务器。同时，ZAB协议将二阶段提交中的中断逻辑移除意味着我们可以在过半<br>的Follower服务器已经反馈Ack之后就开始提交事务Proposal了，而不需要等待集群中所有的Follower服务器都反馈响应。</p><p>当然，在这种简化了的二阶段提交模型下，是无法处理Leader服务器崩溃退出而带来的数据不一致问题的，因此在ZAB协议中添加了另一个模式，即采用崩愤恢复模式来解决这个问题。另外，整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能够很容易地保证消息广播过程中消息接收与发送的顺序性。</p><p>在整个消息广播过程中，Leader服务器会为每个事务请求生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个事务Proposal 分配一个全局单调递增的唯一ID，我们称之为事务ID(即ZXID)。由于ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务Proposal按照其ZXID的先后顺序来进行排序与处理。</p><p>在消息广播过程中，Leader服务器会为每一个Follower服务器都各自分配一个单独的队列，然后将需要广播的事务Proposal依次放入这些队列中去，并且根据FIFO策略进行消息发送。每一个Follower服务器在接收到这个事务Proposal之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给Leader服务器一个Ack响应。当Leader服务器接收到超过半数Follower的Ack响应后，就会广播一个Commit消息给所有的Follower服务器以通知其进行事务提交，同时Leader自身也会完成对事务的提交，而每一个Follower服务器在接收到Commit消息后，也会成对事务提交。</p><p><strong>崩溃恢复：</strong></p><p>上面我们说过一旦Leader服务器出现崩愤，或者说由于网络原因导致Leader服务器失去了与过半Follower的联系，那么就会进入崩溃恢复模式。在ZAB协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的Leader服务器。</p><p>为了确保ZAB可以快速的选出一个Leader，同时让新Leader知道自己被选举为Leader和让集群中的机器也快速的感知到产生了新的Leader，ZAB需要确保一些特性：</p><ol><li><p><strong>ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交。</strong></p><p>假设一个事务在Leader服务器上被提交了，并且已经得到过半Follower服务器的Ack反馈，但是在它将Commit消息发送给所有Follower机器之前，Leader服务器挂了。</p></li><li><p><strong>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务。</strong></p><p>如果在崩愤恢复过程中出现一个需要被丢弃的提案，那么在崩溃恢复结束后需要跳过该事务Proposal。，假设初始的Leader服务器Server1在提出了一个事务Proposal3之后就崩愤退出了，从而导致集群中的其他服务器都没有收到这个事务Proposal。于是，当Server恢复过来再次加入到集群中的时候，ZAB协议需要确保丢弃Proposal3这个事务。</p></li></ol><p>结合上面提到的这两个崩愤恢复过程中需要处理的特殊情况，就决定了ZAB 协议必须设计这样一个Leader选举算法：</p><p><strong>能够确保提交已经被Leader提交的事务Proposal，同时丢弃已经被跳过的事务Proposal。针对这个要求，如果让Leader选举算越能够保证新选举出来的Leader服务器拥有集群中所有机器最高编号(即ZXID最大)的事务Proposal,那么就可以保证这个新选举出来的Leader一定具有所有已经提交的提案。更为重要的是，如果让具有最高编号事务Proposal的机器来成为Leader，就可以省去Leader服务器检查Proposal的提交和丢弃工作的这一步操作了。</strong></p><h5 id="12-数据同步"><a class="markdownIt-Anchor" href="#12-数据同步"></a> 1.2 数据同步</h5><p>所有正常运行的服务器，要么成为Leader，要么成为Follower并和Leader保持同步。Leader服务器需要确保所有的Follower服务器能够接收到每一条事务Proposal，并且能够正确地将所有已经提交了的事务Proposal应用到内存数据库中去。具体的，Leader服务器会为每一个<br>Follower服务器都准备一个队列，并将那些没有被各Follower服务器同<br>步的事务以Proposal以消息的形式逐个发送给Follower服务器，并在每一个Proposal消息后面紧接着再发送一个Commit消息，以表示该事务已经被提交。等到Follower服务器将所有其尚未同步的事务Proposal都从Leader服务器上同步过来并成功应用到本地数据库中后，Leader服务器就会将该Follower服务器加入到真正的可用Follower列表中，并开始之后的其他流程。</p><h5 id="13-zab算法描述"><a class="markdownIt-Anchor" href="#13-zab算法描述"></a> 1.3 ZAB算法描述</h5><p>整个ZAB 协议主要包括消息广播和崩愤恢复两个过程，进一步可以细分为三个阶段，分别是发现(Discovery)、同步(Synchronization)和广播(Broadcast)阶段。组成ZAB协议的每一个分布式进程，会循环地执行这三个阶段，我们将这样一个循环称为一个主进程周期。</p><p>ZAB协议算法表述说明：</p><table><thead><tr><th>术语名</th><th>说明</th></tr></thead><tbody><tr><td>F<sub>p</sub></td><td>Follower f处理过的最后一个事务 Proposal</td></tr><tr><td>F<sub>.zxid</sub></td><td>Follower f 处理过的历史事务Proposal 中最后一个事务Proposal 的事务标识ZXID</td></tr><tr><td>h<sub>f</sub></td><td>每一个Follower f通常都已经处理（接受）了不少事务Proposal ,并且会有一个针对已经处理过的事务的集合， 将其表示为h&lt;sub&gt;f&lt;/sub&gt;, 表示Follower f 已经处理过的事务序列</td></tr><tr><td>I<sub>e</sub></td><td>初始化历史记录，在某一个主进程周期epoch e 中， 当准Leader 完成阶段一之后，此时它的h<sub>f</sub>就被标记为I<sub>e</sub></td></tr></tbody></table><p>下面我们就从发现、同步和广播这三个阶段展开来讲解ZAB 协议的内部原理。</p><p><strong>阶段1：发现</strong></p><p>阶段一主要就是Leader选举过程，用于在多个分布式进程中选举出主进程，准Leader L和Follower F的工作流程分别如下：</p><ol><li>步骤F.1.1： Follower F将自己最后接受的事务Proposal的epoch值CEPOCH(F.p)发送给准Leader L。</li><li>步骤L.1.1 当接收到来自过半Follower的CEPOCH(F.p)消息后，准Leader L会生成NEWEPOCH(e’)悄息给这些过半的Follower。<br>关于这个epoch值e’，准Leader L 会从所有接收到的CEPOCH(F.p）消息中选取出最大的epoch值，然后对其进行加l操作，即为e’。</li><li>步骤F.1.2：当Follower接收到来自准Leader L 的NEWEPOCH(e’)消息后，如果其检测到当前的CEPOCH(F.p)值小于e’，那么就会将CEPOCH(F.p)赋值为e’,同时向这个准Leader L反馈Ack消息。在这个反馈消息(ACK-E(F<sub>.p</sub>,h<sub>f</sub>)中,包含了当前该Follower 的epoch CEPOCH(F.p),以及该Follower的历史事务Proposal集合:h<sub>r</sub>。</li></ol><p>当Leader L接收到来自过半Follower的确认消息Ack之后，Leader L就会从这过半服务器中选取出一个Follower F,并使用其作为初始化事务集合I<sub>e’</sub>。</p><p><strong>阶段2：同步</strong></p><p>在这一阶段中，Leader L和Follower F的工作流程分别如下。</p><ol><li>步骤L.2.1: Leader L会将e’和Ie’以NEWLEADER(e’,I<sub>e’</sub>）消息的形式发送给所有Quorum中的Follower。</li><li>步骤F.2.1:当Follower接收到来自Leader L的NEWLEADER(e’,I<sub>e’</sub>)消息后，如果Follower发现CEPOCH(F<sub>.p</sub>)那么直接进入下一轮循环，因为此时Follower发现自己还在上一轮，或者更上轮，无法参与本轮的同步。如果CEPOCH(F.p) = e’，那么Follower就会执行事务应用操作。具体的，对于每一个事务Proposal:&lt;v,z&gt;∈I<sub>e’</sub>,Follower都会接受&lt;e’,&lt;v,z&gt;&gt;。最后 Follower会反馈给Leader，表明自己已经接受并处理了所有I<sub>e’</sub>中的事务Proposal。</li><li>步骤L.2.2 :当Leader接收到来自过半Follower针对NEWLEADER(e’，Ie’)的反馈消息后，就会向所有的Follower发送Commit消息。至此Leader完成阶段二。</li><li>步骤F.2.2: 当Follower收到来自Leader的Commit消息后，就会依次处理并提交所有在I<sub>e’'</sub>中未处理的事务。至此Follower完成阶段二。</li></ol><p><strong>阶段3：广播</strong></p><p>完成同步阶段之后，ZAB协议就可以正式开始接收客户端新的事务请求，井进行消息广播流程。</p><ol><li>步骤L.3.1： Leader L接收到客户端新的事务请求后，会生成对应的事务Proposal并根据zxid的顺序向所有Follower发送提案&lt;e’,&lt;v,z&gt;&gt;,其中epoch(z) = e’。</li><li>步骤F.3.1： Follower根据消息接收的先后次序来处理这些来自Leader的事务Proposal,并将他们追加到h<sub>r</sub>中去，之后再反馈给Leader。</li><li>步骤L.3.1：当Leader接收到来自过半Follower针对事务Proposal&lt; e’,&lt;v,z&gt;&gt;的Ack消息后，就会发送Commit&lt;e’,&lt;v,z&gt;&gt;消息给所有的Follower，要求它们进行事务的提交。</li><li>步骤F.3.2: 当Follower F接收到来自Leader的Commit&lt;e’,&lt;v,z&gt;&gt;消息后，就会开始提交事务Proposal&lt;e’,&lt;v,z&gt;&gt;。需要注意的是，此时该Follower F必定已经提交了事务Proposal &lt;v’,z’&gt;，其中&lt;v’,z’&gt;∈h<sub>f</sub>,z’ ∈ <sub>z</sub> Z。</li></ol><p>以上就是整个ZAB 协议的三个核心工作流程，以上各个状态字段说明如下：</p><ul><li>CEPOCH: Follower进程向准Leader发送自己处理过的最后一个事务Proposal的epoch值。</li><li>NEWEPOCH ：准Leader进程根据接收的各进程的epoch，来生成新一轮周期的epoch值。</li><li>ACK-E: Follower进程反馈准Leader进程发来的NEWEPOCH消息。</li><li>NEWLEADER：准Leader程确立自己的领导地位，并发送NEWLEADER消息给各进程。</li><li>ACK-LD : Follower进程反馈Leader进程发来的NEWLEADER消息。</li><li>COMMIT-LD：要求Follower进程提交相应的历史事务Proposal。</li><li>PROPOSE:Leader进程生成一个针对客户端事务请求的Proposal。</li><li>ACK: Follower进程反馈Leader进程发来的PROPOSAL消息。</li><li>COMMIT:Leader发送COMMIT消息，要求所有进程提交事务PROPOSE。</li></ul><h4 id="14-zab与paxos算法的区别"><a class="markdownIt-Anchor" href="#14-zab与paxos算法的区别"></a> 1.4 ZAB与Paxos算法的区别</h4><p>ZAB 协议并不是Paxos算法的一个典型实现，在讲解ZAB和Paxos之间的区别之前，我们首先来看下两者的联系：</p><ol><li>两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行。</li><li>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交。</li><li>在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前的Leader周期，在Paxos算法中，同样存在这样的一个标识，只是名字变成了Ballot。</li></ol><p>在Paxos算法中，一个新选举产生的主进程会进行两个阶段的工作。第一阶段被称为读阶段，在这个阶段中，这个新的主进程会通过和所有其他进程进行通信的方式来收集上一个主进程提出的提案，井将它们提交。第二阶段被称为写阶段，在这个阶段，当前主进程开始提出它自己的提案。在Paxos算法设计的基础上，ZAB协议额外添加了一个同步阶段。在同步阶段之前，ZAB协议也存在一个和Paxos算法中的读阶段非常类似的过<br>程，称为发现(Discovery)阶段。在同步阶段中，新的Leader会确保存在过半的Follower已经提交了之前Leader周期中的所有事务Proposal。这一同步阶段的引入，能够有效地保证Leader在新的周期中提出事务Proposal之前，所有的进程都已经完成了对之前所有事务Proposal的提交。一旦完成同步阶段后，那么ZAB就会执行和Paxos算法类似的写阶段。</p><p>总的来讲，ZAB协议和Paxos算法的本质区别在于，两者的设计目标不太一样。ZAB协议主要用于构建一个高可用的分布式数据主备系统，例如ZooKeeper，而Paxos算法则是用于构建一个分布式的一致性状态机系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-zookeeper中的一致性协议-zab协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-zookeeper中的一致性协议-zab协议&quot;&gt;&lt;/a&gt; 1. zookeeper中的一致性协议-ZAB协议&lt;/h4&gt;
&lt;p&gt;在深入了解
      
    
    </summary>
    
      <category term="分布式组件" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    
      <category term="zookeeper" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/zookeeper/"/>
    
    
      <category term="分布式" scheme="http://blog.rickiyang.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Paxos算法原理</title>
    <link href="http://blog.rickiyang.cn/posts/64ecab81.html"/>
    <id>http://blog.rickiyang.cn/posts/64ecab81.html</id>
    <published>2018-08-11T02:20:21.000Z</published>
    <updated>2018-12-13T02:14:20.616Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1从acid到cap"><a class="markdownIt-Anchor" href="#1从acid到cap"></a> 1.从ACID到CAP</h4><p>我们知道传统集中式系统中实现ACID是很简单的，在分布式环境中，涉及到不同的节点，节点内的ACID可以控制，那么节点间的ACID如何控制呢？构建一个可用性和一致性的分布系统成为难题，于是出现了CAP和BASE这样的理论。</p><p>CAP定理：</p><p>CAP告诉我们一个分布式系统不可能同时满足一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)。最多只能同时满足其中两项。</p><table><thead><tr><th style="text-align:center">放弃CAP定理</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">放弃P</td><td style="text-align:left">放弃分区容错性意味着你把所有的数据都放在同一个节点上，这可能会导致出错时系统不可用。同时也放弃了系统的可扩展性。</td></tr><tr><td style="text-align:center">放弃A</td><td style="text-align:left">放弃可用性带来的影响就更大了，出现故障系统直接停止提供服务。</td></tr><tr><td style="text-align:center">放弃C</td><td style="text-align:left">放弃一致性指的是需要系统保持强一致还是保持最终一致。</td></tr></tbody></table><p>为解决分布式一致性问题，涌现出来一大批经典的一致性算法和协议，其中最著名的是二阶段提交协议，三阶段提交协议和Paxos算法。</p><p>2PC：</p><p>two-Phase-Commit。通常二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统的数据一致性。目前绝大部分关系型数据库都是采用二阶段提交来完成分布式事务处理的。</p><p>协议说明：</p><ol><li>提交事务请求;</li><li>执行事务提交；</li></ol><p>优缺点：</p><ol><li>二阶段提交协议的优点：原理简单，实现方便。</li><li>二阶段提交协议的缺点：同步阻塞、单点问题、脑裂、太过保守。</li></ol><p>3PC：</p><p>将二阶段提交协议的“提交事务请求”过程一分为二，形成了由CanCommit，PreCommit和doCommit三个阶段组成的事务处理协议，协议设计如下图：</p><p><img src="https://i.imgur.com/w160kvh.png" alt=""></p><ol><li>阶段1，canCommit<ol><li>事务查询；</li><li>各参与者向协调者反馈事务询问的响应。</li></ol></li><li>阶段2,preCommit<ol><li>假如协调者从所有的参与者获得的反馈都是Yes 响应，那么就会执行事务预提交。</li><li>假如任何一个参与者向协调者反馈了No 响应，或者在等待超时之后，协调者尚无能接收到所有参与者的反馈响应，那么就会中断事务。</li></ol></li><li>阶段3，doCommit<ol><li>执行提交；</li><li>进入这一阶段，假设协调者处于正常工作状态，井且有任意一个参与者向协调者反馈了No 响应，或者在等待超时之后，协调者尚无告接收到所有参与者的反馈响应，那么就会中断事务。</li></ol></li></ol><p>优缺点：</p><p>三阶段提交协议的优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。</p><p>三阶段提交协议的缺点：三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无能进行正常的网络通信，在这种情况下， 该参与者依然会进行事务的提交，这必然出现数据的不一致性。</p><h4 id="2-paxos算法"><a class="markdownIt-Anchor" href="#2-paxos算法"></a> 2. Paxos算法</h4><p>Paxos算法的核心是一个一致性算法，也就是论文The Part-time Parliament中提到的&quot;synid&quot;算法，我们将从对一致性问题的描述开始来讲解该算法需要解决的实际需求。</p><p>问题描述：</p><p>假设有一组可以提出提案的进程集合，那么对于一个一致性算越来说需要保证以下几点：</p><ul><li>在这些被提出的提案中，只有一个会被选定</li><li>如果没有提案被提出，那么就不会有被选定的提案</li><li>当一个提案被迫定后，进程应该可以获取被选定的提案信息</li></ul><p>对于一致性来说，安全性（ Safety ）的需求如下：</p><ul><li>只有被提出的提案才能被选定（ Chosen ）</li><li>只能有一个值被选定。</li><li>如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个</li></ul><p>从整体上来说，Paxos算法的目标就是要保证最终有一个提案会被选定， 当提案被选定后，进程最终也能获取到被选定的提案。</p><p>要选定一个唯一提案的最简单方式莫过于只允许一个Accpetor存在，这样的话，Proposer只能发送提案给该Accpetor, Acceptor 会选择接收到的第一个提案作为被选定的提案。这种解决方式尽管实现起来非常简单，但是却很难让人满意，因为一旦这个Accpetor出现问题，那么整个系统就无能工作了。</p><p>因此，应该寻找一种更好的解决方式，例如可以使用多个Accpetor 来避免Accpetor 的单点问题。现在我们就来看看在存在多个Acceptor 的情况下如何进行提案的选取：</p><p>Proposer向一个Acceptor集合发送提案，同样，集合中的每个Acceptor 都可能会批准(Accept）该提案，当有足够多的Acceptor批准这个提案的时候，我们就可以认为该提案被选定了。那么，什么是足够多呢？我们假定足够多的Acceptor是整个Acceptor集合的一个子集，井且让这个集合大得可以包含Acceptor集合中的大多数成员，因为任意两个包含大多数Acceptor的子集至少有一个公共成员。另外我们再规定，每一个Acceptor最多只能批准一个提案，那么就能保证只有一个提案被选定了。</p><p>在没有失败和消息丢失的情况下，如果我们希望即使在只有一个提案被提出的情况下，仍然可以选出一个提案，这就暗示了如下的需求：</p><p><strong>条件1： 一个Acceptor 必须批准它收到的第一个提案。</strong></p><p>上面这个需求就引出了另外一个问题：如果有多个提案被不同的Proposer 同时提出，这可能会导致虽然每个Acceptor都批准了它收到的第一个提案，但是没有一个提案是由多数人都批准的。</p><p><img src="https://i.imgur.com/kK477ld.png" alt=""></p><p>不同的Proposer 分别提出每个提案。</p><p>另外，即使只有两个提案被提出，如果每个提案都被差不多一半的<br>Acceptor 批准了，此时即使只有一个Acceptor出错，都有可能导致无法确定该选定哪个提案。</p><p><img src="https://i.imgur.com/GlPwiFk.png" alt=""></p><p>任意一个Acceptor 出现问题。</p><p>因此在需求1的基础上，再加上一个提案被选定需要由半数以上的Acceptor批准的需求暗示着一个Acceptor必须能够批准不止一个提案。</p><p>在这里，我们使用一个全局的编号（这种全局唯一编号的生成并不是Paxos算法需要关注的地方，就算法本身而言，其假设当前已经具备这样的外部组件能够生成一个全局唯一的编号）来唯一标识每一个被Acceptor 批准的提案，当一个具有某Value值的提案被半数以上的Acceptor批准后，我们就认为该Value被选定了，此时我们也认为该提案被选定了。需要注意的是，此处讲到的提案已经和Value不是同一个概念了，提案变成了一个由编号和Value组成的组合体，因此我们以“［编号，Value］＂来表示一个提案。</p><p>根据上面讲到的内容，我们虽然允许多个提案被选定，但同时必须要保证所有被选定的提案都具有相同的Value值这是一个关于提案Value的约定， 结合提案的编号，该约定可以定义如下：</p><p><strong>条件2：</strong></p><p><strong>如果编号为Mo, Value值为V0的提案(即[Mo, Vo])被选定了，那么所<br>有比编号Mo更高的，且被选定的提案，其Value值必须也是Vo。</strong></p><p>因为提案的编号是全序的，条件2就保证了只有一个Value值被选定这一关键安全性属性。同时，一个提案要被选定，其首先必须被至少一个Acceptor 批准，因此我们可以通过满足如下条件来满足条件2：</p><p><strong>条件2.1：</strong></p><p><strong>如果编号为Mo，Value值为Vo的提案(即［Mo, Vo])被选定了，那么所<br>有比编号Mo更高的，且被Acceptor批准的提案，其Valu值必须也是Vo。</strong></p><p>因此，我们在条件1的前提下来发起提案，但是因为通信是异步的，一个提案可能会在某个Acceptor还未收到任何提案时就被选定了。</p><p><img src="https://i.imgur.com/gKbR7xF.png" alt=""></p><p>在Acceptorl没有收到任何提案的情况下，其他4个Acceptor已经批准<br>了来自Proposer2的提案［Mo,V1],而此时,Proposerl产生了一个具有其他Value值的、编号更高的提案［M1,V2］，并发送给了Acceptor1。根据条件1就需要Acceptorl批准该提案，但是这与条件2矛盾，因此如果要同时满足条件1和1，需要对条件2进行如下强化：</p><p><strong>条件2.2：</strong></p><p><strong>如果一个提案[Mo,Vo]被选定后，那么之后任何Proposer产生的编号是<br>高的提案，其Value值都为Vo。</strong></p><p>因为一个提案必须在被Proposer提出后才能被Acceptor批准，因此2.2 包含了2.1，进而包含了2。于是，接下去的重点就是论证2.2成立即可：</p><p><strong>假设某个提案[Mo,Vo]已经被选定了，证明任何编号Mn&gt; Mo的提案，其Value值都是Vo。</strong></p><h5 id="21-证明"><a class="markdownIt-Anchor" href="#21-证明"></a> 2.1 证明</h5><p>我们可以将上述结论转化为如下：</p><p><strong>假设编号在Mo到Mn-1之间的提案，其Value值都是Vo，证明编号为Mn的提案的Value值也为Vo。</strong></p><p>因为编号为Mo的提案已经被选定了，这就意味着肯定存在一个由半数以上的Acceptor组成的集合c, c中的每个Acceptor都批准了该提案。再结合归纳假设，&quot;编号为Mo的提案被选定&quot;意味着：</p><p><strong>C中的每个Acceptor都批准了一个编号在Mo到Mn-范围内的提案，并且每个编号在Mo到Mn-1范围内的被Acceptor批准的提案，其Value值都为Vo。</strong></p><p>因为任何包含半数以上Acceptor的集合S都至少包含C中的一个成员，因此我们可以认为如果保持了下面条件2.3的不变性，那么编号为Mn的提案的Value也为Vo。</p><p><strong>条件2.3：</strong></p><p><strong>对于任意的Mn和Vn，如果提[Mn,Yn]被提出，那么肯定存在一个由半数以上的Acceptor组成的集合S ，满足以下两个条件中的任意一个。</strong></p><ul><li>S中不存在任何批准过编号小于Mn的提案的Acceptor。</li><li>选取S中所有Acceptor批准的编号小于Mn的提案，其中编号最大的那个提案其Value值是Vn。</li></ul><p>至此，只需要通过保持条件2.3我们就能够满足条件2.2了。</p><p>实际上2.3规定了每个Proposer如何产生一个提案：对于产生的每个提案[Mn,Yn]，需要满足如下条件：</p><p>存在一个由超过半数的Acceptor 组成的集合S :</p><ul><li>要么S中没有Acceptor批准过编号小干Mn的任何提案。</li><li>要么S中的所有Acceptor批准的所有编号小于Mn的提案中，编号最大的那个提案的Value值为Vn。</li></ul><p>当每个Proposer都按照这个规则来产生提案时，就可以保证满足2.2了。我们继续来证明2.3。</p><p>首先假设提案[Mo,Vo]被选定了,设比该提案编号大的提案为[Mn,Vn]，我们需要证明的就是在2.3的前提下，对于所有的[Mn,Vn]，存在Vn=Vo。</p><ol><li><p>当Mn= Mo+1时，如果有这样一个编号为Mn的提案，首先我们知道[Mo,Vo]已经被选定了，那么就一定存在－个Acceptor的子集S，且S中的Acceptor已经批准了小于M的提案，于是，Vn只能是多数集S中编号小于M但为最大编号的那个提案的值。而此时因为Mn= Mo+1，因此理论上编号小于Mn但为最大编号的那个提案肯定是[Mo,Vo]同时由于S和通过[Mo,Vo]的Acceptor集合都是多数集,也就是说二者肯定有交集—这样Proposer在确定Vn取值的时候，就一定会选择Vo。</p><p>值得注意的一点是，Paxos算法的证明过程使用的是第二数学归纳法，上面实际上就是数学归纳陆的第一步，验证了某个初始值成立。接下去，就需要假设编号在Mo + 1到Mn-l 区间内时成立，并在此基础上推导出当编号为Mn时也成立。</p></li><li><p>根据假设，编号在Mo+1到Mn-1区间内的所有提案的Value值为Vo,需要证明的是编号为Mn的提案的Value值也为Vo。根据2.3，首先同样一定存在一个Acceptor的子集S，且S中的Acceptor已经批准了小子Mn的提案，那么编号为Mn的提案的Value值只能是这个多数集S中编号小于Mn但为最大编号的那个提案的值。如果这个最大编号落在Mo+1到Mn-1区间内，那么Value值肯定是Vo，如果不落在Mo+1到Mn-1区间内，那么它的编号不可能比Mo再小了,肯定就是Mo,因为S也肯定会与批准[Mo,Vo]这个提案的Acceptor集合S有交集，而如果编号是Mo,那么它的Value值也是Vo,由此得证。</p></li></ol><p><strong>proposer生成提案</strong></p><p>对于一个Proposer来说，获取那些已经被通过的提案远比预恻未来可能会被通过的提案来得简单。因此，Proposer 在产生一个编号为Mn的提案时，必须要知道当前某一个将要或已经被半数以上Acceptor批准的编号小于Mn但为最大编号的提案。并且，Proposer会要求所有的Acceptor都不<br>要再批准任何编号小于Mn的提案—这就引出了如下的提案生成算法。</p><ol><li><p>Proposer选择一个新的提案编号Mn，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下回应：</p><ol><li>向Proposer承诺，保证不再批准任何编号小于Mn 的提案。</li><li>如果Acceptor已经批准过任何提案，那么其就向Proposer反馈当前该Acceptor已经批准的编号小于Mn但为最大编号的那个提案的值。</li><li>我们将该请求称为编号为Mn的提案的Prepare请求。</li></ol></li><li><p>如果Proposer收到了来自半数以上的Acceptor的晌应结果，那么它就可以产生编号为Mn，Value值为Vn的提案，这里的Vn是所有响应中编号最大的提案的Value值。当然还存在另一种情况，就是半数以上的Acceptor 都没有批准过任何提案，即响应中不包含任何的提案，那么此时Vn值就可以由Proposer任意选择。</p></li></ol><p><strong>Acceptor批准提案：</strong></p><p>一个Acceptor可能会收到来自Proposer的两种请求，分别是Prepare<br>请求和Accept请求，对这两类请求做出响应的条件分别如下：</p><ol><li>Prepare请求：Acceptor可以在任何时候响应一个Prepare请求。</li><li>Accept请求：在不违背Accept现有承诺的前提下，可以任意响应Accept请求。</li></ol><p>因此对Acceptor逻辑处理的约束条件大体如下：</p><p><strong>一个Acceptor只要尚未响应过任何编号大于Mn的Prepare请求，那么它<br>就可以接受这个编号为Mn的提案。</strong></p><h5 id="22-算法优化"><a class="markdownIt-Anchor" href="#22-算法优化"></a> 2.2 算法优化</h5><p>在上面的内容中，我们分别从Proposer和Acceptor对提案的生成和批准两方面来讲解了Paxos算法在提案选定过程中的算也细节，同时也在提案的编号全局唯一的前提下，获得了一个满足安全性需求的提案选定算法，接下来我们再对这个初步算法做一个小优化，尽可能地忽略Prepare请求：</p><p><strong>假设一个Acceptor收到了一个编号为Mn的Prepare请求，但此时该Acceptor已经对编号大于Mn的Prepare请求做出了响应，因此它肯定不会再批准任何新的编号为Mn的提案，那么很显然，Acceptor就没有必要对这个Prepare请求做出响应，于是Acceptor可以选择忽略这样的Prepare 请求。同时，Acceptor也可以忽略掉那些它已经批准过的提案的Prepare 请求。</strong></p><p>通过这个优化，每个Acceptor只需要记住它已经批准的提案的最大编号以及它已经做出Prepare请求响应的提案的最大编号，以便在出现故障或节点重启的情况下，也能保证条件2.3的不变性。而对干Proposer来说，只要它可以保证不会产生具有相同编号的提案，那么就可以丢弃任意的提案以及它所有的运行时状态信息。</p><p>根据我们的优化，结合Proposer和Acceptor对提案的处理逻辑，就可以得到如下类似于两阶段提交的算能执行过程：</p><p><strong>阶段1：</strong></p><ol><li>Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。</li><li>如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acceptor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案。</li></ol><p>举个例子来说，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为l，2, …，5 和7，那么该Acceptor在接收到一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。</p><p><strong>阶段2：</strong></p><ol><li>如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn 的Prepare请求的晌应，那么它就会发送一个针对［Mn,Vn］提案的Accept请求给Acceptor。注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。</li><li>如果Acceptor收到这个针对[Mn,Vn]提案的Accept请求，只要该Acceptor尚未对编号大于Mn的Prepare请求做出响应，它就可以通过这个提案。</li></ol><p>当然，在实际运行过程中，每一个Proposer都有可能会产生多个提案，但只要每个Proposer都遵循如上所述的算陆运行，就一定能够保证算怯执行的正确性。值得一提的是，每个Proposer都可以在任意时刻丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos 算法的一系列规约，依然可以保证其在提案选定上的正确性。事实上，如果某个Proposer已经在试图生成编号更大的提案，那么丢弃一些旧的提案未尝不是一个好的选择。因此，如果一个Acceptor因为已经收到过更大编号的Prepare请求而忽略某个编号更小的Prepare或者Accept请求，那么它也应当通知其对应的Proposer，以便该Proposer也能够将该提案进行丢弃—这和上面“算法优化”部分中提到的提案丢弃是一致的。</p><p><strong>Learner获取提案：</strong></p><p>Learner获取提案大致有以下几种方案：</p><p>方案一：</p><p>Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做怯就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Learner。</p><p>很显然，这种做法虽然可以让Learner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Learner逐个进行一次通信，通信的次数至少为二者个数的乘积。</p><p>方案二：</p><p>另一种可行的方案是，我们可以让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定的Learner(下文中我们将这样的Learner称为&quot;主Learner&quot;），在不考虑拜占庭将军问题的前提下，我们假定Learner之间可以通过消息通信来互相感知提案的选定情况。基于这样的前提，当主Learner被通知一个提案已经被选定时，它会负责通知其他的Learner。</p><p>在这种方案中，Acceptor首先会将得到批准的提案发送给圭Learner，再由其同步给其他Learner，因此较方案一而言，方案二虽然需要多一个步骤才能将提案通知到所有的Learner，但其通信次数却大大减少了，通常只是Acceptor和Learner的个数总和。但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障。</p><p>方案三：</p><p>在讲解方案二的时候，我们提到，方案二最大的问题在于主Learner存在单点问题，即主Learner随时可能出现故障。因此，对方案二进行改进，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。这个Learner集合中的Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高。</p><h5 id="23-通过选举出主proposer保证算法的活性"><a class="markdownIt-Anchor" href="#23-通过选举出主proposer保证算法的活性"></a> 2.3 通过选举出主Proposer保证算法的活性</h5><p>根据前面的内容讲解，我们已经基本上了解了Paxos算法的核心逻辑，下面我们再来看看Paxos算法在实际运作过程中的一些细节。假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的议案，但是最终都无法被选定，具体流程如下：</p><p>Proposer P1提出了一个编号为M1的提案，并完成了上述阶段一的流程。但与此同时，另外一个Proposer P2提出了一个编号为M2(M2&gt;M1)的提案，同样也完成了阶段一的流程，于是Acceptor已经承诺不再批准编号小于M2 的提案了。因此，当P1进入阶段二的时候，其发出的Acceptor请求将被Acceptor忽略，于是P1再次进入阶段一并提出了一个编号为M3(M3 &gt; M2)的提案，而这又导致P2在第二阶段的Accept请求被忽略，以此类格，提案的选定过程将陷入死循环。</p><p>为了保证Paxos算法流程的可持续性，以避免陷入上述提到的“死循环”，就必须选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准。当然，如果Proposer发现当前算法流程中已经有一个编号更大的提案被提出或正在接受批准，那么它会丢弃当前这个编号较小的提案，并最终能够选出一个编号足够大的提案。因此，如果系统中有足够多的组件（包括Proposer，Acceptor和其他网络通信组件）能够正常工作，那么通过选择一个主Proposer，整套Paxos算住流程就能够保持活性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1从acid到cap&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1从acid到cap&quot;&gt;&lt;/a&gt; 1.从ACID到CAP&lt;/h4&gt;
&lt;p&gt;我们知道传统集中式系统中实现ACID是很简单的，在分布式环境中，涉及到不同的节点，节点内的AC
      
    
    </summary>
    
      <category term="分布式组件" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    
      <category term="zookeeper" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/zookeeper/"/>
    
    
      <category term="分布式" scheme="http://blog.rickiyang.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spark核心API开发</title>
    <link href="http://blog.rickiyang.cn/posts/e7493326.html"/>
    <id>http://blog.rickiyang.cn/posts/e7493326.html</id>
    <published>2018-07-23T14:23:54.000Z</published>
    <updated>2018-12-13T02:14:20.613Z</updated>
    
    <content type="html"><![CDATA[<p>开发人员在编写Spark应用的时候，需要提供一个包含main函数的驱动程序作为程序的入口，开发人员根据自己的需求，在main函数中调用Spark提供的数据操纵接口，利用集群对数据执行并行操作。</p><p>Spark为开发人员提供了两类抽象接口。</p><ol><li>第一类抽象接口是弹性分布式数据集（Resilient Distributed Dataset，下文简称RDD），顾名思义，RDD是对数据集的抽象封装，开发人员可以通过RDD提供的开发接口来访问和操纵数据集合，而无需了解数据的存储介质（内存或磁盘）、文件系统（本地文件系统、HDFS或Tachyon）、存储节点（本地或远程节点）等诸多实现细节；</li><li>第二类抽象是共享变量（Shared Variables），通常情况下，一个应用程序在运行的时候会被划分成分布在不同执行器之上的多个任务，从而提高运算的速度，每个任务都会有一份独立的程序变量拷贝，彼此之间互不干扰，然而在某些情况下需要任务之间相互共享变量，Apache Spark提供了两类共享变量，它们分别是：广播变量（Broadcast Variable）和累加器（Accumulators）。后面将介绍RDD的基本概念和RDD提供的编程接口，并在后面详细解读接口的源码实现，从而加深对RDD的理解，此外会介绍两类共享变量的使用方法。</li></ol><p>另外，除了单独编写一个应用程序的方式之外，Spark还提供了一个交互式Shell来使用。在Shell中，用户的每条语句都能在输入完毕后及时得到结果，而无需手动编译和运行程序。启用非常简单，在spark的安装目录找到bin目录下面的spark-shell命令即可。</p><p>在Shell中，系统根据命令提供的参数自动配置和生成了一个SparkContext对象sc，直接使用即可，无需再手动实例化SparkContext。除了结果会实时显示之外，其余操作与编写单独应用程序类似。读者可直接参考Spark官方提供的Spark ProgrammingGuide等文档，在此不做具体介绍。</p><h4 id="1-spark-context"><a class="markdownIt-Anchor" href="#1-spark-context"></a> 1. Spark Context</h4><p>SparkContext是整个项目程序的入口，无论从本地读取文件（textfile方法）还是从HDFS读取文件或者通过集合并行化获得RDD，都先要创建SparkContext对象，然后使用SparkContext对RDD进行创建和后续的转换操作。本节主要介绍SparkContext类的作用和创建过程，然后通过一个简单的例子向读者介绍SparkContext的应用方法，从应用角度来理解其作用。</p><h5 id="11-sparkcontext的作用"><a class="markdownIt-Anchor" href="#11-sparkcontext的作用"></a> 1.1 SparkContext的作用</h5><p>SparkContext除了是Spark的主要入口，它也可以看作是对用户的接口，它代表与Spark集群的连接对象，由下图2可以看到，SparkContext主要存在于Driver Program中。可以使用SparkContext来创建集群中的RDD、累积量和广播量，在后台SparkContext还能发送任务给集群管理器。每一个JVM只能有运行一个程序，即对应只有一个SparkContext处于激活状态，因此在创建新的SparkContext前需要把旧的SparkContext停止。</p><p><img src="https://i.imgur.com/pC28WGO.png" alt=""></p><p>下面有一个简单的单词统计例子来看一下SparkContext的使用方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> inputFile =  <span class="string">"file:///usr/local/spark/test/word.txt"</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"WordCount"</span>).setMaster(<span class="string">"local"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="keyword">val</span> textFile = sc.textFile(inputFile)</span><br><span class="line">    <span class="keyword">val</span> wordCount = textFile.flatMap(line =&gt; line.split(<span class="string">" "</span>)).map(word =&gt; (word, <span class="number">1</span>)).reduceByKey((a, b) =&gt; a + b)</span><br><span class="line">    wordCount.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，首先创建配置文件conf，使用本地模式，将配置文件放入sparkContext上下文并实例化。从sparkContext上下文中读取文件数据并将数据转化RDD，然后统计词频。</p><h4 id="2-rdd算子"><a class="markdownIt-Anchor" href="#2-rdd算子"></a> 2. RDD算子</h4><p>下面再来说RDD的两个主要操作算子Transformation和Action的使用方法，由于Spark是基于延迟计算，Transforamation算子并不立即执行，这时只是保存计算状态，当Action算子出现才真正执行计算。</p><h5 id="21-单值型tranformation算子"><a class="markdownIt-Anchor" href="#21-单值型tranformation算子"></a> 2.1 单值型Tranformation算子</h5><p>单值型的算子就是输入为单个值形式，这里主要介绍map、flatMap、mapPartitions、union、cartesian、groupBy、filter、distinct、subtract、foreach、cache、persist、sample以及takeSample方法：</p><table><thead><tr><th>方法名</th><th>方法定义</th></tr></thead><tbody><tr><td>map</td><td>def map[U](f: (T) ⇒ U)(implicit arg0: ClassTag[U]): RDD[U]</td></tr><tr><td>flatMap</td><td>defmapPartitions[U](f: (Iterator[T])⇒ Iterator[U], preservesPartitioning: Boolean = false)</td></tr><tr><td>mapPartition</td><td>def mapPartitions[U](f: (Iterator[T])⇒ Iterator[U], preservesPartitioning: Boolean = false)(implicit arg0: ClassTag[U]): RDD[U]</td></tr><tr><td>mapPartitionsWithIndex</td><td>def mapPartitionsWithIndex[U](f: (Int, Iterator[T])⇒ Iterator[U], preservesPartitioning: Boolean = false)(implicit arg0: ClassTag[U]): RDD[U]</td></tr><tr><td>foreach</td><td>def foreach(f: (T) ⇒ Unit): Unit</td></tr><tr><td>foreachPartition</td><td>def foreachPartition(f: (Iterator[T])⇒ Unit): Unit</td></tr><tr><td>glom</td><td>def glom(): RDD[Array[T]]</td></tr><tr><td>union</td><td>def union(other: RDD[T]): RDD[T]</td></tr><tr><td>cartesian</td><td>def cartesian[U](other: RDD[U])(implicit arg0: ClassTag[U]): RDD[(T, U)]</td></tr><tr><td>groupBy</td><td>def groupBy[K](f: (T) ⇒ K, p: Partitioner)(implicit kt: ClassTag[K], ord: Ordering[K] = null): RDD[(K, Iterable[T])]</td></tr><tr><td>filter</td><td>def filter(f: (T) ⇒ Boolean): RDD[T]</td></tr><tr><td>distinct</td><td>def distinct(): RDD[T]</td></tr><tr><td>subtract</td><td>def subtract(other: RDD[T], p: Partitioner)(implicit ord: Ordering[T] = null): RDD[T]</td></tr><tr><td>cache</td><td>def cache(): RDD.this.type</td></tr><tr><td>persist</td><td>def persist(): RDD.this.type</td></tr><tr><td>sample</td><td>def sample(withReplacement: Boolean, fraction: Double, seed: Long = Utils.random.nextLong): RDD[T]</td></tr><tr><td>takeSample</td><td>def takeSample(withReplacement: Boolean, num: Int, seed: Long = Utils.random.nextLong): Array[T]</td></tr></tbody></table><h6 id="211-map"><a class="markdownIt-Anchor" href="#211-map"></a> 2.1.1 <strong>map</strong></h6><p>对原来每一个输入的RDD数据集进行函数转换，返回的结果为新的RDD，该方法对分区操作是一对一的。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"bit"</span>, <span class="string">"linc"</span>, <span class="string">"xwc"</span>, <span class="string">"fjg"</span>, <span class="string">"wc"</span>,<span class="string">"spark"</span>), <span class="number">3</span>)<span class="comment">//创建RDD</span></span><br><span class="line"><span class="keyword">val</span> b = a.map(word =&gt; word.length)<span class="comment">//计算每个单词的长度</span></span><br><span class="line"><span class="keyword">val</span> c = a.zip(b)<span class="comment">//拉链方法，把两列数据对应配对成键值对格式</span></span><br><span class="line">c.collect<span class="comment">//把结果转换为数组</span></span><br><span class="line">结果：</span><br><span class="line">scala&gt; c.collect</span><br><span class="line">res3: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((bit,<span class="number">3</span>), (linc,<span class="number">4</span>), (xwc,<span class="number">3</span>), (fjg,<span class="number">3</span>), (wc,<span class="number">2</span>), (spark,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h6 id="212-flatmap"><a class="markdownIt-Anchor" href="#212-flatmap"></a> 2.1.2  <strong>flatMap</strong></h6><p>flapMap方法与map方法类似，但是允许在一次map方法中输出多个对象，而不是map中的一个对象经过函数转换生成另一个对象。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">0</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; a.flatMap(num =&gt; <span class="number">1</span> to num).collect</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h6 id="213-mappartitions"><a class="markdownIt-Anchor" href="#213-mappartitions"></a> 2.1.3 <strong>mapPartitions</strong></h6><p>mapPartitions是map的另一个实现。map的输入函数是应用于RDD中每个元素，而mapPartitio的输入函数是作用于每个分区，也就是把每个分区中的内容作为整体来处理的。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;  <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">9</span>, <span class="number">3</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">0</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">myfunc</span></span>[<span class="type">T</span>](iter: <span class="type">Iterator</span>[<span class="type">T</span>]) : <span class="type">Iterator</span>[(<span class="type">T</span>, <span class="type">T</span>)] = &#123;</span><br><span class="line">     | <span class="keyword">var</span> res = <span class="type">List</span>[(<span class="type">T</span>, <span class="type">T</span>)]()</span><br><span class="line">     | <span class="keyword">var</span> pre = iter.next</span><br><span class="line">     | <span class="keyword">while</span> (iter.hasNext) &#123;</span><br><span class="line">     | <span class="keyword">val</span> cur = iter.next</span><br><span class="line">     | res .::= (pre, cur)</span><br><span class="line">     | pre = cur</span><br><span class="line">     | &#125;</span><br><span class="line">     | res.iterator</span><br><span class="line">     | &#125;</span><br><span class="line">myfunc: [<span class="type">T</span>](iter: <span class="type">Iterator</span>[<span class="type">T</span>])<span class="type">Iterator</span>[(<span class="type">T</span>, <span class="type">T</span>)]</span><br><span class="line">scala&gt; a.mapPartitions(myfunc).collect</span><br><span class="line">res0: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((<span class="number">2</span>,<span class="number">3</span>), (<span class="number">1</span>,<span class="number">2</span>), (<span class="number">5</span>,<span class="number">6</span>), (<span class="number">4</span>,<span class="number">5</span>), (<span class="number">8</span>,<span class="number">9</span>), (<span class="number">7</span>,<span class="number">8</span>))</span><br></pre></td></tr></table></figure><p>解释一下这段程序：先得到一个分为3个分区的1-9的序列然，即每个分区的数据分别是(1,2,3),(4,5,6),(7,8,9)。下面定义了一个myfunc函数，遍历一个集合，集合里面是tuple对象，如果这个tuple的元素有next元素，name将pre和cur构造成一个tuple存入list。下面<br>mapPartitions函数将myfunc函数作为参数去作用于每一个分区，所以获得的结果为(1,2),(2,3),因为3没有next元素，所以每一个分区中只有两个tuple，下面的分区以此类推。</p><h6 id="214-mappartitionwithindex"><a class="markdownIt-Anchor" href="#214-mappartitionwithindex"></a> 2.1.4 <strong>mapPartitionWithIndex</strong></h6><p>mapPartitionWithIndex方法与mapPartitions方法功能类似，不同的是mapPartitionWithIndex还会对原始分区的索引进行追踪，这样能知道分区所对应的元素，方法的参数为一个函数，函数的输入为整型索引和迭代器。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">9</span>, <span class="number">3</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">0</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">myfunc</span></span>(index: <span class="type">Int</span>, iter: <span class="type">Iterator</span>[<span class="type">Int</span>]) : <span class="type">Iterator</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">     | iter.toList.map(x =&gt; index + <span class="string">","</span> + x).iterator</span><br><span class="line">     | &#125;</span><br><span class="line">myfunc: (index: <span class="type">Int</span>, iter: <span class="type">Iterator</span>[<span class="type">Int</span>])<span class="type">Iterator</span>[<span class="type">String</span>]</span><br><span class="line">scala&gt; a.mapPartitionsWithIndex(myfunc).collect()</span><br><span class="line">res1: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(<span class="number">0</span>,<span class="number">1</span>, <span class="number">0</span>,<span class="number">2</span>, <span class="number">0</span>,<span class="number">3</span>, <span class="number">1</span>,<span class="number">4</span>, <span class="number">1</span>,<span class="number">5</span>, <span class="number">1</span>,<span class="number">6</span>, <span class="number">2</span>,<span class="number">7</span>, <span class="number">2</span>,<span class="number">8</span>, <span class="number">2</span>,<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>这段程序就是先得到一个3个分区的序列，然后调用mapPartitionWithIndex函数可以获取每个分区的下标，方便追踪当前处理的分区。myfunc函数将每个分区的下标和值用&quot;,&quot;拼装在一起，从输出结果我们可以看到分区下标是从0开始的。</p><h6 id="215-foreach"><a class="markdownIt-Anchor" href="#215-foreach"></a> 2.1.5 <strong>foreach</strong></h6><p>foreach方法主要是对输入的数据对象执行循环操作，该方法常用来输出RDD中的内容。</p><p>这个方法比较直观：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>, <span class="string">"ee"</span>, <span class="string">"ff"</span>, <span class="string">"mm"</span>, <span class="string">"kk"</span>, <span class="string">"zz"</span>, <span class="string">"rr"</span>), <span class="number">3</span>)</span><br><span class="line">c: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">2</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; c.foreach(x =&gt; println(<span class="string">"word is : "</span>+x))</span><br></pre></td></tr></table></figure><h6 id="216-foreachpartition"><a class="markdownIt-Anchor" href="#216-foreachpartition"></a> 2.1.6 <strong>foreachPartition</strong></h6><p>foreachPartition方法的作用是通过迭代器参数对RDD中每一个分区的数据对象应用函数。mapPartitions方法的作用于foreachPartition方法作用非常相似，区别就在于使用的参数是否有返回值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">3</span>)</span><br><span class="line">b.foreachPartition(x =&gt; println((a,b) =&gt; x.reduce(a + b)</span><br></pre></td></tr></table></figure><h6 id="217-glom"><a class="markdownIt-Anchor" href="#217-glom"></a> 2.1.7 <strong>glom</strong></h6><p>作用类似collect，但它不是直接将所有RDD直接转化为数组形式，glom方法的作用是将RDD中分区数据进行组装到数组类型RDD中，每一个返回的数组包含一个分区的元素，按分区转化为数组，最后有几个分区就返回几个数组类型的RDD。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">1</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line">scala&gt; a.glom.collect</span><br><span class="line">res2: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="type">Array</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="type">Array</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h6 id="218-union"><a class="markdownIt-Anchor" href="#218-union"></a> 2.1.8 <strong>union</strong></h6><p>union方法（等价于“++”）是将两个RDD取并集，取并集过程中不会把相同元素去掉。union操作是输入分区与输出分区多对一模式。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">3</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = sc.parallelize(<span class="number">2</span> to <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">4</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; (a ++ b).collect</span><br><span class="line">res3: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; a.union(b).collect</span><br><span class="line">res4: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可见结果集没有执行distinct操作。</p><h6 id="219-cartesian"><a class="markdownIt-Anchor" href="#219-cartesian"></a> 2.1.9 <strong>cartesian</strong></h6><p>计算两个RDD中每个对象的笛卡尔积（例如第一个RDD中的每一个对象与第二个RDD中的对象join连接），但使用该方法时要注意可能出现内存不够的情况。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> x =sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="number">1</span>)</span><br><span class="line">x: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">7</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> y =sc.parallelize(<span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>),<span class="number">1</span>)</span><br><span class="line">y: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">8</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; x.cartesian(y).collect</span><br><span class="line">res5: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((<span class="number">1</span>,<span class="number">4</span>), (<span class="number">1</span>,<span class="number">5</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">2</span>,<span class="number">5</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>谨慎执行笛卡尔积操作。</p><h6 id="2110-groupby"><a class="markdownIt-Anchor" href="#2110-groupby"></a> 2.1.10 <strong>groupBy</strong></h6><p>groupBy方法有三个重载方法，功能是将元素通过map函数生成Key-Value格式，然后使用reduceByKey方法对Key-Value对进行聚合。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">9</span>, <span class="number">3</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">10</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; a.groupBy(x =&gt; &#123; <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) <span class="string">"even"</span> <span class="keyword">else</span> <span class="string">"odd"</span> &#125;).collect</span><br><span class="line">res6: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Int</span>])] = <span class="type">Array</span>((even,<span class="type">CompactBuffer</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)), (odd,<span class="type">CompactBuffer</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">myfunc</span></span>(a: <span class="type">Int</span>) : <span class="type">Int</span> =&#123;a % <span class="number">2</span>&#125;</span><br><span class="line">myfunc: (a: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; a.groupBy(myfunc).collect</span><br><span class="line">res7: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">Iterable</span>[<span class="type">Int</span>])] = <span class="type">Array</span>((<span class="number">0</span>,<span class="type">CompactBuffer</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)), (<span class="number">1</span>,<span class="type">CompactBuffer</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)))</span><br><span class="line"></span><br><span class="line">scala&gt; a.groupBy(myfunc(_),<span class="number">1</span>).collect</span><br><span class="line">res9: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">Iterable</span>[<span class="type">Int</span>])] = <span class="type">Array</span>((<span class="number">0</span>,<span class="type">CompactBuffer</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)), (<span class="number">1</span>,<span class="type">CompactBuffer</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)))</span><br></pre></td></tr></table></figure><p>第一个方法使用的是默认分区器，只需要传入自定义函数即可，第二个和第三个方法本质没有区别。</p><h6 id="2111-filter"><a class="markdownIt-Anchor" href="#2111-filter"></a> 2.1.11 <strong>filter</strong></h6><p>filter方法通过名称就能猜出来功能，其实就是对输入元素进行过滤，参数是一个返回值为boolean的函数，如果函数对输入元素运算结果为true，则通过该元素，否则将该元素过滤，不能进入结果集。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">25</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = a.filter(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">26</span>] at filter at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">scala&gt; b.collect</span><br><span class="line">res13: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h6 id="2112-distinct"><a class="markdownIt-Anchor" href="#2112-distinct"></a> 2.1.12 <strong>distinct</strong></h6><p>将RDD中重复的元素去掉，只留下唯一的RDD元素。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> x = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>), <span class="number">3</span>)</span><br><span class="line">x: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">27</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; x.distinct.collect</span><br><span class="line">res14: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h6 id="2112-subtract"><a class="markdownIt-Anchor" href="#2112-subtract"></a> 2.1.12  <strong>subtract</strong></h6><p>subtract的含义就是求集合A-B的差，即把集合A中包含集合B的元素都删除，结果是剩下的元素。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">9</span>, <span class="number">3</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">31</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = sc.parallelize(<span class="number">1</span> to <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">32</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> c = a.subtract(b)</span><br><span class="line">c: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">36</span>] at subtract at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">scala&gt; c.collect</span><br><span class="line">res15: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h6 id="2113-persistcache"><a class="markdownIt-Anchor" href="#2113-persistcache"></a> 2.1.13 <strong>persist,cache</strong></h6><p>顾名思义，是缓存数据，其作用是把RDD缓存到内存中，以方便下一次计算被再次调用。</p><p>有所不同的是：cache只是将数据保存在内存中，而persist方法的作用是把RDD根据不同的级别进行持久化，通过使用带参数方法能指定持久化级别，如果不带参数则为默认持久化级别，即只保存到内存，与cache等价。</p><p>persist方法通过StorageLevel函数来设置持久化级别，如果不设置持久化级别默认为持久化级别，即只保存到内准中，与cache一样。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>),<span class="number">1</span>)</span><br><span class="line">c: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">37</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; c.cache</span><br><span class="line">res16: c.<span class="keyword">type</span> = <span class="type">ParallelCollectionRDD</span>[<span class="number">37</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line">scala&gt; c.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY</span>)</span><br></pre></td></tr></table></figure><p><em>注意：c.persist(StorageLevel.MEMORY_ONLY) 在spark-shell中是无法执行的，StorageLevel是spark-core包中的对象。</em></p><p>Persist StorageLevel说明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StorageLevel</span> <span class="title">private</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    private var _useDisk: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    private var _useMemory: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    private var _useOffHeap: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    private var _deserialized: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    private var _replication: <span class="type">Int</span> = 1</span>)</span></span><br></pre></td></tr></table></figure><p>初始化StorageLevel可以传入5个参数，分别对应是否存入磁盘、是否存入内存、是否使用堆外内存、是否不进行序列化，副本数（默认为1）。</p><p>Storagelevel对应的枚举类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StorageLevel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">NONE</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">DISK_ONLY</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">DISK_ONLY_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY_SER</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY_SER_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_SER</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_SER_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">OFF_HEAP</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在持久化操作中需要注意的是：如果我们希望只是保存某一时刻的RDD信息，而不是在持久化到内存或者磁盘中仍然会变化的RDD，我们可以执行checkpoint()算子，可以把RDD持久化到HDFS，同时切断RDD之间的依赖。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>),<span class="number">1</span>)</span><br><span class="line">c.checkpoint()</span><br></pre></td></tr></table></figure><h5 id="checkpoint-可以把rdd持久化到hdfs同时切断rdd之间的依赖"><a class="markdownIt-Anchor" href="#checkpoint-可以把rdd持久化到hdfs同时切断rdd之间的依赖"></a> checkpoint : 可以把RDD持久化到HDFS，同时切断RDD之间的依赖</h5><p>对于切断RDD之间的依赖的说明：<br>当业务逻辑很复杂时，RDD之间频繁转换，RDD的血统很长，如果中间某个RDD的数据丢失，还需要重新从头计算，如果对中间某个RDD调用了checkpoint()方法，把这个RDD上传到HDFS，同时让后面的RDD不再依赖于这个RDD，而是依赖于HDFS上的数据，那么下次计算会方便很多。</p><p>checkpoint()执行原理：</p><ol><li>当RDD的job执行完毕后，会从finalRDD从后往前回溯</li><li>当回溯到调用了checkpoint()方法的RDD后，会给这个RDD做一个标记</li><li>Spark框架自动启动一个新的job，计算这个RDD的数据，然后把数据持久化到HDFS上</li><li>优化：对某个RDD执行checkpoint()之前，对该RDD执行cache()，这样的话，新启动的job只需要把内存中的数据上传到HDFS中即可，不需要重新计算。</li></ol><h6 id="2114-sample"><a class="markdownIt-Anchor" href="#2114-sample"></a> 2.1.14 <strong>sample</strong></h6><p>sample的作用是随机的对RDD中的元素采样，获得一个新的子集RDD，根据参数能指定是否又放回采样、子集占总数的百分比和随机种子。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">1000</span>, <span class="number">2</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">38</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; a.sample(<span class="literal">false</span>, <span class="number">0.1</span>, <span class="number">0</span>).collect</span><br><span class="line">res21: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">10</span>, <span class="number">39</span>, <span class="number">41</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">80</span>, <span class="number">89</span>, <span class="number">98</span>, <span class="number">113</span>, <span class="number">114</span>, <span class="number">128</span>, <span class="number">134</span>, <span class="number">144</span>, <span class="number">161</span>, <span class="number">173</span>, <span class="number">176</span>, <span class="number">177</span>, <span class="number">198</span>, <span class="number">201</span>, <span class="number">211</span>, <span class="number">212</span>, <span class="number">213</span>, <span class="number">218</span>, <span class="number">224</span>, <span class="number">232</span>, <span class="number">235</span>, <span class="number">241</span>, <span class="number">242</span>, <span class="number">243</span>, <span class="number">246</span>, <span class="number">264</span>, <span class="number">287</span>, <span class="number">307</span>, <span class="number">319</span>, <span class="number">321</span>, <span class="number">325</span>, <span class="number">334</span>, <span class="number">339</span>, <span class="number">353</span>, <span class="number">354</span>, <span class="number">366</span>, <span class="number">367</span>, <span class="number">373</span>, <span class="number">392</span>, <span class="number">403</span>, <span class="number">407</span>, <span class="number">419</span>, <span class="number">426</span>, <span class="number">429</span>, <span class="number">434</span>, <span class="number">458</span>, <span class="number">465</span>, <span class="number">466</span>, <span class="number">478</span>, <span class="number">492</span>, <span class="number">495</span>, <span class="number">514</span>, <span class="number">522</span>, <span class="number">536</span>, <span class="number">547</span>, <span class="number">550</span>, <span class="number">557</span>, <span class="number">560</span>, <span class="number">567</span>, <span class="number">575</span>, <span class="number">595</span>, <span class="number">613</span>, <span class="number">618</span>, <span class="number">638</span>, <span class="number">639</span>, <span class="number">643</span>, <span class="number">658</span>, <span class="number">659</span>, <span class="number">660</span>, <span class="number">662</span>, <span class="number">672</span>, <span class="number">681</span>, <span class="number">682</span>, <span class="number">686</span>, <span class="number">693</span>, <span class="number">694</span>, <span class="number">696</span>, <span class="number">716</span>, <span class="number">720</span>, <span class="number">737</span>, <span class="number">763</span>, <span class="number">769</span>, <span class="number">774</span>, <span class="number">775</span>, <span class="number">791</span>, <span class="number">795</span>, <span class="number">802</span>, <span class="number">804</span>, <span class="number">812</span>, <span class="number">815</span>, <span class="number">817</span>, <span class="number">822</span>, <span class="number">877</span>, <span class="number">888</span>, <span class="number">889</span>, <span class="number">915</span>, <span class="number">942</span>, <span class="number">947</span>, <span class="number">948</span>, <span class="number">971</span>, <span class="number">972</span>, <span class="number">976</span>, <span class="number">985</span>, <span class="number">992</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; a.sample(<span class="literal">true</span>, <span class="number">0.1</span>, <span class="number">0</span>).collect</span><br><span class="line">res22: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">10</span>, <span class="number">23</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">50</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">79</span>, <span class="number">79</span>, <span class="number">85</span>, <span class="number">91</span>, <span class="number">91</span>, <span class="number">110</span>, <span class="number">122</span>, <span class="number">132</span>, <span class="number">133</span>, <span class="number">133</span>, <span class="number">153</span>, <span class="number">166</span>, <span class="number">171</span>, <span class="number">172</span>, <span class="number">175</span>, <span class="number">180</span>, <span class="number">198</span>, <span class="number">208</span>, <span class="number">211</span>, <span class="number">229</span>, <span class="number">233</span>, <span class="number">241</span>, <span class="number">271</span>, <span class="number">275</span>, <span class="number">287</span>, <span class="number">289</span>, <span class="number">307</span>, <span class="number">318</span>, <span class="number">322</span>, <span class="number">329</span>, <span class="number">337</span>, <span class="number">338</span>, <span class="number">339</span>, <span class="number">354</span>, <span class="number">358</span>, <span class="number">366</span>, <span class="number">369</span>, <span class="number">374</span>, <span class="number">377</span>, <span class="number">379</span>, <span class="number">388</span>, <span class="number">394</span>, <span class="number">407</span>, <span class="number">415</span>, <span class="number">420</span>, <span class="number">424</span>, <span class="number">425</span>, <span class="number">428</span>, <span class="number">436</span>, <span class="number">447</span>, <span class="number">452</span>, <span class="number">462</span>, <span class="number">492</span>, <span class="number">492</span>, <span class="number">494</span>, <span class="number">515</span>, <span class="number">526</span>, <span class="number">529</span>, <span class="number">550</span>, <span class="number">571</span>, <span class="number">587</span>, <span class="number">587</span>, <span class="number">597</span>, <span class="number">601</span>, <span class="number">603</span>, <span class="number">621</span>, <span class="number">626</span>, <span class="number">630</span>, <span class="number">638</span>, <span class="number">643</span>, <span class="number">644</span>, <span class="number">649</span>, <span class="number">650</span>, <span class="number">657</span>, <span class="number">659</span>, <span class="number">661</span>, <span class="number">670</span>, <span class="number">686</span>, <span class="number">689</span>, <span class="number">720</span>, <span class="number">722</span>, <span class="number">722</span>, <span class="number">728</span>, <span class="number">743</span>, <span class="number">748</span>, <span class="number">761</span>, <span class="number">763</span>, <span class="number">782</span>, <span class="number">787</span>, <span class="number">787</span>, <span class="number">796</span>, <span class="number">817</span>, <span class="number">820</span>, <span class="number">825</span>, <span class="number">833</span>, <span class="number">844</span>, <span class="number">846</span>, <span class="number">855</span>, <span class="number">872</span>, <span class="number">873</span>, <span class="number">881</span>, <span class="number">899</span>, <span class="number">904</span>, <span class="number">916</span>, <span class="number">935</span>, <span class="number">936</span>, <span class="number">951</span>, <span class="number">952</span>, <span class="number">967</span>, <span class="number">982</span>, <span class="number">990</span>, <span class="number">992</span>, <span class="number">993</span>)</span><br></pre></td></tr></table></figure><p>上述例子中sample方法第一个参数为true时使用放回抽样（<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUIzJThBJUU2JTlEJUJFJUU1JTg4JTg2JUU0JUJEJTg4" title="https://zh.wikipedia.org/wiki/%E6%B3%8A%E6%9D%BE%E5%88%86%E4%BD%88">泊松抽样<i class="fa fa-external-link"></i></span>），为false时使用不放回抽样（<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJDJUFGJUU1JThBJUFBJUU1JTg4JUE5JUU1JTg4JTg2JUU1JUI4JTgz" title="https://zh.wikipedia.org/wiki/%E4%BC%AF%E5%8A%AA%E5%88%A9%E5%88%86%E5%B8%83">伯努利抽样<i class="fa fa-external-link"></i></span>），第二个参数fraction是百分比，第三个参数seed是种子，也就是随机取值的起源数字。从例子2中还看出当选择放回抽样时，取出的元素中会出现重复值。</p><h5 id="22-键值对型transformation算子"><a class="markdownIt-Anchor" href="#22-键值对型transformation算子"></a> 2.2 <strong>键值对型Transformation算子</strong></h5><p>RDD的操作算子除了单值型还有键值对（Key-Value）型。这里开始介绍键值对型的算子，主要包括groupByKey、combineByKey、reduceByKey、sortByKey、cogroup和join，如下表所示：</p><table><tbody><tr><td><p>方法名</p></td><td><p>方法定义</p></td></tr><tr><td><p>groupByKey</p></td><td><p>def groupByKey(partitioner: Partitioner): RDD[(K, Iterable[V])]</p></td></tr><tr><td><p>combineByKey</p></td><td><p>def combineByKey[C](createCombiner: V =&gt; C, mergeValue: (C,V) =&gt; C, mergeCombiners: (C, C) =&gt; C) : RDD[(K, C)]</p></td></tr><tr><td><p>reduceByKey</p></td><td><p>def reduceByKey(partitioner: Partitioner, func: (V, V) =&gt; V): RDD[(K, V)]</p></td></tr><tr><td><p>sortByKey</p></td><td><p>def sortByKey(ascending: Boolean = true, numPartitions: Int = self.partitions.size): RDD[P]</p></td></tr><tr><td><p>cogroup</p></td><td><p>def cogroup[W](other: RDD[(K, W)], partitioner: Partitioner): RDD</p></td></tr><tr><td><p>join</p></td><td><p>def join[W](other: RDD[(K, W)], partitioner: Partitioner): RDD[(K, (V, W))]</p></td></tr></tbody></table><h6 id="221-groupbykey"><a class="markdownIt-Anchor" href="#221-groupbykey"></a> 2.2.1 <strong>groupByKey</strong></h6><p>类似groupBy方法，作用是把每一个相同Key值的的Value聚集起来形成一个序列，可以使用默认分区器和自定义分区器，但是这个方法开销比较大，如果想对同一Key进行Value的聚合或求平均，则推荐使用aggregateByKey或者reduceByKey。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"mk"</span>, <span class="string">"zq"</span>, <span class="string">"xwc"</span>, <span class="string">"fjg"</span>, <span class="string">"dcp"</span>, <span class="string">"snn"</span>), <span class="number">2</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">41</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = a.keyBy(x =&gt; x.length)</span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">42</span>] at keyBy at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">scala&gt; b.groupByKey.collect</span><br><span class="line">res23: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">Iterable</span>[<span class="type">String</span>])] = <span class="type">Array</span>((<span class="number">2</span>,<span class="type">CompactBuffer</span>(mk, zq)), (<span class="number">3</span>,<span class="type">CompactBuffer</span>(xwc, fjg, dcp, snn)))</span><br></pre></td></tr></table></figure><h6 id="222-combinebykey"><a class="markdownIt-Anchor" href="#222-combinebykey"></a> 2.2.2 <strong>combineByKey</strong></h6><p>combineByKey方法能高效的将键值对形式的RDD按相同的Key把Value合并成序列形式，用户能自定义RDD的分区器和是否在map端进行聚合操作。</p><p>spark新版本中函数名更新为combineByKeyWithClassTag，为了兼容两个函数同时保留都可以使用。</p><p>如下为combineByKey的定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combineByKey</span></span>[<span class="type">C</span>](</span><br><span class="line">      createCombiner: <span class="type">V</span> =&gt; <span class="type">C</span>,</span><br><span class="line">      mergeValue: (<span class="type">C</span>, <span class="type">V</span>) =&gt; <span class="type">C</span>,</span><br><span class="line">      mergeCombiners: (<span class="type">C</span>, <span class="type">C</span>) =&gt; <span class="type">C</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">C</span>)] = self.withScope &#123;</span><br><span class="line">    combineByKeyWithClassTag(createCombiner, mergeValue, mergeCombiners)(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>解释下3个重要的函数参数：</p><ul><li>createCombiner: V =&gt; C ，这个函数把当前的值作为参数，此时我们可以对其做些附加操作(类型转换)并把它返回 (这一步类似于初始化操作)</li><li>mergeValue: (C, V) =&gt; C，该函数把元素V合并到之前的元素C(createCombiner)上 (这个操作在每个分区内进行)</li><li>mergeCombiners: (C, C) =&gt; C，该函数把2个元素C合并 (这个操作在不同分区间进行)</li></ul><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> initialScores = <span class="type">Array</span>((<span class="string">"Fred"</span>, <span class="number">88.0</span>), (<span class="string">"Fred"</span>, <span class="number">95.0</span>), (<span class="string">"Fred"</span>, <span class="number">91.0</span>), (<span class="string">"Wilma"</span>, <span class="number">93.0</span>), (<span class="string">"Wilma"</span>, <span class="number">95.0</span>), (<span class="string">"Wilma"</span>, <span class="number">98.0</span>))</span><br><span class="line">initialScores: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = <span class="type">Array</span>((<span class="type">Fred</span>,<span class="number">88.0</span>), (<span class="type">Fred</span>,<span class="number">95.0</span>), (<span class="type">Fred</span>,<span class="number">91.0</span>), (<span class="type">Wilma</span>,<span class="number">93.0</span>), (<span class="type">Wilma</span>,<span class="number">95.0</span>), (<span class="type">Wilma</span>,<span class="number">98.0</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> d1 = sc.parallelize(initialScores)</span><br><span class="line">d1: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">52</span>] at parallelize at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">MVType</span> </span>= (<span class="type">Int</span>, <span class="type">Double</span>)</span><br><span class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">MVType</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">d1</span>.<span class="title">combineByKey</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">     | score =&gt; (1, score</span>),</span></span><br><span class="line"><span class="class">     <span class="title">|</span> (<span class="params">c1: <span class="type">MVType</span>, newScore</span>) <span class="title">=&gt;</span> (<span class="params">c1._1 + 1, c1._2 + newScore</span>),</span></span><br><span class="line"><span class="class">     <span class="title">|</span> (<span class="params">c1: <span class="type">MVType</span>, c2: <span class="type">MVType</span></span>) <span class="title">=&gt;</span> (<span class="params">c1._1 + c2._1, c1._2 + c2._2</span>)</span></span><br><span class="line"><span class="class">     <span class="title">|</span> ).<span class="title">map</span> </span>&#123; <span class="keyword">case</span> (name, (num, socre)) =&gt; (name, socre / num) &#125;.collect</span><br><span class="line">res27: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = <span class="type">Array</span>((<span class="type">Fred</span>,<span class="number">91.33333333333333</span>), (<span class="type">Wilma</span>,<span class="number">95.33333333333333</span>))</span><br></pre></td></tr></table></figure><p>上面是combineByKey来求解平均数的例子，解释一下参数：</p><ul><li>score =&gt; (1, score)，我们把分数作为参数,并返回了附加的元组类型。 以&quot;Fred&quot;为列，当前其分数为88.0 =&gt;(1,88.0)  1表示当前科目的计数器，此时只有一个科目；</li><li>(c1: MVType, newScore) =&gt; (c1._1 + 1, c1._2 + newScore)，注意这里的c1就是createCombiner初始化得到的(1,88.0)。在一个分区内，我们又碰到了&quot;Fred&quot;的一个新的分数91.0。当然我们要把之前的科目分数和当前的分数加起来即c1._2 + newScore,然后把科目计算器加1即c1._1 + 1；</li><li>(c1: MVType, c2: MVType) =&gt; (c1._1 + c2._1, c1._2 + c2._2)，注意&quot;Fred&quot;可能是个学霸,他选修的科目可能过多而分散在不同的分区中。所有的分区都进行mergeValue后,接下来就是对分区间进行合并了,分区间科目数和科目数相加分数和分数相加就得到了总分和总科目数。</li></ul><p>######2.2.3 <strong>reduceByKey</strong></p><p>使用一个reduce函数来实现对相同Key的Value的聚集操作，在发送结果给reduce前会在map端的执行本地merge操作。该方法的底层实现就是调用combineByKey方法的一个重载方法。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list = sc.parallelize(<span class="type">List</span>(<span class="string">"dcp"</span>, <span class="string">"fjg"</span>, <span class="string">"snn"</span>, <span class="string">"wc"</span>, <span class="string">"zq"</span>), <span class="number">2</span>)</span><br><span class="line">list: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">55</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> map = list.map(x =&gt; (x.length, x))</span><br><span class="line">map: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">56</span>] at map at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">scala&gt; map.reduceByKey((a,b) =&gt; a + b).collect</span><br><span class="line">res28: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">Array</span>((<span class="number">2</span>,wczq), (<span class="number">3</span>,dcpfjgsnn))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">124</span>,<span class="number">32</span>,<span class="number">5</span> ), <span class="number">2</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">58</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = a.map(x =&gt; (x.toString.length, x))</span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">59</span>] at map at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">scala&gt; b.reduceByKey(_ + _).collect</span><br><span class="line">res29: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((<span class="number">2</span>,<span class="number">44</span>), (<span class="number">1</span>,<span class="number">8</span>), (<span class="number">3</span>,<span class="number">124</span>))</span><br></pre></td></tr></table></figure><p>上面示例中先用map方法映射出键值对，然后调用reduceByKey方法对相同Key的Value值进行累加,因为第一个示例是字符串，所以结果为每个key中字符串的拼接，示例2中为数字，所以结果每个key中数字之和。</p><h6 id="224-sortbykey"><a class="markdownIt-Anchor" href="#224-sortbykey"></a> 2.2.4 <strong>sortByKey</strong></h6><p>这个函数会根据Key值对键值对进行排序，如果Key是字母，则按字典顺序排序，如果Key是数字，则从小到大排序（或从大到小），该方法的第一个参数控制是否为升序排序，当为true时是升序，反之为降序。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"owl"</span>, <span class="string">"gnu"</span>, <span class="string">"ant"</span>), <span class="number">2</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">61</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = sc.parallelize(<span class="number">1</span> to a.count.toInt, <span class="number">2</span>) #得到单词的字母个数</span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">62</span>] at parallelize at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> c = a.zip(b)</span><br><span class="line">c: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">ZippedPartitionsRDD2</span>[<span class="number">63</span>] at zip at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">scala&gt; c.sortByKey(<span class="literal">true</span>).collect</span><br><span class="line">res30: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((ant,<span class="number">5</span>), (cat,<span class="number">2</span>), (dog,<span class="number">1</span>), (gnu,<span class="number">4</span>), (owl,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; c.sortByKey(<span class="literal">false</span>).collect</span><br><span class="line">res31: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((owl,<span class="number">3</span>), (gnu,<span class="number">4</span>), (dog,<span class="number">1</span>), (cat,<span class="number">2</span>), (ant,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h6 id="225-cogroup"><a class="markdownIt-Anchor" href="#225-cogroup"></a> 2.2.5 <strong>cogroup</strong></h6><p>cogroup是一个比较高效的函数，能根据Key值聚集最多3个键值对的RDD，把相同Key值对应的Value聚集起来。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">78</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = a.map(x =&gt; (x, <span class="string">"b"</span>))</span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">79</span>] at map at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> c = a.map(y =&gt; (y, <span class="string">"c"</span>))</span><br><span class="line">c: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">80</span>] at map at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">scala&gt; b.cogroup(c).collect</span><br><span class="line">res35: <span class="type">Array</span>[(<span class="type">Int</span>, (<span class="type">Iterable</span>[<span class="type">String</span>], <span class="type">Iterable</span>[<span class="type">String</span>]))] = <span class="type">Array</span>((<span class="number">1</span>,(<span class="type">CompactBuffer</span>(b, b),<span class="type">CompactBuffer</span>(c, c))), (<span class="number">3</span>,(<span class="type">CompactBuffer</span>(b, b),<span class="type">CompactBuffer</span>(c, c))), (<span class="number">2</span>,(<span class="type">CompactBuffer</span>(b, b),<span class="type">CompactBuffer</span>(c, c))))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> d = a.map(m =&gt; (m, <span class="string">"x"</span>))</span><br><span class="line">d: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">83</span>] at map at &lt;console&gt;:<span class="number">25</span></span><br><span class="line"></span><br><span class="line">scala&gt; b.cogroup(c, d).collect</span><br><span class="line">res36: <span class="type">Array</span>[(<span class="type">Int</span>, (<span class="type">Iterable</span>[<span class="type">String</span>], <span class="type">Iterable</span>[<span class="type">String</span>], <span class="type">Iterable</span>[<span class="type">String</span>]))] = <span class="type">Array</span>((<span class="number">1</span>,(<span class="type">CompactBuffer</span>(b, b),<span class="type">CompactBuffer</span>(c, c),<span class="type">CompactBuffer</span>(x, x))), (<span class="number">3</span>,(<span class="type">CompactBuffer</span>(b, b),<span class="type">CompactBuffer</span>(c, c),<span class="type">CompactBuffer</span>(x, x))), (<span class="number">2</span>,(<span class="type">CompactBuffer</span>(b, b),<span class="type">CompactBuffer</span>(c, c),<span class="type">CompactBuffer</span>(x, x))))</span><br></pre></td></tr></table></figure><h6 id="226-join"><a class="markdownIt-Anchor" href="#226-join"></a> 2.2.6 <strong>join</strong></h6><p>对键值对的RDD进行cogroup操作，然后对每个新的RDD下Key的值进行笛卡尔积操作，再对返回结果使用flatMapValues方法，最后返回结果。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"fjg"</span>, <span class="string">"wc"</span>, <span class="string">"xwc"</span>,<span class="string">"dcp"</span>), <span class="number">2</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">90</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = a.keyBy(_.length)<span class="comment">//得到诸如（3，"fjg"），（2，"wc"）的键值对序列</span></span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">91</span>] at keyBy at &lt;console&gt;:<span class="number">25</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"fjg"</span>, <span class="string">"wc"</span>, <span class="string">"snn"</span>, <span class="string">"zq"</span>, <span class="string">"xwc"</span>,<span class="string">"dcp"</span>), <span class="number">2</span>)</span><br><span class="line">c: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">92</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> d = c.keyBy(_.length)</span><br><span class="line">d: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">93</span>] at keyBy at &lt;console&gt;:<span class="number">25</span></span><br><span class="line"></span><br><span class="line">scala&gt; b.cogroup(d).collect</span><br><span class="line">res1: <span class="type">Array</span>[(<span class="type">Int</span>, (<span class="type">Iterable</span>[<span class="type">String</span>], <span class="type">Iterable</span>[<span class="type">String</span>]))] = <span class="type">Array</span>((<span class="number">2</span>,(<span class="type">CompactBuffer</span>(wc),<span class="type">CompactBuffer</span>(wc, zq))), (<span class="number">3</span>,(<span class="type">CompactBuffer</span>(fjg, xwc, dcp),<span class="type">CompactBuffer</span>(fjg, snn, xwc, dcp))))</span><br><span class="line"></span><br><span class="line">scala&gt; b.join(d).collect</span><br><span class="line">res38: <span class="type">Array</span>[(<span class="type">Int</span>, (<span class="type">String</span>, <span class="type">String</span>))] = <span class="type">Array</span>((<span class="number">2</span>,(wc,wc)), (<span class="number">2</span>,(wc,zq)), (<span class="number">3</span>,(fjg,fjg)), (<span class="number">3</span>,(fjg,snn)), (<span class="number">3</span>,(fjg,xwc)), (<span class="number">3</span>,(fjg,dcp)), (<span class="number">3</span>,(xwc,fjg)), (<span class="number">3</span>,(xwc,snn)), (<span class="number">3</span>,(xwc,xwc)), (<span class="number">3</span>,(xwc,dcp)), (<span class="number">3</span>,(dcp,fjg)), (<span class="number">3</span>,(dcp,snn)), (<span class="number">3</span>,(dcp,xwc)), (<span class="number">3</span>,(dcp,dcp)))</span><br></pre></td></tr></table></figure><p>上面的例子中，cogroup将两个RDD聚集起来，join的操作其实就是在cogroup的基础上做了笛卡尔积。</p><h5 id="23-action算子"><a class="markdownIt-Anchor" href="#23-action算子"></a> 2.3 <strong>Action算子</strong></h5><p>当Spark的计算模型中出现Action算子时才会执行提交作业的runJob动作，这时会触发后续的DAGScheduler和TaskScheduler工作。这里主要讲解常用的Action算子，有collect、reduce、take、top、count、takeSample、saveAsTextFile、countByKey、aggregate，具体方法和定义如下表所示：</p><p align="center">Action算子</p><table><tbody><tr><td><p>Action</p></td><td><p>算子作用</p></td></tr><tr><td><p>reduce(func)</p></td><td><p>令原RDD中的每个&#20540;依次经过函数func，func的类型为(T, T) =&gt; T，返回最终结果</p></td></tr><tr><td><p>collect()</p></td><td><p>将原RDD中的数据打包成数组并返回</p></td></tr><tr><td><p>count()</p></td><td><p>返回原RDD中数据的个数</p></td></tr><tr><td><p>first()</p></td><td><p>返回原RDD中的第一个数据项</p></td></tr><tr><td><p>take(n)</p></td><td><p>返回原RDD中前n个数据项，返回结果为数组</p></td></tr><tr><td><p>takeSample(withReplacement, num, [seed])</p></td><td><p>对原RDD中的数据进行采样，返回num个数据项</p></td></tr><tr><td><p>saveAsTextFile(path)</p></td><td><p>将原RDD中的数据写入到文本文件当中</p></td></tr><tr><td><p>saveAsSequenceFile(path)(Java and Scala)</p></td><td><p>将原RDD中的数据写入到序列文件当中</p></td></tr><tr><td><p>savaAsObjectFile(path)(Java and Scala)</p></td><td><p>将原RDD中的数据序列化并写入到文件当中。可以通过SparkContext.objectFile()方法加载</p></td></tr><tr><td><p>countByKey()</p></td><td><p>原RDD数据的类型为(K, V)，返回hashMap(K, Int)，用于统计K出现的次数</p></td></tr><tr><td><p>foreach(func)</p></td><td><p>对于原RDD中的每个数据执行函数func，返回数组</p></td></tr></tbody></table><h6 id="231-collect"><a class="markdownIt-Anchor" href="#231-collect"></a> 2.3.1 <strong>collect</strong></h6><p>这个我们已经很熟悉了，上面使用很多次，collect方法的作用是把RDD中的元素以数组的方式返回。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>), <span class="number">2</span>)</span><br><span class="line">c: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">0</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; c.collect</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(a, b, c, d, e, f)</span><br></pre></td></tr></table></figure><h6 id="232-reduce"><a class="markdownIt-Anchor" href="#232-reduce"></a> 2.3.2 <strong>reduce</strong></h6><p>reduce方法使用一个带两个参数的函数把元素进行聚集，返回一个元素结果，注意该函数中的二元操作应该满足交换律和结合律，这样才能在并行系统中正确计算。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">10</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">1</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; a.reduce((a,b)=&gt; a + b)</span><br><span class="line">res1: <span class="type">Int</span> = <span class="number">55</span></span><br></pre></td></tr></table></figure><h6 id="233-take"><a class="markdownIt-Anchor" href="#233-take"></a> 2.3.3 <strong>take</strong></h6><p>take方法会从RDD中取出前n[[1]](file:///C:/Users/admin/Desktop/%E5%86%99%E4%B9%A6/Spark%E4%B9%A6%E7%B1%8D%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9%EF%BC%88%E6%9C%80%E7%BB%88%E7%A8%BF%EF%BC%892015-11-20.docx#_ftn1)个元素。方法是先扫描一个分区并后从分区中得到结果，然后评估得到的结果是否达到取出元素个数，如果没达到则继续从其他分区中扫描获取。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> b = sc.parallelize(<span class="type">List</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>), <span class="number">2</span>)</span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">2</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; b.take(<span class="number">2</span>)</span><br><span class="line">res2: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(a, b)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = sc.parallelize(<span class="number">1</span> to <span class="number">100</span>, <span class="number">5</span>)</span><br><span class="line">b: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">3</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; b.take(<span class="number">30</span>)</span><br><span class="line">res3: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><h6 id="234-top"><a class="markdownIt-Anchor" href="#234-top"></a> 2.3.4 <strong>top</strong></h6><p>top方法会利用隐式排序转换方法（见实现源码中implicit修饰的方法）来获取最大的前n个元素。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> c = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>,<span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>,<span class="number">11</span>,<span class="number">5</span>), <span class="number">3</span>)</span><br><span class="line">c: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">4</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; c.top(<span class="number">3</span>)</span><br><span class="line">res4: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h6 id="235-count"><a class="markdownIt-Anchor" href="#235-count"></a> 2.3.5 <strong>count</strong></h6><p>count方法计算并返回RDD中元素的个数。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> c = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">3</span>, <span class="number">2</span>,<span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>,<span class="number">11</span>,<span class="number">5</span>), <span class="number">2</span>)</span><br><span class="line">c: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">6</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; c.count</span><br><span class="line">res5: <span class="type">Long</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure><h6 id="236-takesample"><a class="markdownIt-Anchor" href="#236-takesample"></a> 2.3.6 <strong>takeSample</strong></h6><p>takeSample方法返回一个固定大小的数组形式的采样子集，此外还把返回的元素顺序随机打乱，方法的三个参数含义依次是否放回数据、返回取样的大小和随机数生成器的种子。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> x = sc.parallelize(<span class="number">1</span> to <span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line">x: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">7</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; x.takeSample(<span class="literal">true</span>, <span class="number">30</span>, <span class="number">1</span>)</span><br><span class="line">res6: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">4</span>, <span class="number">97</span>, <span class="number">99</span>, <span class="number">95</span>, <span class="number">46</span>, <span class="number">86</span>, <span class="number">16</span>, <span class="number">88</span>, <span class="number">55</span>, <span class="number">93</span>, <span class="number">77</span>, <span class="number">10</span>, <span class="number">69</span>, <span class="number">7</span>, <span class="number">48</span>, <span class="number">70</span>, <span class="number">22</span>, <span class="number">4</span>, <span class="number">17</span>, <span class="number">49</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">86</span>, <span class="number">2</span>, <span class="number">48</span>, <span class="number">70</span>, <span class="number">54</span>, <span class="number">41</span>, <span class="number">91</span>)</span><br></pre></td></tr></table></figure><h6 id="237-saveastextfile"><a class="markdownIt-Anchor" href="#237-saveastextfile"></a> 2.3.7 <strong>saveAsTextFile</strong></h6><p>把RDD存储为文本文件，一次存一行。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">100</span>, <span class="number">3</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">9</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; a.saveAsTextFile(<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure><h6 id="238-countbykey"><a class="markdownIt-Anchor" href="#238-countbykey"></a> 2.3.8 <strong>countByKey</strong></h6><p>类似count方法，不同的是countByKey方法会根据相同的Key计算其对应的Value个数，返回的是map类型的结果。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>((<span class="number">1</span>, <span class="string">"bit"</span>), (<span class="number">2</span>, <span class="string">"xwc"</span>), (<span class="number">2</span>, <span class="string">"fjg"</span>), (<span class="number">3</span>, <span class="string">"wc"</span>),(<span class="number">3</span>, <span class="string">"wc"</span>),(<span class="number">3</span>, <span class="string">"wc"</span>)), <span class="number">2</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">0</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; a.countByKey</span><br><span class="line">res1: scala.collection.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Long</span>] = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">2</span>, <span class="number">1</span> -&gt; <span class="number">1</span>, <span class="number">3</span> -&gt; <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h6 id="239-aggregate"><a class="markdownIt-Anchor" href="#239-aggregate"></a> 2.3.9 <strong>aggregate</strong></h6><p>aggregate方法先将每个分区里面的元素进行聚合，然后用combine函数将每个分区的结果和初始值(zeroValue)进行combine操作。这个函数最终返回的类型不需要和RDD中元素类型一致。</p><p>aggregate有两个函数seqOp和combOp，这两个函数都是输入两个参数，输出一个参数，其中seqOp函数可以看成是reduce操作，combOp函数可以看成是第二个reduce操作（一般用于combine各分区结果到一个总体结果），由定义，combOp操作的输入和输出类型必须一致。</p><p>先看一下函数定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](zeroValue: <span class="type">U</span>)(seqOp: (<span class="type">U</span>, <span class="type">T</span>) =&gt; <span class="type">U</span>, combOp: (<span class="type">U</span>, <span class="type">U</span>) =&gt; <span class="type">U</span>): <span class="type">U</span> = withScope &#123;</span><br><span class="line">    <span class="comment">// Clone the zero value since we will also be serializing it as part of tasks</span></span><br><span class="line">    <span class="keyword">var</span> jobResult = <span class="type">Utils</span>.clone(zeroValue, sc.env.serializer.newInstance())</span><br><span class="line">    <span class="keyword">val</span> cleanSeqOp = sc.clean(seqOp)</span><br><span class="line">    <span class="keyword">val</span> cleanCombOp = sc.clean(combOp)</span><br><span class="line">    <span class="keyword">val</span> aggregatePartition = (it: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; it.aggregate(zeroValue)(cleanSeqOp, cleanCombOp)</span><br><span class="line">    <span class="keyword">val</span> mergeResult = (index: <span class="type">Int</span>, taskResult: <span class="type">U</span>) =&gt; jobResult = combOp(jobResult, taskResult)</span><br><span class="line">    sc.runJob(<span class="keyword">this</span>, aggregatePartition, mergeResult)</span><br><span class="line">    jobResult</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>seqOp函数是处理数据，combOp函数是拿到处理完成的数据做处理。aggregate相当于是传入了两个函数进去了。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 分区0的reduce操作是max(0, 2,3) = 3</span></span><br><span class="line"><span class="comment">// 分区1的reduce操作是max(0, 4,5) = 5</span></span><br><span class="line"><span class="comment">// 分区2的reduce操作是max(0, 6,7) = 7</span></span><br><span class="line"><span class="comment">// 最后的combine操作是0 + 3 + 5 + 7 = 15</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> z = sc.parallelize(<span class="type">List</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>), <span class="number">3</span>)</span><br><span class="line">z: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">3</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt;  z.aggregate(<span class="number">0</span>)((a,b) =&gt; math.max(a, b), (c,d) =&gt; c + d )</span><br><span class="line">res2: <span class="type">Int</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区0的reduce操作是max(3, 2,3) = 3</span></span><br><span class="line"><span class="comment">// 分区1的reduce操作是max(3, 4,5) = 5</span></span><br><span class="line"><span class="comment">// 分区2的reduce操作是max(3, 6,7) = 7</span></span><br><span class="line"><span class="comment">// 最后的combine操作是3 + 3 + 5 + 7 = 18</span></span><br><span class="line">scala&gt;  z.aggregate(<span class="number">3</span>)((a,b) =&gt; math.max(a, b), (c,d) =&gt; c + d )</span><br><span class="line">res4: <span class="type">Int</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> z = sc.parallelize(<span class="type">List</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>),<span class="number">2</span>)</span><br><span class="line">z: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">4</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt;  z.aggregate(<span class="string">""</span>)(_ + _, _+_)</span><br><span class="line">res5: <span class="type">String</span> = defabc</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> z = sc.parallelize(<span class="type">List</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>),<span class="number">2</span>)</span><br><span class="line">z: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">5</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt;  z.aggregate(<span class="string">"x"</span>)(_ + _, _+_)</span><br><span class="line">res6: <span class="type">String</span> = xxabcxdef</span><br></pre></td></tr></table></figure><h6 id="2310-fold"><a class="markdownIt-Anchor" href="#2310-fold"></a> 2.3.10 <strong>fold</strong></h6><p>fold方法与aggregate方法原理类似，区别就是少了一个seqOp方法。fold方法是把每个分区的元素进行聚合，然后调用reduce（op）方法处理。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分区0的reduce操作是0 + 1 + 2 + 3 = 6</span></span><br><span class="line"><span class="comment">// 分区1的reduce操作是0 + 4 + 5 + 6 = 15</span></span><br><span class="line"><span class="comment">// 分区2的reduce操作是0 + 7 + 8 + 9 = 24</span></span><br><span class="line"><span class="comment">// 最后的combine操作是0 + 6 + 15 + 24 = 45</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>), <span class="number">3</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">6</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line">scala&gt; a.fold(<span class="number">0</span>)(_ + _)</span><br><span class="line">res7: <span class="type">Int</span> = <span class="number">45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区0的reduce操作是1 + 1 + 2 + 3 = 7</span></span><br><span class="line"><span class="comment">// 分区1的reduce操作是1 + 4 + 5 + 6 = 16</span></span><br><span class="line"><span class="comment">// 分区2的reduce操作是1 + 7 + 8 + 9 = 25</span></span><br><span class="line"><span class="comment">// 最后的combine操作是1 + 7 + 16 + 25 = 53</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>), <span class="number">3</span>)</span><br><span class="line">a: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">7</span>] at parallelize at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; a.fold(<span class="number">1</span>)(_ + _)</span><br><span class="line">res8: <span class="type">Int</span> = <span class="number">49</span></span><br></pre></td></tr></table></figure><p>这个例子中的使用方式与aggregate方法非常相似，注意zeroValue参与所有分区计算。fold计算是保证每个分区能独立计算，它与aggregate最大的区别是aggregate对不同分区提交的最终结果定义了一个专门的comOp函数来处理，而fold方法是采用一个方法来处理aggregate的两个方法过程。</p><h4 id="3-共享变量"><a class="markdownIt-Anchor" href="#3-共享变量"></a> 3. <strong>共享变量</strong></h4><p>因为在tasks之间读写共享变量会很低效，spark提供两种类型的共享变量类型，即broadcast variables和accumulators。</p><h5 id="31-广播变量"><a class="markdownIt-Anchor" href="#31-广播变量"></a> 3.1 广播变量</h5><p>广播变量（Broadcast variables）允许用户将一个只读变量缓存到每一台机器之上，而不像传统变量一样，拷贝到每一个任务当中，同一台机器上的不同任务可以共享该变量值。如下面例子代码所示，对于变量v，只需要调用SparkContext.broadcast(v)即可得到变量v的广播变量broadcastVar，通过调用broadcastVar的value方法即可取得变量值。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> broadcastVar = sc.broadcast(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">broadcastVar:spark.<span class="type">Broadcast</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = spark.<span class="type">Broadcast</span>(b5c40191-a864<span class="number">-4</span>c7d-b9bf-d87e1a4e787c)</span><br><span class="line">scala&gt; broadcastVar.value</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h5 id="32-累加器"><a class="markdownIt-Anchor" href="#32-累加器"></a> 3.2 <strong>累加器</strong></h5><p>累加器（Accumulators）是另外一种共享变量。累加器变量只能执行加法操作，但其支持并行操作，这意味着不同任务多次对累加器执行加法操作后，加法器最后的值等于所有累加的和。累加器的值只能被驱动程序访问，集群中的任务无法访问该值。</p><p>示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> accum = sc.accumulator(<span class="number">0</span>, <span class="string">"My Accumulator"</span>)</span><br><span class="line">scala&gt; accum.value（）<span class="comment">//(通过这种方法进行读取原始变量值)</span></span><br><span class="line">accum: spark.<span class="type">Accumulator</span>[<span class="type">Int</span>] = <span class="number">0</span></span><br><span class="line">scala&gt; sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)).foreach(x =&gt; accum += x)</span><br><span class="line">res2:<span class="type">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开发人员在编写Spark应用的时候，需要提供一个包含main函数的驱动程序作为程序的入口，开发人员根据自己的需求，在main函数中调用Spark提供的数据操纵接口，利用集群对数据执行并行操作。&lt;/p&gt;
&lt;p&gt;Spark为开发人员提供了两类抽象接口。&lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="spark" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/spark/"/>
    
    
      <category term="spark学习" scheme="http://blog.rickiyang.cn/tags/spark%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>RDD的设计与运行原理</title>
    <link href="http://blog.rickiyang.cn/posts/d422b66e.html"/>
    <id>http://blog.rickiyang.cn/posts/d422b66e.html</id>
    <published>2018-07-16T10:31:11.000Z</published>
    <updated>2018-12-13T02:14:20.612Z</updated>
    
    <content type="html"><![CDATA[<p>Spark的核心是建立在统一的抽象RDD之上，使得Spark的各个组件可以无缝进行集成，在同一个应用程序中完成大数据计算任务 。</p><h4 id="1-rdd设计背景"><a class="markdownIt-Anchor" href="#1-rdd设计背景"></a> 1. RDD设计背景</h4><p>在实际应用中，存在许多迭代式算法（比如机器学习、图算法等）和交互式数据挖掘工具，这些应用场景的共同之处是，不同计算阶段之间会重用中间结果，即一个阶段的输出结果会作为下一个阶段的输入。但是，目前的MapReduce框架都是把中间结果写入到HDFS中，带来了大量的数据复制、磁盘IO和序列化开销。虽然，类似Pregel等图计算框架也是将结果保存在内存当中，但是，这些框架只能支持一些特定的计算模式，并没有提供一种通用的数据抽象。RDD就是为了满足这种需求而出现的，它提供了一个抽象的数据架构，我们不必担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，可以实现管道化，从而避免了中间结果的存储，大大降低了数据复制、磁盘IO和序列化开销。</p><h4 id="2rdd概念"><a class="markdownIt-Anchor" href="#2rdd概念"></a> 2.RDD概念</h4><p>一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个RDD可以分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算。</p><p>RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集来创建RDD，或者通过在其他RDD上执行确定的转换操作（如map、join和groupBy）而创建得到新的RDD。</p><p>RDD提供了一组丰富的操作以支持常见的数据运算，分为“行动”（Action）和“转换”（Transformation）两种类型，前者用于执行计算并指定输出的形式，后者指定RDD之间的相互依赖关系。两类操作的主要区别是：</p><ul><li>转换操作（比如map、filter、groupBy、join等）接受RDD并返回RDD</li><li>行动操作（比如count、collect等）接受RDD但是返回非RDD（即输出一个值或结果）。</li></ul><p>RDD提供的转换接口都非常简单，都是类似map、filter、groupBy、join等粗粒度的数据转换操作，而不是针对某个数据项的细粒度修改。因此，RDD比较适合对于数据集中元素执行相同操作的批处理式应用，而不适合用于需要异步、细粒度状态的应用，比如Web应用系统、增量式的网页爬虫等。正因为这样，这种粗粒度转换接口设计，会使人直觉上认为RDD的功能很受限、不够强大。但是，实际上RDD已经被实践证明可以很好地应用于许多并行计算应用中，可以具备很多现有计算框架（比如MapReduce、SQL、Pregel等）的表达能力，并且可以应用于这些框架处理不了的交互式数据挖掘应用。</p><p>RDD典型的执行过程如下：</p><ol><li>RDD读入外部数据源（或者内存中的集合）进行创建；</li><li>RDD经过一系列的“转换”操作，每一次都会产生不同的RDD，供给下一个“转换”使用；</li><li>最后一个RDD经“行动”操作进行处理，并输出到外部数据源（或者变成Scala集合或标量）。 需要说明的是，RDD采用了惰性调用，即在RDD的执行过程中（如下图1所示），真正的计算发生在RDD的“行动”操作，对于“行动”之前的所有“转换”操作，Spark只是记录下“转换”操作应用的一些基础数据集以及RDD生成的轨迹，即相互之间的依赖关系，而不会触发真正的计算。</li></ol><p><img src="https://i.imgur.com/jztn48J.jpg" alt=""></p><p>例如，在图2中，从输入中逻辑上生成A和C两个RDD，经过一系列“转换”操作，逻辑上生成了F（也是一个RDD），之所以说是逻辑上，是因为这时候计算并没有发生，Spark只是记录了RDD之间的生成和依赖关系。当F要进行输出时，也就是当F进行“行动”操作的时候，Spark才会根据RDD的依赖关系生成DAG，并从起点开始真正的计算。</p><p><img src="https://i.imgur.com/ep5VDRn.jpg" alt=""></p><p>上述这一系列处理称为一个“血缘关系（Lineage）”，即DAG拓扑排序的结果。采用惰性调用，通过血缘关系连接起来的一系列RDD操作就可以实现管道化（pipeline），避免了多次转换操作之间数据同步的等待，而且不用担心有过多的中间数据，因为这些具有血缘关系的操作都管道化了，一个操作得到的结果不需要保存为中间数据，而是直接管道式地流入到下一个操作进行处理。同时，这种通过血缘关系把一系列操作进行管道化连接的设计方式，也使得管道中每次操作的计算变得相对简单，保证了每个操作在处理逻辑上的单一性；相反，在MapReduce的设计中，为了尽可能地减少MapReduce过程，在单个MapReduce中会写入过多复杂的逻辑。</p><h4 id="3rdd之间的依赖关系"><a class="markdownIt-Anchor" href="#3rdd之间的依赖关系"></a> 3.RDD之间的依赖关系</h4><p>RDD中不同的操作会使得不同RDD中的分区会产生不同的依赖。RDD中的依赖关系分为窄依赖（Narrow Dependency）与宽依赖（Wide Dependency）：</p><p>**宽依赖：**父RDD的分区被子RDD的多个分区使用 , 例如 groupByKey、reduceByKey、sortByKey等操作会产生宽依赖，会产生shuffle；</p><p>**窄依赖：**父RDD的每个分区都只被子RDD的一个分区使用  例如map、filter、union等操作会产生窄依赖；</p><p><img src="https://i.imgur.com/kB8zCwT.jpg" alt=""></p><h4 id="4阶段的划分"><a class="markdownIt-Anchor" href="#4阶段的划分"></a> 4.阶段的划分</h4><p>Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分阶段，具体划分方法是：在DAG中进行反向解析，遇到宽依赖就断开，遇到窄依赖就把当前的RDD加入到当前的阶段中；将窄依赖尽量划分在同一个阶段中，可以实现流水线计算 。例如，如图4所示，假设从HDFS中读入数据生成3个不同的RDD（即A、C和E），通过一系列转换操作后再将计算结果保存回HDFS。对DAG进行解析时，在依赖图中进行反向解析，由于从RDD A到RDD B的转换以及从RDD B和F到RDD G的转换，都属于宽依赖，因此，在宽依赖处断开后可以得到三个阶段，即阶段1、阶段2和阶段3。可以看出，在阶段2中，从map到union都是窄依赖，这两步操作可以形成一个流水线操作，比如，分区7通过map操作生成的分区9，可以不用等待分区8到分区9这个转换操作的计算结束，而是继续进行union操作，转换得到分区13，这样流水线执行大大提高了计算的效率。</p><p><img src="https://i.imgur.com/4l4sMDg.jpg" alt=""></p><p>由上述论述可知，把一个DAG图划分成多个“阶段”以后，每个阶段都代表了一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集合。每个任务集合会被提交给任务调度器（TaskScheduler）进行处理，由任务调度器将任务分发给Executor运行。</p><h4 id="5rdd运行过程"><a class="markdownIt-Anchor" href="#5rdd运行过程"></a> 5.RDD运行过程</h4><p>通过上述对RDD概念、依赖关系和阶段划分的介绍，结合之前介绍的Spark运行基本流程，这里再总结一下RDD在Spark架构中的运行过程：</p><p>（1）创建RDD对象；</p><p>（2）SparkContext负责计算RDD之间的依赖关系，构建DAG；</p><p>（3）DAGScheduler负责把DAG图分解成多个阶段，每个阶段中包含了多个任务，每个任务会被任务调度器分发给各个工作节点（Worker Node）上的Executor去执行。</p><p><img src="https://i.imgur.com/GcGMfvx.jpg" alt=""></p><h4 id="6rdd转换操作"><a class="markdownIt-Anchor" href="#6rdd转换操作"></a> 6.RDD转换操作</h4><p>转换（Transformation）操作是由一个RDD转换到另一个新的RDD，例如，map操作在RDD中是一个转换操作，map转换会让RDD中的每一个数据都通过一个指定函数得到一个新的RDD。</p><p>RDD内部可以封装任意类型的数据，但某些操作只能应用在封装键值对类型数据的RDD之上，例如转换操作reduceByKey、groupByKey和countByKey等下表提供了所有转换操作：</p><p align="center">表1：RDD提供的转换操作</p><table border="1" cellspacing="0" cellpadding="0" width="686"><tr><td>    <p>Transformation</p></td><td>    <p>算子作用</p></td></tr><tr><td>    <p>map(func)</p></td><td>    <p>新RDD中的数据由原RDD中的每个数据通过函数func得到</p></td></tr><tr><td>    <p>filter(func)</p></td><td>    <p>新RDD种的数据由原RDD中每个能使函数func返回true&#20540;的数据组成</p></td></tr><tr><td>    <p>flatMap(func)</p></td><td>    <p>类&#20284;于map转换，但func的返回&#20540;是一个Seq对象，Seq中的元素个数可以是0或者多个</p></td></tr><tr><td>    <p>mapPartitions(func)</p></td><td>    <p>类&#20284;于map转换，但func的输入不是一个数据项，则是一个分区，若RDD内数据类型为T，则func必须是Iterator&lt;T&gt; =&gt; Iterator&lt;U&gt;类型</p></td></tr><tr><td>    <p>mapPartitionsWithIndex(func)</p></td><td>    <p>类&#20284;于mapPartitions转换，但func的数据还多了一个分区索引，即func类型是(Int, Iterator&lt;T&gt; =&gt; Iterator&lt;U&gt;)</p></td></tr><tr><td>    <p>sample(withReplacement, fraction, seed)</p></td><td>    <p>对fraction中的数据进行采样，可以选择是否要进行替换，需要提供一个随机数种子</p></td></tr><tr><td>    <p>union(otherDataset)</p></td><td>    <p>新RDD中数据是原RDD与RDD otherDataset中数据的并集</p></td></tr><tr><td>    <p>Intersection(otherDataset)</p></td><td>    <p>新RDD中数据是原RDD与RDD otherDataset中数据的交集</p></td></tr><tr><td>    <p>distinct([numTasks])</p></td><td>    <p>新RDD中数据是原RDD中数据去重的结果</p></td></tr><tr><td>    <p>groupByKey([numTasks])</p></td><td>    <p>原RDD中数据类型为(K, V)对，新RDD中数据类型为(K, Iterator(V))对，即将相同K的所有V放到一个迭代器中</p></td></tr><tr><td>    <p>reduceByKey(func, [numTasks])</p></td><td>    <p>原RDD和新RDD数据的类型都为(K, V)对，让原RDD相同K的所有V依次经过函数func，得到的最终&#20540;作为K的V</p></td></tr><tr><td>    <p>aggregateByKey(zeroValue)(seqOp, combOp, [numTasks])</p></td><td>    <p>原RDD数据的类型为(K, V)，新RDD数据的类型为(K, U)，类&#20284;于groupbyKey函数，但聚合函数由用户指定。键&#20540;对的&#20540;的类型可以与原RDD不同</p></td></tr><tr><td>    <p>sortByKey([ascending], [numTasks])</p></td><td>    <p>原RDD和新RDD数据的类型为(K, V)键&#20540;对，新RDD的数据根据ascending的指定顺序或者逆序排序</p></td></tr><tr><td>    <p>join(otherDataset, [numTasks])</p></td><td>    <p>原RDD数据的类型为(K, V)，otherDataset数据的类型为(K, W)，对于相同的K，返回所有的(K, (V, W))</p></td></tr><tr><td>    <p>cogroup(otherDataset, [numTasks])</p></td><td>    <p>原RDD数据的类型为(K, V)，otherDataset数据的类型为(K, W)，对于相同的K，返回所有的(K, Iterator&lt;V&gt;, Iterator&lt;W&gt;)</p></td></tr><tr><td>    <p>catesian(otherDataset)</p></td><td>    <p>原RDD数据的类型为为T，otherDataset数据的类型为U，返回所有的(T, U)</p></td></tr><tr><td>    <p>pipe(command, [envValue])</p></td><td>    <p>令原RDD中的每个数据以管道的方式依次通过命令command，返回得到的标准输出</p></td></tr><tr><td>    <p>coalesce(numPartitions)</p></td><td>    <p>减少原RDD中分区的数目至指定&#20540;numPartitions</p></td></tr><tr><td>    repartition(numPartitions)</td><td>    修改原RDD中分区的数目至指定&#20540;numPartitions</td></tr></table><h4 id="7rdd动作操作"><a class="markdownIt-Anchor" href="#7rdd动作操作"></a> 7.RDD动作操作</h4><p>相对于转换，动作（Action）操作用于向驱动（Driver）程序返回值或者将值写入到文件当中。例如reduce动作会使用同一个指定函数让RDD中的所有数据做一次聚合，把运算的结果返回。</p><p align="center">表2 RDD动作操作</p><table border="1" cellspacing="0" cellpadding="0" width="746"><tbody><tr><td valign="top"><p align="center">Action</p></td><td valign="top"><p align="center">算子作用</p></td></tr><tr><td><p align="center">reduce(func)</p></td><td valign="top"><p align="left">令原RDD中的每个&#20540;依次经过函数func，func的类型为(T, T) =&gt; T，返回最终结果</p></td></tr><tr><td valign="top"><p align="center">collect()</p></td><td valign="top"><p align="left">将原RDD中的数据打包成数组并返回</p></td></tr><tr><td valign="top"><p align="center">count()</p></td><td valign="top"><p align="left">返回原RDD中数据的个数</p></td></tr><tr><td valign="top"><p align="center">first()</p></td><td valign="top"><p align="left">返回原RDD中的第一个数据项</p></td></tr><tr><td valign="top"><p align="center">take(n)</p></td><td valign="top"><p align="left">返回原RDD中前n个数据项，返回结果为数组</p></td></tr><tr><td valign="top"><p align="center">takeSample(withReplacement, num, [seed])</p></td><td valign="top"><p align="left">对原RDD中的数据进行采样，返回num个数据项</p></td></tr><tr><td valign="top"><p align="center">saveAsTextFile(path)</p></td><td valign="top"><p align="left">将原RDD中的数据写入到文本文件当中</p></td></tr><tr><td valign="top"><p align="center">saveAsSequenceFile(path)(Java and Scala)</p></td><td valign="top"><p align="left">将原RDD中的数据写入到序列文件当中</p></td></tr><tr><td><p align="center">savaAsObjectFile(path)(Java and Scala)</p></td><td valign="top"><p align="left">将原RDD中的数据序列化并写入到文件当中。可以通过SparkContext.objectFile()方法加载</p></td></tr><tr><td valign="top"><p align="center">countByKey()</p></td><td valign="top"><p align="left">原RDD数据的类型为(K, V)，返回hashMap(K, Int)，用于统计K出现的次数</p></td></tr><tr><td valign="top"><p align="center">foreach(func)</p></td><td valign="top"><p align="left">对于原RDD中的每个数据执行函数func，返回数组</p></td></tr></tbody></table><h4 id="8惰性计算"><a class="markdownIt-Anchor" href="#8惰性计算"></a> 8.惰性计算</h4><p>需要注意的是，一个RDD执行转换操作之后，数据的计算是延迟的，新生成的RDD会记录转换的相关信息，包括父RDD的编号、用户指定函数等等，但并不会立即执行计算操作，真正的计算操作过程得等到遇到一个动作操作（Action）才会执行，此外，除非用户指定持久化操作，否则转换过程中产生的中间数据在计算完毕后会被丢弃，即数据是非持久化。即使对同一个RDD执行相同的转换操作，数据同样会被重新计算。</p><p>Spark采取惰性计算机制有其道理所在。例如可以实现通过map方法创建的一个新数据集，然后使用reduce方法，最终只返回 reduce 的结果给driver，而不是整个大的新数据集。</p><h4 id="9rdd持久化"><a class="markdownIt-Anchor" href="#9rdd持久化"></a> 9.RDD持久化</h4><p>惰性计算的缺陷也是明显的：中间数据默认不会保存，每次动作操作都会对数据重复计算，某些计算量比较大的操作可能会影响到系统的运算效率，因此Spark允许将转换过程中手动将某些会被频繁使用的RDD执行持久化操作，持久化后的数据可以被存储在内存、磁盘或者Tachyon当中，这将使得后续的动作(Actions)变得更加迅速（通常快10倍）。</p><p>通过调用RDD提供的cache或persist函数即可实现数据的持久化，persist函数需要指定存储级别（StorageLevel），cache等价于采用默认存储级别的persist函数，Spark提供的存储级别及其含义如表3所示：</p><p align="center">表3 RDD的存储级别</p><table border="1" cellspacing="0" cellpadding="0" width="710"><tbody><tr><td valign="top"><p align="center">存储级别</p></td><td valign="top"><p align="center">含义</p></td></tr><tr><td><p align="center">MEMORY_ONLY</p></td><td valign="top"><p align="left">把RDD以非序列化状态存储在内存中，如果内存空间不够，则有些分区数据会在需要的时候进行计算得到</p></td></tr><tr><td><p align="center">MEMORY_AND_DISK</p></td><td valign="top"><p align="left">把RDD以非序列化存储在内存中，如果内存空间不够，则存储在硬盘中</p></td></tr><tr><td valign="top"><p align="center">&nbsp;</p><p align="center">MEMORY_ONLY_SER</p></td><td valign="top"><p align="left">把RDD以Java对象序列化储存在内存中，序列化后占用空间更小，尤其当使用快速序列化库（如Kyro<span class="exturl" data-url="ZmlsZTovLy9DOi9Vc2Vycy9hZG1pbi9EZXNrdG9wLyVFNSU4NiU5OSVFNCVCOSVBNi9TcGFyayVFNCVCOSVBNiVFNyVCMSU4RCVFNyVBQyVBQyVFNCVCQSU4QyVFNiVBQyVBMSVFNCVCRiVBRSVFNiU5NCVCOSVFRiVCQyU4OCVFNiU5QyU4MCVFNyVCQiU4OCVFNyVBOCVCRiVFRiVCQyU4OTIwMTUtMTEtMjAuZG9jeCNfZnRuMQ==" title="file:///C:/Users/admin/Desktop/%E5%86%99%E4%B9%A6/Spark%E4%B9%A6%E7%B1%8D%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9%EF%BC%88%E6%9C%80%E7%BB%88%E7%A8%BF%EF%BC%892015-11-20.docx#_ftn1">[1]<i class="fa fa-external-link"></i></span>）时效果更好。缺点是读数据要反序列化，会消耗CPU计算资源</p></td></tr><tr><td><p align="center">MEMORY_AND_DISK_SER</p></td><td valign="top"><p align="left">类&#20284;MEMORY_ONLY_SER，区别是当内存不够的时候会把RDD持久化到磁盘中，而不是在需要它们的时候实时计算</p></td></tr><tr><td><p align="center">DISK_ONLY</p></td><td valign="top"><p align="left">只把RDD存储到磁盘中</p></td></tr><tr><td><p align="center">MEMORY_ONLY_2,</p></td><td valign="top"><p align="left">类&#20284;MEMORY_ONLY，不同的是会复制一个副本到另一个集群节点</p></td></tr><tr><td><p align="center">MEMORY_AND_DISK_2, etc.</p></td><td valign="top"><p align="left">类&#20284;MEMORY_AND_DISK，不同的是会复制一个副本到另一个集群节点</p></td></tr><tr><td valign="top"><p align="center">&nbsp;</p><p align="center">OFF_HEAP</p></td><td valign="top"><p align="left">把RDD以序列化形式存储在Tachyon中，与MEMORY_ONLY_SER不同的是，使用OFF-HEAP模式会减少垃圾回收的开销，此外还能让执行器共享内存，这种模式更适应于多并发和对内存要求高的环境</p></td></tr></tbody></table><h4 id="10rdd检查点"><a class="markdownIt-Anchor" href="#10rdd检查点"></a> 10.RDD检查点</h4><p>因为DAG中血统（lineage）如果太长，当重计算的时候开销会很大，故使用检查点机制，将计算过程持久化到磁盘，这样如果出现计算故障的时候就可以在检查点开始重计算，而不需要从头开始。RDD的检查点（Checkpoint）机制类似持久化机制中的persist(StorageLevel.DISK_ONLY)，数据会被存储在磁盘当中，两者最大的区别在于：持久化机制所存储的数据，在驱动程序运行结束之后会被自动清除；检查点机制则会将数据永久存储在磁盘当中，如果不手动删除，数据会一直存在。换句话说，检查点机制存储的数据能够被下一次运行的应用程序所使用。</p><p>检查点的使用与持久化类似，调用RDD的checkpoint方法即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spark的核心是建立在统一的抽象RDD之上，使得Spark的各个组件可以无缝进行集成，在同一个应用程序中完成大数据计算任务 。&lt;/p&gt;
&lt;h4 id=&quot;1-rdd设计背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-rdd设计背景&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="spark" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/spark/"/>
    
    
      <category term="spark学习" scheme="http://blog.rickiyang.cn/tags/spark%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>spark集群环境搭建</title>
    <link href="http://blog.rickiyang.cn/posts/9d4156ed.html"/>
    <id>http://blog.rickiyang.cn/posts/9d4156ed.html</id>
    <published>2018-07-12T05:10:25.000Z</published>
    <updated>2018-12-13T02:14:20.611Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-试验环境"><a class="markdownIt-Anchor" href="#1-试验环境"></a> 1. 试验环境</h4><ul><li>jdk：1.8</li><li>Scala：2.12.6</li><li>hadoop：2.7.3</li><li>Spark：spark-2.3.0-bin-hadoop2.7.tgz</li></ul><h4 id="2系统规划"><a class="markdownIt-Anchor" href="#2系统规划"></a> 2.系统规划</h4><p>3个节点，一个master，2个slave。<br>Master节点服务角色：namenode、SecondNameNodeResourceManager<br>Slave节点服务角色：datanode、NodeManager</p><h4 id="3安装spark前必备"><a class="markdownIt-Anchor" href="#3安装spark前必备"></a> 3.安装Spark前必备：</h4><p>Spark依赖的服务比较多。确保在安装Spark之前已经安装了如下：</p><hr><ul><li>jdk(注意版本)</li><li>Scala</li><li>Hadoop</li></ul><hr><h4 id="4安装"><a class="markdownIt-Anchor" href="#4安装"></a> 4.安装</h4><p>默认已经完成上面程序的安装，直接安装Spark。</p><p>首先将下载的Spark包上传至服务器，并且解压缩。解压缩完毕，配置环境变量：</p><pre><code>#vi /etc/profileexport SPARK_HOME=/usr/local/sparkexport PATH=$SPARK_HOME/bin:$PATH</code></pre><p>使环境变量生效:</p><pre><code>source /etc/profile</code></pre><p>配置完环境变量之后开始配置文件,进入conf文件夹下：</p><pre><code>cp slaves.template slavescp spark-env.sh.template spark-env.sh</code></pre><p>然后准备配置这两个文件：</p><pre><code>vim conf/spark-env.sh</code></pre><p>在最后加入：</p><pre><code>export JAVA_HOME=/usr/java/jdkexport SCALA_HOME=/usr/local/scalaexport HADOOP_HOME=/usr/local/hadoopexport HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoopexport SPARK_MASTER_IP=hadoopmasterexport SPARK_WORKER_MEMORY=1gexport SPARK_WORKER_CORES=2export SPARK_WORKER_INSTANCES=1</code></pre><p>变量说明</p><ul><li>JAVA_HOME：Java安装目录</li><li>SCALA_HOME：Scala安装目录</li><li>HADOOP_HOME：hadoop安装目录</li><li>HADOOP_CONF_DIR：hadoop集群的配置文件的目录</li><li>SPARK_MASTER_IP：spark集群的Master节点的ip地址</li><li>SPARK_WORKER_MEMORY：每个worker节点能够最大分配给exectors的内存大小</li><li>SPARK_WORKER_CORES：每个worker节点所占有的CPU核数目</li><li>SPARK_WORKER_INSTANCES：每台机器上开启的worker节点的数目</li></ul><p>修改slaves文件：</p><pre><code>vim slaves</code></pre><p>删除原来的location，加入两台slaver的机器名：</p><pre><code>hadoopslaver1hadoopslaver2</code></pre><p>以上是在master上配置的，需要将如上配置同步到两台slaver上，使用scp命令：</p><pre><code>scp -r spark hadoop@hadoopslaver1:/usr/localscp -r spark hadoop@hadoopslaver2:/usr/local</code></pre><p>同步文件夹需要加&quot;-r&quot;。</p><p>以上我们就做好了spark的安装配置，下面就可以启动：</p><p>Spark需要用到hadoop的HDFS存储,所以正式使用的时候需要启动hadoop的HDFS：</p><pre><code>start-dfs.sh</code></pre><p>启动Spark：</p><pre><code>sh start-all.sh</code></pre><p><img src="https://i.imgur.com/celOFCL.png" alt=""></p><p>成功打开Spark集群之后可以进入Spark的WebUI界面，可以通过:</p><p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMTMxLjEyODo4MDgwLw==" title="http://192.168.131.128:8080/">http://192.168.131.128:8080/<i class="fa fa-external-link"></i></span></p><p><img src="https://i.imgur.com/85y5qzI.png" alt=""></p><p>打开Spark-shell</p><p>使用命令：</p><pre><code>sh spark-shell</code></pre><p><img src="https://i.imgur.com/EyeW7f0.png" alt=""></p><p>Spark-shell可以查看当前正在执行的任务,可以通过如下端口来访问：</p><p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMTMxLjEyODo0MDQwL2pvYnMv" title="http://192.168.131.128:4040/jobs/">http://192.168.131.128:4040/jobs/<i class="fa fa-external-link"></i></span></p><p><img src="https://i.imgur.com/LjUFsYx.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-试验环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-试验环境&quot;&gt;&lt;/a&gt; 1. 试验环境&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;jdk：1.8&lt;/li&gt;
&lt;li&gt;Scala：2.12.6&lt;/li&gt;
&lt;li&gt;hadoop：2.7.3&lt;/
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="spark" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/spark/"/>
    
    
      <category term="spark学习" scheme="http://blog.rickiyang.cn/tags/spark%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习(九)----hadoop HA环境搭建</title>
    <link href="http://blog.rickiyang.cn/posts/a5e8b95c.html"/>
    <id>http://blog.rickiyang.cn/posts/a5e8b95c.html</id>
    <published>2018-07-09T15:53:26.000Z</published>
    <updated>2018-12-13T02:14:20.611Z</updated>
    
    <content type="html"><![CDATA[<p>我们先回忆一下hadoop在完全分布式环境中运行的基本知识：</p><p>HDFS集群有两类节点以管理者-工作者模式运行：一个namenode和多个datanode。namenode管理文件系统的命名空间，维护着文件系统树以及整棵树内所有的文件和目录，这些信息以两个文件形式永久的存储在本地磁盘上：命令空间镜像(fsimage)和编辑日志文件(edits)。</p><p>namenode也记录着每个文件中的各个块所在的数据节点信息，但它并不永久的保存块的位置信息，因为这些信息在系统启动时由数据节点重建。</p><p>客户端代表用户通过与namenode和datanode交互来访问整个文件系统。客户端提供一个提供文件系统接口来访问数据，因此用户在编程时无需知道namenode和datanode也可以实现相应的操作功能。</p><p>datanode时文件系统的工作节点。他们被客户端或者namenode调度去触发存储或检索数据块，并定期向namenode发送他们所存储的块的列表信息。</p><h4 id="1hadoop-ha和federation"><a class="markdownIt-Anchor" href="#1hadoop-ha和federation"></a> 1.hadoop HA和Federation</h4><p>如果没有namenode，hdfs文件系统将无法使用。如果运行namenode服务的机器被destroy，后果就是文件系统上的所有文件将会成为废数据：因为你根本就不知道如何去重建datanode。基于此对namenode实现容错非常重要，hadoop为此提供了两种机制。</p><h5 id="11-hadoop20之前的单点故障解决方案"><a class="markdownIt-Anchor" href="#11-hadoop20之前的单点故障解决方案"></a> 1.1 hadoop2.0之前的单点故障解决方案</h5><ol><li>secondary namenode（以下简称SNN）。SNN并不是HA，它本身所起的作用是阶段性的合并edits和fsimage以缩短集群启动的时间。因为SNN是在每次checkpoint的时候触发合并，如果namenode宕机SNN肯定会丢失一段时间的数据，这段时间取决于checkpoint的周期。所以这种方式无法保证数据完整性。</li><li>NFS方案(网络文件系统)。设置多个data目录，让namenode在持久化元数据的时候同时同时写入多个目录。这种方案在院里上是可行的。</li></ol><h5 id="12-hadoop20单点故障解决方案"><a class="markdownIt-Anchor" href="#12-hadoop20单点故障解决方案"></a> 1.2 hadoop2.0单点故障解决方案</h5><p>Hadoop官方提供了一种quorum journal manager来实现高可用，在高可用配置下，edit log不再存放在名称节点，而是存放在一个共享存储的地方，这个共享存储由若干Journal Node组成，一般是3个节点(JN小集群)， 每个JN专门用于存放来自NN的编辑日志，编辑日志由活跃状态的名称节点写入。</p><p>要有2个NN节点，二者之中只能有一个处于活跃状态（active），另一个是待命状态（standby），只有active节点才能对外提供读写HDFS服务，也只有active态的NN才能向JN写入编辑日志；standby的名称节点只负责从JN小集群中的JN节点拷贝数据到本地存放。另外，各个datanode也要同时向两个namenode节点报告状态(心跳信息、块信息)。</p><p>一主一从的2个NameNode节点同时和3个JN构成的组保持通信，活跃的NameNode节点负责往JN集群写入编辑日志，待命的NN节点负责观察JN组中的编辑日志,并且把日志拉取到待命节点（接管Secondary NameNode的工作）。再加上两节点各自的fsimage镜像文件，这样一来就能确保两个NN的元数据保持同步。一旦active不可用，standby继续对外提供服。架构分为手动模式和自动模式，其中手动模式是指由管理员通过命令进行主备切换，这通常在服务升级时有用，自动模式可降低运维成本，但存在潜在危险。这两种模式下的架构如下。</p><p>【手动模式】</p><p><img src="https://i.imgur.com/l9NRJaF.png" alt=""></p><p>【自动模式】</p><p><img src="https://i.imgur.com/F3MwdrY.png" alt=""></p><p><span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL2Jyb3dzZS9IREZTLTE2MjM=" title="tu ">图片来源于：HDFS-1623<i class="fa fa-external-link"></i></span></p><p>作者：Sanjay Radia, Suresh Srinivas<br>Yahoo! Inc</p><p>以上两种模式都是基于共享存储系统，active master将信息写入sharedStorage，standby读取信息保持与mastr同步。常用的共享文件系统有zookeeper(被YARN HA采用)，NFS(被HDFS HA采用)，HDFS(被MapReduce HA采用)。</p><p>自动方式中采用了ZKFailoverController，是基于zk实现的切换控制器，主要由两个核心组件构成：ActiveStandByElector和HealthMonitor，中，ActiveStandbyElector负责与zookeeper集群交互，通过尝试获取全局锁，以判断所管理的master进入active还是standby状态；HealthMonitor负责监控各个活动master的状态，以根据它们状态进行状态切换。</p><p>datanode需要同时向两个namenode汇报，这是让standby随时保持集群最新状态的必要步骤。</p><p>隔离机制(Fencing),防止脑裂。脑裂是指在主备切换时，由于切换不彻底或其他原因，导致客户端和Slave误以为出现两个active master，最终使得整个集群处于混乱状态。</p><p>隔离机制一般包括三个方面：</p><ol><li>共享存储fencing：确保只有一个Master往共享存储中写数据。</li><li>客户端fencing：确保只有一个Master可以响应客户端的请求。</li><li>Slave fencing：确保只有一个Master可以向Slave下发命令。</li></ol><p>Hadoop公共库中对外提供了两种fencing实现，分别是sshfence和shellfence（缺省实现），其中sshfence是指通过ssh登陆目标Master节点上，使用命令fuser将进程杀死（通过tcp端口号定位进程pid，该方法比jps命令更准确），shellfence是指执行一个用户事先定义的shell命令（脚本）完成隔离。</p><h5 id="13-hadoop20-里的federation实现"><a class="markdownIt-Anchor" href="#13-hadoop20-里的federation实现"></a> 1.3 hadoop2.0 里的Federation实现</h5><p><img src="https://i.imgur.com/IeAp8SO.png" alt=""></p><p><span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL2Jyb3dzZS9IREZTLTEwNTI=" title="https://issues.apache.org/jira/browse/HDFS-1052">图片来源： HDFS-1052 设计文档<i class="fa fa-external-link"></i></span></p><p>根据文档大致理解他的设计：</p><ol><li>多个namenode共用一个集群里的datanode的资源，每个datanode都可以单独对外提供服务；</li><li>每个namenode都会定义一个存储池，有单独的id，每个datanode都会为所有的存储池提供服服务；</li><li>datanode会按照存储池id向其对应的namenode汇报信息，同时datanode也会向所有namenode汇报本地存储资源可用情况；</li><li>如果需要在客户端方便的访问若干个namende上的资源，可以使用客户端挂载表，把不同的目录映射到不同的namenode上去，但前提是namenode必须存在相应的目录。</li></ol><h4 id="2-搭建我们的-ha-hadoop集群"><a class="markdownIt-Anchor" href="#2-搭建我们的-ha-hadoop集群"></a> 2. 搭建我们的 HA hadoop集群</h4><p>前面我们已经搭建过权完全分布的hadoop集群。HA的搭建引入了JournalNode节点，所以需要修改之前的配置文件，我们先把需要修改的部分贴出来，这次我们的集群规划是：</p><p>zookeeper集群：</p><p>192.168.238.128   hadoopmaster</p><p>192.168.238.129   hadoopslaver1</p><p>192.168.238.130   hadoopslaver2</p><p>hadoop集群：</p><p>192.168.238.128   hadoopmaster   namenodeMaster节点    ResourceManager节点   Journalnode节点</p><p>192.168.238.129   hadoopslaver1  namenodeStandBy节点    ResourceManager节点   Journalnode节点</p><p>192.168.238.130   hadoopslaver2  datanode节点   nodemanager1</p><p>192.168.238.131   hadoopslaver3  datanode节点   nodemanager1</p><p>下面看需要修改的配置文件：</p><p>core-site.xml</p><pre><code>&lt;configuration&gt;&lt;!-- 指定hdfs的nameservice为ns1 --&gt;&lt;property&gt;&lt;name&gt;fs.defaultFS&lt;/name&gt;&lt;value&gt;hdfs://ns1&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定HDFS数据存放路径，默认存放在linux的/tmp目录中 --&gt;&lt;property&gt;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;&lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定zookeeper的地址 --&gt;&lt;property&gt;&lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;&lt;value&gt;hadoopmaster:2181,hadoopslaver1:2181,hadoopslaver2:2181&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>之前配置的value是：hdfs://机器名:9000,现在改为名称服务，会对应到hdfs-site.xml中的配置。</p><p>hdfs-site.xml，配置这个nameservice中有几个namenode：</p><pre><code>&lt;configuration&gt; &lt;!--指定hdfs的nameservice为ns1，需要和core-site.xml中的保持一致 --&gt;&lt;property&gt;&lt;name&gt;dfs.nameservices&lt;/name&gt;&lt;value&gt;ns1&lt;/value&gt;&lt;/property&gt;​&lt;!-- ns1下面有两个NameNode，分别是nn1，nn2 --&gt;&lt;property&gt;&lt;name&gt;dfs.ha.namenodes.ns1&lt;/name&gt;&lt;value&gt;nn1,nn2&lt;/value&gt;&lt;/property&gt;​&lt;!-- nn1的RPC通信地址 --&gt;&lt;property&gt;&lt;name&gt;dfs.namenode.rpc-address.ns1.nn1&lt;/name&gt;&lt;value&gt;hadoopmaster:9000&lt;/value&gt;&lt;/property&gt;​&lt;!-- nn1的http通信地址 --&gt;&lt;property&gt;&lt;name&gt;dfs.namenode.http-address.ns1.nn1&lt;/name&gt;&lt;value&gt;hadoopmaster:50070&lt;/value&gt;&lt;/property&gt;​&lt;!-- nn2的RPC通信地址 --&gt;&lt;property&gt;&lt;name&gt;dfs.namenode.rpc-address.ns1.nn2&lt;/name&gt;&lt;value&gt;hadoopslaver1:9000&lt;/value&gt;&lt;/property&gt;​&lt;!-- nn2的http通信地址 --&gt;&lt;property&gt;&lt;name&gt;dfs.namenode.http-address.ns1.nn2&lt;/name&gt;&lt;value&gt;hadoopslaver1:50070&lt;/value&gt;&lt;/property&gt;​&lt;!-- 指定NameNode的日志在JournalNode上的存放位置 --&gt;&lt;property&gt;&lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;&lt;value&gt;qjournal://hadoopmaster:8485;hadoopslaver1:8485;/ns1&lt;/value&gt;&lt;/property&gt;​&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;&lt;property&gt;&lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;&lt;value&gt;usr/local/hadoop/journal&lt;/value&gt;&lt;/property&gt;​&lt;!-- 开启NameNode失败自动切换 --&gt;&lt;property&gt;&lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;​&lt;!-- 配置失败自动切换实现方式 --&gt;&lt;property&gt;&lt;name&gt;dfs.client.failover.proxy.provider.ns1&lt;/name&gt;&lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;&lt;/property&gt;​&lt;!-- 配置隔离机制方法，多个机制用换行分割，即每个机制暂用一行--&gt;&lt;property&gt;&lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;&lt;value&gt;sshfenceshell(/bin/true)&lt;/value&gt;&lt;/property&gt;        &lt;!-- 使用sshfence隔离机制时需要ssh免登陆 --&gt;&lt;property&gt;&lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;&lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;&lt;/property&gt;        &lt;!-- 配置sshfence隔离机制超时时间 --&gt;&lt;property&gt;&lt;name&gt;dfs.ha.fencing.ssh.connect-timeout&lt;/name&gt;&lt;value&gt;30000&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>mapred-site.xml:</p><pre><code>&lt;configuration&gt;&lt;property&gt;&lt;name&gt;mapreduce.framework.name&lt;/name&gt;&lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>yarn-site.xml:</p><pre><code>&lt;configuration&gt;&lt;!-- 开启RM高可靠 --&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;    &lt;!-- 指定RM的cluster id --&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;&lt;value&gt;yrc&lt;/value&gt;&lt;/property&gt;    &lt;!-- 指定RM的名字 --&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;&lt;value&gt;rm1,rm2&lt;/value&gt;&lt;/property&gt;    &lt;!-- 分别指定RM的地址 --&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;&lt;value&gt;hadoopmaster&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;&lt;value&gt;hadoopslaver1&lt;/value&gt;&lt;/property&gt;    &lt;!-- 指定zk集群地址 --&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;&lt;value&gt;hadoopmaster:2181,hadoopslaver1:2181,hadoopslaver2:2181&lt;/value&gt;&lt;/property&gt;    &lt;property&gt;&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;&lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>将配置好的HA分发到其余机器上。</p><p>下面我们来启动HA集群：</p><ol><li><p>启动zookeeper集群：</p><p>在每一台机器上输入：</p><pre><code> zkServer.sh start</code></pre></li><li><p>启动journalnode:</p><p>在hadoopmaster和hadooslaver1上启动journalnode节点：</p><pre><code> hadoop-daemon.sh start journalnode</code></pre></li><li><p>格式化HDFS和zookeeper：</p><pre><code> 格式化HDFS: hdfs namenode -format</code></pre><p>格式化zookeeper：</p><pre><code> hdfs zkfc -formatZK</code></pre></li></ol><p>以上操作完毕我们就可以启动hadoop 集群了：</p><pre><code>start-all.sh</code></pre><p>在hadoopslaver1上启动resourceManager作为Yarn的备用主节点：</p><pre><code>yarn-daemon.sh start resourcemanager</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们先回忆一下hadoop在完全分布式环境中运行的基本知识：&lt;/p&gt;
&lt;p&gt;HDFS集群有两类节点以管理者-工作者模式运行：一个namenode和多个datanode。namenode管理文件系统的命名空间，维护着文件系统树以及整棵树内所有的文件和目录，这些信息以两个文件形
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hadoop" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hadoop/"/>
    
    
      <category term="hadoop学习" scheme="http://blog.rickiyang.cn/tags/hadoop%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习(八)----mapReduce的工作机制</title>
    <link href="http://blog.rickiyang.cn/posts/de556527.html"/>
    <id>http://blog.rickiyang.cn/posts/de556527.html</id>
    <published>2018-07-06T09:28:37.000Z</published>
    <updated>2018-12-13T02:14:20.610Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们分析了MapReduce的运行过程，对mapReduce的执行流程有了一个大致的了解。那么这一节我们开始看MapReduce的工作机制，顺带实现一下MapReduce编程。</p><h3 id="mapreduce的工作机制"><a class="markdownIt-Anchor" href="#mapreduce的工作机制"></a> MapReduce的工作机制</h3><p>前面我们是从数据流的角度解释了数据从输入到HDFS到mapReduce是如何流向的，那么具体到一个MapReduce作业到底是怎么样的一个运作过程呢。又得祭出这一张经典的图：</p><p><img src="https://i.imgur.com/QooKifr.png" alt=""></p><p>上图大体介绍了MapReduce的执行过程。我们就上面的过程简要介绍一下。</p><p>客户端提交作业到JobTracker，即提交我们实现好了的Mapper、Reducer类，那么job类是如何提交到JobTracker的呢，大致过程如下：</p><p><img src="https://i.imgur.com/PvpI5kg.png" alt=""></p><p>上图中，首先由JobClient的SubJobInternal方法提交作业（<font color="#7FFF00" size="4">步骤1</font>），并且在waitForCompletion方法中调用monitorAndPrintJob方法轮询作业进度，作业进度信息会输出到控制台。</p><p>在JobClient的submitInternal方法中，通过调用JobTracker的getNewJobId方法向JobTracker请求一个作业id（<font color="#7FFF00" size="4">步骤2</font>），然后检查作业输出目录和输入分片是否符合要求，将运行作业所需要的资源包括jar包复制到HDFS下指定的目录（<font color="#7FFF00" size="4">步骤3</font>），通过调用JobTracker的submitJob方法通知JobTracker作业准备执行（&lt;font color=#7FFF00 size=4步骤4）。</p><p>当JobTracker收到其对submitJob方法的调用之后，会将调用交给作业调度器进行调度并初始化，创建一个表示正在运行作业的对象（<font color="#7FFF00" size="4">步骤5</font>）；</p><p>为了给TaskTracker分配任务，必须先从HDFS系统中获得已经计算好的输入分片信息（<font color="#7FFF00" size="4">步骤6</font>）；</p><p>然后为每个分片创建一个Map任务，而创建的Reduce任务的个数由mapred-site.xml文件的mapred.reduce.tasks配置决定，默认是l，可通过setNumReduceTasks方法针对每个作业设置。此时,Map任务和Reduce任务的任务ID 将被指定。</p><p>JobTracker和TaskTracker之间采用push通信模型，即JobTracker不会主动与TaskTracker通信，而是被动等待TaskTasker通过心跳告知JobTracker是否存活以及资源状态等。如果TaskTracker通过心跳信息告知JobTracker已经准备好运行新任务，那么JobTracker将会通过心跳返回值为TaskTracker分配一个任务（<font color="#7FFF00" size="4">步骤7</font>）。</p><p>TaskTracker在接收到启动任务的命令之后，会把作业相关的jar包复制到TaskTracker所在节点的本地目录（<font color="#7FFF00" size="4">步骤8</font>）,由mapred-site.xml文件的mapred.local.dir配置。</p><p>然后TaskTracker会新建一个TaskRunner实例来运行任务，TaskRuner启动一个JVM（<font color="#7FFF00" size="4">步骤9</font>）运行每个任务（<font color="#7FFF00" size="4">步骤10</font>），即每一个任务都是一个单独的容器在执行，任务之间是不会有影响的。</p><p>当JobTracker收到最后一个任务已经完成的通知后，会把作业状态设置为成功。JobClient查询状态时会将作业完成的消息打印在控制台，最后JobTracker会清空作业的工作状态并通知TaskTracker也清空作业的工作状态。</p><h3 id="mapreduce关键类介绍"><a class="markdownIt-Anchor" href="#mapreduce关键类介绍"></a> MapReduce关键类介绍</h3><h4 id="1-writable类"><a class="markdownIt-Anchor" href="#1-writable类"></a> 1 Writable类</h4><p>序列化对于hadoop是必备的操作，从文件中读取数据然后通过序列化转换为&lt;key,value&gt;存储到HDFS中。这一切离不开Writable接口以及其实现类的操作。</p><p><img src="https://i.imgur.com/0SJEbJH.jpg" alt=""></p><p>上面源码中看到Writable只是一个接口，hadoop的序列化操作无非就是上一篇中提到的7种基本数据类型，我们可以随便点开一个：</p><p><img src="https://i.imgur.com/mpxlLUI.jpg" alt=""></p><p>IntWritable实现的是WritableComparable接口，接着看WritableComparable接口：<br><img src="https://i.imgur.com/n51CJBn.jpg" alt=""></p><p>可以看到WritableComparable接口继承了Writable接口，单独作为基本数据类型的实现接口。</p><p>接口中有两个方法：</p><ol><li>write(DataOutput out) 将对象写入DataOutput二进制流</li><li>readFields(DataInput in) 从DataInput二进制流中反序列化</li></ol><p>实际开发过程中也许hadoop提供的Writable不一定能满足我们的需要，那么我们可以自己编写自己的Writable类。从上面的分析可知编写自己的Writable类需要实现WritableComparable接口而不是Writable接口。比如我们想写一个数据类型存储文件的名字和类型作为一对字符串：</p><pre><code>import org.apache.hadoop.io.Text;import org.apache.hadoop.io.WritableComparable;import java.io.DataInput;import java.io.DataOutput;import java.io.IOException;</code></pre><p>​<br>public class FilePair implements WritableComparable<filepair> {<br>private Text fileName;</filepair></p><pre><code>    private Text fileType;    public FilePair(String fileName,String fileType){        set(fileName,fileType);    }    public FilePair(Text fileName,Text fileType){        this.fileName = fileName;        this.fileType = fileType;    }    private void set(String fileName,String fileType){        this.fileName =+- new Text(fileName);        this.fileType = new Text(fileType);    }    public Text getFileName() {        return fileName;    }    public void setFileName(Text fileName) {        this.fileName = fileName;    }    public Text getFileType() {        return fileType;    }    public void setFileType(Text fileType) {        this.fileType = fileType;    }    @Override    public int compareTo(FilePair o) {        return 0;    }    @Override    public void write(DataOutput dataOutput) throws IOException {        fileName.write(dataOutput);        fileType.write(dataOutput);    }    @Override    public void readFields(DataInput dataInput) throws IOException {        fileName.readFields(dataInput);        fileType.readFields(dataInput);    }}</code></pre><p>大致的实现如上代码所示，当然如果你有需要还可以去实现compareTo方法和equals方法。</p><h4 id="2-mapper类和reducer类"><a class="markdownIt-Anchor" href="#2-mapper类和reducer类"></a> 2 Mapper类和Reducer类</h4><p>在MapReduce任务中Mapper类的作用是将任务处理成键值对的形式，即做数据处理然后交给reducer去做计算和归并。</p><p>Mapper类中有 setup、map、cleanup、和run四个方法，setup一般用来进行map的预处理工作；map是主方法，将数据包装我们需要的形式；cleanup则是执行收尾的工作比如关闭文件或者是执行map后的键值对分发；run方法则是提供了依次setup–map–cleanup的执行模板。</p><p>Hadoop 自带了一些Mapper类的实现，如InverseMapper类和TokenCounterMapper 类。InverseMapper类的作用是调换键值对的顺序再原样输出TokenCounterMapper 类的作用和WordCount中的Mapper类的作用是一样的，单词计数，读者可以根据需要选择。如果需要自己编写Mapper 类时，用户需要做的只是继承Mapper 类并实现其中的map 方法即可。</p><p>reducer类承担的任务是实现数据处理逻辑，用法和Mapper类相似就不说。</p><h4 id="3-shuffle"><a class="markdownIt-Anchor" href="#3-shuffle"></a> 3 shuffle</h4><p>前面在写wordCount程序的时候我们只用到了Mapper和Reducer两个过程。Map是映射负责数据的过滤和分发，Reducer是处理，负责数据的计算和合并。简单的逻辑在Map阶段我们就可以完成，但是如果有复杂的逻辑Map阶段是无法支撑的，还记得我们在前面说MapReduce原理的时候画过一个MapReduce过程图：</p><p><img src="https://i.imgur.com/opLh5pp.png" alt=""></p><p>map到reduce之间其实还有一个shuffle阶段。根据进程的阶段我们将shuffle过程分为两个阶段：map shuffle和reduce shuffle。</p><p><img src="https://i.imgur.com/oBGF6QX.png" alt=""></p><p>map阶段将数据初始化处理为键值对，以内存缓冲的方式存到内存并在内存中进行分区，排序后，缓冲区的使用量达到一定比例以后就会开启一个后台线程开始把缓冲区数据写入磁盘，这个写的过程叫做spill。spill的buffer比例默认为0.8，可以通过mapreduce.map.sort.spill.percent配置。在后台线程写入的同时，map继续将输出写入这个环形缓冲，如果缓冲池写满了，map会阻塞直到spill过程完成，而不会覆盖缓冲池中的已有的数据。</p><p>上面说到了将数据进行分区，这个分区的作用是什么呢：即决定将数据交给哪个reduce处理。hadoop处理分区的方法为Partitioner，他是一个抽象类：</p><p><img src="https://i.imgur.com/9XutJuZ.jpg" alt=""></p><p>类里面的方法：getPartition()返回的是分区号。之前在wordCount中我们并没有指定Partitioner，这能说明wordCount就没有做shuffle吗？其实并不是，因为Partitioner提供了两个Partitioner的子类：HashPartitioner和TotalOrderPartitioner，Hadoop默认会使用HashPartitioner类。</p><p><img src="https://i.imgur.com/YvyYm7u.jpg" alt=""></p><p>我们能看到HashPartitioner中的getPartition()第三个参数：numReduceTasks，该参数为Reduce Task的数量允许用户自定义。</p><p>前面我们也提到在MapReduce任务中一共发生了三次排序，上面从环形缓冲区写到磁盘之间做了一次，第二次发生在什么时候呢？</p><p>我们知道如果map任务输出的数据量很大可能会进行好几次spill，相应产生的输出文件也很多会分布在不同的磁盘上，为了给后面的reduce省下工作量，所以在该阶段做了一次merge。因为spill产生的文件分为out文件和index文件，out文件即map数据，index文件即文件位置索引信息。那么每次做合并操作的时候只需要去扫描这些index文件即可以找到out文件，然后一个partition一个partition的进行合并和排序并生成一个最终的out和index文件。</p><p>以上就是map端的suffle，下面说reduce端的suffle。</p><p>reduce任务通过http请求去询问各个Map里面是否有他要的数据，如果map正好是该reduce对应的数据reduce则将改数据拖到内存中等待处理，reduce要去询问每一个map然后把数据拖到内存中，当内存中的Map数据占用空间达到一定程度时开始启动内存中的merge，把内存中的merge输出到磁盘中保存。</p><p>如果内存中放不下map数据的话则直接把map数据写到磁盘上，有一个map就会创建一个文件，当文件的数量达到阈值时开始启动磁盘文件的merge，把这些文件合并输出到一个文件。</p><p>还有第三种情况是有些map的数据量小时在内存中存放，而有些map太大是存放在磁盘里，那么最后reduce任务会对两个部分的数据来一个总的合并。</p><p>当然在合并的过程中也是在做sort，一般reduce任务都是在拖取map数据的时候就开始做sort，这就是mapreduce的第三次排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们分析了MapReduce的运行过程，对mapReduce的执行流程有了一个大致的了解。那么这一节我们开始看MapReduce的工作机制，顺带实现一下MapReduce编程。&lt;/p&gt;
&lt;h3 id=&quot;mapreduce的工作机制&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hadoop" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hadoop/"/>
    
    
      <category term="hadoop学习" scheme="http://blog.rickiyang.cn/tags/hadoop%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习(七)----mapReduce原理以及操作过程</title>
    <link href="http://blog.rickiyang.cn/posts/b8ffaf86.html"/>
    <id>http://blog.rickiyang.cn/posts/b8ffaf86.html</id>
    <published>2018-06-22T11:30:15.000Z</published>
    <updated>2018-12-13T02:14:20.610Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们使用HDFS进行了相关的操作，也了解了HDFS的原理和机制，有了分布式文件系统我们如何去处理文件呢，这就的提到hadoop的第二个组成部分-MapReduce。</p><p>MapReduce充分借鉴了分而治之的思想，将一个数据的处理过程分为Map（映射）和Reduce（处理）两步。那么用户只需要将数据以需要的格式交给reduce函数处理就能轻松实现分布式的计算，很多的工作都由mapReduce框架为我们封装好，大大简化了操作流程。</p><h4 id="1-mapreduce的编程思想"><a class="markdownIt-Anchor" href="#1-mapreduce的编程思想"></a> 1 MapReduce的编程思想</h4><p>MapReduce的设计思路来源于LISP和其他的函数式编程语言中的映射和化简操作。数据操作的最小单位是一个键值对。用户在使用MapReduce编程模型的时候第一步就是要将数据转化为键值对的形式，map函数会以键值对作为输入，经过map函数的处理，产生新的键值对作为中间结果，然后MapReduce计算框架会自动将这些中间结果数据做聚合处理，然后将键相同的数据分发给reduce函数处理。reduce函数以键值对的形式对处理结果进行输出。要用表达式的形式表达的话，大致如下：</p><pre><code>{key1,value1}-----&gt;{key2,List&lt;value2&gt;}-----&gt;{key3,value3}</code></pre><h4 id="2-mapreduce的运行环境"><a class="markdownIt-Anchor" href="#2-mapreduce的运行环境"></a> 2 MapReduce的运行环境</h4><p>与HDFS相同的是，MapReduce计算框也是主从架构。支撑MapReduce计算框架的是JobTracker和TaskTracker两类后台进程。</p><p><img src="https://i.imgur.com/mwXjL3k.png" alt=""></p><h4 id="21-jobtracker"><a class="markdownIt-Anchor" href="#21-jobtracker"></a> 2.1 JobTracker</h4><p>Job Tracker 在集群中扮演了主的角色，它主要负责任务调度和集群资源监控这两个功能，但并不参与具体的计算。一个Hadoop 集群只有一个JobTracker ，存在单点故障的可能，所以必须运行在相对可靠的节点上，一JobTracker 出错，将导致集群所有正在运行的任务全部失败。</p><p>与HDFS 的NameNode 和DataNode 相似， TaskTracker 也会通过周期性的心跳向JobTracker汇报当前的健康状况和状态，心跳信息里面包括了自身计算资源的信息、被占用的计算资源的信息和正在运行中的任务的状态信息。JobTracker 则会根据各个TaskTracker 周期性发送过来的心跳信息综合考虑TaskTracker 的资源剩余量、作业优先级、作业提交时间等因素，为TaskTracker分配合适的任务。</p><h5 id="22-tasktracker"><a class="markdownIt-Anchor" href="#22-tasktracker"></a> 2.2 TaskTracker</h5><p>TaskTracker 在集群中扮模了从的角色，它主要负责汇报心跳和执行JobTracker 的命令这两个功能。一个集群可以有多个TaskTracker ，但一个节点只会有一个TaskTracker ， 并且TaskTracker和DataNode 运行在同一个节点之中，这样， 一个节点既是计算节点又是存储节点。TaskTracker会周期性地将各种信息汇报给JobTracker ，而JobTracker 收到心跳信息， 会根据心跳信息和当前作业运行情况为该TaskTracker 下达命令， 主要包括启动任务、提交任务、杀死任务、杀死作业和重新初始化5 种命令。</p><h5 id="23-客户端"><a class="markdownIt-Anchor" href="#23-客户端"></a> 2.3 客户端</h5><p>用户通过客户端提交编写的MapReduce程序给JobTracker。</p><h4 id="3-mapreduce-作业和任务"><a class="markdownIt-Anchor" href="#3-mapreduce-作业和任务"></a> 3 MapReduce 作业和任务</h4><p>Map Reduce 作业（ job ）是用户提交的最小单位， 而Map/Reduce 任务（ task ） 是MapReduce<br>计算的最小单位。当用户向Hadoop 提交一个MapReduce 作业时， JobTracker 的作业分解模块会将其分拆为<br>任务交由各个TaskTracker 执行， 在MapReduce 计算框架中，任务分为两种-Map 任务和Reduce 任务。</p><p><img src="https://i.imgur.com/Q2tKbYe.png" alt=""></p><h4 id="4-mapreduce-的计算资源划分"><a class="markdownIt-Anchor" href="#4-mapreduce-的计算资源划分"></a> 4 MapReduce 的计算资源划分</h4><p>一个MapReduce 作业的计算工作都由TaskTracker 完成。用户向Hadoop 提交作业，Job Tracker 会将该作业拆分为多个任务， 并根据心跳信息交由空闲的TaskTracker 启动。一个Task Tracker 能够启动的任务数量是由TaskTracker 配置的任务槽（ slot ） 决定。槽是Hadoop 的计算资源的表示模型， Hadoop 将各个节点上的多维度资源（ CPU 、内存等）抽象成一维度的槽，这样就将多维度资源分配问题转换成一维度的槽分配的问题。在实际情况中，Map 任务和Reduce任务需要的计算资源不尽相同， Hadoop 又将槽分成Map 槽和Reduce 槽， 并且Map 任务只能使用Map槽， Reduce 任务只能使用Reduce槽。</p><p><img src="https://i.imgur.com/7oXaIPd.png" alt=""></p><p>Hadoop 的资源管理采用了静态资源设置方案，即每个节点配置好Map 槽和Reduce 槽的数量（配置项为mapred-site.xml 的mapred.task:tracker.map.tasks.maximum 和mapred.taskTracker.reduce.tasks.maximum),一旦Hadoop启动后将无法动态更改。</p><h4 id="5-mapreduce-的局限性"><a class="markdownIt-Anchor" href="#5-mapreduce-的局限性"></a> 5 MapReduce 的局限性</h4><ol><li><p>从MapReduce 的特点可以看出MapReduce 的优点非常明显，但是MapReduce 也有其局限性，井不是处理海量数据的普适方法。它的局限性主要体现在以下几点：<br>MapReduce 的执行速度慢。一个普通的MapReduce作业一般在分钟级别完成，复杂的作业或者数据量更大的情况下，也可能花费一小时或者更多，好在离线计算对于时间远没有OLTP那么敏感。所以MapReduce 现在不是，以后也不会是关系型数据库的终结者。MapReduce的慢主要是由于磁盘1/0 , MapReduce 作业通常都是数据密集型作业，大量的中间结果需要写到磁盘上并通过网络进行传输，这耗去了大量的时间。</p></li><li><p>MapReduce过于底层。与SQL相比，MapReduce显得过于底层。对于普通的查询，一般人是不会希望写一个map 函数和reduce函数的。对于习惯于关系型数据库的用户，或者数据分析师来说，编写map 函数和reduce 函数无疑是一件头疼的事情。好在Hive的出现，大大改善了这种状况。</p></li><li><p>不是所有算法都能用MapReduce 实现。这意味着，不是所有算法都能实现并行。例如机器学习的模型训练， 这些算法需要状态共享或者参数间有依赖，且需要集中维护和更新。</p></li></ol><h4 id="6-来一个hello-world"><a class="markdownIt-Anchor" href="#6-来一个hello-world"></a> 6 来一个Hello world</h4><p>本次hello world为word count程序，通过这个小程序来了解一下MapReduce的用法。</p><p>Mapper类：</p><pre><code>import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Mapper;public class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; {    //声时一个IntWritable变量，作计数用，每出现一个key，给其一个value=1的值    IntWritable one = new IntWritable(1);    Text word = new Text();    public void map(Object key, Text value, Context context) throws IOException,InterruptedException {        //Hadoop读入的value是以行为单位的，其key为该行所对应的行号，因为我们要计算每个单词的数目，        //默认以空格作为间隔，故用StringTokenizer辅助做字符串的拆分，也可以用string.split(&quot;&quot;)来作。        StringTokenizer itr = new StringTokenizer(value.toString());        //遍历每一个单词        while(itr.hasMoreTokens()) {            word.set(itr.nextToken());            context.write(word, one);        }    }}</code></pre><p>以上就是Map打散过程。</p><p>上面我们看到有IntWritable这个数据类型，这里的Text相当于jdk中的String IntWritable相当于jdk的int类型，hadoop有8个基本数据类型，它们均实现了WritableComparable接口：</p><table>    <thead>        <tr>            <td>类</td>            <td>描述</td>        </tr>    </thead>    <tbody>        <tr>            <td>BooleanWritable</td>            <td>标准布尔型数值</td>        </tr>        <tr>            <td>ByteWritable</td>            <td>单字节数值</td>        </tr>        <tr>            <td>DoubleWritable</td>            <td>双字节数</td>        </tr>        <tr>            <td>FloatWritable</td>            <td>浮点数</td>        </tr>        <tr>            <td>IntWritable</td>            <td>整型数</td>        </tr>        <tr>            <td>LongWritable</td>            <td>长整型数</td>        </tr>        <tr>            <td>Text</td>            <td>使用UTF8格式存储的文本</td>        </tr>        <tr>            <td>NullWritable</td>            <td>当《key,value》中的key或value为空时使用</td>        </tr>    </tbody></table>   <p>下面接着写reduce类：</p><pre><code>import java.io.IOException;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Reducer;public class MyReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {    IntWritable result = new IntWritable();    public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException,InterruptedException {        int sum = 0;//因为map已经将文本处理为键值对的形式，所以在这里只用取出map中保存的键值        for(IntWritable val:values) {            sum += val.get();        }        result.set(sum);        context.write(key,result);    }}</code></pre><p>下面是主函数：</p><pre><code>import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.GenericOptionsParser;public class WordCount {    public static void main(String[] args) throws Exception {        Configuration conf = new Configuration();        String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();        //判断一下命令行输入路径/输出路径是否齐全，即是否为两个参数        if(otherArgs.length != 2) {            System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);            System.exit(2);        }        //此程序的执行，在hadoop看来是一个Job，故进行初始化job操作        Job job = new Job(conf, &quot;wordcount&quot;);        //可以认为成，此程序要执行WordCount.class这个字节码文件        job.setJarByClass(WordCount.class);        //在这个job中，我用TokenizerMapper这个类的map函数        job.setMapperClass(TokenizerMapper.class);        //在这个job中，我用MyReducer这个类的reduce函数        job.setCombinerClass(MyReducer.class);        job.setReducerClass(MyReducer.class);        //在reduce的输出时，key的输出类型为Text        job.setOutputKeyClass(Text.class);        //在reduce的输出时,value的输出类型为IntWritable        job.setOutputValueClass(IntWritable.class);        //初始化要计算word的文件的路径        FileInputFormat.addInputPath(job, new Path(otherArgs[0]));        //初始化要计算word的文件的之后的结果的输出路径         FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));        //提交job到hadoop上去执行了，意思是指如果这个job真正的执行完了则主函数退出了，若没有真正的执行完就退出了。        System.exit(job.waitForCompletion(true)?0:1);    }}</code></pre><p>工程目录结构如下：</p><p><img src="https://i.imgur.com/hE1Zr6g.jpg" alt=""></p><p>然后就是打jar包，我用的是idea，打包的过程就不表，自己百度一下。我打的jar包名为：hadoop.jar。打完之后将jar包上传至服务器。<br>在你的hadoop服务开启的状态下，输入如下命令：</p><pre><code>#hadoop jar hadoop.jar cn.edu.hust.demo1.WordCount /user/input /user/output</code></pre><p>中间的是主程序的路径，后面第一个路径是你的单词文档的路径，我将单词文档上传到/user/input下，/user/output的路径为输出路径。这个路径在执行上面这个命令之前不能存在，不然会报错。</p><p><img src="https://i.imgur.com/PmalxRc.jpg" alt=""></p><p>执行完等一会之后，如果出现上面的输出表示运行成功。</p><p>下面是输出路径的内容：</p><p><img src="https://i.imgur.com/ZSEvPmD.jpg" alt=""></p><p>我上传的txt 单词文件内容为：</p><pre><code>hello world bighello world xiaomingthe world is beautifulxiaoming is my friend</code></pre><p>运行完程序之后的单词统计结果为：</p><p><img src="https://i.imgur.com/1sLSiIC.jpg" alt=""></p><p>由此我们的单词统计就完成了。</p><p>下面我们借着词频统计来说一下MapReduce的运行过程。</p><h4 id="7-mapreduce的运行过程深入了解"><a class="markdownIt-Anchor" href="#7-mapreduce的运行过程深入了解"></a> 7 MapReduce的运行过程深入了解</h4><p>从前面的WordCount可以看出， 一个MapReduce作业经过了input,map,combine,reduce,output 五个阶段,其中combine阶段并不一定发生， map输出的中间结果被分发到reducer的过程被称为shuffle （数据混洗）。</p><h5 id="71-从输入到输出的状态"><a class="markdownIt-Anchor" href="#71-从输入到输出的状态"></a> 7.1 从输入到输出的状态</h5><p><img src="https://i.imgur.com/dkoF6eI.png" alt=""></p><p>在shuffle阶段还会发生copy（复制）和sort（排序)。<br>在MapReduce 的过程中，一个作业被分成Map和Reduce计算两个阶段，它们分别由两个或者多个Map任务和Reduce任务组成，这个在前面已经说过了。Reduce任务默认会在Map任务数量完成5%后才开始启动。</p><p>Map任务的执行过程可概括为：</p><ol><li><p>首先通过用户指定的Inputformat类（如WordCount中的FilelnputFormat 类）中的getSplits方法和next方法将输入文件切片并解析成键值对作为map函数的输入。</p></li><li><p>然后map函数经过处理之后输出并将中间结果交给指定的Partitioner处理，确保中间结果分发到指定的Reduce任务处理，此时如果用户指定了Combiner，将执行combine操作。</p></li><li><p>最后map函数将中间结果保存到本地。</p></li></ol><p>Reduce 任务的执行过程可概括为：</p><p>首先需要将已经完成的Map任务的中问结果复制到Reduce任务所在的节点，待数据复制完成后，再以key进行排序，通过排序，将所有key相同的数据交给reduce函数处理，处理完成后，结果直接输出到HDFS上。</p><h5 id="72-input过程"><a class="markdownIt-Anchor" href="#72-input过程"></a> 7.2 input过程</h5><p>如果使用HDFS上的文件作为MapReduce的输入（由于用户的数据大部分数据是以文件的<br>形式存储在HDFS上，所以这是最常见的情况）MapReduce计算框架首先会用<br>org.apache.hadoop.mapreduce.InputFormat类的子类FilelnputFormat类将作为输入的HDFS 上的文件切分形成输入分片（InputSplit），每个InputSplit将作为一个Map任务的输入，再将InputSplit解析为键值对。InputSplit的大小和数量对于MapReduce作业的性能有非常大的影响，因此有必要深入了解InputSplit 。</p><p>在List<inputsplit> getSplits(JobContext job)方法中会对JobTracker进行拆分，确定需要多少个taskTracker。</inputsplit></p><p><img src="https://i.imgur.com/EGuET71.jpg" alt=""></p><p>该方法中调用了computeSplitSize(blockSize, minSize, maxSize)方法。用来计算拆分多少个taskTracker。我们看到三个参数：blockSize, minSize, maxSize，</p><p><img src="https://i.imgur.com/UfIts4G.jpg" alt=""></p><ol><li>其中minSize由mapred-site.xml文件中的配置项mapred.min.split.size决定，默认为l;</li><li>maxSize由mapred-site.xml文件中的配置项mapred.max.split.size决定，默认为9223372036854775807;</li><li>而blockSize也是由hdfs-site.xml文件中的配置项dfs.block.size决定，默认为67108864字节(64MB)。</li></ol><p>一般来说， dfs.block.size的大小是确定不变的，所以得到目标InputSplit大小，只需改变mapred.min.split.size和mapred.max.split.size的大小即可。</p><p>对于Map任务来说，处理的单位为一个InputSplit。而InputSplit是一个逻辑概念， InputSplit所包含的数据是仍然是存储在HDFS 的块里面，它们之间的关系如下图所示：</p><p><img src="https://i.imgur.com/3h4xc0A.png" alt=""></p><p>InputSplit 可以不和块对齐，根据前面的公式也可以看出，一个InputSplit的大小可以大于一个块的大小亦可以小于一个块的大小。Hadoop在进行任务调度的时候，会优先考虑本节点的数据，如果本节点没有可处理的数据或者是还需要其他节点的数据， Map 任务所在的节点会从其他节点将数据通过网络传输给自己。当InputSplit的容量大于块的容量，Map任务就必须从其他节点读取一部分数据，这样就不能实现完全数据本地性，所以当使用FileIputFormat实现InputFormat时，应尽量使InputSplit的大小和块的大小相同以提高Map任务计算的数据本地性。</p><h5 id="73-map及中间结果的输出"><a class="markdownIt-Anchor" href="#73-map及中间结果的输出"></a> 7.3 Map及中间结果的输出</h5><p>InputSplit将解析好的键值对交给用户编写的map函数处理，处理后的中间结果会写到本地磁盘上，在刷写磁盘的过程中，还做了partition（分区）和sort（排序）的操作。map 函数产生输出时，并不是简单地刷写磁盘。为了保证I/0 效率，采取了先写到内存的环形缓冲区，并作一次预排序。</p><p><img src="https://i.imgur.com/Z2EubV9.png" alt=""></p><p>每个Map任务都有一个环形内存缓冲区，用于存储map函数的输出。默认情况下，缓冲<br>区的大小是100 MB ，该值可以通过mapred-site.xml文件的io.sort.mb的配置项配置。一旦缓冲区内容达到阀值（由mapred-site.xml文件的io.sort.spill.percent 的值决定，默认为0.80或80%），一个后台线程便会将缓冲区的内容溢写（spill）到磁盘中。在写磁盘的过程中，map函数的输出继续被写到缓冲区，但如果在此期间缓冲区被填满,map会阻塞直到写磁盘过程完成。写磁盘会以轮询的方式写到mapred.local.dir(mapred-site.xml文件的配置项）配置的作业特定目录下。</p><p>在写磁盘之前，线程会根据数据最终要传送到的Reducer把缓冲区的数据划分成（默认是按照键）相应的分区。在每个分区中，后台线程技键进行内排序，此时如果有一个Combiner,它会在排序后的输出上运行。</p><p>如果己经指定Combiner且溢出写次数至少为3时，Combiner就会在输出文件写到磁盘之前运行。如前文所述，Combiner可以多次运行，并不影响输出结果。运行Combiner 的意义在于使map 输出的中间结果更紧凑，使得写到本地磁盘和传给Reducer的数据更少。</p><p>为了提高磁盘I/O 性能，可以考虑压缩map的输出，这样会让写磁盘的速度更快，节约磁盘空间，从而使传送给Reducer的数据量减少。默认情况下，map的输出是不压缩的，但只要将mapred-site.xml文件的配置项mapred.compress.map.output设为true 即可开启压缩功能。使用的压缩库由mapred-site.xml文件的配置项mapred.map.output.compression.codec指定。</p><p>map输出的中间结果存储的格式为IFile,IFile是一种支持行压缩的存储格式。Reducer通过HTTP方式得到输出文件的分区。将map输出的中间结果（map 输出）发送<br>到Reducer的工作线程的数量由mapred-site.xml文件的tasktracker.http.threads 配置项决定，此配置针对每个节点，即每个TaskTracker,而不是每个Map任务，默认是40，可以根据作业大小，集群规模以及节点的计算能力而增大。</p><h5 id="74-shuffle"><a class="markdownIt-Anchor" href="#74-shuffle"></a> 7.4 shuffle</h5><p>shuffle,也叫数据混洗。在某些语境中，代表map函数产生输出到reduce的消化输入的整个过程，上面我们也有一个流程图中看到shuffle是在combine和reduce之间的过程，前面map已经处理完了数据那为什么还要shuffle呢，这就是shuffle的功能：完成数据和合并和排序。</p><p>前面我们说了，Map任务输出的结果位于运行Map任务的TaskTracker所在的节点的本地磁盘上。TaskTracker需要为这些分区文件（map输出）运行Reduce任务。但是 Reduce任务可能需要多个Map 任务的输出作为其特殊的分区文件。每个Map 任务的完成时间可能不同，当只要有一个任务完成，Reduce 任务就开始复制其输出。这就是shuffle中的copy阶段。Reduce任务有少量复制线程，可以井行取得Map 任务的输出，默认值是5个线程，该值可以通过设置mapred-site.xml的mapred.reduce.parallel.copies配置项来改变。</p><p>如果map输出相当小，则会被复制到Reducer所在的TaskTracker的内存的缓冲区中，缓冲区的大小由mapred-site.xml文件中的mapred.job.shuffie.input.buffer.percent配置项指定。否则，<br>map输出将会被复制到磁盘。一旦内存缓冲区达到阀值大小（由mapred-site.xml 文件的<br>mapred.job.shuffle.merge.percent 配置项决定）或缓冲区的文件数达到阀值大小（由<br>mapred-site.xml文件的mapred.inmem.merge.threshold配置项决定）,则合并后溢写到磁盘中。</p><p>随着溢写到磁盘的文件增多，后台线程会将它们合并为更大的、有序的文件，这会为后面的合并节省时间为了合并,压缩的中间结果都将在内存中解压缩。</p><p>复制完所有的map输出，shuffle进入sort阶段。这个阶段将合并map的输出文件，并维持其顺序排序，其实做的是归并排序。排序的过程是循环进行，如果有50个map的输出文件，而合并因子（由mapred-site.xml文件的io.sort.factor配置项决定，默认为10）为10,合并操作将进行5次，每次将10个文件合,并成一个文件,最后会有5个文件，这5个文件由于不满足合并条件（文件数小于合并因子），则不会进行合井，将会直接把这5 个文件交给reduce函数处理。至此，shuffle 阶段完成。</p><p><img src="https://i.imgur.com/7HVBNsi.png" alt=""></p><p>从shuffle的过程可以看出,Map任务处理的是一个InputSplit,而Reduce任务处理的是所有Map任务同一个分区的中间结果。</p><p>reduce阶段操作的实质就是对经过shuffle处理后的文件调用reduce函数处理。由于经过了shuffle的处理，文件都是按键分区且有序，对相同分区的文件调用一次reduce函数处理。与map的中间结果不同的是,reduce的输出一般为HDFS。</p><h5 id="75-sort"><a class="markdownIt-Anchor" href="#75-sort"></a> 7.5 sort</h5><p>上面我们讲到shuffle的过程在合并Map的时候顺带做了排序。其实排序贯穿Map和Reduce的所有任务，在MapReduce任务中一共发生了三次排序：</p><ol><li>当map函数产生输出时，会首先写入内存的环形缓冲区，当达到设定的阀值，在刷写磁盘之前，后台线程会将缓冲区的数据划分为相应的分区。在每个分区中，后台线程按照键的值进行内排序。</li><li>在Map任务完成之前，磁盘上存在多个己经分好区并排好序的、大小和缓冲区一样的溢写文件，这时溢写文件将被合并成一个己分区且己排序的输出文件。由于溢写文件己经经过第一次排序，所以合并文件时只需再做一次排序就可使输出文件整体有序。</li><li>在shuffle阶段，需要将多个Map任务的输出文件合并，由于经过第二次排序，所以合并文件时只需再做一次排序就可使输出文件整体有序。</li></ol><p>在这3次排序中第一次是在内存缓冲区做的内排序，使用的算法是快速排序，第二次排序和第三次排序都是在文件合并阶段发生的，使用的是归并排序。</p><p>至此mapReduce的工作过程我们就说完啦，多看几次好好消化消化吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们使用HDFS进行了相关的操作，也了解了HDFS的原理和机制，有了分布式文件系统我们如何去处理文件呢，这就的提到hadoop的第二个组成部分-MapReduce。&lt;/p&gt;
&lt;p&gt;MapReduce充分借鉴了分而治之的思想，将一个数据的处理过程分为Map（映射）和Red
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hadoop" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hadoop/"/>
    
    
      <category term="hadoop学习" scheme="http://blog.rickiyang.cn/tags/hadoop%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeeper开源客户端Curator</title>
    <link href="http://blog.rickiyang.cn/posts/c934629c.html"/>
    <id>http://blog.rickiyang.cn/posts/c934629c.html</id>
    <published>2018-06-17T14:41:17.000Z</published>
    <updated>2018-12-13T02:18:39.800Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开源zk客户端-curator"><a class="markdownIt-Anchor" href="#开源zk客户端-curator"></a> 开源zk客户端-Curator</h4><p>创建会话：</p><pre><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.131.128:2181&quot;,retryPolicy);</code></pre><p>使用CuratorFrameworkFactory工厂类的静态方法newClient来创建会话。</p><p>在重试策略上， Curator通过一个接口RetryPolicy来让用户实现自定义的重试策略。在RetryPolicy接口中只定义了一个方法：</p><pre><code>boolean allowRetry(int var1, long var2, RetrySleeper var4);</code></pre><p>三个参数分别为：</p><ul><li>baseSleepTimeMs：初始sleep时间</li><li>maxRetries：最大重试次数</li><li>maxSleepMs：最大sleep时间</li></ul><p>ExponentialBackoffRetry的重试策略设计如下：</p><p>给定一个初始sleep时间baseSleepTimeMs，在这个基础上结合重试次数，通过以下公式计算出当前需要sleep的时间：</p><pre><code>当前sleep时间 = baseSleepTimeMs  * Math.max(1,random.nextInt(1 &lt;&lt; (retryCount = 1)))</code></pre><p>可以看出，随着重试次数的增加，计算出的sleep时间会越来越大。如果该sleep时间在maxSleepMs的范围之内，那么就使用该sleep时间，否则使用maxSleepMs。另外，maxRetries参数控制了最大重试次数，以避免无限制的重试。</p><p>另外，newClient方法并没有完成创建客户端的工作，你需要主动调用CuratorFramework的start()方法来完成创建客户端。</p><p>一个完整的创建客户端的例子：</p><pre><code>import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.api.CreateBuilder;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;public class Demo1 {    public static void main(String[] args) {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.131.128:2181&quot;,retryPolicy);        client.start();        CreateBuilder builder = client.create();        try {            builder.withMode(CreateMode.EPHEMERAL).forPath(&quot;/test&quot;,&quot;ceshi&quot;.getBytes());        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>创建一个节点，初始内容为空：</p><p>builder.forPath(&quot;/test&quot;,“ceshi”.getBytes());</p><p>注意，如果没有设置节点属性，那么Curator默认创建的是持久节点，内容默认是空。</p><p>创建一个临时节点，初始内容为空：</p><pre><code>builder.withMode(CreateMode.EPHEMERAL).forPath(&quot;/test&quot;);</code></pre><p>创建一个临时节点，并自动逆归创建父节点：</p><pre><code>builder.creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(&quot;/test&quot;,&quot;ceshi&quot;.getBytes());</code></pre><p>这个接口非常有用，在使用ZooKeeper 的过程中，开发人员经常会碰到<br>NoNodeException异常，其中一个可能的原因就是试图对一个不存在的父节点创建子节点。因此，开发人员不得不在每次创建节点之前，都判断－下该父节点是否存在。在使用Curator之后，通过调用creatingParentsIfNeeded接口，Curator就能够自动地递归创建所有需要的父节点。</p><p><strong>同时要注意的一点是，由于在ZooKeeper中规定了所有非叶子节点必须为持久节点，调用上面这个API之后，只有path参数对应的数据节点是临时节点，其父节点均为持久节点。</strong></p><p>删除节点：</p><p>同样创建和删除操作都是由CuratorFramework接口发出来的。</p><pre><code>client.delete().forPath(&quot;/test/test1&quot;);</code></pre><p>使用上面的方法只能删除叶子节点。</p><p>删除一个节点，并递归删除其所有子节点：</p><pre><code>client.delete().deletingChildrenIfNeeded().forPath(&quot;/test/test1&quot;);</code></pre><p>删除一个节点，强制指定版本进行删除：</p><pre><code>client.delete().withVersion(1).forPath(&quot;/test/test1&quot;);</code></pre><p>删除一个节点，强制保证删除：</p><pre><code>client.delete().guaranteed().forPath(&quot;/test/test1&quot;);</code></pre><p>一个完整的创建节点删除节点的例子：</p><pre><code>import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.api.CreateBuilder;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;public class Demo1 {    public static void main(String[] args) {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.131.128:2181&quot;,retryPolicy);        client.start();        CreateBuilder builder = client.create();        try {            builder.creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(&quot;/test/test1&quot;,&quot;ceshi&quot;.getBytes());            client.delete().guaranteed().forPath(&quot;/test/test1&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p><strong>异步接口：</strong></p><p>Curator中引入了BackgroundCallback接口，用来处理异步接口调用。CreateBuilder提供了一个inBackground()方法可供使用，此接口就是Curator提供的异步调用入口。对应的异步处理接口为BackgroundCallback。此接口指提供了一个processResult的方法，用来处理回调结果。其中processResult的参数event中的getType()包含了各种事件类型，getResultCode()包含了各种响应码。</p><pre><code>import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.api.BackgroundCallback;import org.apache.curator.framework.api.CreateBuilder;import org.apache.curator.framework.api.CuratorEvent;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import java.util.concurrent.Executors;public class Demo2 {    public static void main(String[] args) {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.131.128:2181&quot;,retryPolicy);        client.start();        CreateBuilder builder = client.create();        try {            builder.withMode(CreateMode.PERSISTENT).inBackground(new BackgroundCallback() {                public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                    System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;,code:&quot;                            + event.getResultCode() + &quot;,type:&quot; + event.getType());                }            }, Executors.newFixedThreadPool(10)).forPath(&quot;/test&quot;);</code></pre><p>​<br>builder.withMode(CreateMode.EPHEMERAL).inBackground(new BackgroundCallback() {<br>public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {<br>System.out.println(“当前线程：” + Thread.currentThread().getName() + “,code:”<br>+ event.getResultCode() + “,type:” + event.getType());<br>}<br>}).forPath(&quot;/test1&quot;);</p><p>​<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>}<br>}</p><p><strong>注意:如果自己指定了线程池,那么相应的操作就会在线程池中执行,如果没有指定,那么就会使用Zookeeper的EventThread线程对事件进行串行处理。</strong></p><p><strong>事件监听：</strong></p><p>ZooKeeper原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便，需要开发人员自己反复注册Watcher，比较繁琐。Curator 引入了Cache来实现对ZooKeeper服务端事件的监听。Cache是Curator 中对事件监听的包装，其对事件的监听其实可以近似看作是一个本地缓存视图和远程ZooKeeper视图的对比过程。同时Curator能够自动为开发人员处理反复注册监听，从而大大简化了原生API开发的繁琐过程。Cache分为两类监听类型：节点监听和子节点监听。</p><p>NodeCache：</p><p>NodeCache不仅可以用于监听数据节点的内容变更，也能监听指定节点是否存在。如果原本节点不存在，那么Cache 就会在节点被创建后触发NodeCachelistener。但是，如果该数据节点被删除，那么Curator就无法触发NodeCachelistener了。</p><pre><code>import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.api.BackgroundCallback;import org.apache.curator.framework.api.CreateBuilder;import org.apache.curator.framework.api.CuratorEvent;import org.apache.curator.framework.recipes.cache.NodeCache;import org.apache.curator.framework.recipes.cache.NodeCacheListener;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import java.util.concurrent.Executors;public class Demo2 {    public static void main(String[] args) {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.131.128:2181&quot;,retryPolicy);        client.start();        CreateBuilder builder = client.create();        try {            final NodeCache cache = new NodeCache(client,&quot;/test/test1&quot;,false);            cache.start();            cache.getListenable().addListener(new NodeCacheListener() {                @Override                public void nodeChanged() throws Exception {                    System.out.println(&quot;cache: &quot;+cache.getCurrentData().getData());                }            });            builder.creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(&quot;/test/test1&quot;,&quot;ceshi&quot;.getBytes());            client.setData().forPath(&quot;/test/test1&quot;,&quot;haha&quot;.getBytes());            client.delete().deletingChildrenIfNeeded().forPath(&quot;/test/test1&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>PathChildrenCache:</p><p>PathChildrenCache用于监听指定ZooKeeper数据节点的子节点变化情况。</p><p>当指定节点的子节点发生变化时，就会回调该方法。PathChildrenCacheEvent类中定义了所有的事件类型，主要包括新增子节点(CHILD_ADDED)、子节点数据变更(CHILD_UPDATED)和子节点删除(CHILD_RE问OVED)三类。</p><pre><code>import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.api.BackgroundCallback;import org.apache.curator.framework.api.CreateBuilder;import org.apache.curator.framework.api.CuratorEvent;import org.apache.curator.framework.recipes.cache.*;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import java.util.concurrent.Executors;public class Demo2 {    public static void main(String[] args) {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.131.128:2181&quot;,retryPolicy);        client.start();        CreateBuilder builder = client.create();        try {            final PathChildrenCache cache = new PathChildrenCache(client,&quot;/test&quot;,true);            cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent) throws Exception {                    switch (pathChildrenCacheEvent.getType()){                        case CHILD_ADDED:                            System.out.println(&quot;CHILD_ADDED: &quot;+pathChildrenCacheEvent.getData().getPath());                            break;                        case CHILD_UPDATED:                            System.out.println(&quot;CHILD_UPDATED: &quot;+pathChildrenCacheEvent.getData().getPath());                            break;                        case CONNECTION_SUSPENDED:                            System.out.println(&quot;CONNECTION_SUSPENDED: &quot;+pathChildrenCacheEvent.getData().getPath());                            break;                        case INITIALIZED:                            System.out.println(&quot;INITIALIZED: &quot;+pathChildrenCacheEvent.getData().getPath());                            break;                        case CONNECTION_RECONNECTED:                            System.out.println(&quot;CONNECTION_RECONNECTED: &quot;+pathChildrenCacheEvent.getData().getPath());                            break;                        case CHILD_REMOVED:                            System.out.println(&quot;CHILD_REMOVED: &quot;+pathChildrenCacheEvent.getData().getPath());                            break;                        case CONNECTION_LOST:                            System.out.println(&quot;CONNECTION_LOST: &quot;+pathChildrenCacheEvent.getData().getPath());                            break;                    }                }            });            builder.withMode(CreateMode.PERSISTENT).forPath(&quot;/test&quot;,&quot;ceshi&quot;.getBytes());            builder.withMode(CreateMode.PERSISTENT).forPath(&quot;/test/test1&quot;,&quot;ceshi&quot;.getBytes());            client.setData().forPath(&quot;/test/test1&quot;,&quot;haha&quot;.getBytes());            client.delete().deletingChildrenIfNeeded().forPath(&quot;/test/test1&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h4 id="4-curator应用"><a class="markdownIt-Anchor" href="#4-curator应用"></a> 4. Curator应用</h4><h5 id="41-master选举"><a class="markdownIt-Anchor" href="#41-master选举"></a> 4.1 master选举</h5><p>有这样的场景：在分布式系统中，我们需要从集群中选举出一台机器作为master来分发任务。借助zk我们可以很方便的实现master选举功能。大体思路如下：</p><p>选择一个根节点，例如/master，多台机器同时向该节点创建一个子节点<br>力naster/lock ,利用ZooKeeper的特性，最终只有一台机器能够创建成功，成功的那台机器就作为Master。</p><p>Curator也是基于这个思路，但是它将节点创建、事件监听和自动选举过程进行了封装，开发人员只需要调用简单的API 即可实现Master选举。</p><pre><code>import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.api.BackgroundCallback;import org.apache.curator.framework.api.CreateBuilder;import org.apache.curator.framework.api.CuratorEvent;import org.apache.curator.framework.recipes.cache.*;import org.apache.curator.framework.recipes.leader.LeaderSelector;import org.apache.curator.framework.recipes.leader.LeaderSelectorListener;import org.apache.curator.framework.state.ConnectionState;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Demo2 {    public static void main(String[] args) {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.131.128:2181&quot;,retryPolicy);        client.start();        ExecutorService excutor = Executors.newFixedThreadPool(20);        for(int i = 0;i&lt;4;i++){            excutor.submit(new LeaderSelect(client));        }    }}class LeaderSelect implements Runnable{    private CuratorFramework client;    public LeaderSelect(CuratorFramework client) {        this.client = client;    }    @Override    public void run() {        createLeader();    }    private void createLeader (){        LeaderSelector selector = new LeaderSelector(client, &quot;/test&quot;, new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework curatorFramework) throws Exception {                System.out.println(Thread.currentThread().getName()+&quot; 成为leader&quot;);            }            @Override            public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {            }        });        selector.autoRequeue();        selector.start();    }}</code></pre><p>输出结果：</p><pre><code>Curator-LeaderSelector-2 成为leaderCurator-LeaderSelector-3 成为leaderCurator-LeaderSelector-1 成为leaderCurator-LeaderSelector-0 成为leaderCurator-LeaderSelector-2 成为leaderCurator-LeaderSelector-3 成为leaderCurator-LeaderSelector-1 成为leaderCurator-LeaderSelector-0 成为leaderCurator-LeaderSelector-2 成为leaderCurator-LeaderSelector-3 成为leaderCurator-LeaderSelector-1 成为leaderCurator-LeaderSelector-0 成为leaderCurator-LeaderSelector-2 成为leader...</code></pre><h5 id="42-分布式锁"><a class="markdownIt-Anchor" href="#42-分布式锁"></a> 4.2 分布式锁</h5><p>锁的问题经常会遇到，在分布式环境中更甚。zk实现分布式锁的逻辑是：各个节点同时在某个根节点&quot;Lock&quot;下创建临时顺序子节点：</p><pre><code>/Lock/instance1_00001/Lock/instance2_00002/Lock/instance3_00003...</code></pre><p>然后对比谁的序号最小即谁获得锁。<br>那么Curator也是同理做了封装：InterProcessMutex类提供了分布式锁支持。</p><pre><code>import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.recipes.locks.InterProcessMutex;import org.apache.curator.retry.ExponentialBackoffRetry;import java.text.SimpleDateFormat;import java.util.Date;public class Demo5 {    public static void main(String[] args) {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.131.128:2181&quot;,retryPolicy);        client.start();        final InterProcessMutex lock = new InterProcessMutex(client,&quot;/test/test1&quot;);        for(int i = 0;i&lt;30;i++){            new Thread(new Runnable() {                @Override                public void run() {                    try {                        lock.acquire();                    } catch (Exception e) {                        e.printStackTrace();                    }                    SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss|SSS&quot;);                    String date = format.format(new Date());                    System.out.println(&quot;date is : &quot;+date);                    try {                        lock.release();                    } catch (Exception e) {                        e.printStackTrace();                    }                }            }).start();        }    }}</code></pre><p>结果：</p><pre><code>date is : 2018-05-05 21:40:55|129date is : 2018-05-05 21:40:55|175date is : 2018-05-05 21:40:55|193date is : 2018-05-05 21:40:55|249date is : 2018-05-05 21:40:55|266date is : 2018-05-05 21:40:55|291date is : 2018-05-05 21:40:55|301date is : 2018-05-05 21:40:55|314date is : 2018-05-05 21:40:55|335date is : 2018-05-05 21:40:55|357date is : 2018-05-05 21:40:55|377date is : 2018-05-05 21:40:55|383date is : 2018-05-05 21:40:55|393date is : 2018-05-05 21:40:55|404date is : 2018-05-05 21:40:55|411date is : 2018-05-05 21:40:55|422date is : 2018-05-05 21:40:55|426date is : 2018-05-05 21:40:55|431date is : 2018-05-05 21:40:55|439date is : 2018-05-05 21:40:55|446date is : 2018-05-05 21:40:55|456date is : 2018-05-05 21:40:55|465date is : 2018-05-05 21:40:55|472date is : 2018-05-05 21:40:55|480date is : 2018-05-05 21:40:55|488date is : 2018-05-05 21:40:55|492date is : 2018-05-05 21:40:55|502date is : 2018-05-05 21:40:55|519date is : 2018-05-05 21:40:55|535date is : 2018-05-05 21:40:55|541Process finished with exit code 0</code></pre><h5 id="43-分布式计数器"><a class="markdownIt-Anchor" href="#43-分布式计数器"></a> 4.3 分布式计数器</h5><p>如果有需求是在分布式环境中统计系统访问人数，那么这个时候分布式计数器可以发挥作用。基于zk的分布式计数器实现思路也很简单：</p><p><em>指定一个zk数据节点作为计数器，多个应用实例在分布式锁的控制下，通<br>过更新该数据节点的内容来实现计数功能。</em></p><p>Curator同样将这一系列逻辑封装在了DistributedAtomic开头的类中，从其类名我们可以看出这是一个可以在分布式环境中使用的原子整型。具体使用与java中的Atomic类一样：</p><pre><code>RetryPolicy policy = new RetryNTimes(3,1000);DistributedAtomicLong atomicLong = new DistributedAtomicLong(client,&quot;/test&quot;,policy);try {    atomicLong.increment();} catch (Exception e) {    e.printStackTrace();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;开源zk客户端-curator&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#开源zk客户端-curator&quot;&gt;&lt;/a&gt; 开源zk客户端-Curator&lt;/h4&gt;
&lt;p&gt;创建会话：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RetryPolicy 
      
    
    </summary>
    
      <category term="分布式组件" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    
      <category term="zookeeper" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/zookeeper/"/>
    
    
      <category term="分布式" scheme="http://blog.rickiyang.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeeper应用实践</title>
    <link href="http://blog.rickiyang.cn/posts/4bbefda4.html"/>
    <id>http://blog.rickiyang.cn/posts/4bbefda4.html</id>
    <published>2018-06-14T12:08:15.000Z</published>
    <updated>2018-12-13T02:18:39.788Z</updated>
    
    <content type="html"><![CDATA[<p>zk的应用还是非常广泛的。</p><h4 id="1-分布式锁"><a class="markdownIt-Anchor" href="#1-分布式锁"></a> 1. 分布式锁</h4><p>单机环境下的锁还是很容易去实现的，但是在分布式环境下一切都变得不是那么简单。zk实现分布式锁的原理还简单，因为在分布式环境中的zk节点的变化会被每一台机器watch，有任何变化都会被通知，所以我们可以利用这个机制：</p><ol><li>我们创建一个根节点Lock，在获取锁的时候在该节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在Lock下创建临时顺序节点。<br>. 调用getChildren(&quot;Lock&quot;)来获取Lock下的所有节点，注意此时不用设置任何的Watcher。</li><li>客户端获取到所有子节点的path之后发现如果自己之前所创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己所创的节点并非Lock中最小的说明自己还没获得到锁。</li><li>此时客户端需要找到比自己小的马哥节点，然后对其调用exist()方法，同时对其注册时间监听器。是山猫关注这个节点是否被删除（前面我们说了释放所就会删除节点）。</li><li>当监听到了删除事件，再次判断自己所创建的节点是否是Lock中节点顺序最小的节点，如果是则获取到了锁，如果不是则继续重复以上步骤直到获取到比自己小的节点的删除事件并注册监听。</li></ol><p>大致流程就是上面所说，我们可以画一个流程图来表示：</p><p><img src="https://i.imgur.com/wCQVsKI.jpg" alt=""></p><p>下面写一个测试例子运行一下我们的逻辑：</p><p>DistributedLock：</p><pre><code>import java.io.IOException;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.KeeperException;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.ZooDefs;import org.apache.zookeeper.ZooKeeper;import org.apache.zookeeper.data.Stat;</code></pre><p>​<br>public class DistributedLock implements Lock, Watcher{<br>private ZooKeeper zk;<br>private String root = “/locks”;//根<br>private String lockName;//竞争资源的标志<br>private String waitNode;//等待前一个锁<br>private String myZnode;//当前锁<br>private CountDownLatch latch;//计数器<br>private int sessionTimeout = 30000;<br>private List<exception> exception = new ArrayList<exception>();</exception></exception></p><pre><code>    /**     * 创建分布式锁,使用前请确认config配置的zookeeper服务可用     * @param config 127.0.0.1:2181     * @param lockName 竞争资源标志,lockName中不能包含单词lock     */    public DistributedLock(String config, String lockName){        this.lockName = lockName;        // 创建一个与服务器的连接        try {            zk = new ZooKeeper(config, sessionTimeout, this);            Stat stat = zk.exists(root, false);            if(stat == null){                // 创建根节点                zk.create(root, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);            }        } catch (IOException e) {            exception.add(e);        } catch (KeeperException e) {            exception.add(e);        } catch (InterruptedException e) {            exception.add(e);        }    }    /**     * zookeeper节点的监视器     */    public void process(WatchedEvent event) {        if(this.latch != null) {            this.latch.countDown();        }    }    public void lock() {        if(exception.size() &gt; 0){            throw new LockException(exception.get(0));        }        try {            if(this.tryLock()){                System.out.println(&quot;Thread &quot; + Thread.currentThread().getId() + &quot; &quot; +myZnode + &quot; get lock true&quot;);                return;            }            else{                waitForLock(waitNode, sessionTimeout);//等待锁            }        } catch (KeeperException e) {            throw new LockException(e);        } catch (InterruptedException e) {            throw new LockException(e);        }    }    public boolean tryLock() {        try {            String splitStr = &quot;_lock_&quot;;            if(lockName.contains(splitStr))                throw new LockException(&quot;lockName can not contains \\u000B&quot;);            //创建临时子节点            myZnode = zk.create(root + &quot;/&quot; + lockName + splitStr, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);            System.out.println(myZnode + &quot; is created &quot;);            //取出所有子节点            List&lt;String&gt; subNodes = zk.getChildren(root, false);            //取出所有lockName的锁            List&lt;String&gt; lockObjNodes = new ArrayList&lt;String&gt;();            for (String node : subNodes) {                String _node = node.split(splitStr)[0];                if(_node.equals(lockName)){                    lockObjNodes.add(node);                }            }            Collections.sort(lockObjNodes);            System.out.println(myZnode + &quot;==&quot; + lockObjNodes.get(0));            if(myZnode.equals(root+&quot;/&quot;+lockObjNodes.get(0))){                //如果是最小的节点,则表示取得锁                return true;            }            //如果不是最小的节点，找到比自己小1的节点            String subMyZnode = myZnode.substring(myZnode.lastIndexOf(&quot;/&quot;) + 1);            waitNode = lockObjNodes.get(Collections.binarySearch(lockObjNodes, subMyZnode) - 1);        } catch (KeeperException e) {            throw new LockException(e);        } catch (InterruptedException e) {            throw new LockException(e);        }        return false;    }    public boolean tryLock(long time, TimeUnit unit) {        try {            if(this.tryLock()){                return true;            }            return waitForLock(waitNode,time);        } catch (Exception e) {            e.printStackTrace();        }        return false;    }    private boolean waitForLock(String lower, long waitTime) throws InterruptedException, KeeperException {        Stat stat = zk.exists(root + &quot;/&quot; + lower,true);        //判断比自己小一个数的节点是否存在,如果不存在则无需等待锁,同时注册监听        if(stat != null){            System.out.println(&quot;Thread &quot; + Thread.currentThread().getId() + &quot; waiting for &quot; + root + &quot;/&quot; + lower);            this.latch = new CountDownLatch(1);            this.latch.await(waitTime, TimeUnit.MILLISECONDS);            this.latch = null;        }        return true;    }    public void unlock() {        try {            System.out.println(&quot;unlock &quot; + myZnode);            zk.delete(myZnode,-1);            myZnode = null;            zk.close();        } catch (InterruptedException e) {            e.printStackTrace();        } catch (KeeperException e) {            e.printStackTrace();        }    }    public void lockInterruptibly() throws InterruptedException {        this.lock();    }    public Condition newCondition() {        return null;    }    public class LockException extends RuntimeException {        private static final long serialVersionUID = 1L;        public LockException(String e){            super(e);        }        public LockException(Exception e){            super(e);        }    }}</code></pre><p>这里面的实现逻辑和上面叙述的一样。然后我们创建一个多线程环境的测试：</p><pre><code>import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;import java.util.concurrent.CountDownLatch;import java.util.concurrent.atomic.AtomicInteger;</code></pre><p>​<br>​<br>public class ConcurrentTest {<br>private CountDownLatch startSignal = new CountDownLatch(1);//开始阀门<br>private CountDownLatch doneSignal = null;//结束阀门<br>private CopyOnWriteArrayList<long> list = new CopyOnWriteArrayList<long>();<br>private AtomicInteger err = new AtomicInteger();//原子递增<br>private ConcurrentTask[] task = null;</long></long></p><pre><code>    public ConcurrentTest(ConcurrentTask... task){        this.task = task;        if(task == null){            System.out.println(&quot;task can not null&quot;);            System.exit(1);        }        doneSignal = new CountDownLatch(task.length);        start();    }    /**     * @param args     * @throws ClassNotFoundException     */    private void start(){        //创建线程，并将所有线程等待在阀门处        createThread();        //打开阀门        startSignal.countDown();//递减锁存器的计数，如果计数到达零，则释放所有等待的线程        try {            doneSignal.await();//等待所有线程都执行完毕        } catch (InterruptedException e) {            e.printStackTrace();        }        //计算执行时间        getExeTime();    }    /**     * 初始化所有线程，并在阀门处等待     */    private void createThread() {        long len = doneSignal.getCount();        for (int i = 0; i &lt; len; i++) {            final int j = i;            new Thread(new Runnable(){                public void run() {                    try {                        startSignal.await();//使当前线程在锁存器倒计数至零之前一直等待                        long start = System.currentTimeMillis();                        task[j].run();                        long end = (System.currentTimeMillis() - start);                        list.add(end);                    } catch (Exception e) {                        err.getAndIncrement();//相当于err++                    }                    doneSignal.countDown();                }            }).start();        }    }    /**     * 计算平均响应时间     */    private void getExeTime() {        int size = list.size();        List&lt;Long&gt; _list = new ArrayList&lt;Long&gt;(size);        _list.addAll(list);        Collections.sort(_list);        long min = _list.get(0);        long max = _list.get(size-1);        long sum = 0L;        for (Long t : _list) {            sum += t;        }        long avg = sum/size;        System.out.println(&quot;min: &quot; + min);        System.out.println(&quot;max: &quot; + max);        System.out.println(&quot;avg: &quot; + avg);        System.out.println(&quot;err: &quot; + err.get());    }    public interface ConcurrentTask {        void run();    }}</code></pre><p>接下来写一个测试方法：</p><pre><code>public class ZkTest {    public static void main(String[] args) {        Runnable task1 = new Runnable(){            public void run() {                DistributedLock lock = null;                try {                    lock = new DistributedLock(&quot;192.168.131.128:2181&quot;,&quot;test1&quot;);                    //lock = new DistributedLock(&quot;127.0.0.1:2182&quot;,&quot;test2&quot;);                    lock.lock();                    Thread.sleep(3000);                    System.out.println(&quot;===Thread &quot; + Thread.currentThread().getId() + &quot; running&quot;);                } catch (Exception e) {                    e.printStackTrace();                }                finally {                    if(lock != null)                        lock.unlock();                }            }        };        new Thread(task1).start();        try {            Thread.sleep(1000);        } catch (InterruptedException e1) {            e1.printStackTrace();        }        ConcurrentTest.ConcurrentTask[] tasks = new ConcurrentTest.ConcurrentTask[10];        for(int i=0;i&lt;tasks.length;i++){            ConcurrentTest.ConcurrentTask task3 = new ConcurrentTest.ConcurrentTask(){                public void run() {                    DistributedLock lock = null;                    try {                        lock = new DistributedLock(&quot;192.168.131.130:2181&quot;,&quot;test2&quot;);                        lock.lock();                        System.out.println(&quot;Thread &quot; + Thread.currentThread().getId() + &quot; running&quot;);                    } catch (Exception e) {                        e.printStackTrace();                    }                    finally {                        lock.unlock();                    }                }            };            tasks[i] = task3;        }        new ConcurrentTest(tasks);    }}</code></pre><p>运行结果如下：</p><pre><code>/locks/test1_lock_0000000001 is created /locks/test1_lock_0000000001==test1_lock_0000000001Thread 12 /locks/test1_lock_0000000001 get lock true/locks/test2_lock_0000000002 is created /locks/test2_lock_0000000003 is created /locks/test2_lock_0000000004 is created /locks/test2_lock_0000000005 is created /locks/test2_lock_0000000002==test2_lock_0000000002Thread 18 /locks/test2_lock_0000000002 get lock trueThread 18 runningunlock /locks/test2_lock_0000000002/locks/test2_lock_0000000003==test2_lock_0000000002/locks/test2_lock_0000000004==test2_lock_0000000002/locks/test2_lock_0000000005==test2_lock_0000000002/locks/test2_lock_0000000006 is created Thread 24 waiting for /locks/test2_lock_0000000003Thread 21 runningunlock /locks/test2_lock_0000000003Thread 22 waiting for /locks/test2_lock_0000000004/locks/test2_lock_0000000007 is created /locks/test2_lock_0000000008 is created /locks/test2_lock_0000000009 is created /locks/test2_lock_0000000006==test2_lock_0000000003/locks/test2_lock_0000000010 is created /locks/test2_lock_0000000011 is created /locks/test2_lock_0000000008==test2_lock_0000000004Thread 24 runningunlock /locks/test2_lock_0000000004/locks/test2_lock_0000000007==test2_lock_0000000004/locks/test2_lock_0000000009==test2_lock_0000000004Thread 20 waiting for /locks/test2_lock_0000000005/locks/test2_lock_0000000011==test2_lock_0000000004/locks/test2_lock_0000000010==test2_lock_0000000004Thread 15 waiting for /locks/test2_lock_0000000007Thread 23 waiting for /locks/test2_lock_0000000006Thread 22 runningunlock /locks/test2_lock_0000000005Thread 19 waiting for /locks/test2_lock_0000000008Thread 17 waiting for /locks/test2_lock_0000000010Thread 16 waiting for /locks/test2_lock_0000000009Thread 20 runningunlock /locks/test2_lock_0000000006Thread 23 runningunlock /locks/test2_lock_0000000007Thread 15 runningunlock /locks/test2_lock_0000000008Thread 19 runningunlock /locks/test2_lock_0000000009Thread 16 runningunlock /locks/test2_lock_0000000010Thread 17 runningunlock /locks/test2_lock_0000000011min: 93max: 156avg: 124err: 0===Thread 12 runningunlock /locks/test1_lock_0000000001Process finished with exit code 0</code></pre><p>通过测试例子中：</p><p>第一次的测试只创建了一个节点test1_01,很显然是可以成功获取到锁的。</p><p>下面的测试中创建了10组线程，可以发现他们之间是有锁竞争的。到最后每个线程严格按照节点创建顺序分别都获取到了锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;zk的应用还是非常广泛的。&lt;/p&gt;
&lt;h4 id=&quot;1-分布式锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-分布式锁&quot;&gt;&lt;/a&gt; 1. 分布式锁&lt;/h4&gt;
&lt;p&gt;单机环境下的锁还是很容易去实现的，但是在分布式环境下一切都变得不是那么简单。
      
    
    </summary>
    
      <category term="分布式组件" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    
      <category term="zookeeper" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/zookeeper/"/>
    
    
      <category term="分布式" scheme="http://blog.rickiyang.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper的命令行操作</title>
    <link href="http://blog.rickiyang.cn/posts/590af71f.html"/>
    <id>http://blog.rickiyang.cn/posts/590af71f.html</id>
    <published>2018-06-13T14:31:03.000Z</published>
    <updated>2018-12-13T02:14:20.615Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-zookeeper服务命令"><a class="markdownIt-Anchor" href="#1-zookeeper服务命令"></a> 1、 ZooKeeper服务命令</h4><pre><code>在准备好相应的配置之后，可以直接通过zkServer.sh 这个脚本进行服务的相关操作1. 启动ZK服务:       sh bin/zkServer.sh start2. 查看ZK服务状态:    sh bin/zkServer.sh status3. 停止ZK服务:       sh bin/zkServer.sh stop4. 重启ZK服务:       sh bin/zkServer.sh restart</code></pre><h4 id="2-zk客户端命令"><a class="markdownIt-Anchor" href="#2-zk客户端命令"></a> 2、 zk客户端命令</h4><p>启动客户端：</p><pre><code>./zkCli.sh -server localhost:2181 或者zkCli.sh   连接到本机的zookeeper服务；</code></pre><p>ZooKeeper命令行工具类似于Linux的shell环境，不过功能肯定不及shell啦，但是使用它我们可以简单的对ZooKeeper进行访问，数据创建，数据修改等操作.  使用 <span class="exturl" data-url="aHR0cDovL3prQ2xpLnNo" title="http://zkCli.sh">zkCli.sh<i class="fa fa-external-link"></i></span> -server 127.0.0.1:2181 连接到 ZooKeeper 服务，连接成功后，系统会输出 ZooKeeper 的相关环境以及配置信息。</p><p>命令行工具的一些简单操作如下：</p><pre><code>1. 显示根目录下、文件： ls / 使用 ls 命令来查看当前 ZooKeeper 中所包含的内容2. 创建文件，并设置初始内容： create /zk &quot;test&quot; 创建一个新的 znode节点“ zk ”以及与它关联的字符串3. 获取文件内容： get /zk 确认 znode 是否包含我们所创建的字符串4. 修改文件内容： set /zk &quot;zkbak&quot; 对 zk 所关联的字符串进行设置5. 删除文件： delete /zk 将刚才创建的 znode 删除6. 递归删除一个目录： rms /zk6. 退出客户端： quit7. 帮助命令： help </code></pre><p>我们来进入zk的客户端操作一下：</p><pre><code>初始化只有一个节点[zk: localhost:2181(CONNECTED) 0] ls /[zookeeper]创建一个节点node，值为node1[zk: localhost:2181(CONNECTED) 1] create /node node1Created /node[zk: localhost:2181(CONNECTED) 2] ls /[node, zookeeper]查看新建的节点，还显示了创建时间，修改时间，version,长度，children个数等[zk: localhost:2181(CONNECTED) 3] get /nodenode1cZxid = 0x2ctime = Mon Mar 26 14:50:55 CST 2018mZxid = 0x2mtime = Mon Mar 26 14:50:55 CST 2018pZxid = 0x2cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 5numChildren = 0修改新建节点的值，我们看到dataVersion，修改时间，数据长度的值变了[zk: localhost:2181(CONNECTED) 4] set /node reset_node_valuecZxid = 0x2ctime = Mon Mar 26 14:50:55 CST 2018mZxid = 0x3mtime = Mon Mar 26 14:51:56 CST 2018pZxid = 0x2cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 16numChildren = 0节点的值变为修改后的值[zk: localhost:2181(CONNECTED) 5] get /nodereset_node_valuecZxid = 0x2ctime = Mon Mar 26 14:50:55 CST 2018mZxid = 0x3mtime = Mon Mar 26 14:51:56 CST 2018pZxid = 0x2cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 16numChildren = 0在node节点下创建子节点[zk: localhost:2181(CONNECTED) 6] create /node/sub_node sub_node_valueCreated /node/sub_node[zk: localhost:2181(CONNECTED) 7] ls /node[sub_node]查看父节点，numChildren的值变为1[zk: localhost:2181(CONNECTED) 8] get /nodereset_node_valuecZxid = 0x2ctime = Mon Mar 26 14:50:55 CST 2018mZxid = 0x3mtime = Mon Mar 26 14:51:56 CST 2018pZxid = 0x4cversion = 1dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 16numChildren = 1查看子节点[zk: localhost:2181(CONNECTED) 9] get /node/sub_nodesub_node_valuecZxid = 0x4ctime = Mon Mar 26 14:53:09 CST 2018mZxid = 0x4mtime = Mon Mar 26 14:53:09 CST 2018pZxid = 0x4cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 14numChildren = 0删除节点，发现如果父节点有子节点的话是删不了的[zk: localhost:2181(CONNECTED) 10] delete /nodeNode not empty: /node需要先删除子节点[zk: localhost:2181(CONNECTED) 11] delete /node/sub_node[zk: localhost:2181(CONNECTED) 12] delete /node[zk: localhost:2181(CONNECTED) 13] ls /[zookeeper][zk: localhost:2181(CONNECTED) 14] </code></pre><h4 id="3-zookeeper-常用四字命令"><a class="markdownIt-Anchor" href="#3-zookeeper-常用四字命令"></a> 3、 ZooKeeper 常用四字命令</h4><p>ZooKeeper 支持某些特定的四字命令字母与其的交互。它们大多是查询命令，用来获取 ZooKeeper 服务的当前状态及相关信息。用户在客户端可以通过 telnet 或 nc 向 ZooKeeper 提交相应的命令</p><pre><code>1. 可以通过命令：echo stat|nc 127.0.0.1 2181 来查看哪个节点被选择作为follower或者leader2. 使用echo ruok|nc 127.0.0.1 2181 测试是否启动了该Server，若回复imok表示已经启动。3. echo dump| nc 127.0.0.1 2181 ,列出未经处理的会话和临时节点。4. echo kill | nc 127.0.0.1 2181 ,关掉server5. echo conf | nc 127.0.0.1 2181 ,输出相关服务配置的详细信息。6. echo cons | nc 127.0.0.1 2181 ,列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息。7. echo envi |nc 127.0.0.1 2181 ,输出关于服务环境的详细信息（区别于 conf 命令）。8. echo reqs | nc 127.0.0.1 2181 ,列出未经处理的请求。9. echo wchs | nc 127.0.0.1 2181 ,列出服务器 watch 的详细信息。10. echo wchc | nc 127.0.0.1 2181 ,通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。11. echo wchp | nc 127.0.0.1 2181 ,通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径。 </code></pre><h4 id="4-zookeeper-java-api使用"><a class="markdownIt-Anchor" href="#4-zookeeper-java-api使用"></a> 4、Zookeeper  java API使用</h4><p>创建一个maven工程，加入zookeeper的jar包：</p><pre><code>    &lt;dependency&gt;      &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;      &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;      &lt;version&gt;3.4.6&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>测试代码如下：</p><pre><code>import org.apache.zookeeper.*;import org.apache.zookeeper.data.Stat;import java.io.IOException;import java.util.List;public class Test1 {    private ZooKeeper zk = null;    /**     * 创建ZK连接     * @param connectString     * @param sessionTimeout     */    public void createConnection( String connectString, int sessionTimeout ) {        this.releaseConnection();        try {            zk = new ZooKeeper(connectString,                    sessionTimeout, new Watcher() {                // 监控所有被触发的事件                public void process(WatchedEvent event) {                    // TODO Auto-generated method stub                    System.out.println(&quot;已经触发了&quot; + event.getType() + &quot;事件！&quot;);                }            });        } catch ( IOException e ) {            System.out.println( &quot;连接创建失败，发生 IOException&quot; );            e.printStackTrace();        }    }    /**     * 关闭ZK连接     */    public void releaseConnection() {        if ( zk != null ) {            try {                this.zk.close();            } catch ( InterruptedException e ) {                // ignore                e.printStackTrace();            }        }    }    /**     *  创建节点     * @param path 节点path     * @param data 初始数据内容     * @return     */    public boolean createPath( String path, String data ) {        try {            String node = zk.create( path, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,  CreateMode.PERSISTENT );//临时、永久...节点            System.out.println( &quot;节点创建成功, Path: &quot;                    +  node                    + &quot;, content: &quot; + data );        } catch ( KeeperException e ) {            System.out.println( &quot;节点创建失败，发生KeeperException&quot; );            e.printStackTrace();        } catch ( InterruptedException e ) {            System.out.println( &quot;节点创建失败，发生 InterruptedException&quot; );            e.printStackTrace();        }        return true;    }    /**     * 读取指定节点数据内容     * @param path 节点path     * @return     */    public String readData( String path ) {        try {            String res = new String( zk.getData( path, false, null ) );            System.out.println( &quot;获取数据成功：&quot; + res );            return res;        } catch ( KeeperException e ) {            System.out.println( &quot;读取数据失败，发生KeeperException，path: &quot; + path  );            e.printStackTrace();            return &quot;&quot;;        } catch ( InterruptedException e ) {            System.out.println( &quot;读取数据失败，发生 InterruptedException，path: &quot; + path  );            e.printStackTrace();            return &quot;&quot;;        }    }    /**     * 更新指定节点数据内容     * @param path 节点path     * @param data  数据内容     * @return     */    public boolean writeData( String path, String data ) {        try {            Stat stat = zk.setData( path, data.getBytes(), -1 );//-1表示匹配所有版本            System.out.println( &quot;更新数据成功，path：&quot; + path + &quot;, stat: &quot; + stat);        } catch ( KeeperException e ) {            System.out.println( &quot;更新数据失败，发生KeeperException，path: &quot; + path  );            e.printStackTrace();        } catch ( InterruptedException e ) {            System.out.println( &quot;更新数据失败，发生 InterruptedException，path: &quot; + path  );            e.printStackTrace();        }        return false;    }    /**     * 删除指定节点     * @param path 节点path     */    public void deleteNode( String path ) {        try {            zk.delete( path, -1 );            System.out.println( &quot;删除节点成功，path：&quot; + path );        } catch ( KeeperException e ) {            System.out.println( &quot;删除节点失败，发生KeeperException，path: &quot; + path  );            e.printStackTrace();        } catch ( InterruptedException e ) {            System.out.println( &quot;删除节点失败，发生 InterruptedException，path: &quot; + path  );            e.printStackTrace();        }    }    public List&lt;String&gt; getChildrens(String path ) {        try {            return zk.getChildren(path, true);        } catch ( KeeperException e ) {            System.out.println( &quot;删除节点失败，发生KeeperException，path: &quot; + path  );            e.printStackTrace();            return null;        } catch ( InterruptedException e ) {            System.out.println( &quot;删除节点失败，发生 InterruptedException，path: &quot; + path  );            e.printStackTrace();            return null;        }    }    /**     * @param args     * @throws Exception     */    public static void main(String[] args) throws Exception {        Test1 test = new Test1();        test.createConnection(&quot;192.168.27.130:2181&quot;, 3000);        test.createPath(&quot;/node&quot;, &quot;node2&quot;);        test.readData(&quot;/node&quot;);        test.createPath(&quot;/node/node1&quot;, &quot;node1&quot;);        test.readData(&quot;/node/node1&quot;);        List&lt;String&gt; childrens = test.getChildrens(&quot;/node&quot;);        for (String str :childrens) {            System.out.println(str);        }        test.releaseConnection();    }}</code></pre><p>​<br>执行完main方法之后我们去zk的控制台去看一下是否创建创建成功：</p><pre><code>[zk: localhost:2181(CONNECTED) 14] ls /[node, zookeeper][zk: localhost:2181(CONNECTED) 15] ls /node[node1]</code></pre><p>可以看到已经成功创建了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-zookeeper服务命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-zookeeper服务命令&quot;&gt;&lt;/a&gt; 1、 ZooKeeper服务命令&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;在准备好相应的配置之后，可以直接通过zkServ
      
    
    </summary>
    
      <category term="分布式组件" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    
      <category term="zookeeper" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/zookeeper/"/>
    
    
      <category term="分布式" scheme="http://blog.rickiyang.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习(六)----HDFS的shell操作</title>
    <link href="http://blog.rickiyang.cn/posts/c689ad69.html"/>
    <id>http://blog.rickiyang.cn/posts/c689ad69.html</id>
    <published>2018-06-13T09:20:44.000Z</published>
    <updated>2018-12-13T02:14:20.610Z</updated>
    
    <content type="html"><![CDATA[<p># HDFS的shell操作</p><p>标签（空格分隔）： HDFS</p><hr><h3 id="hdfs所有命令"><a class="markdownIt-Anchor" href="#hdfs所有命令"></a> HDFS所有命令：</h3><pre><code>[uploaduser@rickiyang ~]$ hadoop fsUsage: hadoop fs [generic options]        [-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;]        [-cat [-ignoreCrc] &lt;src&gt; ...]        [-checksum &lt;src&gt; ...]        [-chgrp [-R] GROUP PATH...]        [-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...]        [-chown [-R] [OWNER][:[GROUP]] PATH...]        [-copyFromLocal [-f] [-p] [-l] &lt;localsrc&gt; ... &lt;dst&gt;]        [-copyToLocal [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]        [-count [-q] [-h] &lt;path&gt; ...]        [-cp [-f] [-p | -p[topax]] &lt;src&gt; ... &lt;dst&gt;]        [-createSnapshot &lt;snapshotDir&gt; [&lt;snapshotName&gt;]]        [-deleteSnapshot &lt;snapshotDir&gt; &lt;snapshotName&gt;]        [-df [-h] [&lt;path&gt; ...]]        [-du [-s] [-h] &lt;path&gt; ...]        [-expunge]        [-find &lt;path&gt; ... &lt;expression&gt; ...]        [-get [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]        [-getfacl [-R] &lt;path&gt;]        [-getfattr [-R] {-n name | -d} [-e en] &lt;path&gt;]        [-getmerge [-nl] &lt;src&gt; &lt;localdst&gt;]        [-help [cmd ...]]        [-ls [-d] [-h] [-R] [&lt;path&gt; ...]]        [-mkdir [-p] &lt;path&gt; ...]        [-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;]        [-moveToLocal &lt;src&gt; &lt;localdst&gt;]        [-mv &lt;src&gt; ... &lt;dst&gt;]        [-put [-f] [-p] [-l] &lt;localsrc&gt; ... &lt;dst&gt;]        [-renameSnapshot &lt;snapshotDir&gt; &lt;oldName&gt; &lt;newName&gt;]        [-rm [-f] [-r|-R] [-skipTrash] &lt;src&gt; ...]        [-rmdir [--ignore-fail-on-non-empty] &lt;dir&gt; ...]        [-setfacl [-R] [{-b|-k} {-m|-x &lt;acl_spec&gt;} &lt;path&gt;]|[--set &lt;acl_spec&gt; &lt;path&gt;]]        [-setfattr {-n name [-v value] | -x name} &lt;path&gt;]        [-setrep [-R] [-w] &lt;rep&gt; &lt;path&gt; ...]        [-stat [format] &lt;path&gt; ...]        [-tail [-f] &lt;file&gt;]        [-test -[defsz] &lt;path&gt;]        [-text [-ignoreCrc] &lt;src&gt; ...]        [-touchz &lt;path&gt; ...]        [-truncate [-w] &lt;length&gt; &lt;path&gt; ...]        [-usage [cmd ...]]Generic options supported are-conf &lt;configuration file&gt;     specify an application configuration file-D &lt;property=value&gt;            use value for given property-fs &lt;local|namenode:port&gt;      specify a namenode-jt &lt;local|resourcemanager:port&gt;    specify a ResourceManager-files &lt;comma separated list of files&gt;    specify comma separated files to be copied to the map reduce cluster-libjars &lt;comma separated list of jars&gt;    specify comma separated jar files to include in the classpath.-archives &lt;comma separated list of archives&gt;    specify comma separated archives to be unarchived on the compute machines.The general command line syntax isbin/hadoop command [genericOptions] [commandOptions]</code></pre><p>1&gt; –ls显示当前目录结构（从根路径开始）</p><pre><code>[uploaduser@rickiyang ~]$ hadoop fs -ls /</code></pre><p>2&gt; -R递归显示目录结构</p><pre><code>[uploaduser@rickiyang ~]$ hadoop fs -ls -R /</code></pre><p>3&gt; 创建带内容的文本</p><pre><code>echo &quot;hello world&quot; &gt; test1.txt</code></pre><p>4&gt; 上传文件</p><pre><code>上传并重命名[uploaduser@rickiyang tmp]$ hadoop fs -put t1.txt /tmp/test1.txt上传文件夹[uploaduser@rickiyang tmp]$ hadoop fs -put newPkg /tmp/pkg一次上传多个文件[uploaduser@rickiyang tmp]$ hadoop fs -put /tmp/t1.txt  /tmp/test1.txt覆盖上传,如果根目录同一级有同名的文件则会覆盖，-f 表示强制覆盖[uploaduser@rickiyang tmp]$ hadoop fs -put -f /tmp/test1.txt</code></pre><p>​<br>5&gt; 追加内容到文件末尾</p><pre><code>[uploaduser@rickiyang tmp]$ hadoop fs -appendToFile /tmp/test2.txt/user/uploadser/test1.txt</code></pre><p>6&gt; 查看HDFS某个文件的内容</p><pre><code>[uploaduser@rickiyang tmp]$ hadoop fs -cat /user/uploaduser/test1.txt</code></pre><p>7&gt; 下载文件/目录</p><pre><code>从HDFS到本地文件系统[uploaduser@rickiyang ~]$ hadoop fs -get  /user/uploaduser/test2.txt /tmp/1.txt与get等价的命令是copyToLocal[uploaduser@rickiyang ~]$ hadoop fs -copyToLocal  /user/uploaduser/test2.txt /tmp/1.txt</code></pre><p>其余的命令跟正常的linux命令大同小异，在实践中多多尝试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# HDFS的shell操作&lt;/p&gt;
&lt;p&gt;标签（空格分隔）： HDFS&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;hdfs所有命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hdfs所有命令&quot;&gt;&lt;/a&gt; HDFS所有命令：&lt;/h3&gt;
&lt;pre&gt;&lt;c
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hadoop" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hadoop/"/>
    
    
      <category term="hadoop学习" scheme="http://blog.rickiyang.cn/tags/hadoop%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习(三)----hadoop2.x完全分布式环境搭建</title>
    <link href="http://blog.rickiyang.cn/posts/82777c64.html"/>
    <id>http://blog.rickiyang.cn/posts/82777c64.html</id>
    <published>2018-06-12T14:30:11.000Z</published>
    <updated>2018-12-13T02:14:20.609Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来完成hadoop2.x的完全分布式环境搭建，话说学习本来是一件很快乐的事情，可是一到了搭环境就怎么都让人快乐不起来啊，搭环境的时间比学习的时间还多。都是泪。话不多说，走起。</p><h3 id="1-准备工作"><a class="markdownIt-Anchor" href="#1-准备工作"></a> 1 准备工作</h3><p>开工之前先说一下我们的机器环境：<br>一共是4台主机，主机1,2,3都是从master克隆过来的：</p><table>    <thead>        <tr>            <th>主机名</th>            <th>IP</th>            <th>用户</th>        </tr>    </thead>    <tbody>        <tr>        <td>hadoopmaster</td>        <td>192.168.131.128</td>        <td>hadoop</td>    </tr>    <tr>        <td>hadoopslaver1</td>        <td>192.168.131.130</td>        <td>hadoop</td>    </tr>    <tr>        <td>hadoopslaver2</td>        <td>192.168.131.131</td>        <td>hadoop</td>    </tr>    <tr>        <td>hadoopslaver3</td>        <td>192.168.131.132</td>        <td>hadoop</td>    </tr>    </tbody></table><p>集群组成：</p><ol><li>Namenode：2台</li><li>Datanode：  3台</li><li>Journalnode：3台</li><li>Zookeeper： 3台</li><li>ZKFC：2台</li><li>ResourceManager：2台</li><li>NodeManager：3台</li></ol><p>​</p><table>    <thead>        <tr><th></th>            <th>Namenode</th>            <th>Datanode</th>            <th>Journalnode</th><th>Zookeeper</th><th>ZKFC</th><th>ResourceManager</th><th>NodeManager</th>        </tr>    </thead>    <tbody>        <tr>        <td>hadoopmaster</td>        <td>1</td><td></td><td>1</td><td>1</td><td>1</td><td></td><td></td>    </tr>    <tr>        <td>hadoopslaver1</td><td>1</td><td>1</td><td>1</td><td>1</td>        <td>1</td><td></td><td>1</td>    </tr>    <tr>        <td>hadoopslaver2</td><td></td><td>1</td><td>1</td><td>1</td>        <td></td><td>1</td><td>1</td>    </tr>    <tr>        <td>hadoopslaver3</td>        <td></td><td>1</td><td></td><td></td>        <td></td><td>1</td><td>1</td>    </tr>    </tbody></table><p>首先我们保证做好了如下工作：</p><ul><li>关闭防火墙</li><li>安装jdk</li><li>配置好了环境变量</li></ul><p>本次安装的hadoop版本为2.7.3。</p><h4 id="11-关闭防火墙修改主机名-配置host文件-设置时间同步"><a class="markdownIt-Anchor" href="#11-关闭防火墙修改主机名-配置host文件-设置时间同步"></a> 1.1 关闭防火墙，修改主机名、配置host文件、设置时间同步</h4><h5 id="111-防火墙状态"><a class="markdownIt-Anchor" href="#111-防火墙状态"></a> 1.1.1 防火墙状态</h5><pre><code>查看防火墙是否开启# service iptables status如果开启则使用如下命令关闭# service iptables stop</code></pre><h5 id="112-修改主机名"><a class="markdownIt-Anchor" href="#112-修改主机名"></a> 1.1.2 修改主机名：</h5><p>修改master主机的 /etc/sysconfig/network文件，将HOSTNAME改为master,其余三台主机分别改为对应的主机名。</p><pre><code># vim /etc/sysconfig/network</code></pre><p>​<br>NETWORKING=yes<br>HOSTNAME=hadoopmaster</p><p>其余三台分别改为相应的主机名，现在四台主机的主机名分别是：</p><pre><code>192.168.131.128    hadoopmaster192.168.131.130    hadoopslaver1192.168.131.131    hadoopslaver2192.168.131.132    hadoopslaver3</code></pre><h5 id="113-修改host文件"><a class="markdownIt-Anchor" href="#113-修改host文件"></a> 1.1.3 修改host文件</h5><pre><code># vim /etc/hosts添加如下配置：192.168.131.128    hadoopmaster192.168.131.130    hadoopslaver1192.168.131.131    hadoopslaver2192.168.131.132    hadoopslaver3</code></pre><h5 id="114-删除持久化文件etcudevrulesd70-persistent-netrules-重启虚拟主机使配置生效"><a class="markdownIt-Anchor" href="#114-删除持久化文件etcudevrulesd70-persistent-netrules-重启虚拟主机使配置生效"></a> 1.1.4 删除持久化文件/etc/udev/rules.d/70-persistent-net.rules  ,重启虚拟主机，使配置生效。</h5><pre><code># rm /etc/udev/rules.d/70-persistent-net.rules</code></pre><table><tr><td bgcolor="#ADFF2F"><font color="#FF00FF" size="4">TIPS：</font><br>该文件记录的是当前主机的MAC地址与IP地址的映射关系，因为我们后面三台主机都是通过克隆来的，所以四台主机的MAC地址是一样的。后面我们四台主机通信的时候你却会发现有问题，我们需要删除这个持久化文件，然后重启一下机器，系统会检测该文件，发现不存在会重新生成该文件。</td></tr></table><h5 id="115-4台主机做时间同步"><a class="markdownIt-Anchor" href="#115-4台主机做时间同步"></a> 1.1.5 4台主机做时间同步</h5><pre><code># yum install ntp</code></pre><p>使用ntp工具来同步时间，这里使用的时间服务器的ip是上海交通大学学的NTP服务器地址，其他的地址自行百度：</p><pre><code># ntpdate 202.120.2.101</code></pre><p>需要注意的是，如果执行上面的命令出现如下提示：</p><pre><code>ntpdate[2747]: no server suitable for synchronization found</code></pre><p>首先检查你的防火墙是否关闭，没有的话先关闭，如果关闭了还是不行可以试一下如下方法：</p><p>使用rdate命令来更新服务器时间，</p><pre><code>查看时间服务器的时间:# rdate time-b.nist.gov如果命令不生效请安装rdate，yum install -y rdate设置时间和时间服务器同步:# rdate -s time-b.nist.gov</code></pre><table><tr><td bgcolor="orange"><font color="#FF00FF" size="4">TIPS：</font><br>以上所有操作需要在4台机器上同步执行！！！</td></tr></table><h3 id="2-配置ssh免密"><a class="markdownIt-Anchor" href="#2-配置ssh免密"></a> 2 配置ssh免密</h3><p>如果设置主机master到主机slaver1的免密钥登录，可按如下方式进行：</p><pre><code>在A主机执行  1、# ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa                                -t 密钥类型（rsa 或 dsa）   -P 旧密码 ''代表为空  -f 密钥文件生成后，保存的位置  2、# ssh-copy-id 192.168.131.130 IP是主机slaver1的IP地址，将主机master生成的密钥，拷贝到远程主机对应的账户下  执行过程中，会提示让输入主机slaver1的登录密码 我们可以使用上面的命令设置4台机器互相免密。</code></pre><h3 id="3-安装jdkhadoopzookeeper配置环境变量"><a class="markdownIt-Anchor" href="#3-安装jdkhadoopzookeeper配置环境变量"></a> 3 安装jdk，hadoop，zookeeper，配置环境变量</h3><h4 id="31-配置环境变量"><a class="markdownIt-Anchor" href="#31-配置环境变量"></a> 3.1 配置环境变量</h4><p>这里我用的jdk是1.8，hadoop是2.7，zookeeper是3.4.11.配置环境变量：</p><pre><code># vim /etc/profile环境信息如下：JAVA_HOME=/usr/java/jdkJRE_HOME=/usr/java/jdk/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/jt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATHexport HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbinexport ZOOKEEPER_HOME=/usr/local/zookeeperexport PATH=$PATH:$ZOOKEEPER_HOME/bin</code></pre><p>配置完成以后执行：</p><pre><code># source /etc/profile</code></pre><p>使配置生效。</p><h4 id="32-安装zookeeper"><a class="markdownIt-Anchor" href="#32-安装zookeeper"></a> 3.2 安装zookeeper</h4><table><tr><td bgcolor="orange"><font color="#FF00FF" size="4">注意：</font><br>环境配置中后面有关zookeeper这两行只用在master、slaver1和slaver2中配置，即只在这三台机器中安装zookeeper。</td></tr></table><p>zookeeper解压到/usr/local/zookeeper目录，我们进入目录/usr/local/zookeeper/conf修改文件模板文件：</p><pre><code>mv zoo_sample.cfg zoo.cfg1.首先修改文件中的dataDir，路径是zookeeper的快照存储路径,不要使用默认的路径，重启的话会清空/tmp目录导致数据丢失：dataDir=/usr/local/zookeeper/tmp</code></pre><table><tr><td bgcolor="orange">✔此处注意：tmp目录是我新建的。</td></tr></table><pre><code>2.在文件的最后加入zookeeper节点的配置：server.1=hadoopmaster:2888:3888server.2=hadoopslaver1:2888:3888server.3=hadoopslaver2:2888:3888</code></pre><p>然后我们需要注意的是：上面指定的配置节点server1.2.3是需要我们手动指定，需要在快照目录新建一个文件：myid。</p><pre><code># vim myid</code></pre><p>然后内容为该服务器对应的节点id，本次试验：hadoopmaster对应的是1，hadoopslaver1对应的是2，hadoopslaver2对应的是3.</p><p>上面我们在master中配置完之后需要分别在另外两台也要配置，我们直接复制过去得了：</p><pre><code>scp -r zookeeper hadoopslaver1:/usr/local/zookeeperscp -r zookeeper hadoopslaver2:/usr/local/zookeeper</code></pre><p>然后记得改一下myid，hadoopslaver1的改为2，hadoopslaver2的改为3。</p><p>好了，配置完成，接下来到了激动人心的启动时刻，启动脚本在bin目录下的zkServer.sh文件:</p><pre><code>zkServer.sh start</code></pre><table><tr><td bgcolor="orange"><font color="#FF00FF" size="4">TIPS：</font><br>✔✔注意：三台机器都需要启动啊！！！</td></tr></table><p>查看zookeeper的状态：</p><pre><code>zkServer.sh status</code></pre><p>如果出现如下提示表明启动成功：</p><p><img src="https://i.imgur.com/OByRFXi.jpg" alt=""></p><p>关闭命令：</p><pre><code>zkServer.sh stop</code></pre><h4 id="33-安装hadoop"><a class="markdownIt-Anchor" href="#33-安装hadoop"></a> 3.3 安装hadoop</h4><p>hadoop集群的配置文件主要涉及到以下这几个：</p><pre><code>hadoop-env.shcore-site.xmlhdfs-site.xmlslavesmapred-site.xmlyarn-site.xml</code></pre><p>下面以此对上面的文件进行配置：</p><p>hadoop-env.sh文件，设置jdk的路径：</p><pre><code>export JAVA_HOME=/usr/java/jdk</code></pre><p>core-site.xml文件，在configuration里面添加如下配置：</p><pre><code>&lt;configuration&gt; &lt;property&gt;           &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;!--此处名称需要和hdfs-site.xml中的dfs.nameservice保持一致--&gt;          &lt;value&gt;hdfs://rickiyang&lt;/value&gt;    &lt;/property&gt;      &lt;property&gt;  &lt;!--配置路径--&gt;         &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;                                                                                            &lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt;    &lt;/property&gt;      &lt;property&gt;          &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;            &lt;value&gt;hadoopmaster:2181,hadoopslaver1:2181,hadoopslaver2:2181&lt;/value&gt;       &lt;/property&gt; &lt;/configuration&gt;</code></pre><p>hdfs-site.xml文件：</p><pre><code>&lt;configuration&gt;  &lt;property&gt;      &lt;name&gt;dfs.nameservices&lt;/name&gt; &lt;!--此处名称需与core-site.xml中fs.defaultFS的值保持一致--&gt;     &lt;value&gt;rickiyang&lt;/value&gt;   &lt;/property&gt;  &lt;!--配置namenode的组成 --&gt;  &lt;property&gt;      &lt;name&gt;dfs.ha.namenodes.rickiyang&lt;/name&gt;     &lt;value&gt;nn1,nn2&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;!--配置namenode1的rpc端口   --&gt;    &lt;name&gt;dfs.namenode.rpc-address.rickiyang.nn1&lt;/name&gt;     &lt;value&gt;hadoopmaster:8020&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;!--配置namenode2的rpc端口   --&gt;    &lt;name&gt;dfs.namenode.rpc-address.rickiyang.nn2&lt;/name&gt;     &lt;value&gt;hadoopslaver1:8020&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;       &lt;!--配置namenode1的http端口  --&gt;    &lt;name&gt;dfs.namenode.http-address.rickiyang.nn1&lt;/name&gt;       &lt;value&gt;hadoopmaster:50070&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;       &lt;!--配置namenode2的http端口  --&gt;    &lt;name&gt;dfs.namenode.http-address.rickiyang.nn2&lt;/name&gt;      &lt;value&gt;hadoopslaver1:50070&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;!--配置journalnode集群  --&gt;    &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;      &lt;value&gt;qjournal://hadoopmaster:8485;hadoopslaver1:8485;hadoopslaver2:8485/rickiyang&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;       &lt;!--配置后台类。作用：HDFS Client用此类联系处于active状态的namenode  --&gt;    &lt;name&gt;dfs.client.failover.proxy.provider.rickiyang&lt;/name&gt;      &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;       &lt;!--用于主备节点切换时实现隔离机制的 --&gt;    &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;      &lt;value&gt;sshfence&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;!--配置密钥的路径 需与前面免密钥设置的路径保持一致--&gt;    &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;     &lt;value&gt;/hadoop/.ssh/id_rsa&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;       &lt;!--journalnode的持久化文件保存路径 --&gt;    &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;       &lt;value&gt;/usr/local/hadoop/journal/data&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;       &lt;!--设置故障自动切换功能可用 --&gt;    &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;     &lt;value&gt;true&lt;/value&gt;    &lt;/property&gt; &lt;/configuration&gt;</code></pre><p>复制配置文件的时候把注释删除，注释是给你看的，不用放进去。</p><p>slaves文件：  配置datanode的主机名称：</p><pre><code>hadoopslaver1hadoopslaver2hadoopslaver3</code></pre><p>mapred-site.xml文件，配置yarn：</p><pre><code>使用自带的模板文件# mv mapred-site.xml.template mapred-site.xml&lt;configuration&gt;      &lt;property&gt;          &lt;name&gt;mapreduce.framework.name&lt;/name&gt;          &lt;value&gt;yarn&lt;/value&gt;      &lt;/property&gt;  &lt;/configuration&gt; </code></pre><p>yarn-site.xml文件：</p><pre><code>&lt;configuration&gt;&lt;property&gt;          &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;          &lt;value&gt;mapreduce_shuffle&lt;/value&gt;      &lt;/property&gt;      &lt;property&gt;         &lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;         &lt;value&gt;true&lt;/value&gt;      &lt;/property&gt;      &lt;property&gt;         &lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;         &lt;value&gt;myyarncluster&lt;/value&gt;      &lt;/property&gt;      &lt;property&gt;         &lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;         &lt;value&gt;rm1,rm2&lt;/value&gt;      &lt;/property&gt;      &lt;property&gt;         &lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;         &lt;value&gt;hadoopslaver2&lt;/value&gt;      &lt;/property&gt;      &lt;property&gt;         &lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;         &lt;value&gt;hadoopslaver3&lt;/value&gt;      &lt;/property&gt;      &lt;property&gt;         &lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;         &lt;value&gt;hadoopmaster:2181,hadoopslaver1:2181,hadoopslaver2:2181&lt;/value&gt;      &lt;/property&gt;  &lt;/configuration&gt;</code></pre><p>以上6个文件配置完毕，同步至其他3台主机：</p><pre><code>进入路径：/usr/local/hadoop/etc/hadoop/下：scp * hadoopslaver1:`pwd`scp * hadoopslaver2:`pwd`scp * hadoopslaver3:`pwd`</code></pre><p>启动journalnode集群。（之所以将journalnode集群放在namenode之前启动，是因为namenode启动时，会往journalnode写入edits日志文件）</p><pre><code>在三台journalnode主机分别启动：hadoop-daemon.sh start journalnode</code></pre><p>NN的格式化 与  同步</p><p>在其中一台NN上，执行文件系统的格式化操作。注意：此处的格式化并非真正的格式化，而是一些准备和清除操作（比如清空fsimage和edits文件的存储目录下已有的文件）</p><pre><code>hdfs namenode -format    </code></pre><p>此时，这一台NN已经完成了格式化操作，接下来，需要将格式化之后的文件系统同步到另一台NN。同步时，第二台NN会从第一台NN读取数据，故需要先将第一台NN启动起来。</p><pre><code>hadoop-daemon.sh start namenode</code></pre><p>第一台NN启动后，在第二台NN上执行以下命令（此时NN尚未启动），即可完成同步操作：</p><pre><code>hdfs namenode -bootstrapStandby</code></pre><p>zookeeper集群的格式化</p><p>在上面已经启动了zookeeper集群，故此处在其中一台NN上执行以下命令，完成zookeeper的格式化：</p><pre><code>集群的一些高可用信息读到zookeeper中hdfs zkfc -formatZK  </code></pre><p>至此，Hadoop完全分布式集群的配置工作都已经完成！</p><p>接下来，启动集群，在其中一台主机上执行以下命令（最好是在NN上执行，因为NN-&gt;DN设置了免密钥）：</p><pre><code>start-all.sh</code></pre><p>然后分别在RS主机上启动resourcemanager：</p><pre><code>yarn-daemon.sh start resourcemanager</code></pre><p>在start-all.sh的时候会有如下信息输出：</p><p><img src="https://i.imgur.com/YJGl439.jpg" alt=""></p><p>在上面截图的信息中我们可以看到，集群的启动顺序是：</p><table><tr><td bgcolor="orange"><font color="#FF00FF" size="4">NN --> DN --> JN  -->ZKFC  --> NM</font></td></tr></table><p>jps  查看进程</p><p>hadoop集群的启动顺序：</p><p>1、启动zk集群</p><pre><code>zkServer.sh  start | status</code></pre><p>2、<span class="exturl" data-url="aHR0cDovL3N0YXJ0LWFsbC5zaA==" title="http://start-all.sh">start-all.sh<i class="fa fa-external-link"></i></span></p><p>3、手动启动两台RS</p><pre><code>yarn-daemon.sh start resourcemanager</code></pre><p>停止顺序：</p><p>1、<span class="exturl" data-url="aHR0cDovL3N0b3AtYWxsLnNo" title="http://stop-all.sh">stop-all.sh<i class="fa fa-external-link"></i></span></p><p>2、手动停止两台rs</p><pre><code>yarn-daemon.sh stop resourcemanager</code></pre><p>3、停止zk集群</p><p>启动完成，浏览器访问：</p><p><img src="https://i.imgur.com/Hh2QdO7.jpg" alt=""></p><p><img src="https://i.imgur.com/ilOXIgw.jpg" alt=""></p><p><img src="https://i.imgur.com/ryx9uUi.jpg" alt=""></p><p>至此，我们的高可用环境就搭建完毕了。大家动手尝试吧！<br>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来完成hadoop2.x的完全分布式环境搭建，话说学习本来是一件很快乐的事情，可是一到了搭环境就怎么都让人快乐不起来啊，搭环境的时间比学习的时间还多。都是泪。话不多说，走起。&lt;/p&gt;
&lt;h3 id=&quot;1-准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anch
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hadoop" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hadoop/"/>
    
    
      <category term="hadoop学习" scheme="http://blog.rickiyang.cn/tags/hadoop%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeeper环境搭建</title>
    <link href="http://blog.rickiyang.cn/posts/bfffb12b.html"/>
    <id>http://blog.rickiyang.cn/posts/bfffb12b.html</id>
    <published>2018-06-09T09:43:21.000Z</published>
    <updated>2018-12-13T02:14:20.615Z</updated>
    
    <content type="html"><![CDATA[<p>zk一般是有2n+1个节点组成的集群。在Zookeeper服务有两个角色，一个是leader，负责写服务和数据同步；剩下的是follower，提供读服务。(为什么是2n+1个节点请看paxos算法)</p><ol><li>leader实效后会在follower中重新选举新的leader。（paxos算法）</li><li>每个follower都和leader有链接，接受leader的数据更新操作。（zab算法）</li><li>客户端可以连接到每个server，每个server的数据完全相同。</li><li>Server记录事务日志和快照到持久存储。</li></ol><h4 id="1-zk的特点如下"><a class="markdownIt-Anchor" href="#1-zk的特点如下"></a> 1. zk的特点如下：</h4><ul><li>最终一致性：为客户端展示同一个视图，这是zookeeper里面一个非常重要的功能</li><li>可靠性：如果消息被到一台服务器接受，那么它将被所有的服务器接受。</li><li>实时性：Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li><li>独立性 ：各个Client之间互不干预</li><li>原子性 ：更新只能成功或者失败，没有中间状态。</li><li>顺序性 ：所有Server，同一消息发布顺序一致。</li></ul><h4 id="2-zk中的角色"><a class="markdownIt-Anchor" href="#2-zk中的角色"></a> 2. zk中的角色：</h4><ul><li><p>领导者(Leader)：领导者负责进行投票的发起和决议，更新系统状态，处理写请求</p></li><li><p>跟随者(Follwer)：Follower用于接收客户端的读写请求并向客户端返回结果，在选主过程中参与投票</p></li><li><p>观察者（Observer）：观察者可以接收客户端的读写请求，并将写请求转发给Leader，但Observer节点不参与投票过程，只同步leader状态，Observer的目的是为了，扩展系统，提高读取速度。在3.3.0版本之后，引入Observer角色的原因：</p><pre><code>  Zookeeper需保证高可用和强一致性；  为了支持更多的客户端，需要增加更多Server；  Server增多，投票阶段延迟增大，影响性能；  权衡伸缩性和高吞吐率，引入Observer ；  Observer不参与投票；  Observers接受客户端的连接，并将写请求转发给leader节点；  加入更多Observer节点，提高伸缩性，同时不影响吞吐率。</code></pre></li></ul><p>客户端(Client)： 执行读写请求的发起方</p><h4 id="3-安装"><a class="markdownIt-Anchor" href="#3-安装"></a> 3. 安装：</h4><p>环境：3台虚拟机：已设置ssh免密登录：</p><pre><code>192.168.131.128192.168.131.130192.168.131.131</code></pre><p>下载zookeeper并解压到/usr/local/zookeeper目录。</p><p>添加到环境变量：</p><pre><code>ZOOKEEPER_HOME=/usr/local/zookeeperexport PATH=$PATH:$ZOOKEEPER_HOME/bin:$ZOOKEEPER_HOME/conf使配置生效source /etc/profile</code></pre><p>修改配置文件：</p><p>在zk的conf/目录下，将zoo_sample.cfg重命名为zoo.cfg，然后：</p><p>修改内容：</p><pre><code># The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.dataDir=/usr/local/zookeeper/data# the port at which the clients will connectclientPort=2183#the location of the log filedataLogDir=/usr/local/zookeeper/logserver.0=hadoopmaster:2288:3388server.1=hadoopslaver1:2288:3388server.2=hadoopslaver2:2288:3388</code></pre><p>上面我们设置了数据库快照位置-data目录，该目录需要手动创建。</p><p>创建myid：</p><p>在dataDir(/usr/local/zk/data)目录创建myid文件</p><pre><code>hadoopmaster的内容为：0hadoopslaver1的内容为：1hadoopslaver2的内容为：2</code></pre><p><strong>注意：以上操作三台机器都需要进行。</strong></p><p>然后我们分别在三台机器启动zk，在bin目录下执行如下命令：</p><pre><code>zkServer.sh start；</code></pre><p>各个机器启动情况如下：</p><p><img src="https://i.imgur.com/0LYJHxb.jpg" alt=""></p><p>当然哪一台机器是leader这都是随机的，一般第一台启动的会是。</p><p>zk的配置：</p><p>Zookeeper的功能特性是通过Zookeeper配置文件来进行控制管理的(zoo.cfg).这样的设计其实有其自身的原因，通过前面对Zookeeper的配置可以看出，在对Zookeeper集群进行配置的时候，它的配置文档是完全相同的。集群伪分布模式中，有少部分是不同的。这样的配置方式使得在部署Zookeeper服务的时候非常方便。如果服务器使用不同的配置文件，必须确保不同配置文件中的服务器列表相匹配。</p><p>我们来看一下上面配置文件中的基本参数：</p><ol><li>client：监听客户端连接的端口。</li><li>tickTime：基本事件单元，这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，每隔tickTime时间就会发送一个心跳；最小 的session过期时间为2倍tickTime。</li><li>dataDir：存储内存中数据库快照的位置，如果不设置参数，更新食物的日志将被存储到默认位置。</li></ol><p>高级配置：</p><ol><li>dataLogdDir：这个操作让管理机器把事务日志写入“dataLogDir”所指定的目录中，而不是“dataDir”所指定的目录。这将允许使用一个专用的日志设备，帮助我们避免日志和快照的竞争。</li><li>maxClientCnxns：这个操作将限制连接到Zookeeper的客户端数量，并限制并发连接的数量，通过IP来区分不同的客户端。此配置选项可以阻止某些类别的Dos攻击。将他设置为零或忽略不进行设置将会取消对并发连接的限制。</li><li>minSessionTimeout和maxSessionTimeout ：即最小的会话超时和最大的会话超时时间。在默认情况下，minSession=2<em>tickTime；maxSession=20</em>tickTime。</li></ol><p>集群配置：</p><ol><li><p>initLimit：此配置表示，允许follower(相对于Leaderer言的“客户端”)连接并同步到Leader的初始化连接时间，以tickTime为单位。当初始化连接时间超过该值，则表示连接失败。</p></li><li><p>syncLimit：此配置项表示Leader与Follower之间发送消息时，请求和应答时间长度。如果follower在设置时间内不能与leader通信，那么此follower将会被丢弃。</p></li><li><p>server.A=B：C：D</p><pre><code>A：其中 A 是一个数字，表示这个是服务器的编号；B：是这个服务器的 ip 地址；C：Leader选举的端口；D：Zookeeper服务器之间的通信端口。</code></pre></li><li><p>myid和zoo.cfg：除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;zk一般是有2n+1个节点组成的集群。在Zookeeper服务有两个角色，一个是leader，负责写服务和数据同步；剩下的是follower，提供读服务。(为什么是2n+1个节点请看paxos算法)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;leader实效后会在follower中重新选举
      
    
    </summary>
    
      <category term="分布式组件" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    
      <category term="zookeeper" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/zookeeper/"/>
    
    
      <category term="分布式" scheme="http://blog.rickiyang.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习(五)----HDFS的java操作</title>
    <link href="http://blog.rickiyang.cn/posts/6f52a716.html"/>
    <id>http://blog.rickiyang.cn/posts/6f52a716.html</id>
    <published>2018-06-07T13:55:23.000Z</published>
    <updated>2018-12-13T02:14:20.609Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们基本学习了HDFS的原理，hadoop环境的搭建，下面开始正式的实践，语言以java为主。这一节来看一下HDFS的java操作。</p><h4 id="1-环境准备"><a class="markdownIt-Anchor" href="#1-环境准备"></a> 1 环境准备</h4><p>上一篇说了windows下搭建hadoop环境，开始之前先启动hadoop。我本地的编译器是idea。搭建maven工程：</p><p>pom.xml文件：</p><pre><code>&lt;dependencies&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.12&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;  &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;  &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;  &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;  &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>​<br><dependency><br><groupid>org.apache.hadoop</groupid><br><artifactid>hadoop-mapreduce-client-core</artifactid><br><version>2.7.3</version><br></dependency></p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;  &lt;artifactId&gt;hadoop-mapreduce-client-jobclient&lt;/artifactId&gt;  &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;log4j&lt;/groupId&gt;  &lt;artifactId&gt;log4j&lt;/artifactId&gt;  &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>新建测试类：FileOperator.java</p><pre><code>import org.apache.commons.compress.utils.IOUtils;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.*;import org.apache.hadoop.fs.permission.FsPermission;import org.apache.hadoop.hdfs.DistributedFileSystem;import org.junit.Before;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.net.URI;import java.text.SimpleDateFormat;import java.util.Date;/** * Created by Administrator on 2017/12/3. */public class FileOperator {    private static final Logger logger = LoggerFactory.getLogger(FileOperator.class);    public static DistributedFileSystem dfs=null;    public static String nameNodeUri=&quot;hdfs://localhost:9000&quot;;    @Before    public void initFileSystem() throws Exception{        logger.info(&quot;initial hadoop env----&quot;);        dfs=new DistributedFileSystem();        dfs.initialize(new URI(nameNodeUri), new Configuration());        logger.info(&quot;connection is successful&quot;);        Path workingDirectory = dfs.getWorkingDirectory();        System.out.println(&quot;current workspace is ：&quot;+workingDirectory);    }    /**     * 创建文件夹     * @throws Exception     */    @Test    public void testMkDir() throws Exception{        boolean res = dfs.mkdirs(new Path(&quot;/test/aaa/bbb&quot;));        System.out.println(&quot;目录创建结果：&quot;+(res?&quot;创建成功&quot;:&quot;创建失败&quot;));    }    /**     * 删除目录/文件     * @throws Exception     */    @Test    public void testDeleteDir() throws Exception{        dfs.delete(new Path(&quot;/test/aaa/bbb&quot;), false);    }    /**     * 获取指定目录下所有文件(忽略目录)     * @throws Exception     * @throws IllegalArgumentException     */    @Test    public void testFileList() throws Exception{        RemoteIterator&lt;LocatedFileStatus&gt; listFiles = dfs.listFiles(new Path(&quot;/&quot;), true);        SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);        while (listFiles.hasNext()) {            LocatedFileStatus fileStatus = (LocatedFileStatus) listFiles.next();            //权限            FsPermission permission = fileStatus.getPermission();            //拥有者            String owner = fileStatus.getOwner();            //组            String group = fileStatus.getGroup();            //文件大小byte            long len = fileStatus.getLen();            long modificationTime = fileStatus.getModificationTime();            Path path = fileStatus.getPath();            System.out.println(&quot;-------------------------------&quot;);            System.out.println(&quot;permission:&quot;+permission);            System.out.println(&quot;owner:&quot;+owner);            System.out.println(&quot;group:&quot;+group);            System.out.println(&quot;len:&quot;+len);            System.out.println(&quot;modificationTime:&quot;+sdf.format(new Date(modificationTime)));            System.out.println(&quot;path:&quot;+path);        }    }    /**     * 【完整】文件上传     * 注意：文件上传在Window开发环境下，使用apache-common提供的&lt;code&gt;org.apache.commons.io.IOUtils.copy&lt;/code&gt;可能存在问题     */    @Test    public void testUploadFullFile() throws Exception{        FSDataOutputStream out = dfs.create(new Path(&quot;/test/aaa/testFile.txt&quot;), true);        InputStream in = new FileInputStream(&quot;F:\\test\\cluster\\input\\testFile.txt&quot;);        IOUtils.copy(in, out);        System.out.println(&quot;上传完毕&quot;);    }</code></pre><p>​<br>/**<br>* 【分段|部分】文件上传<br>* 注意：文件上传在Window开发环境下，使用apache-common提供的<code>org.apache.commons.io.IOUtils.copy</code>可能存在问题<br><em>/<br>@Test<br>public void testUploadFile2() throws Exception{<br>FSDataOutputStream out = dfs.create(new Path(&quot;/test/aaa/testFile1.txt&quot;), true);<br>InputStream in = new FileInputStream(“F:\test\cluster\input\testFile.txt”);<br>org.apache.commons.io.IOUtils.copyLarge(in, out, 6, 12);<br>System.out.println(“上传完毕”);<br>}<br>/</em>*<br>* 【完整】下载文件<br>* 注意：windows开发平台下，使用如下API<br>*/<br>@Test<br>public void testDownloadFile() throws Exception{<br>//使用Java API进行I/O,设置useRawLocalFileSystem=true<br>dfs.copyToLocalFile(false,new Path(&quot;/test/aaa/testFile.txt&quot;),<br>new Path(“E:/”),true);<br>System.out.println(“下载完成”);<br>}</p><pre><code>    /**     * 【部分】下载文件     */    @Test    public void testDownloadFile2() throws Exception{        //使用Java API进行I/O,设置useRawLocalFileSystem=true        FSDataInputStream src = dfs.open(new Path(&quot;/test/aaa/testFile.txt&quot;));        FileOutputStream des = new FileOutputStream(new File(&quot;E:/&quot;,&quot;download_testFile.txt&quot;));        src.seek(6);        org.apache.commons.io.IOUtils.copy(src, des);        System.out.println(&quot;下载完成&quot;);    }}</code></pre><p>代码如上，如要使用请调整相关目录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们基本学习了HDFS的原理，hadoop环境的搭建，下面开始正式的实践，语言以java为主。这一节来看一下HDFS的java操作。&lt;/p&gt;
&lt;h4 id=&quot;1-环境准备&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-环境准备&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hadoop" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hadoop/"/>
    
    
      <category term="hadoop学习" scheme="http://blog.rickiyang.cn/tags/hadoop%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper基本知识入门</title>
    <link href="http://blog.rickiyang.cn/posts/5f43c4fb.html"/>
    <id>http://blog.rickiyang.cn/posts/5f43c4fb.html</id>
    <published>2018-06-07T05:11:28.000Z</published>
    <updated>2018-12-13T02:14:20.614Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们在搭建hadoop分布式环境的时候用到过Zookeeper注册hadoop服务。那么到底Zookeeper在分布式环境中发挥了什么作用呢，这次我们就来讨论这个问题。</p><p>在分布式系统中通常都会有多台机器构成一个集群来对外提供服务，对外来说有几台机器在提供服务它并不关心，那么对内而言组成集群的机器如何互相协调保持一致这是个问题。Zookeeper将提供这样的一个功能–分布式协调技术。</p><h4 id="1-zookerrper概述"><a class="markdownIt-Anchor" href="#1-zookerrper概述"></a> 1. Zookerrper概述</h4><p>ZooKeeper是一种为分布式应用所设计的高可用、高性能且一致的开源协调服务，它提供了一项基本服务：分布式锁服务。由于ZooKeeper的开源特性，后来我们的开发者在分布式锁的基础上，摸索了出了其他的使用方法：配置维护、组服务、分布式消息队列、分布式通知/协调等。</p><p>ZooKeeper性能上的特点决定了它能够用在大型的、分布式的系统当中。从可靠性方面来说，它并不会因为一个节点的错误而崩溃。除此之外，它严格的序列访问控制意味着复杂的控制原语可以应用在客户端上。ZooKeeper在一致性、可用性、容错性的保证，也是ZooKeeper的成功之处，它获得的一切成功都与它采用的协议——Zab协议是密不可分的。</p><p>ZooKeeper在实现这些服务时，首先它设计一种新的数据结构——Znode，然后在该数据结构的基础上定义了一些原语，也就是一些关于该数据结构的一些操作。有了这些数据结构和原语还不够，因为我们的ZooKeeper是工作在一个分布式的环境下，我们的服务是通过消息以网络的形式发送给我们的分布式应用程序，所以还需要一个通知机制——Watcher机制。那么总结一下，ZooKeeper所提供的服务主要是通过：数据结构+原语+watcher机制，三个部分来实现的。那么我就从这三个方面，给大家介绍一下ZooKeeper。</p><h4 id="2-zookeeper的数据模型znode"><a class="markdownIt-Anchor" href="#2-zookeeper的数据模型znode"></a> 2. Zookeeper的数据模型Znode</h4><p><img src="https://i.imgur.com/BnNCwRJ.jpg" alt=""></p><p>Znode用来存储节点信息，它的数据模型和我们平常的文件管理系统目录树非常相似。不同之处在于：</p><p>1）路径引用</p><p>Znode通过路径引用来管理子节点。路径必须是绝对的，所以路径都是以斜杠字符来开头。其次，与我们的文件系统一样，路径必须的是惟一的。</p><p>2）Znode数据结构</p><p>Znode不单单是维护着节点信息，同时自身也保存着一些关联信息。这些信息可以分为3个部分：</p><ol><li>stat：状态信息，描述Znode的版本以及权限信息；</li><li>data; 与该Znode关联的数据信息；</li><li>children：该Znode下的子节点信息；</li></ol><p>其中stat中的信息与我们平常的操作息息相关，stat中又包含如下字段：</p><ol><li>czxid： 引起这个znode创建的zxid</li><li>mzxid： znode最后更新的zxid</li><li>ctime： znode被创建的毫秒数(从1970年开始)</li><li>mtime： znode最后修改的毫秒数(从1970年开始)</li><li>version： znode数据变化号</li><li>cversion： znode子节点变化号</li><li>aversion： znode访问控制列表的变化号</li><li>ephemeralOwner： 如果是临时节点这个是znode拥有者的session id。如果不是临时节点则是0</li><li>dataLength： znode的数据长度</li><li>numChildren： znode子节点数量</li></ol><p>后面我们再分析这些字段的意义。</p><p>data部分并不是存放一些非常大的数据。Zookeeper设计并不是作为常规的数据仓库或者数据库的，他作为分布式协调任务调度器，通常是会保存一些必要的配置文件，状态，以及路由信息，这些信息的存储通常都不会太大，Zookeeeper的服务端和客户端都被设计为严格检查每个Znode的数据大小最大为1M。</p><p>3）数据访问</p><p>Zookeeper中每个节点存储的数据被要求为原子操作。每一个节点都有自己的ACL（访问控制列表），这个列表规定了用户的权限。</p><p>4）节点类型</p><p>zk中的节点分为两种类型：临时节点和永久节点。节点的类型在创建的时候就被确定并且不能更改。</p><ol><li>临时节点：节点的生命周期依赖于创建他们的会话。一旦会话(session)结束，临时节点就会被自动删除。一般临时节点虽然是某一个客户端发起会话创建的，但是他们对所有的客户端都是可见的。另外**，zk中规定临时节点不可以拥有子节点。**</li><li>永久节点：该节点的生命周期不依赖于会话，只有客户端发起删除命令才会被删除。</li></ol><p>5）观察</p><p>客户端可以在节点上设置watch，即监视器。当节点发生改变的时候出发watch所对应的操作，zk将会向客户端发送一条且仅发送一条通知。因为watch只能被出发一次，这样就减少了网络的流量消耗。</p><h5 id="21-zk中的时间"><a class="markdownIt-Anchor" href="#21-zk中的时间"></a> 2.1 zk中的时间</h5><p>zk中记录时间并不是一个简单的时间戳，包含如下属性：</p><p><strong>Zxid</strong></p><p>zk中节点状态改变的每一个操作都会被记录一个Zxid格式的时间戳，这个时间戳全局有序。即每个对节点的改变都会记录一个全局唯一的时间戳，如果Zxid1的值小于Zxid2，那么Zxid1所发生的时间必然在Zxid2之前。事实上zk的每一个节点都维护者三个Zxid：分别为：cZxid，mZxid，pZxid：</p><pre><code> cZxid： 是节点的创建时间所对应的Zxid格式时间戳。 mZxid： 是节点的修改时间所对应的Zxid格式时间戳。 pZxid:  最新修改的Zxid，是不是与mZxid重复了。</code></pre><p>Zxid是一个64位的数字，高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，他都会有一个新的epoch。低32位是个递增计数器。</p><p><strong>Version 版本号</strong></p><p>对节点的每一个操作都会使这个节点的版本号递增。每一个节点分别维护着三个版本号：</p><ol><li>version：节点数据版本号</li><li>cversion：子节点版本号</li><li>aversion：节点所拥有的ACL版本号</li></ol><h4 id="3-zk中的基本操作"><a class="markdownIt-Anchor" href="#3-zk中的基本操作"></a> 3. zk中的基本操作</h4><p>create  :   创建Znode（如果是zi节点，父节点必须存在）<br><br>delete : 删除Znode（Znode没有子节点）<br><br>exists : 测试Znode是否存在，存在则获取他的元数据信息<br><br>getACL/setACL : 为Znode获取/设置ACL信息<br><br>getChildren ：获取Znode所有子节点列表<br><br>getData/setData ：获取/设置Znode的相关数据<br><br>sync ： 是客户端的Znode师徒与zk同步</p><table>        <thead>            <th>操作</th>            <th>说明</th>        </thead>        <tbody>            <tr>                <td>create</td>                <td>创建Znode（如果是zi节点，父节点必须存在）</td>            </tr>            <tr>                <td>delete</td>                <td>删除Znode（Znode没有子节点）</td>            </tr>            <tr>                <td>exists</td>                <td>测试Znode是否存在，存在则获取他的元数据信息</td>            </tr>            <tr>                <td>getACL/setACL</td>                <td> 为Znode获取/设置ACL信息</td>            </tr>            <tr>                <td>getChildren</td>                <td>获取Znode所有子节点列表</td>            </tr>            <tr>                <td>getData/setData</td>                <td>获取/设置Znode的相关数据</td>            </tr>            <tr>                <td>sync</td>                <td>是客户端的Znode师徒与zk同步</td>            </tr>        </tbody>    </table><h4 id="4-watch触发器"><a class="markdownIt-Anchor" href="#4-watch触发器"></a> 4. watch触发器</h4><p>ZooKeeper可以为所有的读操作设置watch，这些读操作包括：exists()、getChildren()及getData()。watch事件是一次性的触发器。</p><p>watch类型可以分为两类：</p><ul><li>数据watch(data  watches)：getData和exists负责设置数据watch</li><li>孩子watch(child watches)：getChildren负责设置孩子watch</li></ul><h4 id="5-zk的应用场景"><a class="markdownIt-Anchor" href="#5-zk的应用场景"></a> 5. zk的应用场景</h4><p>1）分布式锁</p><p>共享锁在同一个进程中是很容易实现，但是在跨进程或者是不同的server中实现起来却不是那么容易。zk实现这个功能却是很容易。</p><p>在实现中，获得锁的 Server 创建一个 EPHEMERAL_SEQUENTIAL 目录节点，然后调用 getChildren方法获取当前的目录节点列表中最小的目录节点是不是就是自己创建的目录节点，如果正是自己创建的，那么它就获得了这个锁，如果不是那么它就调用exists(String path, boolean watch) 方法并监控 Zookeeper 上目录节点列表的变化，一直到自己创建的节点是列表中最小编号的目录节点，从而获得锁，释放锁很简单，只要删除前面它自己所创建的目录节点就行了。</p><p>具体步骤如下：</p><p><img src="https://i.imgur.com/XQPspqh.gif" alt=""></p><p>加锁： ZooKeeper 将按照如下方式实现加锁的操作：</p><ol><li><p>ZooKeeper调用create（）方法来创建一个路径格式为“<em>locknode</em>/lock- ”的节点，此节点类型为sequence （连续）和 ephemeral （临时）。也就是说，创建的节点为临时节点，并且所有的节点连续编号，即“lock-i ”的格式。</p></li><li><p>在创建的锁节点上调用getChildren（）方法，来获取锁目录下的最小编号节点，并且不设置 watch 。</p></li><li><p>步骤 2 中获取的节点恰好是步骤1中客户端创建的节点，那么此客户端获得此种类型的锁，然后退出操作。</p></li><li><p>客户端在锁目录上调用exists（）方法，并且设置 watch 来监视锁目录下比自己小一个的连续临时节点的状态。</p></li><li><p>如果监视节点状态发生变化，则跳转到第2步，继续进行后续的操作，直到退出锁竞争。</p></li></ol><p>2）配置管理(数据发布与订阅)</p><p>在分布式系统里，我们会把一个服务应用分别部署到n台服务器上，这些服务器的配置文件是相同的，如果配置文件的配置选项发生变化，那么我们就得一个个去改这些配置文件，如果我们需要改的服务器比较少，这些操作还不是太麻烦，如果我们分布式的服务器特别多，那么更改配置选项就是一件麻烦而且危险的事情。这时我们可以将配置信息保存在 Zookeeper 的某个目录节点中，然后将所有需要修改的应用机器监控配置信息的状态，一旦配置信息发生变化，每台应用机器就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中。</p><p>3）集群管理</p><p>Zookeeper 能够很容易的实现集群管理的功能，如有多台 Server 组成一个服务集群，那么必须要一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它集群必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台 Server，同样也必须让“总管”知道。</p><p>Zookeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个“总管”，让这个总管来管理集群，这就是 Zookeeper 的另一个功能 Leader Election。</p><p>它们的实现方式都是在 Zookeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。</p><p>Zookeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。</p><p>4）队列管理</p><p>Zookeeper 可以处理两种类型的队列：</p><ul><li>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。</li><li>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。</li></ul><p>A、同步队列 用 Zookeeper 实现的实现思路如下：</p><p>创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。</p><p>B、FIFO队列：</p><p>实现的思路也非常简单，就是在特定的目录下创建 SEQUENTIAL 类型的子目录 /queue_i，这样就能保证所有成员加入队列时都是有编号的，出队列时通过 getChildren( ) 方法可以返回当前所有的队列中的元素，然后消费其中最小的一个，这样就能保证 FIFO。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前我们在搭建hadoop分布式环境的时候用到过Zookeeper注册hadoop服务。那么到底Zookeeper在分布式环境中发挥了什么作用呢，这次我们就来讨论这个问题。&lt;/p&gt;
&lt;p&gt;在分布式系统中通常都会有多台机器构成一个集群来对外提供服务，对外来说有几台机器在提供服
      
    
    </summary>
    
      <category term="分布式组件" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    
      <category term="zookeeper" scheme="http://blog.rickiyang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/zookeeper/"/>
    
    
      <category term="分布式" scheme="http://blog.rickiyang.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习(四)----windows环境下安装hadoop</title>
    <link href="http://blog.rickiyang.cn/posts/a713f481.html"/>
    <id>http://blog.rickiyang.cn/posts/a713f481.html</id>
    <published>2018-06-04T03:03:02.000Z</published>
    <updated>2018-12-13T02:14:20.609Z</updated>
    
    <content type="html"><![CDATA[<p>因为我们不能在线上环境进行调试hadoop，这样就只能在本地先调试好了再放到线上去啦。我本地是windows环境，今天先记下windows下搭建hadoop2.7的步骤。</p><h4 id="1-本地环境"><a class="markdownIt-Anchor" href="#1-本地环境"></a> 1 本地环境</h4><ol><li>windows7 64位</li><li>hadoop-2.7.3.tar.gz</li></ol><p>hadoop在apache下载，看别的教程都说是需要搭建Cygwin，但是后来在国外论坛上看到已经有大神给出了windows下搭建hadoop环境的依赖库，所以我们省下了甚多麻烦哈。<span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmNzZG4ubmV0L2Rvd25sb2FkL2E5NTM3MTM0MjgvMTAxNDE3MzI=" title="http://download.csdn.net/download/a953713428/10141732">依赖环境点击这里下载<i class="fa fa-external-link"></i></span>。将解压的bin目录和etc目录替换掉你的本地hadoop里面的bin和etc即可，etc目录最好还是你自己配置。</p><p>替换完成之后我们别忘了检查你的环境变量，我本地hadoop文件夹在E盘根目录，配置到环境变量：</p><p>新建 HADOOP_HOME 变量：</p><pre><code>HADOOP_HOMEE:\hadoop</code></pre><p>在path里面加上：</p><pre><code>%HADOOP_HOME%\bin;</code></pre><p>然后还有把刚才替换的hadoop/bin里面的 hadoop.dll库文件复制一份放到c:/windows/System32里面。</p><p>然后配置etc/hadoop里面的4个文件：</p><p>core-site.xml</p><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;    &lt;/property&gt;    &lt;/configuration&gt;</code></pre><p>hdfs-site.xml</p><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;            &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;            &lt;value&gt;file:/hadoop/data/dfs/namenode&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;            &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;            &lt;value&gt;file:/hadoop/data/dfs/datanode&lt;/value&gt;      &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>mapred-site.xml</p><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;        &lt;value&gt;yarn&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>yarn-site.xml</p><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;        &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>以上四个文件都是按照最小配置来写的如果你还有别的需求请参考官网的配置。</p><p>接下来我们需要格式化namenode，进入hadoop/bin目录执行：</p><pre><code>hadoop namenode -format</code></pre><p>执行完毕再进入sbin目录执行启动命令：</p><pre><code>start-all.cmd</code></pre><p>接着会启动四个窗口，分别启动本地的namenode，datanode，你可以使用jps命令查看是否启动完成：</p><p><img src="https://i.imgur.com/4uaTTAk.jpg" alt=""></p><p>如上便是成功启动啦，接着我们可以启动浏览器查看datanode控制台和mapreduce控制台：</p><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDA3MA==" title="http://localhost:50070">http://localhost:50070<i class="fa fa-external-link"></i></span></p><p><img src="https://i.imgur.com/ztGResH.jpg" alt=""></p><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDg4L2NsdXN0ZXI=" title="http://localhost:8088/cluster">http://localhost:8088/cluster<i class="fa fa-external-link"></i></span></p><p><img src="https://i.imgur.com/qXjMDbE.jpg" alt=""></p><p>这样我们的本地开发环境就搭建好了。</p><p>停止服务使用如下命令：</p><p>sbin目录下执行： stop-all.cmd</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为我们不能在线上环境进行调试hadoop，这样就只能在本地先调试好了再放到线上去啦。我本地是windows环境，今天先记下windows下搭建hadoop2.7的步骤。&lt;/p&gt;
&lt;h4 id=&quot;1-本地环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hadoop" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hadoop/"/>
    
    
      <category term="hadoop学习" scheme="http://blog.rickiyang.cn/tags/hadoop%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习(二)----HDFS简介及原理</title>
    <link href="http://blog.rickiyang.cn/posts/84e37d27.html"/>
    <id>http://blog.rickiyang.cn/posts/84e37d27.html</id>
    <published>2018-06-03T13:16:24.000Z</published>
    <updated>2018-12-13T02:14:20.608Z</updated>
    
    <content type="html"><![CDATA[<p>前面简单介绍了hadoop生态圈，大致了解hadoop是什么、能做什么。带着这些目的我们深入的去学习他。今天一起看一下hadoop的基石----文件存储。因为hadoop是运行与集群之上，处于分布式环境之中，所以他的文件存储也不同与普通的本地存储，而是分布式存储系统，HDFS（The Hadoop Distributed File System）。</p><p>因为数据量越来越大，一台机器管理的磁盘数量是有限的，所有的数据由很多台机器管理。那么对于这么多台机器管理的数据如何进行协调处理呢？这个时候分布式文件管理系统就出现了。分布式文件系统是一种允许文件通过网络在多台主机上分享的 文件的系统，可让多机器上的多用户分享文件和存储空间。现有的分布式文件系统种类很多：CEPH,glusterfs,moosefs,mogilefs ,fastDFS(国人在mogileds基础上改写的)，Lustre等等。我们今天要学的HDFS只是分布式文件管理系统的一种，触类旁通，学会了一种其余的都好解除。HDFS的使用场景：<strong>适用于一次写入、多次查询的情况，不支持并发写情况，小文件不合适</strong>。因为小文件也占用一个块，小文件越多（1000个1k文件）块越 多，NameNode压力越大。</p><p>我们借用官方的HDFS结构图：</p><p><img src="https://i.imgur.com/fS7P4pS.gif" alt=""></p><blockquote><p>（解释一下图中的一些词：<br>Rack 是指机柜的意思，一个block的三个副本通常会保存到两个或者两个以上的机柜中（当然是机柜中的服务器），这样做的目的是做防灾容错，因为发生一个机柜掉电或者一个机柜的交换机挂了的概率还是蛮高的。<br>数据块(block):HDFS(Hadoop Distributed File System)默认的最基本的存储单位是64M的数据块。HDFS中，如果一个文件小于一个数据块的大小，并不占用整个数据块存储空间。从上图中看，一个文件被分成一个或多个Block，存储在一组Datanode上）</p></blockquote><p>HDFS主要由三个部分组成：namenode,datanode,secondaryNamenode.</p><p>这三者的关系简单理解就是：<br>namenode是主人，颐指气使；<br>datanode是丫鬟们，为主子服务；<br>secondarynamenode就是那个天天跟着主人后面的太监为主子发号命令的；</p><p>下面我们分别介绍三者。</p><h4 id="1-namenode"><a class="markdownIt-Anchor" href="#1-namenode"></a> 1 namenode</h4><p>NameNode的作用是 管理文件目录结构，接受用户的操作请求,是管理数据节点的。名字节点维护两套数据：<br>一套 是文件 目录与数据块之间的关系<br>另一套 是 数据块与节点之间的关系 。<br>前一套 数据是 静态的 ，是存放在磁盘上的， 通过fsimage和edits文件来维护 ；<br>后一套 数据是 动态的 ，不持久放到到磁盘的，每当集群启动的时候，会自动建立这些信息，所以一般都放在内存中。</p><p>内存的数据主要是一些元数据信息，元数据信息就像是一个索引信息，通过索引可以轻松的找到需求的数据的位置包括副本位置；元数据的存在主要是为了便于读取hdfs中的数据。</p><p>硬盘中的数据比较多，最新格式化的namenode会生成以下文件目录结构：</p><p><img src="http://i.imgur.com/WsdXU7K.jpg" alt=""></p><p>VERSION 记载了一些namenode的基础信息，其中有一个namespaceID，这是这个namenode的唯一标示。edits是hdfs的日志文件，这里记录着namenode上的一些读写操作,这是namenode储存的第一个重要的信息，它记录了近期的所有操作记录以及操作状态和操作内容.fsimage是namenode的存在内存中的元数据在硬盘上的镜像文件，但镜像文件并不是与matadata（元数据）同步的，在达到一定条件fsimage会执行更新操作来保持和内存中的元数据信息保持一致，而执行这个镜像同步操作的凭据就是edits。stime，镜像生成或者修改时间.</p><p>namenode主要涉及到的就是读和写操作，其中都比较简单（相对），写则会有一个过程，我们先看读：</p><p><img src="https://i.imgur.com/gHCfUHg.png" alt=""></p><p>读文件过程：</p><p>1.客户端（Client）用FileSystem的open（）函数打开文件。</p><p>2.DistributedFileSystem用RPC调用元数据节点，得到文件的数据块信息。<br>对于每一个数据块，元数据节点返回保存数据块的数据节点的地址。</p><p>3.DistributedFileSystem返回FSDataInputStream给客户端，用来读取数据。</p><p>4.客户端调用stream的read()函数开始读取数据。</p><p>5.DFSInputStream连接保存此文件第一个数据块的最近的数据节点。</p><p>6.Data从数据节点读到客户端(client)</p><p>7.当此数据块读取完毕时，DFSInputStream关闭和此数据节点的连接，然后连接此文件下一个数据块的最近的数据节点。</p><p>8.当客户端读取完毕数据的时候，调用FSDataInputStream的close函数。</p><p>在读取数据的过程中，如果客户端在与数据节点通信出现错误，则尝试连接包含此数据块的下一个数据节点。</p><p>失败的数据节点将被记录，以后不再连接。</p><p>看来看写文件：</p><p><img src="http://i.imgur.com/kJxs64J.jpg" alt=""></p><p>1.客户端调用create()来创建文件</p><p>2.DistributedFileSystem用RPC调用元数据节点，在文件系统的命名空间中创建一个新的文件。</p><p>3.元数据节点首先确定文件原来不存在，并且客户端有创建文件的权限，然后创建新文件。</p><p>4.DistributedFileSystem返回DFSOutputStream，客户端用于写数据。</p><p>5.客户端开始写入数据，DFSOutputStream将数据分成块，写入data queue。</p><p>6.Data queue由Data Streamer读取，并通知元数据节点分配数据节点，用来存储数据块(每块默认复制3块)。分配的数据节点放在一个pipeline里。</p><p>7.Data Streamer将数据块写入pipeline中的第一个数据节点。第一个数据节点将数据块发送给第二个数据节点。第二个数据节点将数据发送给第三个数据节点。</p><p>8.DFSOutputStream为发出去的数据块保存了ack queue，等待pipeline中的数据节点告知数据已经写入成功。</p><p><strong>如果数据节点在写入的过程中失败：</strong></p><p>1.关闭pipeline，将ack queue中的数据块放入data queue的开始。</p><p>2.当前的数据块在已经写入的数据节点中被元数据节点赋予新的标示，则错误节点重启后能够察觉其数据块是过时的，会被删除。</p><p>3.失败的数据节点从pipeline中移除，另外的数据块则写入pipeline中的另外两个数据节点。</p><p>4.元数据节点则被通知此数据块是复制块数不足，将来会再创建第三份备份。</p><p>5.当客户端结束写入数据，则调用stream的close函数。此操作将所有的数据块写入pipeline中的数据节点，并等待ack queue返回成功。最后通知元数据节点写入完毕。</p><h4 id="2-datanode"><a class="markdownIt-Anchor" href="#2-datanode"></a> 2 DataNode</h4><p>Datanode 将 HDFS 数据以文件的形式存储在本地的文件系统中，它并不知道有 关 HDFS 文件的信息。它把每个 HDFS 数据块存储在本地文件系统的一个单独的文件 中。 Datanode 并不在同一个目录创建所有的文件，实际上，它用试探的方法来确定 每个目录的最佳文件数目，并且在适当的时候创建子目录。在同一个目录中创建所 有的本地文件并不是最优的选择，这是因为本地文件系统可能无法高效地在单个目 录中支持大量的文件。</p><p>当一个 Datanode 启动时，它会扫描本地文件系统，产生一个这些本地文件对应 的所有 HDFS 数据块的列表，然后作为报告发送到 Namenode ，这个报告就是块状态 报告。</p><h4 id="3-secondary-namenode"><a class="markdownIt-Anchor" href="#3-secondary-namenode"></a> 3 Secondary NameNode</h4><p>SecondaryNameNode不是说NameNode挂了的备用节点<br>。他的主要功能只是定期合并日志, 防止日志文件变得过大<br>。合并过后的镜像文件在NameNode上也会保存一份。</p><p>secondaryname作为一个附庸，其实它也一直在工作，他的工作就是解决matadata和fsimage之间的不和谐（不一致），这里为神马会使用到secondarynamenode来帮助namenode来管理namenode，原因是因为namenode不断的写，会产生大量的日志，若namenode重启，那么加载这些日志文件就会消耗大量的时间，而采用secondarynamenode处理过edits和faimage后，edits的大小始终保持一个比较小的水平，那么naemnode就算重启也可以快速启动而且保持前面的状态。</p><p>我们来看一下secondaryNameNode是如何工作的：</p><p><img src="https://i.imgur.com/fReOrLo.png" alt=""></p><ol><li>namenode 响应 Secondary namenode 请求，将 edit log 推送给 Secondary namenode ， 开始重新写一个新的 edit log</li><li>Secondary namenode 收到来自 namenode 的 fsimage 文件和 edit log</li><li>Secondary namenode 将 fsimage 加载到内存，应用 edit log ， 并生成一 个新的 fsimage 文件</li><li>Secondary namenode 将新的 fsimage 推送给 Namenode</li><li>Namenode 用新的 fsimage 取代旧的 fsimage ， 在 fstime 文件中记下检查 点发生的时</li></ol><p>关于hdfs的机制我们先简单介绍这么多，用多少先学多少等到后面接触的时候我们继续深入学习。</p><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面简单介绍了hadoop生态圈，大致了解hadoop是什么、能做什么。带着这些目的我们深入的去学习他。今天一起看一下hadoop的基石----文件存储。因为hadoop是运行与集群之上，处于分布式环境之中，所以他的文件存储也不同与普通的本地存储，而是分布式存储系统，HDF
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hadoop" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hadoop/"/>
    
    
      <category term="hadoop学习" scheme="http://blog.rickiyang.cn/tags/hadoop%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>hive基础知识</title>
    <link href="http://blog.rickiyang.cn/posts/88686410.html"/>
    <id>http://blog.rickiyang.cn/posts/88686410.html</id>
    <published>2018-05-16T14:15:00.000Z</published>
    <updated>2018-12-05T06:15:19.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hive基础知识"><a class="markdownIt-Anchor" href="#hive基础知识"></a> hive基础知识</h2><p>Hive是建立在 Hadoop上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），<br>这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。Hive定义了简单的类 SQL查询语言，称为HQL，<br>它允许熟悉SQL的用户查询数据。同时，这个语言也允许熟悉MapReduce开发者的开发自定义的mapper和reducer来处理<br>内建的mapper和reducer无法完成的复杂的分析工作。</p><h3 id="2为什么会产生hive"><a class="markdownIt-Anchor" href="#2为什么会产生hive"></a> 2.为什么会产生hive</h3><p>方便非java编程者（熟悉SQL语言）对hdfs的数据做mapreduce操作。</p><h3 id="3hive能做什么"><a class="markdownIt-Anchor" href="#3hive能做什么"></a> 3.hive能做什么</h3><p>数据仓库： 不与用户交互；存放历史数据；反范式设计，专门引入冗余数据，保证数据完整。数据仓库面向分析，里面存放的数据用来做分析和挖掘。<br>Hive是数据仓库，Hive将SQL转化为MapReduce可以识别的操作，承担解释器、编译器、优化器等角色，Hive运行时，元数据（表的结构、属性）存储在关系型数据库里面。因为元数据信息需要高效的读取。</p><h3 id="4初识hive"><a class="markdownIt-Anchor" href="#4初识hive"></a> 4.初识hive</h3><h4 id="41-hive数据类型"><a class="markdownIt-Anchor" href="#41-hive数据类型"></a> 4.1 hive数据类型</h4><p>hive支持的数据类型包括：</p><ul><li>基本类型：tinyint, smallint, int,bigint, boolean, float, double, string,varchar,char</li><li>复杂类型：struct，map，array,data,timestamp</li></ul><h4 id="42-hive数据模型"><a class="markdownIt-Anchor" href="#42-hive数据模型"></a> 4.2 hive数据模型</h4><p>hive支持四中数据模型：</p><ol><li>external table <b>外部表</b></li><li>table <b>默认为内部表</b></li><li>partion <b>分区表</b></li><li>bucket <b>桶表</b></li></ol><p>内部表：<br><br>为指定表为别的形式的表默认都为内部表，hive会为其建立一个相应的目录保存。删除表时，元数据和数据都会被删除。<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span> (<span class="keyword">name</span> <span class="keyword">string</span> , age <span class="keyword">string</span>) location  <span class="string">'/input/table_data'</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/input/data'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">test</span> ;</span><br></pre></td></tr></table></figure><p>load命令会将/input/data下的数据加载到/input/table_data目录下，当删除test表的时候test表数据和/input/table_data下的数据都被删除。当然/input/data下也没有数据。如果创建内部表的时候没有指定location，就会在hdfs/hive，hdfs的默认目录下新建一个表目录。</p><p>注：本质上load data会转移数据。</p><p>外部表:<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> etest (<span class="keyword">name</span> <span class="keyword">string</span> , age <span class="keyword">string</span>);</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/input/edata'</span> <span class="keyword">into</span> <span class="keyword">table</span> etest;</span><br></pre></td></tr></table></figure><p>当把/input/edata下的数据转移到hdfs的默认目录后执行删除操作，默认目录中已经载入的数据不会被删除，但是/input/edata下的数据已经没有了，相当于做了一次剪切操作。</p><p>分区表：<br><br>hive的表在hdfs上是对应一个文件目录保存的，当使用hive进行查询的时候会对该目录下的文件进行全表扫描，这样是很浪费性能的，这样就引入了partion(分区)和bucket(桶)的概念。</p><p>分区表是指创建表时，指定partition的分区空间:</p><pre><code>partition by(字段名 字段类型)</code></pre><p>分区表又分动态分区和静态分区，静态分区要求在建表的时候指定分区字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dyn_part_test_spark(</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">score <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (</span><br><span class="line">grade <span class="keyword">string</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure><p>在装载完数据之后，分区的列grade和class所对应的值会生成若干个子目录，假如有如下插入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> dyn_part_test_spark <span class="keyword">partition</span>(grade=<span class="string">'grade1'</span>,<span class="keyword">class</span>=<span class="string">'class1'</span>)</span><br></pre></td></tr></table></figure><p>那么查询的时候数据就位于grade1目录下的class1目录里面。</p><p>但是静态分区会有一个问题，那就是在分区之前对应分区的值是需要被确定的，即partition后面的值需要被确定。当值有很多个的时候，就需要重复执行很多类似于上面insert语句这样的插入语句。即在插入的时候需要指定你要插入那个分区，不然插入失败。</p><p>为了解决这个问题，所以提出了动态分区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_created_dynamic_partition (</span><br><span class="line">    orderNumber <span class="keyword">STRING</span>,</span><br><span class="line">    event_time  <span class="keyword">STRING</span></span><br><span class="line">)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (event_month <span class="keyword">string</span>);</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> dyn_part_test_spark <span class="keyword">partition</span>(grade,<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><p>注意到insert语句后面没有指定具体的值，执行成功以后hdfs就会生成相应值对应的文件夹。这就是动态分区的好处。</p><p>要让hive表自动生成分区需要配置开启动态分区，配置如下：</p><pre><code>SET hive.exec.dynamic.partition=true;         //是否开启动态分区，默认为falseSET hive.exec.dynamic.partition.mode=nonstrict; //动态分区的模式，默认为strictSET hive.exec.max.dynamic.partitions.pernode = 1000;//在每个执行MR的节点上最大可创建分区个数，默认值100SET hive.exec.max.dynamic.partitions=1000;//在所有执行MR的节点上，最大可创建多少分区，默认1000</code></pre><p>桶表：<br><br>对于每一个表或者是分区可以进一步组织为桶。在分桶时，对指定字段进行hash运算得到hash值，用hash值除以桶个数取余得到的值作为分桶依据。余数相同的数据会分到同一个桶。做hash运算时hash函数的选择取决于分桶字段的数据类型。分桶之后的查询效率比分区之后的效率要高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="keyword">string</span>, tno <span class="keyword">string</span>,age <span class="built_in">INT</span>)</span><br><span class="line">partitioned <span class="keyword">by</span> (work_date <span class="keyword">string</span>)</span><br><span class="line">clustered <span class="keyword">by</span> (<span class="keyword">id</span>) sorted <span class="keyword">by</span> (<span class="keyword">name</span>) <span class="keyword">into</span> <span class="number">2</span> buckets</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure><p>hive中的table可以拆分为partition,table和partition可以进一步的通过&quot;clustered by&quot;拆分为桶，桶中的数据可以通过&quot;sorted by&quot;进行排序。比如上面的sql语句中通过id进行分桶，每个桶中的数据通过id进行排序。</p><p>插入数据：<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建中间表并插入数据</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp_teacher(<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="keyword">string</span>, tno <span class="keyword">string</span>,age <span class="built_in">INT</span>);</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/data/input/'</span> <span class="keyword">into</span> <span class="keyword">table</span> tmp_teacher;</span><br><span class="line">//将临时表的数据插入到桶表中</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> teacher <span class="keyword">select</span> * <span class="keyword">from</span> tmp_teacher;</span><br><span class="line">//修改桶表中bucket的数量    </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> teacher clustered <span class="keyword">by</span>(<span class="keyword">name</span>) sorted <span class="keyword">by</span>(age) <span class="keyword">into</span> <span class="number">10</span> buckets;</span><br></pre></td></tr></table></figure><h4 id="43-hive基本操作"><a class="markdownIt-Anchor" href="#43-hive基本操作"></a> 4.3 hive基本操作</h4><p><strong>创建库</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> userdb location <span class="string">'/local/path/'</span> <span class="keyword">comment</span> <span class="string">'is coment message'</span>;</span><br></pre></td></tr></table></figure><p><strong>显示数据库的路径</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span> <span class="keyword">database</span> userdb;</span><br></pre></td></tr></table></figure><p><strong>删除数据库</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> userdb;</span><br></pre></td></tr></table></figure><p>默认情况下，hive是不允许删除含有表的数据库，首先删除表，之后在命令行使用‘CASCADE’关键词，同样可以使用‘RESTRICT’：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> userdb <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure><p><strong>建表</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_order (order_sn <span class="keyword">string</span>, user_id <span class="keyword">string</span>,amount <span class="built_in">int</span>,create_time <span class="built_in">timestamp</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></span><br><span class="line">location <span class="string">'/external/hive/t_order'</span>;</span><br></pre></td></tr></table></figure><p>建表指定导入数据的存储格式为每一列中间使用空格分开。<br>导入数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/root/order.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> t_order;</span><br></pre></td></tr></table></figure><p>order.txt的内容如下：</p><pre><code>3016080910 30086 10 2016-08-19 11:50:503016080911 30086 11 2016-08-19 11:51:223016080912 30000 93016080913 30000 2016-08-19 11:52:123016080914 30010 5rmb 2016-08-19 11:53:59</code></pre><p>我们看到数据中第三第四列是有数据缺失的，第五列有数据格式错误，但是我们执行数据插入之后查询发现：</p><pre><code>hive&gt; select * from t_order;3016080910 30086 10 2016-08-19 11:50:50 NULL    NULL    NULL3016080911 30086 11 2016-08-19 11:51:22 NULL    NULL    NULL3016080912 30000 9      NULL    NULL    NULL3016080913 30000 2016-08-19 11:52:12    NULL    NULL    NULL3016080914 30010 NULL 2016-08-19 11:53:59       NULL    NULL    NULLTime taken: 2.144 seconds, Fetched: 5 row(s)</code></pre><p>数据缺失和格式错误的列会自动改为为NULL值。<br>如果数据文件原本就在hdfs上，当我们加载hdfs上的数据到创建的（内部）表的时候，直接将文件移动到该hdfs文件夹下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/order.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> t_order;</span><br></pre></td></tr></table></figure><p>加载后，文件被移动到了对应表的hdfs文件夹下,同样可以直接查询到新增加的数据。<br>external类型的表,表对应的是文件夹，对于文件的位置不做任何限制，放到hdfs任何位置都可以。</p><p><strong>创建临时表</strong>：</p><p>创建表时通过SQL语句得到表结构和数据,用于创建一些临时表存储中间结果,这样的表在hdfs中有相应的目录结构和文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_order_tmp</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> order_sn,user_id <span class="keyword">from</span> t_order;</span><br></pre></td></tr></table></figure><p>这样会将从t_order中查询出来的两列作为t_order_tmp表的列并创建t_order_tmp表。</p><p><strong>复制表结构</strong>（只能复制表结构，无法复制表的内容）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_order_like <span class="keyword">like</span> t_order;</span><br></pre></td></tr></table></figure><p><strong>insert into 是追加数据,overwrite是覆盖写所有表。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> t_order_like <span class="keyword">select</span> * <span class="keyword">from</span> t_order;</span><br></pre></td></tr></table></figure><p><strong>创建分区表</strong></p><blockquote><p>PARTITION(分区)添加一个新字段作为分区字段，在hdfs中表现为在t_order_part文件夹下创建以分区命名的文件夹，只能在创建表的时候就指定好（<em>partitioned关键字必须在row format 之前</em>）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_order_part (order_sn <span class="keyword">string</span>, user_id <span class="keyword">string</span>,amount <span class="built_in">int</span>,create_time <span class="built_in">timestamp</span>)</span><br><span class="line">partitioned <span class="keyword">by</span> (<span class="keyword">month</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure><p>数据集如下：</p><pre><code>2016080910 10086 10 2016-08-19 11:50:50 201608202016080911 10086 11 2016-08-19 11:51:22 201608202016080912 10000 9 2016-08-19 11:51:42 201608202016080913 10000 20 2016-08-19 11:52:12 201608202016080914 10010 100 2016-08-19 11:53:59 201608202016080910 10086 10 2016-08-19 11:50:50 201608212016080911 10086 11 2016-08-19 11:51:22 201608212016080912 10000 9 2016-08-19 11:51:42 201608212016080913 10000 20 2016-08-19 11:52:12 201608212016080914 10010 100 2016-08-19 11:53:59 20160821</code></pre><p>加载数据集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/usr/local/order.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> t_order_part <span class="keyword">partition</span> (<span class="keyword">month</span>=<span class="string">'20160820'</span>);</span><br></pre></td></tr></table></figure><p>因为建表的时候没有指定动态分区，静态分区需要在加载数据集的时候手动指定数据插入那个分区。</p><p><strong>hive函数</strong></p><p>操作符：</p><ol><li>关系操作符，如=、!=、&gt;、&lt;、is null、is not null、like、rlike</li><li>数学操作符，如+、-、*、/、%、&amp;、|、^、~</li><li>逻辑操作符，如and、or、not、&amp;&amp;、|、!</li><li>复杂类型操作符，如array[iter]、map[key]、struct.sub_item</li></ol><p>函数：</p><ol><li>数学函数，如rand()、ln()、sqrt()、abs()、sin()</li><li>字符串函数，如concat_ws()、length()、lower()、ltrim()、reverse()</li><li>日期函数，如year()、unix_timestamp()</li><li>聚合函数，如count([distinct])、sum()、avg()、max()</li><li>条件函数，if(condition, value_true, value_false)、case when a then b when c then d else e end、case a when b then c when d then e else f end</li><li>类型转换函数，如binary()、cast()</li><li>复杂类型函数，如size()、sort_array()</li></ol><p>相关命令行：</p><ol><li>SHOW FUNCTIONS – 列出目前hive中所有函数</li><li>DESCRIBE FUNCTION function_name  – 显示函数简单描述</li><li>DESCRIBE FUNCTION EXTENDED function_name – 获取函数详细描述</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hive基础知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hive基础知识&quot;&gt;&lt;/a&gt; hive基础知识&lt;/h2&gt;
&lt;p&gt;Hive是建立在 Hadoop上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ET
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hive" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hive/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习(一)----概念和整体架构</title>
    <link href="http://blog.rickiyang.cn/posts/d538d95c.html"/>
    <id>http://blog.rickiyang.cn/posts/d538d95c.html</id>
    <published>2018-05-04T03:20:12.000Z</published>
    <updated>2018-12-13T02:14:20.608Z</updated>
    
    <content type="html"><![CDATA[<p>程序员就得不停地学习啊，故步自封不能满足公司的业务发展啊！所以我们要有搞事情的精神。都说现在是大数据的时代，可以我们这些码农还在java的业务世界里面转悠呢。好不容易碰到一个可能会用到大数据技术的场景时可惜你又没这个技术把这一票接下来！书到用时方恨少。所以我们也要与时代同进步，搞搞大数据。分布式的基础架构现在有hadoop和spark。虽然spark目前比较火，但是国内大厂因为最开始学习大数据的先锋们给公司搭架构都是使用hadoop，以至于spark火起来都不能撼动hadoop的地位（大家不会吃饱了没事干把底层重新返工一遍！），所以导致spark在国内应用并不是很广。再有就是hadoop目前的版本已经到了正式版2.8，测试版3.0。但是问题在于hadoop1.x和hadoop2.x的底层架构不一样！稍后我会讲到。面对这些问题我们要做的当然是学新的兼顾旧的（不学新的就是倒退）。所以下面我们会一直使用hadoop2.x的版本。</p><h3 id="1hadoop是什么"><a class="markdownIt-Anchor" href="#1hadoop是什么"></a> 1.hadoop是什么</h3><p>是什么呢？就是一个棕黄色玩具大象的名字。这是真的！hadoop的作者Doug Cutting说的，这是他儿子的玩具的名字。（是不是太随意了，想想国人取名字的场景。。。）我们回到正轨，hadoop是世界上最大的富豪Apache捐助的分布式系统基础架构。该框架由java语言设计实现，用以实现在大量计算机组成的集群中对海量数据进行分布式计算。Hadoop得以在大数据处理应用中广泛应用得益于其自身在数据提取、变形和加载(ETL)方面上的天然优势。Hadoop的分布式架构，将大数据处理引擎尽可能的靠近存储。</p><p>不知道大家有没有听说Nutch这个框架。如果有人使用java做爬虫就应该知道！该框架的作者就是Doug Cutting。hadoop也起源于Nutch并且借鉴了Google于2003年发表的GFS和MapReduce相关论文。有兴趣的可以翻出去看一下。</p><h4 id="11-hadoop简介"><a class="markdownIt-Anchor" href="#11-hadoop简介"></a> 1.1 hadoop简介</h4><p>我们先看一下hadoop1.x的生态系统：</p><p><img src="https://i.imgur.com/yuRDWi1.jpg" alt=""></p><p><strong>我们对上面各个模块做一些简要说明：</strong></p><ul><li>Ambari：基于web的Hadoop集群安装，部署，管理，监控工具。</li><li>HDFS：分布式文件系统，提供数据容错和对数据的高吞吐率访问。</li><li>MapReduce：分布式，并行编程模型。将任务分为map和reduce两个阶段，从而实现每个阶段对数据的并行处理。</li><li>ZooKeeper：高性能的分布式应用程序协调服务，是google的chubby的一个开源实现。</li><li>HBase：基于HDFS的面向列存储的分布式数据库，用于快速读写大量数据。</li><li>Hive：以类SQL语言提供实时大规模数据实时查询的数据仓库。</li><li>Pig：提供高级数据流语言和计算框架来代替mapreduce任务的编写。</li><li>Mahout：可扩展的基于mapreduce的机器学习和数据挖掘库。</li><li>Flume：高可用，高可靠，分布式的海量日志采集、聚合和传输的系统。提供对数据进行简单处理，并写到各种数据接收方的能力。</li><li>Sqoop：用于在关系数据库，数据仓库和Hadoop文件系统之间转移数据的工具。</li></ul><p>我们再来看一下hadoop2.x系统架构：</p><p><img src="https://i.imgur.com/iScFVNa.jpg" alt=""></p><h3 id="2核心模块说明"><a class="markdownIt-Anchor" href="#2核心模块说明"></a> 2.核心模块说明</h3><h4 id="21-hadoop1x-hdfs模块"><a class="markdownIt-Anchor" href="#21-hadoop1x-hdfs模块"></a> 2.1 hadoop1.x----hdfs模块</h4><p>HDFS作为分布式文件系统的一种，设计之初就是针对适合一次写入，多次查询的情况。<strong>不支持并发写，不适用于小文件存储</strong>，低时延的数据访问。HDFS包含3个部分：</p><ul><li><strong>NameNode节点</strong></li><li><strong>SecondaryNameNode节点</strong></li><li><strong>DataNode节点</strong></li></ul><p>NameNode负责存储数据文件的元数据；<br>SecondaryNameNode作为NameNode的冷备份，负责合并NameNode上的fsimage和edits文件，再发送给NameNode；<br>DataNode负责存储实际的数据块。</p><p>NameNode负责管理文件系统目录结构，接受客户端的文件操作请求。NameNode维护两套数据：<br>一套是文件目录与数据块之间的对应关系<br>一套是数据块与存储节点之间的对应关系。<br>前一套数据是静态的，存放在磁盘上，通过fsimage和edits文件来维护；后一套是动态的，在集群重启时会在内存自动建立这些信息。其中fsimage存储的是某一时段NameNode内存元数据信息（配置时通过hdfs-default.xml中的dfs.name.dir选项设置）；edits记录操作日志文件（配置时通过hdfs-default.xml的dfs.name.edits.dir选项设置）；fstime保存最近一次checkpoint的时间。</p><p>DataNode负责按Block存储数据文件。每一个数据文件都会按照Block大小进行划分，每个Block都会进行多副本备份（一般为三份）。通常多个副本会按照一定的策略放在不同的DataNode节点上，配置时通过hdfs-default.xml的dfs.data.dir选项设置。<br>总体架构如下：</p><p><img src="https://i.imgur.com/PwqMwBG.png" alt=""></p><p>HDFS1.x中存在的问题：</p><ul><li><strong>NameNode单点故障，难以应用于在线场景</strong></li><li><strong>NameNode压力过大，且内存受限，影响系统可扩展性</strong></li></ul><h4 id="22-hadoop1x-mapreduce模块"><a class="markdownIt-Anchor" href="#22-hadoop1x-mapreduce模块"></a> 2.2 hadoop1.x----MapReduce模块</h4><p>MapReduce 框架的核心步骤主要包括两部分：Map 和Reduce。当你向MapReduce 框架提交一个计算作业时，它会首先把计算作业拆分成若干个Map 任务，然后分配到不同的节点上去执行，每一个Map 任务处理输入数据中的一部分，当Map 任务完成后，它会生成一些中间文件，这些中间文件将会作为Reduce 任务的输入数据。Reduce任务会对主要对若干个map任务的输出进行汇总。整个数据流图如下：</p><p><img src="https://i.imgur.com/1UU3kjX.png" alt=""></p><p>MapReduce作业涉及两个重要的实体：</p><ul><li><strong>JobTracker：初始化作业，分配作业，与TaskTracker通信，调度整个作业的执行。</strong></li><li><strong>TaskTracker：保持与JobTracker的通信，在分配的数据片段上执行Map或Reduce任务。</strong></li></ul><p>我们简单看一下mapreduce作业的运行过程：</p><p><img src="https://i.imgur.com/Ueztvt9.png" alt=""></p><p>上图中整体流程如下：</p><ol><li>在集群中的任意一个节点提交MapReduce程序；</li><li>JobClient收到作业后，JobClient向JobTracker请求获取一个Job ID；</li><li>将运行作业所需要的资源文件复制到HDFS上（包括MapReduce程序打包的JAR文件、配置文件和客户端计算所得的输入划分信息），这些文件都存放在JobTracker专门为该作业创建的文件夹中，文件夹名为该作业的Job ID；</li><li>获得作业ID后，提交作业；</li><li>JobTracker接收到作业后，将其放在一个作业队列里，等待作业调度器对其进行调度，当作业调度器根据自己的调度算法调度到该作业时，会根据输入划分信息为每个划分创建一个map任务，并将map任务分配给TaskTracker执行；</li><li>对于map和reduce任务，TaskTracker根据主机核的数量和内存的大小有固定数量的map槽和reduce槽。这里需要强调的是：map任务不是随随便便地分配给某个TaskTracker的，这里有个概念叫：<strong>数据本地化（Data-Locality）</strong>，意思是：将map任务分配给含有该map处理的数据块的TaskTracker上，同时将程序JAR包复制到该TaskTracker上来运行，这叫“运算移动，数据不移动”；</li><li>TaskTracker每隔一段时间会给JobTracker发送一个心跳，告诉JobTracker它依然在运行，同时心跳中还携带着很多的信息，比如当前map任务完成的进度等信息。当JobTracker收到作业的最后一个任务完成信息时，便把该作业设置成“成功”。当JobClient查询状态时，它将得知任务已完成，便显示一条消息给用户；</li><li>运行的TaskTracker从HDFS中获取运行所需要的资源，这些资源包括MapReduce程序打包的JAR文件、配置文件和客户端计算所得的输入划分等信息；</li><li>TaskTracker获取资源后启动新的JVM虚拟机，运行每一个任务。</li></ol><p>MapReduce1.x存在的问题：</p><ul><li><strong>JobTracker访问压力大，影响系统可扩展性</strong></li><li><strong>难以支持出MapReduce之外的其他计算框架，如Spark，Storm</strong></li></ul><h4 id="23-hadoop2x-hsfs模块"><a class="markdownIt-Anchor" href="#23-hadoop2x-hsfs模块"></a> 2.3 hadoop2.x----HSFS模块</h4><p>HDFS2针对HDFS1中问题的主要改进是提供了NameNode HA和NameNode Federation。</p><ul><li>NameNode HA：主备NameNode解决单点故障，主NameNode对外提供服务，备NameNode同步主NameNode元数据以待切换，所有DataNode同时向两个NameNode汇报数据块信息</li></ul><p><img src="https://i.imgur.com/GgKnaWq.png" alt=""></p><ul><li>NameNode Federation：把元数据的存储和管理分散到多个节点上，每个NameNode管理文件系统命名空间的一部分，实现NameNode横向扩展，把单个NameNode的负载分散到多个节点上。</li></ul><p><img src="https://i.imgur.com/DKQUxVy.png" alt=""></p><h4 id="24-hadoop2xyarn模块"><a class="markdownIt-Anchor" href="#24-hadoop2xyarn模块"></a> 2.4 hadoop2.x—Yarn模块</h4><p>Hadoop2.x为了改进1.x中MapReduce的缺点，促进框架的长远发展，从0.23.0版本开始，对MapReduce框架进行完全重构，并将新框架命名为Yarn（Yet Another Resource Negotiator），主要思想是将资源管理和任务调度监控划分到不同的组件中，整体架构如下图，包含三个主要组件ResourceManager，ApplicationMaster，NodeManager。</p><p><img src="https://i.imgur.com/sCjMD7t.png" alt=""></p><ul><li>ResourceManager：基于应用程序对资源（内存，CPU，磁盘，网络等）的需求进行集群资源的仲裁，RM 会追踪集群中有多少可用的活动节点和资源，协调用户提交的哪些应用程序应该在何时获取这些资源，每一个应用程序需要不同类型的资源因此就需要不同的容器。包含ResourceScheduler（根据容量、队列等限制条件，将系统中的资源分配给各个正在运行的应用程序）和Applications Manager（负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动ApplicationMaster、监控</li><li>ApplicationMaster运行状态并在失败时重新启动它等）l两个组件。</li><li>ApplicationMaster：向RM和NodeManager要求启动占用一定资源的Container，跟踪协调应用程序（MR作业，DAG作业）中所有任务的执行。</li><li>NodeManager：每个节点的框架代理，启动执行应用程序的容器，监控应用程序的资源使用情况，并向调度器汇报。</li></ul><p><img src="https://i.imgur.com/u12HYc1.png" alt=""></p><p>yarn工作流程：</p><ol><li><p>用户向YARN中提交应用程序，其中包括ApplicationMaster程序、启动ApplicationMaster的命令、用户程序等。</p></li><li><p>ResourceManager为该应用程序分配第一个Container，并与对应的Node-Manager通信，要求它在这个Container中启动应用程序的ApplicationMaster。</p></li><li><p>ApplicationMaster首先向ResourceManager注册，这样用户可以直接通过ResourceManager查看应用程序的运行状态，然后它将为各个任务申请资源，并监控它的运行状态，直到运行结束，即重复步骤4~7。</p></li><li><p>ApplicationMaster采用轮询的方式通过RPC协议向ResourceManager申请和领取资源。</p></li><li><p>一旦ApplicationMaster申请到资源后，便与对应的NodeManager通信，要求它启动任务。</p></li><li><p>NodeManager为任务设置好运行环境（包括环境变量、JAR包、二进制程序等）后，将任务启动命令写到一个脚本中，并通过运行该脚本启动任务。</p></li><li><p>各个任务通过某个RPC协议向ApplicationMaster汇报自己的状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。 在应用程序运行过程中，用户可随时通过RPC向ApplicationMaster查询应用程序的当前运行状态。</p></li><li><p>应用程序运行完成后，ApplicationMaster向ResourceManager注销并关闭自己。</p></li></ol><p><strong>hadoop2.x—pig模块</strong></p><p>Pig提供类SQL语言（Pig Latin）通过MapReduce来处理大规模半结构化数据。而Pig Latin是更高级的过程语言，通过将MapReduce中的设计模式抽象为操作，如Filter，GroupBy，Join，OrderBy，由这些操作组成有向无环图（DAG）。例如如下程序：</p><pre><code>visits = load ‘/data/visits’ as (user, url, time);gVisits  = group visits by url;visitCounts  = foreach gVisits generate url, count(visits);urlInfo  = load ‘/data/urlInfo’ as (url, category, pRank);visitCounts  = join visitCounts by url, urlInfo by url;gCategories = group visitCounts by category;topUrls = foreach gCategories generate top(visitCounts,10);store topUrls into ‘/data/topUrls’;</code></pre><p>描述了数据处理的整个过程。</p><p>而Pig Latin又是通过编译为MapReduce，在Hadoop集群上执行的。上述程序被编译成MapReduce时，会产生如下图所示的Map和Reduce：</p><p><img src="https://i.imgur.com/rIOWveN.png" alt=""></p><p>Pig解决了MapReduce存在的大量手写代码，语义隐藏，提供操作种类少的问题。类似的项目还有Cascading，JAQL等。</p><h4 id="25-hadoop2xtez模块"><a class="markdownIt-Anchor" href="#25-hadoop2xtez模块"></a> 2.5 hadoop2.x—Tez模块</h4><p>Apache Tez，Tez是HortonWorks的Stinger Initiative的的一部分。作为执行引擎，Tez也提供了有向无环图（DAG），DAG由顶点（Vertex）和边（Edge）组成，Edge是对数据的移动的抽象，提供了One-To-One，BroadCast，和Scatter-Gather三种类型，只有Scatter-Gather才需要进行Shuffle。<br>以如下SQL为例：</p><pre><code>SELECT a.state, COUNT(*),AVERAGE(c.price)FROM aJOIN b ON (a.id = b.id)JOIN c ON (a.itemId = c.itemId)GROUP BY a.state</code></pre><p><img src="https://i.imgur.com/XuOuA08.png" alt=""></p><p>图中蓝色方块表示Map，绿色方块表示Reduce，云状表示写屏障（write barrier，一种内核机制，可以理解为持久的写），Tez的优化主要体现在：</p><ol><li>去除了连续两个作业之间的写屏障</li><li>去除了每个工作流中多余的Map阶段（Stage）</li></ol><p>通过提供DAG语义和操作，提供了整体的逻辑，通过减少不必要的操作，Tez提升了数据处理的执行性能。</p><p>上面简单说了一下hadoop的框架和重要模块。其实说了这么久hadoop，你到底知不知道hadoop是干嘛的？弄清这个问题很重要哈。学以致用，用到了才算。文上我们也说了是在大数据的场景中诞生hadoop。那么什么是大数据呢？大数据的实质特性：<strong>针对增量中海量的结构化，非结构化，半结构数据</strong>，在这种情况下，如何快速反复计算挖掘出高效益的市场数据？</p><p>带着这个问题渗透到业务中去分析，就知道hadoop需要应用到什么业务场景了！！！如果关系型数据库都能应付的工作还需要hadoop吗？</p><p>我们举一些例子：</p><ol><li><p>银行的信用卡业务，当你正在刷卡完一笔消费的那一瞬间，假如在你当天消费基础上再消费满某个额度，你就可以免费获得某种令你非常满意的利益等等，你可能就会心动再去消费，这样就可能提高银行信用卡业务，那么这个消费额度是如何从海量的业务数据中以秒级的速度计算出该客户的消费记录，并及时反馈这个营销信息到客户手中呢？这时候关系型数据库计算出这个额度或许就需要几分钟甚至更多时间，就需要hadoop了，这就是所谓的“秒级营销”. 针对真正的海量数据，一般不主张多表关联。</p></li><li><p>在淘宝，当你浏览某个商品的时候，它会及时提示出你感兴趣的同类商品的产品信息和实时销售情况，这或许也需要用到hadoop.</p></li><li><p>.谷歌搜索引擎分析的时候应该也会用到。</p></li></ol><p><strong>hadoop 主要用于大数据的并行计算</strong>：</p><ol><li><p>数据密集型并行计算：数据量极大，但是计算相对简单的并行处理<br>如：大规模Web信息搜索</p></li><li><p>计算密集型并行计算：数据量相对不是很大，但是计算较为复杂的并行计算<br>如：3-D建模与渲染，气象预报，科学计算</p></li><li><p>数据密集与计算密集混合型的并行计算<br>如：3－D电影的渲染</p></li></ol><p><strong>hadoop主要应用于数据量大的离线场景</strong>。特征为：</p><p>1、数据量大。一般真正线上用Hadoop的，集群规模都在上百台到几千台的机器。这种情况下，T级别的数据也是很小的。Coursera上一门课了有句话觉得很不错：Don’t use hadoop, your data isn’t that big</p><p>2、离线。（<strong>大数据不等于高并发</strong>）Mapreduce框架下，很难处理实时计算，作业都以日志分析这样的线下作业为主。另外，集群中一般都会有大量作业等待被调度，保证资源充分利用。</p><p>3、数据块大。由于HDFS设计的特点，Hadoop适合处理文件块大的文件。大量的小文件使用Hadoop来处理效率会很低。</p><p>举个例子，百度每天都会有用户对侧边栏广告进行点击。这些点击都会被记入日志。然后在离线场景下，将大量的日志使用Hadoop进行处理，分析用户习惯等信息。</p><p><strong>总的来说Hadoop适合应用于大数据存储和大数据分析的应用，适合于服务器几千台到几万台的集群运行，支持PB级的存储容量</strong>。</p><p><strong>Hadoop典型应用有：搜索、日志处理、推荐系统、数据分析、视频图像分析、数据保存等。</strong></p><p>所以各位hadoop的应用场景还是有限的，不是任一个场景都可以上hadoop哈。适得其反就不好了。</p><p>Hadoop诞生至今已经十一年，经历了两次重大的版本更新，版图不断扩张，期间也经历了来自其他开源黑马的冲击。Spark在早期发展阶段通过全面兼容Hadoop从而发展成为成熟的生态系统，但Hadoop实际上已经拥抱了Spark技术，积极地适应着不同计算范式的软件平台。此外，Hadoop的商业化也滋养了成千上万的企业，比如Cloudera，Hortonworks，MapR。毫无疑问，Hadoop在这十一年已经是大数据的代名词，大数据的王者，大数据时代软件开发者的必备技能。我们作为技术人员在有这么多前辈无私贡献自己的知识的基础上，应该在有限的时间里多了解这些开源技术，追上时代的步伐！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序员就得不停地学习啊，故步自封不能满足公司的业务发展啊！所以我们要有搞事情的精神。都说现在是大数据的时代，可以我们这些码农还在java的业务世界里面转悠呢。好不容易碰到一个可能会用到大数据技术的场景时可惜你又没这个技术把这一票接下来！书到用时方恨少。所以我们也要与时代同进
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hadoop" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hadoop/"/>
    
    
      <category term="hadoop学习" scheme="http://blog.rickiyang.cn/tags/hadoop%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Scala文件读写（五）</title>
    <link href="http://blog.rickiyang.cn/posts/596588bb.html"/>
    <id>http://blog.rickiyang.cn/posts/596588bb.html</id>
    <published>2018-04-29T12:43:27.000Z</published>
    <updated>2019-01-07T01:48:18.201Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1读取文件"><a class="markdownIt-Anchor" href="#1读取文件"></a> 1.读取文件</h4><p>在Scala中有两种基本方式可以打开并读取文件：</p><ol><li>使用一个仅一行的代码，这种方式有个副作用-文件不会被自动关闭，对于那些生命周期很短的程序比如shell脚本可以使用。</li><li>使用稍长些的代码，确保文件流会被关闭。</li></ol><p>使用简洁语法：</p><pre><code>var fileName = &quot;c:/1.txt&quot;//每次读取一行for(line &lt;- Source.fromFile(fileName).getLines()){  println(line)}//将所有的行转为一个列表val txt = Source.fromFile(fileName).getLines().toListprintln(txt)//将所有的内容当做一个字符串读取val txt1 = Source.fromFile(fileName).getLines().mkStringprintln(txt1)结果：白日依山尽 尽黄河List(白日依山尽 尽, 黄河)白日依山尽 尽黄河Process finished with exit code 0</code></pre><p>文件流会伴随JVM的生命周期。</p><p>确保文件流会被关闭的步骤：</p><pre><code>var fileName = &quot;c:/1.txt&quot;val bufferSource = Source.fromFile(fileName)for(line &lt;- bufferSource.getLines()){  println(line)}bufferSource.close()</code></pre><p>需要手动的调用文件流的close方法。</p><h4 id="2写入文件"><a class="markdownIt-Anchor" href="#2写入文件"></a> 2.写入文件</h4><p>Scala不提供写入文件的能力，但是你可以使用Java的字符流来写文件，比如：BufferedWriter,PrintWriter,或者FileWriter。</p><pre><code>var fileName = &quot;c:/1.txt&quot;val pw = new PrintWriter(new File(fileName))pw.write(&quot;我是PrintWriter&quot;)pw.close()val fileWriter = new FileWriter(fileName)fileWriter.write(&quot;我是FileWriter&quot;)fileWriter.close()val bufferedWriter = new BufferedWriter(new FileWriter(fileName))bufferedWriter.write(&quot;我是BufferWriter&quot;)bufferedWriter.close()val outputStreamWriter = new OutputStreamWriter(new FileOutputStream(fileName))outputStreamWriter.write(&quot;我是outputStream&quot;)outputStreamWriter.close()</code></pre><h4 id="3-序列化"><a class="markdownIt-Anchor" href="#3-序列化"></a> 3. 序列化</h4><p>Scala的序列号方式和Java一样，继承Serilizable接口。但是在实现上有一些区别：</p><pre><code>@SerialVersionUID(100L)class User extends Serializable{}</code></pre><p>需要将@SerialVersionUID(100L)标注添加到类上。因为Serializable是一个特质，所以可以将他混入任何类中，即使这个类已经继承了别的类：</p><pre><code>@SerialVersionUID(100L)class User extends OldUser with Serializable{}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1读取文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1读取文件&quot;&gt;&lt;/a&gt; 1.读取文件&lt;/h4&gt;
&lt;p&gt;在Scala中有两种基本方式可以打开并读取文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用一个仅一行的代码，这种方式有个副作用-文件不
      
    
    </summary>
    
      <category term="scala" scheme="http://blog.rickiyang.cn/categories/scala/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="scala学习" scheme="http://blog.rickiyang.cn/tags/scala%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Scala集合（四）</title>
    <link href="http://blog.rickiyang.cn/posts/c3007ea1.html"/>
    <id>http://blog.rickiyang.cn/posts/c3007ea1.html</id>
    <published>2018-04-26T15:12:08.000Z</published>
    <updated>2019-01-07T01:48:18.201Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-集合"><a class="markdownIt-Anchor" href="#1-集合"></a> 1. 集合</h4><p>集合主要有三种：</p><ol><li>Sequence</li><li>Map</li><li>Set</li></ol><p>sequence是一种线性元素的集合，可能会是索引或者线性的（链表）。map是包含键值对的集合，就像Java的Map,set是包含无重复元素的集合。</p><p>除了这三个主要的集合类之外，还有其他有用的集合类型，如Stack, Queue和Range。还有其他一些用起来像集合的类，如元组、枚举、Option/Some/None以及Try/Success/Failure类。</p><p>Scala通用的序列集合：</p><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-us36{border-color:inherit;vertical-align:top}</style><table class="tg">  <tr>    <th class="tg-us36"></th>    <th class="tg-us36">不可变(Immutable)</th>    <th class="tg-us36">可变</th>  </tr>  <tr>    <td class="tg-us36">索引(Indexed)</td>    <td class="tg-us36">Vector</td>    <td class="tg-us36">ArrayBuffer</td>  </tr>  <tr>    <td class="tg-us36">线性链表(Linked lists)</td>    <td class="tg-us36">List</td>    <td class="tg-us36">ListBuffer</td>  </tr></table><p>主要不可变序列集合类：</p><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-us36{border-color:inherit;vertical-align:top}.tg .tg-yw4l{vertical-align:top}</style><table class="tg" style="undefined;table-layout: fixed; width: 690px"><colgroup><col style="width: 147px"><col style="width: 67px"><col style="width: 82px"><col style="width: 394px"></colgroup>  <tr>    <th class="tg-us36"></th>    <th class="tg-us36">索引序列</th>    <th class="tg-us36">线性序列</th>    <th class="tg-yw4l">描述</th>  </tr>  <tr>    <td class="tg-us36">List</td>    <td class="tg-us36"></td>    <td class="tg-us36">√</td>    <td class="tg-yw4l">一个单链表。适于拆分头和剩余链表的递归算法</td>  </tr>  <tr>    <td class="tg-yw4l">Queue</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">先进先出数据结构</td>  </tr>  <tr>    <td class="tg-yw4l">Range</td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">整数值范围</td>  </tr>  <tr>    <td class="tg-yw4l">Stack</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">后进先出</td>  </tr>  <tr>    <td class="tg-yw4l">Stream</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">与链表相似，但是延迟并且持久。适用于大型或无限序列，与<br>Haskell的链表类似</td>  </tr>  <tr>    <td class="tg-yw4l">String</td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">可以被当作一个不可变的，索引的字符序列</td>  </tr>  <tr>    <td class="tg-us36">Vector</td>    <td class="tg-us36">√</td>    <td class="tg-us36"></td>    <td class="tg-yw4l">“定位”不可变，可索引的序列。Scaladoc这样描述它， “处<br>理split和join非常有效率的一组嵌套数组实现”</td>  </tr></table><p>主要的可变序列集合：</p><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-us36{border-color:inherit;vertical-align:top}.tg .tg-yw4l{vertical-align:top}</style><table class="tg" style="undefined;table-layout: fixed; width: 748px"><colgroup><col style="width: 160px"><col style="width: 73px"><col style="width: 88px"><col style="width: 427px"></colgroup>  <tr>    <th class="tg-us36"></th>    <th class="tg-us36">索引序列</th>    <th class="tg-us36">线性序列</th>    <th class="tg-yw4l">描述</th>  </tr>  <tr>    <td class="tg-us36">Array</td>    <td class="tg-us36">√</td>    <td class="tg-us36"></td>    <td class="tg-yw4l">依靠于Java的数组，其中元素是可变的，但不能改变大小</td>  </tr>  <tr>    <td class="tg-yw4l">ArrayBuffer</td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">一个可变的序列集合的“定位”类。成本是常数</td>  </tr>  <tr>    <td class="tg-yw4l">ArrayStack</td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">后进先出数据结构。在性能比较重要时Stack更好</td>  </tr>  <tr>    <td class="tg-yw4l">DoubleLinkedList</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">像一个单链表，但有一个prev方法。文档说“额外的连<br>接让删除元素变得非常快。”</td>  </tr>  <tr>    <td class="tg-yw4l">LinkedList</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">一个可变的单链表</td>  </tr>  <tr>    <td class="tg-yw4l">ListBuffer</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">像ArrayBuffer，但依靠链表。文档说， 如果想把buffer<br>转成list，用ListBuffer而不是ArrayBuffer。前插后插开<br>销都是常数。其他的大部分操作都是线性的</td>  </tr>  <tr>    <td class="tg-us36">MutableList</td>    <td class="tg-us36"></td>    <td class="tg-us36">√</td>    <td class="tg-yw4l">一个可变的，单链表，后插开销是常数</td>  </tr>  <tr>    <td class="tg-yw4l">Queue</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">先进先出数据结构</td>  </tr>  <tr>    <td class="tg-yw4l">Stack</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">后进先出数据结构。（文档建议ArrayStack的效率稍微好<br>些。）</td>  </tr>  <tr>    <td class="tg-yw4l">StringBuilder</td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">像在循环里构建字符串</td>  </tr></table><p>常用到的map：</p><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-us36{border-color:inherit;vertical-align:top}.tg .tg-yw4l{vertical-align:top}</style><table class="tg" style="undefined;table-layout: fixed; width: 796px"><colgroup><col style="width: 168px"><col style="width: 61px"><col style="width: 94px"><col style="width: 473px"></colgroup>  <tr>    <th class="tg-us36"></th>    <th class="tg-us36">不可变</th>    <th class="tg-us36">可变</th>    <th class="tg-yw4l">描述</th>  </tr>  <tr>    <td class="tg-us36">HashMap</td>    <td class="tg-us36">√<br></td>    <td class="tg-us36">√<br></td>    <td class="tg-yw4l">不可变版本用“hash trie” （晗希线索）实现，可变版本用<br>“哈希表”实现</td>  </tr>  <tr>    <td class="tg-us36">LinkedHashMap</td>    <td class="tg-us36"></td>    <td class="tg-us36">√<br></td>    <td class="tg-yw4l">“用哈希表实现可变map”，元素按插入顺序返回</td>  </tr>  <tr>    <td class="tg-yw4l">ListMap</td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">用链表数据结构实现的map。元素按插入的相反顺序返回，因<br>为每次插入的元素都放在head</td>  </tr>  <tr>    <td class="tg-yw4l">Map</td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">基础的map，有可变的和不可变的实现</td>  </tr>  <tr>    <td class="tg-yw4l">SortedMap</td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">接序存键的一个基本特质。（当前用5。rtedMap创建一个变量<br>返回TreeMap。）</td>  </tr>  <tr>    <td class="tg-yw4l">TreeMap</td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">不可变的，排序的map，由红黑树实现</td>  </tr>  <tr>    <td class="tg-yw4l">WeakHashMap</td>    <td class="tg-yw4l"></td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">一个java.util.WeakHashMap的包装，弱引用的hashmap</td>  </tr></table><p>选择Set：</p><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-us36{border-color:inherit;vertical-align:top}.tg .tg-yw4l{vertical-align:top}</style><table class="tg" style="undefined;table-layout: fixed; width: 796px"><colgroup><col style="width: 168px"><col style="width: 61px"><col style="width: 94px"><col style="width: 473px"></colgroup>  <tr>    <th class="tg-us36"></th>    <th class="tg-us36">不可变</th>    <th class="tg-us36">可变</th>    <th class="tg-yw4l">描述</th>  </tr>  <tr>    <td class="tg-us36">BitSet</td>    <td class="tg-us36">√<br></td>    <td class="tg-us36">√<br></td>    <td class="tg-yw4l">非负整数表示为比特放入64位字节的可变尺寸数组。当有一组<br>整数时来节省内存空间</td>  </tr>  <tr>    <td class="tg-us36">HashSet</td>    <td class="tg-us36">√</td>    <td class="tg-us36">√<br></td>    <td class="tg-yw4l">不可变版本用“hash trie” （哈希线索），可变版本用“哈希<br>表” ( hashtable)</td>  </tr>  <tr>    <td class="tg-yw4l">LinkedHashSet</td>    <td class="tg-yw4l"><br></td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">一个由hashtable实现的可变Set，按照插入顺序返回元素</td>  </tr>  <tr>    <td class="tg-yw4l">ListSet</td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">用链表实现的set</td>  </tr>  <tr>    <td class="tg-yw4l">TreeSet</td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">不可变版本用树实现。可变版本基于不可变的AVL树作为数据结构的SortedSet</td>  </tr>  <tr>    <td class="tg-yw4l">Set</td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">一般的基础特质</td>  </tr>  <tr>    <td class="tg-yw4l">SortedSet</td>    <td class="tg-yw4l">√</td>    <td class="tg-yw4l">√<br></td>    <td class="tg-yw4l">一个基础特质</td>  </tr></table><p>表现的像集合的类型：</p><p>Scala提供了很多其他的集合类型，还有一些表现的像集合的类型，尽管它们不是集合：</p><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-us36{border-color:inherit;vertical-align:top}.tg .tg-yw4l{vertical-align:top}</style><table class="tg" style="undefined;table-layout: fixed; width: 776px"><colgroup><col style="width: 153px"><col style="width: 623px"></colgroup>  <tr>    <th class="tg-us36"></th>    <th class="tg-yw4l">描述</th>  </tr>  <tr>    <td class="tg-us36">Enumeration</td>    <td class="tg-yw4l">一个包含常数值的有限集合（比如，一周的天数或一年的周数）</td>  </tr>  <tr>    <td class="tg-us36">Iterator</td>    <td class="tg-yw4l">迭代器不是一个集合，它可以访问集合中的元素．它也是集合，然而，定义许多方法便会发现一个普通的集合类，包括foreach, map, flatMap等。也可以在需要时把迭代器转换为一个集合</td>  </tr>  <tr>    <td class="tg-yw4l">Option</td>    <td class="tg-yw4l">包含一个或者零个元素的集合，Some和None继承自Option。</td>  </tr>  <tr>    <td class="tg-yw4l">Tuple</td>    <td class="tg-yw4l">支持异构的集合元素。没有一个“元组”类，元组由Tuple1 到Tuple22组成， 支持从1至22个元素</td>  </tr></table><h4 id="2-list"><a class="markdownIt-Anchor" href="#2-list"></a> 2. List</h4><p>创建List：</p><pre><code>val list = List(1,2,3)val list1 = List[Number](1,2,3,4)val list2 = List.range(1,10)val list3 = List.range(1,20,2)val list4 = List.fill[String](3)(&quot;list&quot;)List[Char] list5 = &quot;list&quot;.toList</code></pre><p>创建可变列表：</p><pre><code>var buffer = new ListBuffer[String]()buffer.+=(&quot;you&quot;,&quot;have&quot;,&quot;a&quot;,&quot;child&quot;)buffer += &quot;。&quot;println(buffer.toList)输出：List(you, have, a, child, 。)Process finished with exit code 0</code></pre><p>List基本方法的使用：</p><p>1.合并两个list：</p><pre><code>val l3 = list ::: list1val l7 = list ++ list1val l8 = List.concat(list,list1)println(l3,l7,l8)结果：(List(2, 3, 4, 5),List(2, 3, 4, 5),List(2, 3, 4, 5))</code></pre><p>2.+:和:+ 的用法区别-连接两个列表：</p><pre><code>val list = List(2,3)val list1 = List(4,5)val l2 = list +: list1val l3 = list :+ list1println(l2,l3)输出：(List(List(2, 3), 4, 5),List(2, 3, List(4, 5)))</code></pre><p>由结果可以看出+:和:+是根据&quot;:“的方法来解析数据的，”:&quot;朝向那一边，这一边的数据就会作为基数据，另一方的数据会被添加到这个List中。</p><p>3.使用Stream----惰性计算元素周期</p><p>List通过::构造， Stream可以用#::方法构建，表达式的结尾用Stream.empty代替Nil:</p><pre><code>val stream = 1#::2#::3#::Stream.emptyprintln(stream)val iterator = stream.iteratorwhile (iterator.hasNext){  println(iterator.next())}输出：Stream(1, ?)123Process finished with exit code 0</code></pre><p>可以看到打印stream的时候只打出了1，后面的是?。这是因为流的结尾还没有执行,？表示惰性集合的结尾尚未被执行的表示方式。</p><h4 id="2数组"><a class="markdownIt-Anchor" href="#2数组"></a> 2.数组</h4><p>2.1 创建数组：</p><pre><code>val array = Array(1,2,3)val array1 = Array(&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;boy&quot;)val array2 = Array[String](&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;boy&quot;)val array3 = new Array[Number](3)array3(0) = 1array3(1) = 2array3(2) = 3println(array.toList,array1.toList,array2.toList,array3.toList)输出：(List(1, 2, 3),List(I, am, a, boy),List(I, am, a, boy),List(1, 2, 3))</code></pre><p>其他创建数组的方式：</p><pre><code>val a1 = Array.range(1,10)val a2 = Array.range(1,20,2)val a3 = Array.apply(2,3,4,5,6)val a4 = Array.fill[String](3)(&quot;oo&quot;)val a5 = Array.tabulate(5)(n=&gt;n+5)println(a1.toList,a2.toList,a3.toList,a4.toList,a5.toList)输出：(List(1, 2, 3, 4, 5, 6, 7, 8, 9),List(1, 3, 5, 7, 9, 11, 13, 15, 17, 19),List(2, 3, 4, 5, 6),List(oo, oo, oo),List(5, 6, 7, 8, 9))</code></pre><p>创建可变数组：</p><p>Array既是可变的又是不可变的，可变的是他的内容，不可变的是他的大小。要想创建一个大小可变的数组，可以使用ArrayBuffer。</p><pre><code>val a1 = ArrayBuffer[Number](1)a1 += 2a1 += 3a1 += 4println(a1)val a2 = List[Number](5,6)a1 ++= a2println(a1)输出：ArrayBuffer(1, 2, 3, 4)ArrayBuffer(1, 2, 3, 4, 5, 6)Process finished with exit code 0</code></pre><p>删除操作：</p><pre><code>val a1 = ArrayBuffer[Number](1,2,3,4,5)a1 -= 1println(a1)a1 -= (1,2)println(a1)a1 --= List(1,2,3)println(a1)val a2 = ArrayBuffer[Number](2,2,4,3,4,5)#删除第一个位置的数据a2.remove(1)println(a2)#从第三个位置开始，删除两个数据a2.remove(3,2)println(a2)输出：ArrayBuffer(2, 3, 4, 5)ArrayBuffer(3, 4, 5)ArrayBuffer(4, 5)ArrayBuffer(2, 4, 3, 4, 5)ArrayBuffer(2, 4, 3)Process finished with exit code 0</code></pre><h4 id="3-map"><a class="markdownIt-Anchor" href="#3-map"></a> 3. Map</h4><p>创建Map：</p><pre><code>var a1 =  Map(&quot;name&quot;-&gt;&quot;xiaoming&quot;,&quot;age&quot;-&gt;12)val a2 = Map((&quot;name&quot;,&quot;xiaoming&quot;),(&quot;age&quot;,12))a1 += (&quot;address&quot;-&gt;&quot;xxxx&quot;)println(a1,a2)输出：(Map(name -&gt; xiaoming, age -&gt; 12, address -&gt; xxxx),Map(name -&gt; xiaoming, age -&gt; 12))Process finished with exit code 0</code></pre><p>修改Map：</p><p>默认Map是immutable类型的，所以如果要修改Map，需要手动引入Mutable的Map。</p><pre><code>var a1 =  mutable.Map(&quot;name&quot;-&gt;&quot;xiaoming&quot;,&quot;age&quot;-&gt;12)a1(&quot;name&quot;) = &quot;xiaohong&quot;println(a1)a1 ++= List(&quot;address&quot;-&gt;&quot;xxx&quot;,&quot;sex&quot;-&gt;1)println(a1)a1 -= &quot;name&quot;println(a1)a1 --= List(&quot;age&quot;,&quot;sex&quot;)println(a1)a1.put(&quot;idCard&quot;,&quot;111&quot;)a1.remove(&quot;address&quot;)println(a1)输出：Map(age -&gt; 12, name -&gt; xiaohong)Map(address -&gt; xxx, age -&gt; 12, name -&gt; xiaohong, sex -&gt; 1)Map(address -&gt; xxx, age -&gt; 12, sex -&gt; 1)Map(address -&gt; xxx)Map(idCard -&gt; 111)</code></pre><p>遍历映射：</p><pre><code>var a1 =  mutable.Map(&quot;name&quot;-&gt;&quot;xiaoming&quot;,&quot;age&quot;-&gt;12,&quot;address&quot;-&gt;&quot;xxx&quot;,&quot;sex&quot;-&gt;1)for((k,v) &lt;- a1){  println(k,v)}a1.foreach(x=&gt;{  println(x._1,x._2)})</code></pre><p>常用方法：</p><pre><code>var a1 =  mutable.Map(&quot;name&quot;-&gt;&quot;xiaoming&quot;,&quot;age&quot;-&gt;12,&quot;address&quot;-&gt;&quot;xxx&quot;,&quot;sex&quot;-&gt;1)//判断某个key是否存在if(a1.contains(&quot;name&quot;)){  println(a1(&quot;name&quot;))}//过滤元素,a1直接就被改变为过滤后的值a1 = a1.retain((k,v)=&gt;k.length == 3)println(a1)//改变元素的值a1.transform((k,v)=&gt;v + &quot;1&quot;)println(a1)a1 =  mutable.Map(&quot;name&quot;-&gt;&quot;xiaoming&quot;,&quot;age&quot;-&gt;12,&quot;address&quot;-&gt;&quot;xxx&quot;,&quot;sex&quot;-&gt;1)//保留指定的key,一定要将返回结果赋值给新的变量，返回类型为MapLikeval a2  =a1.filterKeys(_.length &gt; 3)println(a2)//也可以使用Set集合传递你需要的keyval a3 = a1.filterKeys(Set(&quot;name&quot;,&quot;age&quot;))println(a3)//使用filter方法可以任意指定过滤key还是valuea1 = a1.filter(k=&gt;k._1.length &gt; 3)println(a1)//take方法可以提取map中的前n个元素，注意如果用Map因为是无序的，每次都不保证取出元素的顺序a1 =  mutable.LinkedHashMap(&quot;name&quot;-&gt;&quot;xiaoming&quot;,&quot;age&quot;-&gt;12,&quot;address&quot;-&gt;&quot;xxx&quot;,&quot;sex&quot;-&gt;1)a1 = a1.take(2)println(a1)输出：xiaomingMap(age -&gt; 12, sex -&gt; 1)Map(age -&gt; 121, sex -&gt; 11)Map(address -&gt; xxx, name -&gt; xiaoming)Map(age -&gt; 12, name -&gt; xiaoming)Map(address -&gt; xxx, name -&gt; xiaoming)Map(name -&gt; xiaoming, age -&gt; 12)</code></pre><h4 id="4set"><a class="markdownIt-Anchor" href="#4set"></a> 4.Set</h4><p>集合的基本操作：</p><pre><code>val a1 = mutable.Set(1,2,3,4)a1 += 5//集合中的元素是无序的并且是唯一的a1 += 1println(a1)a1 += (6,7)println(a1)a1 ++= List(8,9)println(a1)a1.add(10)println(a1)a1 -= 1println(a1)a1 -= (2,3)println(a1)a1 --=Array(4,5)println(a1)//过滤元素a1.retain(_ &gt; 9)println(a1)输出：Set(1, 5, 2, 3, 4)Set(1, 5, 2, 6, 3, 7, 4)Set(9, 1, 5, 2, 6, 3, 7, 4, 8)Set(9, 1, 5, 2, 6, 3, 10, 7, 4, 8)Set(9, 5, 2, 6, 3, 10, 7, 4, 8)Set(9, 5, 6, 10, 7, 4, 8)Set(9, 6, 10, 7, 8)Set(10)</code></pre><p>创建有序集合：</p><pre><code>var a1 = SortedSet(1,2,3,4)println(a1)a1 = a1.filter(v=&gt;v&gt;3)println(a1)var a2 = mutable.LinkedHashSet(1,2,3,4)a2 = a2.filter(v=&gt;v&gt;3)println(a2)输出：TreeSet(1, 2, 3, 4)TreeSet(4)Set(4)</code></pre><p>从输出类型上可以看到SortedSet被改变之后输出为TreeSet对象，这是因为SortedSet只有不可变的版本，如果想用可变的集合，可以使用TreeSet。</p><h5 id="5队列和堆栈"><a class="markdownIt-Anchor" href="#5队列和堆栈"></a> 5.队列和堆栈</h5><pre><code>var a1 = mutable.Queue(1,2,3)a1.enqueue(1)var a2 = a1.dequeueAll(x=&gt;x&gt;0)println(a2)println(a1)输出：ArrayBuffer(1, 2, 3, 1)Queue()var a1 = mutable.Stack(1,2,3,4)a1.pop()println(a1)a1.push(1)println(a1)a1.pop()println(a1)输出：Stack(2, 3, 4)Stack(1, 2, 3, 4)Stack(2, 3, 4)Process finished with exit code 0</code></pre><h4 id="6强大的range功能"><a class="markdownIt-Anchor" href="#6强大的range功能"></a> 6.强大的Range功能</h4><pre><code>var a1 = (1 to 10).toListprintln(a1)var a2 =(1 until(10)).toListprintln(a2)var a3 = (1 to 10 by(2)).toListprintln(a3)var a4 = ('a' to 'm').toListprintln(a4)输出：List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)List(1, 2, 3, 4, 5, 6, 7, 8, 9)List(1, 3, 5, 7, 9)List(a, b, c, d, e, f, g, h, i, j, k, l, m)Process finished with exit code 0</code></pre><p>上面这些功能在for循环中经常用到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-集合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-集合&quot;&gt;&lt;/a&gt; 1. 集合&lt;/h4&gt;
&lt;p&gt;集合主要有三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sequence&lt;/li&gt;
&lt;li&gt;Map&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;/o
      
    
    </summary>
    
      <category term="scala" scheme="http://blog.rickiyang.cn/categories/scala/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="scala学习" scheme="http://blog.rickiyang.cn/tags/scala%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Scala函数式编程（三）</title>
    <link href="http://blog.rickiyang.cn/posts/64535299.html"/>
    <id>http://blog.rickiyang.cn/posts/64535299.html</id>
    <published>2018-04-25T08:12:51.000Z</published>
    <updated>2019-01-07T01:48:18.201Z</updated>
    
    <content type="html"><![CDATA[<p>Scala既是一门面向对象(OOP)语言，又是一门函数式编程(FP)语言。作为一门支持函数式编程的语言，Scala鼓励面向表达式编程(EOP)模型。简单来说，EOP中每个语句都有返回值。这一模式很明显，因为if/else语句就可以返回值：</p><pre><code>val result = if(a &gt; b) a else b</code></pre><h5 id="1-使用函数字面量匿名函数"><a class="markdownIt-Anchor" href="#1-使用函数字面量匿名函数"></a> 1. 使用函数字面量(匿名函数)</h5><pre><code>val a = List.range(1,10)val b = a.filter((i:Int) =&gt; i % 2 == 0)println(b)结果：List(2, 4, 6, 8)Process finished with exit code 0</code></pre><p>在上面的例子中代码：</p><pre><code>(i:Int) =&gt; i % 2 == 0</code></pre><p>就是匿名函数。</p><h5 id="2-将函数转变为变量"><a class="markdownIt-Anchor" href="#2-将函数转变为变量"></a> 2. 将函数转变为变量</h5><pre><code>val double = (i:Int) =&gt; {i * 2}println(double(3))结果：6</code></pre><p>这个时候的变量double是一个实例。在这种情况下他是函数实例你可以像函数一样去调用他。</p><p>除了调用，还可以将其传入到任何具有相同参数签名的方法或者函数中：</p><pre><code>val double = (i:Int) =&gt; {i * 2}val list = List.range(1,5)val l =list.map(double)println(l)结果：List(2, 4, 6, 8)Process finished with exit code 0</code></pre><p><strong>Scala的Unit类：</strong></p><p>Unit类和java的Void类似，使用于表明函数无返回值的场景。比如我们定义main函数：</p><pre><code>def main(args: Array[String]): Unit = {}</code></pre><h5 id="3-使用闭包"><a class="markdownIt-Anchor" href="#3-使用闭包"></a> 3. 使用闭包</h5><p>先看一个例子：</p><pre><code>package scope{  class Foo{    def exec(f:String =&gt; Unit,name:String): Unit ={      f(name)    }  }}object claEx extends App{  var hello = &quot;hello&quot;  def sayHello(name:String){println(s&quot;$hello,$name&quot;)}  val foo = new scope.Foo  foo.exec(sayHello,&quot;hah&quot;)}结果：hello,hahProcess finished with exit code 0</code></pre><p>关于闭包的定义有很多，有如下的说法，“闭包是满足下面三个条件的一段代码块”：</p><ol><li>代码块可以当作值来传递。</li><li>同时可以被任何拥有该值的对象按需执行。</li><li>可以引用上下文中已经创建的变量（如它的封闭是相对于变量访问，在数学上称之为“关闭”）。</li></ol><p>再举一个简单的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> newAge = <span class="number">18</span></span><br><span class="line">    <span class="keyword">val</span> isMoreThanAge = (age:<span class="type">Int</span>) =&gt; age &gt;= newAge</span><br><span class="line">    println(isMoreThanAge(<span class="number">3</span>))</span><br><span class="line">    println(isMoreThanAge(<span class="number">40</span>))</span><br><span class="line">    printResult(isMoreThanAge,<span class="number">33</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printResult</span></span>(f:<span class="type">Int</span> =&gt; <span class="type">Boolean</span>,x:<span class="type">Int</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(f(x))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><pre><code>falsetruetrueProcess finished with exit code 0</code></pre><h5 id="4部分应用函数"><a class="markdownIt-Anchor" href="#4部分应用函数"></a> 4.部分应用函数</h5><p>先看定义：</p><pre><code>val sum = (a:Int,b:Int,c:Int) =&gt; a+b+cval f = sum(3,6,_:Int)</code></pre><p>在函数调用的时候不提供第三个参数，这个时候函数f就变为部分应用函数。</p><pre><code>val sum = (a:Int,b:Int,c:Int) =&gt; a+b+cval f = sum(3,6,_:Int)println(f.toString())结果：Demo$$$Lambda$2/1329552164@1b40d5f0</code></pre><p>结果表明f是一个Function。因为上面第三个参数为Int类型的空缺值，所以f函数还可以传入一个参数：</p><pre><code>println(f(3))结果：12</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala既是一门面向对象(OOP)语言，又是一门函数式编程(FP)语言。作为一门支持函数式编程的语言，Scala鼓励面向表达式编程(EOP)模型。简单来说，EOP中每个语句都有返回值。这一模式很明显，因为if/else语句就可以返回值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;va
      
    
    </summary>
    
      <category term="scala" scheme="http://blog.rickiyang.cn/categories/scala/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="scala学习" scheme="http://blog.rickiyang.cn/tags/scala%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Scala类和对象（二）</title>
    <link href="http://blog.rickiyang.cn/posts/a0c17a47.html"/>
    <id>http://blog.rickiyang.cn/posts/a0c17a47.html</id>
    <published>2018-04-22T13:26:34.000Z</published>
    <updated>2019-01-07T01:48:18.200Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-类和属性"><a class="markdownIt-Anchor" href="#1-类和属性"></a> 1. 类和属性</h4><h5 id="11-如何控制构造函数字段的可见性"><a class="markdownIt-Anchor" href="#11-如何控制构造函数字段的可见性"></a> 1.1 如何控制构造函数字段的可见性</h5><p>在Scala中：</p><ol><li>如果一个字段被声明为var, Scala会为该字段生成getter和setter方法。</li><li>如果字段是val, Scala只生成getter方法。</li><li>如果一个字段没有var或者val的修饰符， Scala比较保守，不会生成getter和setter方法。</li><li>另外，var和val字段可以被private关键字修饰，这样可以防止生成getter和setter方法。</li></ol><p>我们看一下测试代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"haah"</span>)</span><br><span class="line">      println(p.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">var name:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><pre><code>haah</code></pre><p>我们再把name设置为val:</p><p><img src="https://i.imgur.com/h0IxRYX.jpg" alt=""></p><p>还没有到运行阶段，编译器自动捕获了异常。改为var就可以了。</p><p>如果设置为非val和非var的字段：</p><p><img src="https://i.imgur.com/8bEhpSG.png" alt=""></p><p>直接找不到name这个对象，当构造函数参数既没有声明为val或var时，字段的可见性很受限制，井且Scala不会为此生成访问修改方法。</p><p>给val或者var加上private，这个关键字会阻止getter和setter方法的生成，所以这种宇段只能被类的成员变量使用。</p><h4 id="2-构造函数"><a class="markdownIt-Anchor" href="#2-构造函数"></a> 2. 构造函数</h4><p>如同在java中可以定义多个构造函数，Scala中也可以，不同的是除了主构造函数以外其余的构造函数都被称为辅助构造函数。所有的辅助构造函数必须以this为名，另外每个构造函数必须调用之前已经定义好了的构造函数：</p><pre><code>//主构造函数class MakePizza(var size:Int,var pizzaType:String){  //辅构造函数  def this(pizzaAuthor:String){    this(size,&quot;3&quot;)  }   //辅构造函数  def this(){    this(&quot;libai&quot;)  }  }</code></pre><p><strong>定义私有主构造函数：</strong></p><pre><code>class Order private{}</code></pre><p>私有构造函数是无法实例化的。我们知道在java中实现单例模式就是把构造函数私有化。提供一个getInstance方法来初始化类。</p><pre><code>class MakePizza private (var size:Int,var pizzaType:String){    object getInstance extends MakePizza(size,pizzaType){    val makePizza = new MakePizza(size,pizzaType)  }}</code></pre><p><strong>设置构造函数参数默认值</strong></p><pre><code>class Socket(var timeout:Int = 10000)</code></pre><p>那么在调用构造函数的时候就可以不指定默认值：</p><pre><code>val s = new Socket</code></pre><p><strong>用case类生成模板代码：</strong>、</p><p>定义case类可以生成模板类，包括如下方法：apply，unapply，toString，equals，hashCode。</p><pre><code>case class Person(name:String,relation:String)</code></pre><p>将类定义为case类会生成许多模板代码，好处在于：</p><ol><li>会生成一个apply方怯，这样就可以不用new关键字创建新的实例。</li><li>由于case类的构造函数参数默认是val ，那么构造函数参数会自动生成访问方站。如果是var也会有修改方怯。</li><li>会生成一个默认的toString方怯。</li><li>会生成一个unapply方法，在模式匹配时很好用。</li><li>会生成equals和hashCode方法。</li><li>还有一个copy方站。</li></ol><p>定义case类，就不用再new来创建一个实例：</p><pre><code>val wmily = Person(&quot;xiaoming&quot;,&quot;niece&quot;)</code></pre><p>case类的构造参数默认是val，所以会自动生成get方法，不会生成set。当把case类的构造方法参数设置为var的时候就会有get和set。</p><p>case类主要是为了创建“不可变的记录”，这样容易在模式匹配中使用。正因为如此，casel的构造函数参数默认值是val，如果你改为var那就违背了case的本意。</p><h4 id="3-方法"><a class="markdownIt-Anchor" href="#3-方法"></a> 3. 方法</h4><p>在java中声明一个方法如下：</p><pre><code>public String doSomething(int x){}</code></pre><p>在scala中则是这样：</p><pre><code>sef doSomeThing(x:Int):String = {}</code></pre><p><strong>控制方法的作用域：</strong></p><p>Scala中的方法缺省是public。</p><p>在java中protected修饰的方法对同一包中的类都可见。但是在Scala中仅对该类的子类可见。</p><p>下表中给出了Scala中各种级别的访问控制：</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>private[this]</td><td>对当前实例可见</td></tr><tr><td>private</td><td>对当前类的所有实例可见</td></tr><tr><td>protected</td><td>对当前类以及其子类的实例可见</td></tr><tr><td>private[model]</td><td>对model包下的所有类可见</td></tr><tr><td>private[coolapp]</td><td>对cooapp包下的所有类可见</td></tr><tr><td>private[acme]</td><td>对acme包下的所有类可见</td></tr><tr><td>无修饰符</td><td>公开方法</td></tr></tbody></table><p><strong>调用父类中的方法：</strong></p><p>Scala中调用父类，用super代表父类，然后是方法名：</p><pre><code>class App extends Fruit{override def onCreate(color:String){super.onCreate(color)}}</code></pre><p><strong>可以继承多个类：</strong></p><p>**与java中不同的是Scala的类对象可以同时继承多个类。**如果继承的多个类中有相同的方法可以用如下方式选择要使用哪个类中的方法：</p><pre><code>super[类名].方法名</code></pre><p>举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="type">ShowColor</span></span><br><span class="line">    a.printApple(<span class="string">"red"</span>)</span><br><span class="line">    a.printBanana(<span class="string">"yellow"</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getColor</span></span>(color: <span class="type">String</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">     printf(<span class="string">"the color is %s \n"</span>,color)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getColor</span></span>(color: <span class="type">String</span>): <span class="type">Unit</span> = <span class="keyword">super</span>.getColor(color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getColor</span></span>(color: <span class="type">String</span>): <span class="type">Unit</span> = <span class="keyword">super</span>.getColor(color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowColor</span> <span class="keyword">extends</span> <span class="title">Fruit</span> <span class="keyword">with</span> <span class="title">Apple</span> <span class="keyword">with</span> <span class="title">Banana</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printSuper</span></span>(color: <span class="type">String</span>) = <span class="keyword">super</span>.getColor(color: <span class="type">String</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printApple</span></span>(color: <span class="type">String</span>) = <span class="keyword">super</span>[<span class="type">Apple</span>].getColor(color: <span class="type">String</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printBanana</span></span>(color: <span class="type">String</span>) = <span class="keyword">super</span>[<span class="type">Banana</span>].getColor(color: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><pre><code>the color is red the color is yellow Process finished with exit code 0</code></pre><p><strong>方法参数默认值：</strong></p><p>如同python一样，Scala可以给方法的参数一个默认值：</p><pre><code>def makeCnnection(timeout:Int = 3000,[protocol:String=&quot;http&quot;){println(&quot;timeout = %d,protocol=%s&quot;.format(timeout,protocol))}</code></pre><p><strong>定义一个返回多个值(tuples)的方法</strong></p><p>如果我们希望一个方法能够返回多个值，又不想把这些值字段用一个对象包装，那么可以使用tuples从方法中返回多个值。</p><p>tuples是Scala中的数据类型，表示元组的意思。元组是使用()表示的数据结构。后面我们介绍集合列表的时候会详细说。</p><p>加入有如下方法返回了包含3个字段的元组：</p><pre><code>def getStackInfo = {return (&quot;RPC&quot;,&quot;sufface&quot;,34)}</code></pre><p>可以使用一个元组来接收：</p><pre><code>val result = getsStackInfoprintln(b._1,b._2,b._3)</code></pre><p>tuple中的值可以通过其位置来访问。</p><p><strong>可变参数的方法</strong></p><p>在java中可以传入String 类型的可变参数：String … str,在Scala中也提供可变参数的方法：在参数类型后面加一个 “*”，这个参数就变成了可变参数。</p><pre><code>def printAll(str:String*){}</code></pre><p><strong>注意：同java一样，当一个方法包含可变参数的时候，那么这个可变参数必须是在所有参数中最后一个位置，否则会报错。</strong></p><p>*<em>使用_<em>来匹配一个序列</em></em></p><p>对于一个序列：Array，List，Seq，Vector，都可以使用_*来匹配里面的每一个对象，从而可以使他可以当做变参传递给一个方法：</p><pre><code>def main(args: Array[String]): Unit = {val fruit = List(&quot;apple&quot;,&quot;banana&quot;,&quot;pair&quot;)printAll(fruit: _*)}def printAll(str:String*): Unit ={str.foreach(println)}</code></pre><p>解析fruit的每一个对象然后作为参数传递给printAll()方法。</p><p><strong>方法的异常声明</strong></p><p>使用@throws注解声明可能抛出的异常。这个和java中的使用方式有区别。</p><pre><code>@throws(classOf[Exception])def paly: Unit ={  //code....}</code></pre><h4 id="4-对象"><a class="markdownIt-Anchor" href="#4-对象"></a> 4. 对象</h4><p><strong>对象的强制转换：</strong></p><p>使用asInstanceOf将一个实例转换为期望的类型。</p><pre><code>val recongnizer = cm.lookup(&quot;recongnizer&quot;).asInstanceOf[Recognizer]</code></pre><p>上面的Scala代码等于下面的java代码：</p><pre><code>Recognizer recognizer = (Recognizer)cm.lookup(&quot;Recognizer&quot;);</code></pre><p><strong>java中的对象.class的Scala等价类</strong></p><p>在java中当你有一个方法里面要求将不同的对象作为参数传进来然后使用不同对象的不同方法，这个时候你可以传入一个参数：class clz。然后利用反射获取不同对象的方法。</p><p>在Scala中使用classOf方法来代替java中的.class。</p><pre><code>val info = new DataLine.Info(classOf[TargetDataLine],null)</code></pre><p>等价于java中的：</p><pre><code>info = new DataLine.info(TargetDataLine.class,null)</code></pre><p><strong>用object 启动一个应用：</strong></p><p>在Scala中启动一个应用有两种方法：</p><ol><li><p>定义继承App特质的object；</p></li><li><p>定义一个object，并实现main方法</p><p>object Demo{<br>def main(args: Array[String]): Unit = {<br>println(“hello”)<br>}</p><p>def printAll(str:String*): Unit ={<br>str.foreach(println)<br>}<br>}</p></li></ol><p>或者：</p><pre><code>object Hello extends App{  println(&quot;hello&quot;)}</code></pre><p><strong>不用new关键字创建对象实例：</strong></p><p>有两种办法：</p><ol><li>为类对象创建伴生类，并在伴生类内定义一个apply方法；</li><li>将类定义为case类。</li></ol><p>用apply方法创建一个伴生类：</p><pre><code>class Person{  var name:String = &quot;&quot;}object Person{  def apply(name:String): Person = {    var p = new Person    p.name = name    p  }}</code></pre><p>调用方式：</p><pre><code>val carry = Person(&quot;carry&quot;)</code></pre><p>在同一个文件中定义Person类和Person对象，在对象中定义apply方法接受期望的参数，这个方法本质上是类的构造函数。</p><p>将类声明为case类：</p><pre><code>case class Person(var name:String)val p = Person(&quot;carry&quot;)</code></pre><p>case类起的作用在于他在伴生类中生成了一个apply方法，上文我们已经说过将一个类定义为case类会自动生成很多方法。</p><h4 id="5包管理"><a class="markdownIt-Anchor" href="#5包管理"></a> 5.包管理</h4><p>Scala的包管理跟Java类似，但更灵活。除了在类文件的开头用package语句外，还可以用花括号，与C＋＋和C＃的命名空间很像。</p><p>Scala会隐式的导入两个包：</p><pre><code>java.lang._scala._</code></pre><p>Scala里的&quot;_“字符类似于java里的”*&quot;。</p><h5 id="51-花括号风格的包记号法"><a class="markdownIt-Anchor" href="#51-花括号风格的包记号法"></a> 5.1 花括号风格的包记号法：</h5><pre><code>package com.rickiyang.zoo{  class Foo{    //todo  }    class food{    //todo  }}</code></pre><p>这种方式允许在一个文件中放多个包。也可以用“花括号”方式定义嵌套的包。</p><h5 id="52-在导入时重命名类名"><a class="markdownIt-Anchor" href="#52-在导入时重命名类名"></a> 5.2 在导入时重命名类名：</h5><pre><code>import java.util.{ArrayList =&gt; JavaList}</code></pre><p>然后再代码中就可以使用别名了。</p><p><strong>当你为你的类取了别名后那么原来的名字就不可以使用了。否则会出错。</strong></p><h4 id="6-特质java中的接口"><a class="markdownIt-Anchor" href="#6-特质java中的接口"></a> 6. 特质—&gt;java中的接口</h4><p>上文中我们使用过trait修饰类，trait就是Scala中的特质，相当于java中的接口。正如Java类能够实现多个接口一样， Scala类可以继承多个特质。所以trait的功能要比java接口的功能要强大的多。</p><p><strong>做为普通的接口来使用：</strong></p><p>方法如果不需要任何参数，在def后面指定方法名即可：</p><pre><code>trait BasePlay{  def playBasketBall  def playFootBall}</code></pre><p>需要参数只需要将其罗列出来：</p><pre><code>trait BasePlay{  def playBasketBall(count:Int)  def playFootBall(count:Int)}</code></pre><p>当一个类需要继承特质时，要使用extends和with关键字。只继承一个特质时，使用extends:</p><pre><code>class BasketBall extends BasketBall{  //todo }</code></pre><ul><li>继承一个类和一个或多个特质时，对类使用extends ，对特质使用with。</li><li>当一个类继承多个特质时，使用extends继承第一个特质，其余的使用with 。</li><li>除非实现特质的类是一个抽象类，否则它必须实现特质所有的抽象方怯。</li><li>如果一个类继承了一个特质但是没有实现它的抽象方法，这个类必须被声明为抽象类。</li><li>特质也可以继承另一个特质。</li></ul><p><strong>像抽象类一样使用特质：</strong></p><p>定义为trait的类中既可以有抽象方法也可以有已经实现了的方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BasePlay</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">playBasketBall</span> </span>&#123;println(<span class="string">"haha"</span>)&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">playFootBall</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">Football</span> <span class="title">extends</span> <span class="title">BasePlay</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">playFootBall</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"hahahh football"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于trait中已经实现了的方法，他的继承类可以重写也可以不重写。但是抽象方法一定要重写，否则继承类必须定义为抽象类(abstract)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-类和属性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-类和属性&quot;&gt;&lt;/a&gt; 1. 类和属性&lt;/h4&gt;
&lt;h5 id=&quot;11-如何控制构造函数字段的可见性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;
      
    
    </summary>
    
      <category term="scala" scheme="http://blog.rickiyang.cn/categories/scala/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="scala学习" scheme="http://blog.rickiyang.cn/tags/scala%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Scala基础语法学习（一）</title>
    <link href="http://blog.rickiyang.cn/posts/e8e22028.html"/>
    <id>http://blog.rickiyang.cn/posts/e8e22028.html</id>
    <published>2018-04-16T16:09:11.000Z</published>
    <updated>2019-01-07T01:48:18.200Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-val和var的区别"><a class="markdownIt-Anchor" href="#1-val和var的区别"></a> 1. val和var的区别</h4><p>val定义的是一个常量，无法改变其内容</p><pre><code>scala&gt; val s = 0s: Int = 0scala&gt; s = 2&lt;console&gt;:12: error: reassignment to val       s = 2         ^</code></pre><p>如果要声明其值可变的变量，可以使用var</p><pre><code>scala&gt; var s = 0s: Int = 0scala&gt; s = 5s: Int = 5</code></pre><p>在scala中建议使用val，除非你真的想改变他的内容。</p><h4 id="2-基本类型"><a class="markdownIt-Anchor" href="#2-基本类型"></a> 2. 基本类型</h4><ul><li>Byte</li><li>Char</li><li>Short</li><li>Int</li><li>Long</li><li>Float</li><li>Double</li><li>Boolean</li></ul><h4 id="3字符串"><a class="markdownIt-Anchor" href="#3字符串"></a> 3.字符串</h4><h5 id="31-测试字符串是否相等"><a class="markdownIt-Anchor" href="#31-测试字符串是否相等"></a> 3.1 测试字符串是否相等</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">"hello world"</span>;</span><br><span class="line">    println(s)</span><br><span class="line">    <span class="keyword">val</span> s1 = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">val</span> s2 = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">val</span> s3 = <span class="string">"H"</span>+<span class="string">"ello"</span>;</span><br><span class="line">    println(s1.equals(s2))</span><br><span class="line">    println(s1.eq(s3))</span><br><span class="line">    println(s1 == s2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><pre><code>hello worldtruetruetrueProcess finished with exit code 0</code></pre><p>在Scala中，可以用＝＝方法测试对象的相等性。这与Java中用equals方法比较两个对象不同。</p><h5 id="32-多行字符串"><a class="markdownIt-Anchor" href="#32-多行字符串"></a> 3.2 多行字符串</h5><p>在Scala中可以使用三个引号创建多行字符串：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> s =</span><br><span class="line">      <span class="string">""</span><span class="string">"ohh</span></span><br><span class="line"><span class="string">        haha</span></span><br><span class="line"><span class="string">            nonono</span></span><br><span class="line"><span class="string">      "</span><span class="string">""</span>;</span><br><span class="line">    println(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>ohh        haha            nonono</code></pre><p>​<br>Process finished with exit code 0</p><p>结果中可以看到每从第二行起每一行都是以空格开头的，要解决这个问题可以这样做：在多行字符串结尾添加stripMargin方法，并且在第一行后面的所有行以管道符&quot;|&quot;开头：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> s =</span><br><span class="line">      <span class="string">""</span><span class="string">"ohh</span></span><br><span class="line"><span class="string">        |haha</span></span><br><span class="line"><span class="string">            |nonono</span></span><br><span class="line"><span class="string">      "</span><span class="string">""</span>.stripMargin;</span><br><span class="line">    println(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><pre><code>ohhhahanonono</code></pre><p>​<br>Process finished with exit code 0</p><p>如果你不想用&quot;|&quot;,你也可以用任意字符：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s =</span><br><span class="line">          <span class="string">""</span><span class="string">"ohh</span></span><br><span class="line"><span class="string">            /haha</span></span><br><span class="line"><span class="string">                /nonono</span></span><br><span class="line"><span class="string">          "</span><span class="string">""</span>.stripMargin(<span class="string">"/"</span>);</span><br></pre></td></tr></table></figure><p>也会有同样的输出效果。</p><h5 id="33-字符串中的变量替换"><a class="markdownIt-Anchor" href="#33-字符串中的变量替换"></a> 3.3 字符串中的变量替换</h5><p>Scala支持在字符串中代换变量。</p><p>如果某个字符串需要插入变量，需要在该字符串的前面加上字母&quot;s&quot;标志，然后再字符串中放入变量，每个变量都应该以&quot;$&quot;开头。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"xiaoming"</span></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">12</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">s"<span class="subst">$name</span> is a man and he is <span class="subst">$age</span> years old"</span></span><br><span class="line">    println(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><pre><code>xiaoming is a man and he is 12 years oldProcess finished with exit code 0</code></pre><p>在字符串前面添加&quot;s&quot;，其实是在创建一个处理字符串字面量。</p><p><strong>在字符串字面量中使用表达式</strong></p><p>除了把变量放到字符串中外，还可以用花括号把表达式包起来再放到字符串中。根据官方文档，&quot;${}&quot;内可嵌入任何表达式。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> age = <span class="number">12</span></span><br><span class="line">println(<span class="string">s"are you kidding me,I always thought you were only <span class="subst">$&#123;age + 1&#125;</span> years old"</span>)</span><br></pre></td></tr></table></figure><p><strong>字符串插值f</strong></p><p>如果有一个需求是不改变原变量的前提下给该值添加两位小数，该如何实现呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> weight = <span class="number">111</span></span><br><span class="line">println(<span class="string">f"ohh dear,I never realized that you have <span class="subst">$weight</span>%.2f kilograms"</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><pre><code>ohh dear,I never realized that you have 111.00 kilograms</code></pre><p>这个简单的需求繁盛了“f字符串插值”。一个可以通过printf个时候内部字符串的方法。</p><p>用这种方法只需要如下两步即可：</p><p>1.在字符串前面加上字母f。</p><p>2.在变量之后使用printf的格式化操作符。</p><p><strong>raw插入符</strong></p><p>raw插入符“不会对字符串中的字符进行转义”。</p><pre><code>scala&gt; s&quot;hello\nyou&quot;res0: String =helloyouscala&gt; raw&quot;hello\nyou&quot;res1: String = hello\nyou</code></pre><p>printf格式化常用字符：</p><table>    <tr>        <td>格式化符号</td>        <td>描述</td>    </tr>    <tr>        <td>%c</td>        <td>字符</td>    </tr>    <tr>        <td>%d</td>        <td>十进制数字</td>    </tr>    <tr>        <td>%e</td>        <td>指数浮点数</td>    </tr>    <tr>        <td>%f</td>        <td>浮点数</td>    </tr>    <tr>        <td>%i</td>        <td>整数</td>    </tr>    <tr>        <td>%o</td>        <td>八进制</td>    </tr>    <tr>        <td>%s</td>        <td>字符串</td>    </tr>    <tr>        <td>%u</td>        <td>无符号十进制</td>    </tr>    <tr>        <td>%x</td>        <td>十六进制</td>    </tr>    <tr>        <td>%%</td>        <td>打印一个百分号</td>    </tr>    <tr>        <td>\%</td>        <td>打印一个百分号</td>    </tr></table><h5 id="34-遍历字符串中的字符"><a class="markdownIt-Anchor" href="#34-遍历字符串中的字符"></a> 3.4 遍历字符串中的字符</h5><p>Scala提供了很多方式遍历字符串以及对字符串进行操作，常用的有map，foreach，for，filter。</p><pre><code>scala&gt; val s = &quot;you are a kid&quot;.map(c =&gt; c.toUpper)s: String = YOU ARE A KIDscala&gt; val s = &quot;you are a kid&quot;.map(_.toUpper)s: String = YOU ARE A KIDscala&gt; val s = &quot;you are a kid&quot;.filter(_ != &quot;\n&quot;).map(v =&gt; v)                   ^s: String = you are a kidval name = &quot;542352354&quot;for(c &lt;- name){  println(c)}name.foreach(println)</code></pre><h4 id="4-数值"><a class="markdownIt-Anchor" href="#4-数值"></a> 4. 数值</h4><p>Scala内建数值类型包括：</p><ul><li>Char</li><li>Byte</li><li>Short</li><li>Int</li><li>Long</li><li>Float</li><li>Double</li></ul><h5 id="41-从字符串到数字"><a class="markdownIt-Anchor" href="#41-从字符串到数字"></a> 4.1 从字符串到数字</h5><p>使用String的to*方法。</p><pre><code>scala&gt; &quot;200&quot;.toIntres0: Int = 200</code></pre><p>如果需要转换的字符串不确定是几进制的，可以通过参数的形式来判断：</p><pre><code>val a = Integer.parseInt(&quot;01101&quot;,2)println(a)结果：13Process finished with exit code 0</code></pre><h5 id="42-和"><a class="markdownIt-Anchor" href="#42-和"></a> 4.2 ++和–</h5><p>Scala中没有++ 和 --这样的操作。所以要是想使用的话只能使用变形的方法：数值类型的可以使用 += 或者是 -= 来操作：</p><pre><code>var a = 4a += 3println(a)a -= 5println(a)结果：72</code></pre><h5 id="43-处理大数"><a class="markdownIt-Anchor" href="#43-处理大数"></a> 4.3 处理大数</h5><p>Scala提供了BigInt和BigDecimal类来创建一个大数：</p><pre><code>var a = BigInt(987654321)var b = BigDecimal(987654321.543433)var c = a + avar d = a * avar e = b + bvar f = b * bprintln(a,b,c,d,e,f)结果为：(987654321,987654321.543433,1975308642,975461057789971041,1975308643.086866,975461058863418942.543305425489)</code></pre><p><strong>我们看到和java中不一样的是：BigDecimal对象支持所有普通数值类型的操作符。</strong></p><h5 id="44-生成随机数"><a class="markdownIt-Anchor" href="#44-生成随机数"></a> 4.4 生成随机数</h5><p>Scala中也提供了Random类，用于随机数生成。</p><pre><code>var a = Random.nextDouble()</code></pre><h5 id="45-创建一个数值区间-列表或者数组"><a class="markdownIt-Anchor" href="#45-创建一个数值区间-列表或者数组"></a> 4.5 创建一个数值区间、列表或者数组</h5><p>使用Int的to方法创建数值区间：</p><pre><code>for(i &lt;- 0 to 9){  println(i)}结果：0123456789Process finished with exit code 0</code></pre><p>也可以使用by方法设置步长：</p><pre><code>for(i &lt;- 0 to 9 by(2)){  println(i)}结果：02468Process finished with exit code 0</code></pre><p>不得不说，跟java比是简洁太多了。</p><h4 id="5-控制语句"><a class="markdownIt-Anchor" href="#5-控制语句"></a> 5. 控制语句</h4><p>Scala中的if/else语句和java中的一样使用。</p><h5 id="51-for循环"><a class="markdownIt-Anchor" href="#51-for循环"></a> 5.1 for循环</h5><p>Scala中的for循环也很简单，使用&quot;&lt;-&quot;符号来获取循环指针。</p><pre><code>var a = Array(&quot;liming&quot;,&quot;hanmeimei&quot;,&quot;xiaohong&quot;)for(user &lt;- a){  println(user)}结果：liminghanmeimeixiaohongProcess finished with exit code 0</code></pre><p><strong>for循环计数器：</strong></p><pre><code>for(i &lt;- 0 to 5){println(i)}for(i &lt;- until a.length){println(i)}</code></pre><p><strong>封装index和值：</strong></p><pre><code>var a = Array(&quot;liming&quot;,&quot;hanmeimei&quot;,&quot;xiaohong&quot;)for((e,count) &lt;- a.zipWithIndex){  println(e,count)}结果：(liming,0)(hanmeimei,1)(xiaohong,2)Process finished with exit code 0</code></pre><p><strong>遍历Map：</strong></p><pre><code>val map = Map(&quot;name&quot;-&gt;&quot;xiaoming&quot;,&quot;age&quot;-&gt;12,&quot;sex&quot;-&gt;1)for((k,v) &lt;- map){  println(k,v)}结果：(name,xiaoming)(age,12)(sex,1)</code></pre><p><strong>在for循环中使用多个计数器：</strong></p><p>Scala允许在一个for循环中使用多个计数器，这个有点高端：</p><pre><code>var i = 1var j = 1var k = 1for(i &lt;- 1 to 3;j &lt;- 1 to 4;k &lt;- 1 to 5){  println(i,j,k)}结果：(1,1,1)(1,1,2)(1,1,3)(1,1,4)(1,1,5)(1,2,1)...(3,4,2)(3,4,3)(3,4,4)(3,4,5)</code></pre><p>当我们创建二维数组或者三维数组，就再也不用像java中那样需要三个for循环了。</p><p><strong>for循环中嵌入if：</strong></p><pre><code>for(i &lt;- 1 to 10 if i % 2 == 0){println(i)}</code></pre><p>过滤循环条件。</p><p><strong>实现break和continue：</strong></p><p>Scala中没有break和continue关键字。但是提供了另外的方式来实现该功能,scala.util.control.Breaks类提供了类似的方法：</p><pre><code>import util.control.Breaks._object Demo{  def main(args: Array[String]): Unit = {    breakable{      for( i &lt;- 1 to 10){        println(i)        if(i == 5)          break      }    }  }}结果：12345Process finished with exit code 0</code></pre><p>注意：break和breakable不是关键字而是util.control.Breaks类中的方法。</p><p>再来看一下continue是如何执行的：</p><pre><code>import util.control.Breaks._object Demo{  def main(args: Array[String]): Unit = {      for( i &lt;- 1 to 10){          breakable{            if(i == 5){              break            }else{              println(i)            }          }      }  }}结果：1234678910Process finished with exit code 0</code></pre><p>其实就是换了一种方式使用breakable哈。</p><p><strong>Scala中的switch/case：</strong></p><pre><code>var i = 0i match {  case 1 =&gt; println(1)  case 2 =&gt; println(2)}</code></pre><p>在Scala中使用match函数来表示switch。</p><p>在Scala中一个case语句可以匹配多个条件，你可以这样用：</p><pre><code>var i = 0i match {  case 1 | 3 | 5 =&gt; println(1)  case 2 | 4 | 6=&gt; println(2)}</code></pre><p>使用&quot;|&quot;分割。对于字符串和其他类型使用的语法是一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-val和var的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-val和var的区别&quot;&gt;&lt;/a&gt; 1. val和var的区别&lt;/h4&gt;
&lt;p&gt;val定义的是一个常量，无法改变其内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scala&amp;
      
    
    </summary>
    
      <category term="scala" scheme="http://blog.rickiyang.cn/categories/scala/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="scala学习" scheme="http://blog.rickiyang.cn/tags/scala%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>kafka消息的处理机制（5）</title>
    <link href="http://blog.rickiyang.cn/posts/9b912c1b.html"/>
    <id>http://blog.rickiyang.cn/posts/9b912c1b.html</id>
    <published>2018-04-10T04:45:11.000Z</published>
    <updated>2018-12-06T02:53:23.043Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇我们不在是探讨kafka的使用，前面几篇基本讲解了工作中的使用方式，基本api的使用还需要更深入的去钻研，多使用才会有提高。今天主要是探讨一下kafka的消息复制以及消息处理机制。</p><h4 id="1-broker的注册"><a class="markdownIt-Anchor" href="#1-broker的注册"></a> 1. broker的注册</h4><p>Kafka使用Zookeeper来维护集群成员的信息。每个broker都有一个唯一标识符，这个标识符可以在配置文件里指定，也可以自动生成。在kafka启动的时候，他通过创建临节点把自己的id注册到zk，kafka组件订阅zk的/broker/ids路径(broker在zk上的注册路径)，当有broker加入或者退出集群的时候，这些组件就可以获得通知。</p><p>如果当前id所在的broker已经注册然后启动另一个有相同id的broker，启动会出错，新的broker会试着进行注册，但是不会成功。因为zk中已经有一个相同名字的id注册过了。</p><p>如果broker出现停机或者网络长时间无响应，broker会从zk断开链接，zk中注册的临时节点会删除，下次broker启动需要重新注册。</p><p>如果是关闭broker那么他对应的节点也会消失，但是他的id也许会存在于其他的数据结构中。比如主题对应的副本，在完全关闭一个broker之后如果使用相同的id启动另一个全新的broker，他会立即加入集群，并且会拥有之前broker所有的主题和分区(前提是没有发生重排序，没有第二个新的broker加入)。</p><p>kafka的哪些组件需要注册到zookeeper？</p><p>（1）<strong>Broker注册到zk</strong></p><p>每个broker启动时，都会注册到zk中，把自身的broker.id通知给zk。待zk创建此节点后，kafka会把这个broker的主机名和端口号记录到此节点。</p><p>（2）<strong>Topic注册到zk</strong></p><p>当broker启动时，会到对应topic节点下注册自己的broker.id到对应分区的isr列表中；当broker退出时，zk会自动更新其对应的topic分区的ISR列表，并决定是否需要做消费者的rebalance</p><p>（3）<strong>Consumer注册到zk</strong></p><p>一旦有新的消费者组注册到zk，zk会创建专用的节点来保存相关信息。如果zk发现消费者增加或减少，会自动触发消费者的负载均衡。</p><p>（<strong><mark>注意，producer不注册到zk</mark></strong>）</p><h4 id="2-kafka集群leader选举"><a class="markdownIt-Anchor" href="#2-kafka集群leader选举"></a> 2. kafka集群leader选举</h4><ol><li>在kafka集群中，第一个启动的broker会在zk中创建一个临时节点/controller让自己成为控制器。其他broker启动时也会试着创建这个节点当然他们会失败，因为已经有人创建过了。那么这些节点会在控制器节点上创建zk        watch对象，这样他们就可以收到这个节点变更的通知。任何时刻都确保集群中只有一个leader的存在。</li><li>如果控制器被关闭或者与zk断开连接，zk上的KB是节点马上就会消失。那么其他订阅了leader节点的broker也会收到通知随后他们会尝试让自己成为新的leader，重复第一步的操作。</li><li>如果leader完好但是别的broker离开了集群，那么leader会去确定离开的broker的分区并确认新的分区领导者(即分区副本列表里的下一个副本)。然后向所有包含该副本的follower或者observer发送请求。随后新的分区首领开始处理请求。</li></ol><h4 id="3-kafka副本"><a class="markdownIt-Anchor" href="#3-kafka副本"></a> 3. kafka副本</h4><p>Kafka每个topic的partition有N个副本，其中N是topic的复制因子。Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个Broker失效情况下仍然保证服务可用。在Kafka中发生复制时确保partition的预写式日志有序地写到其他节点上。N个replicas中。其中一个replica为leader，其他都为follower，leader处理partition的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。</p><p>Kafka必须提供数据复制算法保证,如果leader发生故障或挂掉，一个新leader被选举并接收客户端的消息成功写入。Kafka确保从同步副本列表中选举一个副本为leader,或者换句话说,follower追赶leader数据。leader负责维护和跟踪ISR中所有follower滞后状态。当生产者发送一条消息到Broker,leader写入消息并复制到所有follower。消息提交之后才被成功复制到所有的同步副本。消息复制延迟受最慢的follower限制,重要的是快速检测慢副本,如果follower”落后”太多或者失效,leader将会把它从replicas从ISR移除。</p><h5 id="31-kafka创建副本的2种模式同步复制和异步复制"><a class="markdownIt-Anchor" href="#31-kafka创建副本的2种模式同步复制和异步复制"></a> 3.1 kafka创建副本的2种模式——同步复制和异步复制</h5><p>Kafka动态维护了一个同步状态的副本的集合（a set of In-Sync Replicas），简称ISR，在这个集合中的节点都是和leader保持高度一致的，任何一条消息只有被这个集合中的每个节点读取并追加到日志中，才会向外部通知说“这个消息已经被提交”。</p><p>只有当消息被所有的副本加入到日志中时，才算是“committed”，只有committed的消息才会发送给consumer，这样就不用担心一旦leader down掉了消息会丢失。消息从leader复制到follower,我们可以通过决定Producer是否等待消息被提交的通知(ack)来区分同步复制和异步复制。</p><p>同步复制流程：</p><ol><li>producer联系zk识别leader；</li><li>向leader发送消息；</li><li>leadr收到消息写入到本地log；</li><li>follower从leader pull消息；</li><li>follower向本地写入log；</li><li>follower向leader发送ack消息；</li><li>leader收到所有follower的ack消息；</li></ol><p>leader向producer回传ack。</p><p>异步复制流程：</p><p>和同步复制的区别在于，leader写入本地log之后，直接向client回传ack消息，不需要等待所有follower复制完成。</p><p>既然卡夫卡支持副本模式，那么其中一个Broker里的挂掉，一个新的leader就能通过ISR机制推选出来，继续处理读写请求。</p><p>kafka判断一个broker节点是否存活，依据2个条件：</p><ol><li>节点必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个节点的连接;</li><li>如果节点是个follower,他必须能及时的同步leader的写操作，延时不能太久。Leader会追踪所有“同步中”的节点，一旦一个down掉了，或是卡住了，或是延时太久，leader就会把它移除。</li></ol><h5 id="32-一些名词"><a class="markdownIt-Anchor" href="#32-一些名词"></a> 3.2 一些名词：</h5><ol><li>Leader副本：每个分区都有多个副本，针对每个分区，都有一个唯一的一个Leader副本，负责该分区的读写请求处理。</li><li>Follower副本：从Leader副本拉取数据，作为Leader副本的热备。</li><li>AR：（Assigned Replica）副本集合（Leader+Follower的总和）</li><li>ISR：（In-Sync Replica）同步副本集合，与leader副本消息镜像“相差”不多的副本集合，又称为“核心副本集”，与kafka 发送端的ACK的几种语义有关，后面会详聊（注意这个集合是动态的，是会剔除和新增的）。</li><li>HW：HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broKer的读取请求，没有HW的限制。6. LEO：(Log End Offset)每个分区都会有的一个标记，标示当前分区的最后一条消息（针对Leader就是Leader上的最后一条消息，针对某个Follower，就是当前该Follower的最后一条消息）</li></ol><h5 id="33-图解arisrhwleo"><a class="markdownIt-Anchor" href="#33-图解arisrhwleo"></a> 3.3 图解AR,ISR,HW,LEO：</h5><p>这里我们假设每个副本有三个分区，副本被剔除和加入ISR的临界条件为落后leader 三条消息，kafka判断是否符合ISR的条件有两个:</p><ul><li>Follower落后leader多少条消息，落后超过配置值后将踢出ISR</li><li>Follwer多久没从leader同步消息，超过配置时间没拉取数据将从ISR踢出（kafka0.9后删除了该判断，a为唯一判断标准）。</li></ul><p>下面我们用图来表达下上面的概念的关系：</p><p>1.时刻t1该分区的情况如下，此时ISR与AR一致（Leader，follower1，follower2），follower2 和 leader的消息一致，LEO都为4，follower1的LEO为2，因此leader的HW为2。</p><p><img src="https://i.imgur.com/On1RBAj.png" alt=""></p><p>2.时刻t2 follower full gc：</p><p><img src="https://i.imgur.com/KPBtFa2.png" alt=""></p><p>3.时刻t3，leader接受producer发送来的2条消息5、6，此时发现Follower1已经落后了自己4条消息，将follower1踢出ISR集合：</p><p><img src="https://i.imgur.com/JPeUqqC.png" alt=""></p><p>4.时刻4，follower1从leader拉取到5这条消息，更新HW：</p><p><img src="https://i.imgur.com/etpzcm7.png" alt=""></p><p>5.时刻5，follower1 full gc完成后，发现自己已经落后了很多消息，开始从leader追消息，待消息不落后leader太多时，申请加入ISR中。</p><p><img src="https://i.imgur.com/aV3D61I.png" alt=""></p><p>经过上面的图解分析后，我们来看下几个需要注意的点:</p><ol><li>ISR是AR的一个子集，并且是不断伸缩的，变化的条件为“是否落后太多的消息”</li><li>HW之前的消息代表被集群“commit”的消息，只有commit的消息才对client端（consumer以及request.required.acks为-1时的producer），在前面我们说过，这样能够使kafka在语义上支持不丢消息。我们从producer和consumer两个维度来分析：</li></ol><p>在这之前，我们先说下request.required.acks的取值范围（1，0、-1）</p><ol><li>1:leader成功就返回</li><li>0:无需等待leader响应</li><li>-1:ISR都成功才返回</li></ol><p>从producer的角度：当producer将request.required.acks设置为-1时候，保证了消息已经在多个副本中存在了，此时即便leader挂了，这个消息还是存在的（leader选举会从ISR中选举出新的leader），那么假如ISR迟迟同步不成功怎么办呢？</p><p>从consumer的角度：如果没有HW，consumer拉取到最新的消息后，而此时leader宕机，很有可能新的leader中并没有此消息。</p><p>当然不能保证消息永远不会丢，极端的情况下，如ISR中只有leader的时候（当然可以配置集群可用的最小核心副本集个数，但会极大的损失可用性），或者所有副本都宕机了（这个。。。没办法。），消息还是会丢的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一篇我们不在是探讨kafka的使用，前面几篇基本讲解了工作中的使用方式，基本api的使用还需要更深入的去钻研，多使用才会有提高。今天主要是探讨一下kafka的消息复制以及消息处理机制。&lt;/p&gt;
&lt;h4 id=&quot;1-broker的注册&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
      <category term="kafka" scheme="http://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>kafka同步异步消费和消息的偏移量（4）</title>
    <link href="http://blog.rickiyang.cn/posts/b11b90c4.html"/>
    <id>http://blog.rickiyang.cn/posts/b11b90c4.html</id>
    <published>2018-04-09T14:13:32.000Z</published>
    <updated>2018-12-06T02:53:23.042Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-消费者位置consumer-position"><a class="markdownIt-Anchor" href="#1-消费者位置consumer-position"></a> 1. 消费者位置(consumer position)</h4><p>因为kafka服务端不保存消息的状态，所以消费端需要自己去做很多事情。我们每次调用poll()方法他总是返回已经保存在生产者队列中还未被消费者消费的消息。消息在每一个分区中都是顺序的，那么必然可以通过一个偏移量去确定每一条消息的位置。</p><p>偏移量在消费消息的过程中处于重要的作用。如果是自动提交消息，那么poll()方法会去在每次获取消息的时候自动提交获取最后一条消息的偏移量，告诉服务器我们已经消费到这个位置，下次从下一个位置开始消费。</p><p>我们把更新分区当前位置的操作叫做提交。消费者是如何提交偏移量的呢？kafka最新的api是这样做的：创建一个叫做_consumer_offset的特殊主题用来保存消息的偏移量。消费者每次消费都会往这个主题发送消息，消息包含每个分区的偏移量。</p><p>如果消费者一直处于运行的状态那么这个偏移量没有什么用。不过如果这个消费者崩溃或者有新的消费者加入群组触发再均衡策略，那么再均衡之后该分区的消费者如果不是之前的那一位，那么新的小伙伴怎么知道之前的伙计消费到哪里呢。所以提交他自己的offset就发挥作用了。</p><p>Consumer读取partition中的数据是通过调用发起一个fetch请求来执行的。而从KafkaConsumer来看，它有一个poll方法。但是这个poll方法只是可能会发起fetch请求。原因是：Consumer每次发起fetch请求时，读取到的数据是有限制的，通过配置项max.partition.fetch.bytes来限制的。而在执行poll方法时，会根据配置项个max.poll.records来限制一次最多pool多少个record。</p><p>那么就可能出现这样的情况： 在满足max.partition.fetch.bytes限制的情况下，假如fetch到了100个record，放到本地缓存后，由于max.poll.records限制每次只能poll出15个record。那么KafkaConsumer就需要执行7次才能将这一次通过网络发起的fetch请求所fetch到的这100个record消费完毕。其中前6次是每次pool中15个record，最后一次是poll出10个record。</p><p>在consumer中，还有另外一个配置项：<span class="exturl" data-url="aHR0cDovL21heC5wb2xsLmludGVydmFsLm1z" title="http://max.poll.interval.ms">max.poll.interval.ms<i class="fa fa-external-link"></i></span> ，它表示最大的poll数据间隔，如果超过这个间隔没有发起pool请求，但heartbeat仍旧在发，就认为该consumer处于 livelock状态。就会将该consumer退出consumer group。所以为了不使Consumer 自己被退出，Consumer 应该不停的发起poll(timeout)操作。而这个动作 KafkaConsumer Client是不会帮我们做的，这就需要自己在程序中不停的调用poll方法了。</p><p>当一个consumer因某种原因退出Group时，进行重新分配partition后，同一group中的另一个consumer在读取该partition时，怎么能够知道上一个consumer该从哪个offset的message读取呢？也是是如何保证同一个group内的consumer不重复消费消息呢？上面说了一次走网络的fetch请求会拉取到一定量的数据，但是这些数据还没有被消息完毕，Consumer就挂掉了，下一次进行数据fetch时，是否会从上次读到的数据开始读取，而导致Consumer消费的数据丢失吗？</p><p>为了做到这一点，当使用完poll从本地缓存拉取到数据之后，需要client调用commitSync方法（或者commitAsync方法）去commit 下一次该去读取 哪一个offset的message。</p><p>而这个commit方法会通过走网络的commit请求将offset在coordinator中保留，这样就能够保证下一次读取（不论是进行rebalance）时，既不会重复消费消息，也不会遗漏消息。</p><p>对于offset的commit，Kafka Consumer Java Client支持两种模式：由KafkaConsumer自动提交，或者是用户通过调用commitSync、commitAsync方法的方式完成offset的提交。</p><h4 id="2-位移管理offset-management"><a class="markdownIt-Anchor" href="#2-位移管理offset-management"></a> 2. 位移管理(offset management)</h4><h5 id="21-自动提交"><a class="markdownIt-Anchor" href="#21-自动提交"></a> 2.1 自动提交</h5><p>Kafka默认是定期帮你自动提交位移的(enable.auto.commit = true)，使用这种简单的方式之前你需要知道可能会带来什么后果。</p><p>假设我们仍然使用默认的5s提交时间间隔，在最近一次提交之后的3s发生了再均衡，再均衡之后，消费者从最后一次提交的偏移量位置开始读取消息。这个时候偏移量已经落后<br>了3s，所以在这3s内到达的消息会被重复处理。可以通过修改提交时间间隔来更频繁地提交偏移量，减小可能出现重复悄息的时间窗，不过这种情况是无也完全避免的。</p><p>在使用自动提交时，每次调用轮询方告都会把上一次调用返回的偏移量提交上去，它并不知道具体哪些消息已经被处理了，所以在再次调用之前最好确保所有当前调用返回的消息都已经处理完毕（在调用close()方法之前也会进行自动提交）。一般情况下不会有什么问题，不过在处理异常或提前退出轮询时要格外小心。</p><h5 id="22-手动提交"><a class="markdownIt-Anchor" href="#22-手动提交"></a> 2.2 手动提交</h5><p>在多partition多consumer的场景下自动提交总会发生一些不可控的情况。所以消费者API也为我们提供了另外一种提交偏移量的方式。开发者可以在程序中自己决定何时提交，而不是基于时间间隔。</p><p>在使用手动提交之前我们需要先将：</p><pre><code>properties.put(&quot;enable.auto.commit&quot;, &quot;false&quot;);</code></pre><p>然后使用：</p><pre><code>consumer.commitSync();</code></pre><p>来提交。</p><p>commitSync()方法会提交由poll()方法返回的最新偏移量，提交成功后马上返回，否则跑出异常。</p><p>我们处理消息的逻辑可以变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           consumer.commitSync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"commit failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每处理一次消息我们提交一次offset。</p><p><strong>异步手动提交</strong></p><p>上面我们使用commitSync()的方式提交数据，每次提交都需要等待broker返回确认结果。这样没提交一次等待一次会限制我们的吞吐量。<br>如果采用降低提交频率来保证吞吐量，那么则有增加消息重复消费的风险。所以kafka消费者提供了异步提交的API。我们只管发送提交请求无需等待broker返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commitAsync()方法提交最后一个偏移量。在成功提交或碰到无怯恢复的错误之前，commitAsync()会一直重试，但是commitAsync()不会，这也是commitAsync()不好的一个地方。它之所以不进行重试，是因为在它收到服务器响应的时候， 可能有一个更大的偏移量已经提交成功。假设我们发出一个请求用于提交偏移量2000,这个时候发生了短暂的通信问题，服务器收不到请求，自然也不会作出任何响应。与此同时，我们处理了另外一批消息，并成功提交了偏移量3000。如果commitAsync()重新尝试提交偏移量2000 ，它有可能在偏移量3000之后提交成功。这个时候如果发生再均衡，就会出现重复消息。</p><p>当然使用手动提交最大的好处就是如果发生了错误我们可以记录下来。commitAsync()也支持回调方法，提交offset发生错误我们可以记下当前的偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; map, Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(e != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"commit failed"</span>+map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步和异步组合提交</strong></p><p>一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大问题，因为如果提交失败是因为临时问题导致的，那么后续的提交总会有成功的。但如果这是发生在关闭消费者或再均衡前的最后一次提交，就要确保能够提交成功。因此，在消费者关闭前一般会组合使用commitAsync()和commitSync()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"commit failed"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一切正常我们使用commitAsync()来提交。如果直接关闭消费者，就没有所谓的下一次提交了。使用commitSync()会一直重试，直到提交成功。</p><h5 id="23-提交特定偏移量"><a class="markdownIt-Anchor" href="#23-提交特定偏移量"></a> 2.3 提交特定偏移量</h5><p>上面我们手动提交使用的commitAsync()和commitSync()都是提交每一次消费最后一条消息的偏移量，那么如果我们一次拉取了很多消息但是没有消费完，想提交我们消费完成的位置该怎么处理呢？kafka也有相应的对策。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;TopicPartition,OffsetAndMetadata&gt; currentOffset = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        currentOffset.put(<span class="keyword">new</span> TopicPartition(record.topic(),record.partition()),<span class="keyword">new</span> OffsetAndMetadata(record.offset(),<span class="string">"metadata"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"模拟消息处理失败的情况"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            consumer.commitAsync(currentOffset,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用的是commitAsync()，调用commitSync()也是可以的。代码中模拟我们在处理消息的过程中可能会出错的情况，每次读消息都把当前的offset存入map中，如果出错就提交当前已经消费到的偏移量。</p><h5 id="24-再均衡监听器"><a class="markdownIt-Anchor" href="#24-再均衡监听器"></a> 2.4 再均衡监听器</h5><p>前面我们说过当发生consumer退出或者新增，partition新增的时候会触发再均衡。那么发生再均衡的时候如果某个consumer正在消费的任务没有消费完该如何提交当前消费到的offset呢？kafka提供了再均衡监听器，在发生再均衡之前监听到，当前consumer可以在失去分区所有权之前处理offset关闭句柄等。</p><p>消费者API中有一个()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe(Collection&lt;TopicPartition&gt; var1, ConsumerRebalanceListener var2);</span><br></pre></td></tr></table></figure><p>ConsumerRebalanceListener对象就是监听器的接口对象，我们需要实现自己的监听器继承该接口。接口里面有两个方法需要实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; var1)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个方法会在再均衡开始之前和消费者停止读取消息之后被调用。如果在这里提交偏移量，下一个接管分区的消费者就知道该从哪里开始读取了。</p><p>第二个会在重新分配分区之后和消费者开始读取消息之前被调用。、</p><p>我们来模拟一下再均衡的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"page_visits"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map&lt;TopicPartition,OffsetAndMetadata&gt; currentOffset = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleRebance</span> <span class="keyword">implements</span> <span class="title">ConsumerRebalanceListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; collection)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"partition is rebanlance"</span>);</span><br><span class="line">        consumer.commitAsync(currentOffset,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; collection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer.subscribe(topic,<span class="keyword">new</span> HandleRebance());</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        currentOffset.put(<span class="keyword">new</span> TopicPartition(record.topic(),record.partition()),<span class="keyword">new</span> OffsetAndMetadata(record.offset(),<span class="string">"metadata"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"模拟消息处理失败的情况"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            consumer.commitAsync(currentOffset,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先实现了ConsumerRebalanceListener接口，实现方法里面如果监听到发生再均衡我们提交当前处理过的偏移量。</p><h5 id="25-从特定偏移量处开始处理"><a class="markdownIt-Anchor" href="#25-从特定偏移量处开始处理"></a> 2.5 从特定偏移量处开始处理</h5><p>前面都是consumer.poll()之后读取该批次的消息，kafka还提供了从分区的开始或者末尾读消息的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seekToEnd(Collection&lt;TopicPartition&gt; partitions)</span><br><span class="line">seekToBeginning(Collection&lt;TopicPartition&gt; partitions)</span><br></pre></td></tr></table></figure><p>另外kafka还提供了从指定偏移量处读取消息，可以通过seek()方法来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seek(TopicPartition partition, <span class="keyword">long</span> offset)</span><br></pre></td></tr></table></figure><p>提交当前分区和当前消费位置信息。</p><h5 id="26-独立消费者不属于群组的消费者"><a class="markdownIt-Anchor" href="#26-独立消费者不属于群组的消费者"></a> 2.6 独立消费者–不属于群组的消费者</h5><p>到目前为止我们讨论的都是消费者群组，分区被自动分配给群组的消费者，群组的消费者有变动会触发再均衡。那么是不是可以回归到别的消息队列的方式：不需要群组消费者也可以自己订阅主题？</p><p>kafka也提供了这样的案例，因为kafka的主题有分区的概念，那么如果没有群组就意味着你的自己订阅到特定的一个分区才能消费内容。如果是这样的话，**就不需要订阅主题，而是为自己分配分区。**一个消费者可以订阅主题（井加入消费者群组），或者为自己分配分区，但不能同时做这两件事情。</p><p>下面的例子演示如何为自己分配分区并读取消息的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">List&lt;PartitionInfo&gt; partitionInfoList = consumer.partitionsFor(<span class="string">"page_visits"</span>);</span><br><span class="line">List&lt;TopicPartition&gt; topicPartitionList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(partitionInfoList != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(PartitionInfo partitionInfo : partitionInfoList)&#123;</span><br><span class="line">        topicPartitionList.add(<span class="keyword">new</span> TopicPartition(partitionInfo.topic(),partitionInfo.partition()));</span><br><span class="line">        consumer.assign(topicPartitionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map&lt;TopicPartition,OffsetAndMetadata&gt; currentOffset = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        currentOffset.put(<span class="keyword">new</span> TopicPartition(record.topic(),record.partition()),<span class="keyword">new</span> OffsetAndMetadata(record.offset(),<span class="string">"metadata"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"模拟消息处理失败的情况"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            consumer.commitAsync(currentOffset,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>consumer.partitionsFor(“主题”)方法允许我们获取某个主题的分区信息。</li><li>知道想消费的分区后使用assign()手动为该消费者分配分区。</li></ol><p>除了不会发生再均衡，也不需要手动查找分区，其他的看起来一切正常。不过要记住，如果主题增加了新的分区，消费者并不会收到通知。所以，要么周期性地调用consumer.partitionsFor()方法来检查是否有新分区加入，要么在添加新分区后重启应用程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-消费者位置consumer-position&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-消费者位置consumer-position&quot;&gt;&lt;/a&gt; 1. 消费者位置(consumer position)&lt;/h4&gt;
&lt;p&gt;因为k
      
    
    </summary>
    
      <category term="kafka" scheme="http://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>kafka客户端和服务端开发（3）</title>
    <link href="http://blog.rickiyang.cn/posts/34bc78bf.html"/>
    <id>http://blog.rickiyang.cn/posts/34bc78bf.html</id>
    <published>2018-04-08T08:56:33.000Z</published>
    <updated>2018-12-06T02:53:23.042Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经搭建了kafka的单机和集群环境，分别写了简单的实例代码，对于代码里面使用到的参数并没有做解释。下面我们来详细说一下各个参数的作用。</p><h4 id="1-创建kafka生产者"><a class="markdownIt-Anchor" href="#1-创建kafka生产者"></a> 1. 创建kafka生产者</h4><p>kafka生产者有3个必选的属性：</p><p><strong>bootstrap.servers</strong></p><p>该属性指定broker的地址清单，地址的格式为host:port。清单里不需要包含所有的broker 地址，生产者会从给定的broker里查找到其他broker 的信息。不过建议至少要提供两个broker的信息，一且其中一个若机，生产者仍然能够连接到集群上。</p><p><strong>key.serializer</strong></p><p>broker 希望接收到的消息的键和值都是字节数组。生产者接口允许使用参数化类型，因此可以把Java对象作为键和值发送给broker。这样的代码具有良好的可读性，不过生产者需要知道如何把这些Java 对象转换成字节数组。key.serializer必须被设置为一个实现了org.apache.kafka.common.serialization.Serializer接口的类，生产者会使用这个类把键对象序列化成字节数组。</p><p><strong>要注意， key.serializer是必须设置的，就算你打算只发送值内容。</strong></p><p><strong>value.serializer</strong></p><p>与key.serializer一样,value.serializer指定的类会将值序列化。如果键和值都是字符串，可以使用与key.serializer一样的序列化器。否则就得使用不同的序列化器。</p><p>下面的代码中展示了如何创建一个生产者，这里只指定了必要的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.131.128:9092,192.168.131.130:9092,192.168.131.131:9092"</span>);</span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br></pre></td></tr></table></figure><p>我们的键值都定义为String对象，所以都是用的是内置的StringSerializer。</p><p>实例化生产者对象之后我们就可以发送消息了，发消息主要有一下3种方式：</p><ol><li><p>发送并忘记(fire-and-forget)</p><p>我们把消息发送给服务器，但井不关心它是否正常到达。大多数情况下，消息会正常到达，因为Kafka 是高可用的，而且生产者会自动尝试重发。不过，使用这种方式有时候也会丢失一些消息。</p></li><li><p>同步发送</p><p>我们使用send()方怯发送消息， 它会返回一个Future对象，调用get()方法进行等待，就可以知道消息是否发送成功。</p></li><li><p>异步发送</p><p>我们调用send()方法并且指定一个回调函数，服务器在返回响应时调用该函数。</p></li></ol><p>上面我们已经创建了一个生产者实例，接下来就可以发送消息了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; data = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"page_visits"</span>,<span class="string">"test_key"</span>,<span class="string">"test_msg"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    producer.send(data);</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们构造了一个ProducerRecord对象用来封装topic，消息的key-value。然后用生产者实例的send方法将消息体发送出去。</p><h5 id="11-同步发送消息"><a class="markdownIt-Anchor" href="#11-同步发送消息"></a> 1.1 同步发送消息</h5><p>最简单的同步发送消息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; data = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"page_visits"</span>,<span class="string">"test_key"</span>,<span class="string">"test_msg"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    producer.send(data).get();</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即producer.send(data)返回的是一个Future对象，然后调用Future的get()方法僧带Kafka的响应。如果服务器返回错误，get()方法会抛异常。没有发生错误的话会得到一个RecordMetadata对象。可以用它来获取消息的偏移量。</p><h5 id="12-异步发送消息"><a class="markdownIt-Anchor" href="#12-异步发送消息"></a> 1.2 异步发送消息</h5><p>producer发送消息给broker，如果发送成功，会把目标主题，分区信息以及消息偏移量发送回来。但是发送端大多数时候并不关心这些，只在乎是否发送成功。有的时候对于发送是否成功的状态也不是那么的着急需要。在消息量比较大的时候，如果每一条消息都需要同步去确认发送状态很显然是会发生超时的，这个时候异步回调机制很好的帮我们解决了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; data = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"page_visits"</span>,<span class="string">"test_key"</span>,<span class="string">"test_msg"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    producer.send(data,<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"The offset of the record we just sent is: "</span> + metadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现回调需要实现org.apache.kafka.clients.producer.Callback接口，这个接口只有一个onCompletion方法。</p><p>上面我们简单实现了一个生产者，提供了一个基本实现，producer还有很多其余的配置可以灵活使用，下面我们来看一下其余的参数：</p><ul><li><p>acks ：acks参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有重要影响。该参数有如下选项：</p><ol><li>acks=0 生产者在成功写入悄息之前不会等待任何来自服务器的响应。</li><li>acks=1 只要集群的首领节点收到消息， 生产者就会收到一个来自服务器的成功响应。</li><li>acks=all 只有当所有参与复制的节点全部收到消息时， 生产者才会收到一个来自服务器的成功响应。这种模式是最安全的，它可以保证不止一个服务器收到消息，就算有服务器发生崩溃，整个集群仍然可以运行,不过，它的延迟比acks=l 时更高，因为我们要等待不只一个服务器节点接收消息。</li></ol></li><li><p>buffer.memory: 该参数用来设置生产者内存缓冲区的大小，生产者用它缓冲要发送到服务器的消息。如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足。</p></li><li><p>compression.type : 默认情况下，消息发送时不会被压缩。该参数可以设置为snappy，gzip或lz4，它指定了消息被发送给broker 之前使用哪一种压缩算陆进行压缩。</p></li><li><p>retries ： 生产者从服务器收到的错误有可能是临时性的错误（比如分区找不到首领）。在这种情况下，retries参数的值决定了生产者可以重发消息的次数，如果达到这个次数，生产者会放弃重试并返回错民。默认情况下，生产者会在每次重试之间等待lOOms，不过可以通过retry.backoff.ms参数来改变这个时间间隔。</p></li><li><p>batch.size : 当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算（而不是消息个数）。当批次被填满，批次里的所有消息会被发送出去。不过生产者井不一定都会等到批次被填满才发送，半满的批次，甚至只包含一个消息的批次也有可能被发送。</p></li><li><p><span class="exturl" data-url="aHR0cDovL2xpbmdlci5tcw==" title="http://linger.ms">linger.ms<i class="fa fa-external-link"></i></span> : 该参数指定了生产者在发送批次之前等待更多消息加入批次的时间。KafkaProducer会在批次填满或linger.ms达到上限时把批次发送出去。默认情况下,只要有可用的线程，生产者就会把消息发送出去，就算批次里只有一个消息。把linger.ms设置成比0大的数，让生产者在发送批次之前等待一会儿，使更多的消息加入到这个批次。</p></li><li><p>partitioner.class :实现Partitioner接口的分区类</p></li><li><p><span class="exturl" data-url="aHR0cDovL21heC5ibG9jay5tcw==" title="http://max.block.ms">max.block.ms<i class="fa fa-external-link"></i></span> : 这个配置控制着KafkaProducer.send() 和 KafkaProducer.partitionsFor()会阻塞多久。这个方法会因为缓冲区满了或是元数据不可用而被阻塞。在用户提供的 serializers 或 partitioner 里的阻塞将不会被计算在这个超时里。</p></li><li><p><span class="exturl" data-url="aHR0cDovL2NsaWVudC5pZA==" title="http://client.id">client.id<i class="fa fa-external-link"></i></span> : 发送请求时传递给服务器的一个标识字符串。这样做的目的是能过追踪请求的来源除了除了IP/端口。它是通过允许一个逻辑应用名称被包括在一个服务器端的请求日志来实现的。</p></li></ul><h5 id="13分区和实现自定义分区策略"><a class="markdownIt-Anchor" href="#13分区和实现自定义分区策略"></a> 1.3分区和实现自定义分区策略</h5><p>在前面的基本知识学习里面我们已经讲过kafka分区的问题，一个topic的消息会对应着一个或者多个partition。如果使用默认的分区器，那么记录将会被随机的发送到主题可用的各个分区上，分区器使用轮询算法均衡的分布到各个分区上。</p><p>kafka给用户提供了灵活的分区策略。如果你不想使用默认的均衡分布策略，而是有自己的逻辑需求，那么你可以自己控制。比如在一个topic下的消息分为两种：一种是用户信息增量更新的消息，一种是任职信息增量更新的消息。那么你可以使用自定义分区功能将两种消息分别散列在同一个topic的各个partition上。</p><p>实现自定义分区策略需要继承Partitioner接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.Cluster;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.PartitionInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePartitioner2</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String USER_INFO_KEY = <span class="string">"simple_user_info"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> partition = <span class="number">0</span>;</span><br><span class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">        <span class="keyword">if</span>(numPartitions != <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> partition;</span><br><span class="line">        &#125;</span><br><span class="line">        String stringKey = (String) key;</span><br><span class="line">        <span class="keyword">if</span>(stringKey.contains(USER_INFO_KEY))&#123;</span><br><span class="line">            partition =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们通过实现Partitioner的partition方法，对消息的key进行硬编码，确定key中是否包含某个标志来区分消息的类型进而确定该消息应该进入哪个分区。</p><h4 id="2-创建kafka消费者"><a class="markdownIt-Anchor" href="#2-创建kafka消费者"></a> 2. 创建kafka消费者</h4><h5 id="21-消费者中的群组"><a class="markdownIt-Anchor" href="#21-消费者中的群组"></a> 2.1 消费者中的群组</h5><p>熟悉JMS消息协议的应该知道，消息的消费应该有两种方式：一种是点对对的消息，一方发送，一方消费。一种是发布-订阅模式，一方发送，所有订阅方都可以消费。kafka也是遵循JMS消息规范的，所以这两种消息模式都是可以支持。但是支持的方式可能和我们想象的有些不一样！</p><p>kafka里面的消费者对应着一个<strong>消费者群组</strong>的概念。与别的消息中间件产品不同的是，每个消费者必须是属于某个消费者群组。一个群组里的消费者订阅的是同一个主题。我们通过kafka的&quot;<span class="exturl" data-url="aHR0cDovL2dyb3VwLmlk" title="http://group.id">group.id<i class="fa fa-external-link"></i></span>&quot;参数来配置消费者所属的群组。</p><p>如果你以为kafka的服务端收到一条推送的消息之后，订阅的群组里面所有消费者可以同时消费到这一条消息那你就错了。kafka对于同属一个群组的消费者的定义是：</p><ol><li>同一个分区的消息只能被某个群组中的某个消费者同时消费。</li><li>如果一个群组中的多个消费者订阅了同一个分区，那么只能有一个消费者可以同时获得这一条消息。</li><li>只有一个消费者的群组是可以同时监听到某个主题下的多个分区的。</li><li>同一个群组下的一个消费者可以指定监听多个分区，如果消费者数量和分区数量相等也可以指定1V1的监听模式。但是，如果消费者数量大于分区数量，那么必然会有消费者无法获得消息。</li></ol><p>由上我们得知：<strong>群组的概念并不是消费-订阅模式！</strong></p><p>我们需要严格保证同一个群组下的消费者数量必须小于等于所订阅的topic的分区数量。</p><p>如果存在消费者数量多于分区数量的情况，我们可以将消费者置于不同的分组中，然后再订阅该主题。kafka支持多个分组同时订阅。</p><p>关于具体的消费者的消费模式我们后面详细讨论，先来实现一个简单的消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"192.168.131.128:9092,192.168.131.130:9092,192.168.131.131:9092"</span>);</span><br><span class="line">props.put(ConsumerConfig.GROUP_ID_CONFIG ,<span class="string">"test"</span>) ;</span><br><span class="line">props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line">props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line"></span><br><span class="line">Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br></pre></td></tr></table></figure><p>消费者基本的配置和生产者差不多，我们看到第二个设置，指定了分组id。</p><p>然后需要指定要订阅哪一个topic，当然一个分组是可以订阅多个topic的，所以参数为List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"page_visits"</span>));</span><br></pre></td></tr></table></figure><p>参数也可以是正则匹配。</p><p>消息轮询是消费者API的核心，通过一个简单的轮询向服务器请求数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者必须不停地向kafka轮询，否则会被认为死亡。它的分区会被交给组里的其他消费者。poll()方法里面的参数是一个超时时间，用于设置该次请求的超时时间，如果参数被设置为0 ，请求会立即返回，否则请求会在指定的毫秒数内返回。</p><h5 id="22-消费者基本配置项"><a class="markdownIt-Anchor" href="#22-消费者基本配置项"></a> 2.2 消费者基本配置项</h5><p>消费者也有一些基本的配置项：</p><ul><li><p>fetch.min.bytes:该属性指定了消费者从服务器获取记录的最小字节数。</p></li><li><p><span class="exturl" data-url="aHR0cDovL2ZldGNoLm1heC53YWl0Lm1z" title="http://fetch.max.wait.ms">fetch.max.wait.ms<i class="fa fa-external-link"></i></span>:该属性指定了消费者从服务器获取记录的最大等待时间。该参数和fetch.min.bytes参数会互相克制。如果fetch.min.bytes没有得到满足，则会继续等待消息填充，但是如果到了fetch.max.wait.ms设置的时间，那么会直接返回。同理相反也是一样的。</p></li><li><p>max.partition.fetch.bytes:该属性指定了服务器从每个分区里返回给消费者的最大字节数。它的默认值是lMB。</p></li><li><p><span class="exturl" data-url="aHR0cDovL3Nlc3Npb24udGltZW91dC5tcw==" title="http://session.timeout.ms">session.timeout.ms<i class="fa fa-external-link"></i></span>:该属性指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是3s。如果消费者没有session.timeout.ms定的时间内发送心跳给群组协调器，就被认为已经死亡，协调器就会触发再均衡，把它的分区分配给群组里的其他消费者。该属性与heartbeat.interval.ms紧密相关heartbeat.interval.ms指定了poll()向服务器发送心跳的频率， session.timeout.ms则指定了消费者可以多久不用给服务器发送心跳。</p></li><li><p>auto.offset.reset:该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下（因消费者长时间失效，包含偏移量的记录已经过时井被删除）该作何处理。即指定该从何位置开始读取记录。</p></li><li><p>enable.auto.commit:该属性指定了消费者是否自动提交偏移量，默认值是true。为了尽量避免出现重复数据和数据丢失，可以把它为false，由自己控制何时提交偏移量。如果把它设为true ，还可以通过配置auto.commit.interval.ms属性来控制提交的频率。</p></li><li><p>partition.assignment.strategy:分区会被分配给群组里的消费者。PartitionAssignor根据给定的消费者和主题，决定哪些分区应该被分配给哪个消费者。Kafka有两个默认的分配策略:</p><ol><li><p>range</p><p>该策略会把主题的若干个连续的分区分配给消费者。假设消费者Cl和消费者C2 同时订阅了主题Tl和主题口，井且每个主题有3 个分区。那么消费者Cl有可能分配到这两个主题的分区0和分区i，而消费者C2分配到这两个主题的分区2。因为每个主题拥有奇数个分区，而分配是在主题内独立完成的，第一个消费者最后分配到比第二个消费者更多的分区。只要使用了Range策略，而且分区数量无法被消费者数量整除，就会出现这种情况。</p></li><li><p>RoundRobin</p><p>该策略把主题的所有分区逐个分配给消费者。如果使用RoundRobin策略来给消费者Cl和消费者C2分配分区，那么消费者Cl将分到主题Tl的分区0和分区2以及主题T2的分区1 ，消费者C2 将分配到主题Tl 的分区l 以及主题口的分区0 和分区2 。一般来说，如果所有消费者都订阅相同的主题（这种情况很常见）, RoundRobin策略会给所有消费者分配相同数量的分区（或最多就差一个分区）。</p><p>可以通过设置partition.assignment.strategy来选择分区策略.</p></li></ol></li><li><p><span class="exturl" data-url="aHR0cDovL2NsaWVudC5pZA==" title="http://client.id">client.id<i class="fa fa-external-link"></i></span>:该属性可以是任意字符串，broker用它来标识从客户端发送过来的消息，通常被用在日志、度量指标和配额里。</p></li></ul><p>主要的配置项如上，如果工作中还有别的需要可以去看官网的api查看。</p><p>客户端其实要说的东西还是挺多，下一节学习我们就来看关于自动提交、手动提交和偏移量的关系，又够喝一壶的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们已经搭建了kafka的单机和集群环境，分别写了简单的实例代码，对于代码里面使用到的参数并没有做解释。下面我们来详细说一下各个参数的作用。&lt;/p&gt;
&lt;h4 id=&quot;1-创建kafka生产者&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-
      
    
    </summary>
    
      <category term="kafka" scheme="http://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>kafka集群模式安装（2）</title>
    <link href="http://blog.rickiyang.cn/posts/a74a883e.html"/>
    <id>http://blog.rickiyang.cn/posts/a74a883e.html</id>
    <published>2018-04-07T12:23:15.000Z</published>
    <updated>2018-12-06T02:53:23.042Z</updated>
    
    <content type="html"><![CDATA[<p>我们来安装kafka的集群模式，三台机器：</p><pre><code>192.168.131.128192.168.131.130192.168.131.131</code></pre><p>kafka集群需要依赖zookeeper，所以需要先安装好zk。</p><p>下载kafka安装包：<br>kafka_2.11-1.1.0.tgz</p><p>解压到 /usr/local/下。</p><p>进入到kafka的config目录下：</p><p><img src="https://i.imgur.com/SXELOeW.jpg" alt=""></p><p>我们看到有zk的配置文件，这是kafka自带的zk，如果你没有安装zk，可以使用kafka集成的zk，配置方式和单独安装是一样的。</p><p>我们默认已经安装zk，所以修改server.properties文件，大致的配置项有这些：</p><pre><code>broker.id=0        #每个实例不一样listeners=PLAINTEXT://192.168.131.128:9092    #改为所在主机的ipadvertised.host.name=192.168.131.128　　　　 #改为改为所在主机的ipnum.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=/usr/local/kafka/log                                         #需手动创建，kafka并不会根据配置文件自动创建num.partitions=1num.recovery.threads.per.data.dir=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=192.168.131.128:2181,192.168.131.130:2181,192.168.131.131:2181 #修改为zookeeper所在主机ip:portzookeeper.connection.timeout.ms=6000delete.topic.enable=trueauto.create.topics.enable=false</code></pre><p>需要修改的地方已经标注出来了。</p><p>然后我们需要将kafka同步到另外两台机器上：</p><pre><code>scp -r kafka hadoop@hadoopslaver1:/usr/localscp -r kafka hadoop@hadoopslaver2:/usr/local</code></pre><p>下面我们准备启动，首先确保zk是启动的，如果没有安装可以使用kafka的zk：</p><pre><code>bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></pre><p>然后我们启动kafka：</p><pre><code>bin/kafka-server-start.sh -daemon config/server.properties &amp;</code></pre><p>三台机器上都要执行启动操作，如果偶没有报错就是启动成功了。</p><p>接下来我们可以做一些测试。</p><p>消费端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.Consumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.StringDeserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"192.168.131.128:9092,192.168.131.130:9092,192.168.131.131:9092"</span>);</span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG ,<span class="string">"test"</span>) ;</span><br><span class="line">        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"true"</span>);</span><br><span class="line">        props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="string">"1000"</span>);</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">"page_visits"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Callback;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> events = <span class="number">1</span>;</span><br><span class="line">        Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.131.128:9092,192.168.131.130:9092,192.168.131.131:9092"</span>);</span><br><span class="line">        props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">        props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line">        props.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line">        props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        <span class="comment">//配置partitionner选择策略，可选配置</span></span><br><span class="line">        props.put(<span class="string">"partitioner.class"</span>, <span class="string">"com.rickiyang.service.Partitioner"</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> nEvents = <span class="number">0</span>; nEvents &lt; events; nEvents++) &#123;</span><br><span class="line">            <span class="keyword">long</span> runtime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">            String ip = <span class="string">"192.168.2."</span> + rnd.nextInt(<span class="number">255</span>);</span><br><span class="line">            String msg = runtime + <span class="string">",www.example.com,"</span> + ip;</span><br><span class="line">            ProducerRecord&lt;String, String&gt; data = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"page_visits"</span>, ip, msg);</span><br><span class="line">            producer.send(data,</span><br><span class="line">                    <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"The offset of the record we just sent is: "</span> + metadata.offset());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义分区策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.Cluster;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.PartitionInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Partitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> partition = <span class="number">0</span>;</span><br><span class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">        String stringKey = (String) key;</span><br><span class="line">        <span class="keyword">int</span> offset = stringKey.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            partition = Integer.parseInt( stringKey.substring(offset+<span class="number">1</span>)) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行一下：</p><p>Producer：</p><p><img src="https://i.imgur.com/hgj2Q3y.jpg" alt=""></p><p>Consumer</p><p><img src="https://i.imgur.com/uRKHgiy.jpg" alt=""></p><p>客户端可以接受到服务端的消息的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们来安装kafka的集群模式，三台机器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;192.168.131.128
192.168.131.130
192.168.131.131
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kafka集群需要依赖zookeeper，所以需要先安装好zk。&lt;/p
      
    
    </summary>
    
      <category term="kafka" scheme="http://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>kafka基本知识入门（1）</title>
    <link href="http://blog.rickiyang.cn/posts/2ea97000.html"/>
    <id>http://blog.rickiyang.cn/posts/2ea97000.html</id>
    <published>2018-04-07T07:15:32.000Z</published>
    <updated>2018-12-06T02:53:23.041Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-基础知识"><a class="markdownIt-Anchor" href="#1-基础知识"></a> 1、 基础知识</h4><p>有关RabbitMQ,RocketMQ,kafka的区别这个网上很多，了解一下区别性能，分清什么场景使用。分布式环境下的消息中间件Kafka做的比较不错，在分布式环境下使用频繁，我也不免其俗钻研一下Kafka的使用。</p><p>任何消息队列都遵循AMQP协议，AMQP协议(Advanced Message Queuing Protocol,高级消息队列协议）<br>AMQP是一个标准开放的应用层的消息中间件（Message Oriented Middleware）协议。AMQP定义了通过网络发送的字节流的数据格式。因此兼容性非常好，任何实现AMQP协议的程序都可以和与AMQP协议兼容的其他程序交互，可以很容易做到跨语言，跨平台。</p><p>Kafka是一个分布式的、可分区的、可复制的消息系统。它提供了普通消息系统的功能，但具有自己独特的设计。</p><p>我们先看一些基本的概念：</p><ol><li>消费者：（Consumer）：从消息队列中请求消息的客户端应用程序</li><li>生产者：（Producer） ：向broker发布消息的应用程序</li><li>AMQP服务端（broker）：用来接收生产者发送的消息并将这些消息路由给服务器中的队列，便于fafka将生产者发送的消息，动态的添加到磁盘并给每一条消息一个偏移量，所以对于kafka一个broker就是一个应用程序的实例</li><li>主题（Topic）：一个主题类似新闻中的体育、娱乐、教育等分类概念，在实际工程中通常一个业务一个主题。</li><li>分区（Partition）：一个Topic中的消息数据按照多个分区组织，分区是kafka消息队列组织的最小单位，一个分区可以看作是一个FIFO（ First Input First Output的缩写，先入先出队列）的队列。</li></ol><p>kafka将消息以topic为单位进行归纳，每个broker其实就是一个应用服务器，一个broker中会有很多的topic，每个topic其实就是不同的服务需要消息的消息的聚集地。因为每个topic其实会很大，所以就出现了partition个概念，将每个topic的消息分区存储。</p><p><img src="https://i.imgur.com/lFcOzFz.jpg" alt=""></p><p>kafka中的消费者有一个分组的概念，<strong>每个consumer属于一个consumer group;反过来说,每个group中可以有多个consumer.发送到Topic的消息,只会被订阅此Topic的每个group中的一个consumer消费（而不是该group下的所有consumer，一定要注意这点）</strong></p><ul><li>如果所有的consumer都具有相同的group,这种情况和queue模式很像;消息将会在consumers之间负载均衡.</li><li>如果所有的consumer都具有不同的group,那这就是&quot;发布-订阅&quot;;消息将会广播给所有的消费者.</li></ul><p>在kafka中,<strong>一个partition中的消息只会被group中的一个consumer消费</strong>;每个group中consumer消息消费互相独立;我们可以认为一个group是一个&quot;订阅&quot;者,一个Topic中的每个partions,只会被一个&quot;订阅者&quot;中的一个consumer消费,不过一个consumer可以消费多个partitions中的消息.</p><p>分布式环境中，Kafka默认使用zookeeper作为注册中心，kafka集群几乎不维护任何consumer和producer的信息状态，这些信息都由zookeeper保存，所以consumer和producer非常的轻量级，随时注册和离开都不会对Kafka造成震荡。</p><p><strong>producer和consumer通过zookeeper去发现topic，并且通过zookeeper来协调生产和消费的过程。</strong><br>producer、consumer和broker均采用TCP连接，通信基于NIO实现。Producer和consumer能自动检测broker的增加和减少。</p><p>上面图中没有说明partition的组成，partition物理上由多个<strong>segment</strong>组成，每一个segment 数据文件都有一个索引文件对应。每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做<strong>offset</strong>,用于partition唯一标识一条消息.</p><p>相比传统的消息系统，Kafka可以很好的保证有序性。</p><p>传统的队列在服务器上保存有序的消息，如果多个consumers同时从这个服务器消费消息，服务器就会以消息存储的顺序向consumer分发消息。虽然服务器按顺序发布消息，但是消息是被异步的分发到各consumer上，所以当消息到达时可能已经失去了原来的顺序，这意味着并发消费将导致顺序错乱。为了避免故障，这样的消息系统通常使用“专用consumer”的概念，其实就是只允许一个消费者消费消息，当然这就意味着失去了并发性。</p><p>在这方面Kafka做的更好，通过分区的概念，Kafka可以在多个consumer组并发的情况下提供较好的有序性和负载均衡。将每个分区分只分发给一个consumer组，这样一个分区就只被这个组的一个consumer消费，就可以顺序的消费这个分区的消息。因为有多个分区，依然可以在多个consumer组之间进行负载均衡。注意consumer组的数量不能多于分区的数量，也就是有多少分区就允许多少并发消费。</p><p>Kafka只能保证一个分区之内消息的有序性，在不同的分区之间是不可以的，这已经可以满足大部分应用的需求。如果需要topic中所有消息的有序性，那就只能让这个topic只有一个分区，当然也就只有一个consumer组消费它。</p><h5 id="11-message-被分配到-partition-的过程"><a class="markdownIt-Anchor" href="#11-message-被分配到-partition-的过程"></a> 1.1、 message 被分配到 partition 的过程</h5><p>每一条消息被发送到broker时，会根据paritition规则（有两种基本的策略，一是采用Key Hash算法，一是采用Round Robin算法）选择被存储到哪一个partition。如果partition规则设置的合理，所有消息可以均匀分布到不同的partition里，这样就实现了水平扩展。（如果一个topic对应一个文件，那这个文件所在的机器I/O将会成为这个topic的性能瓶颈，而partition解决了这个问题）。</p><p>在发送一条消息时，可以指定这条消息的key，producer根据这个key和partition机制来判断将这条消息发送到哪个parition。paritition机制可以通过指定producer的paritition.class这一参数来指定，该class必须实现kafka.producer.Partitioner接口。</p><h5 id="12-segment文件存储结构"><a class="markdownIt-Anchor" href="#12-segment文件存储结构"></a> 1.2、 segment文件存储结构</h5><p>segment file由2大部分组成，分别为index file和data file，这两个文件一一对应，成对出现，后缀&quot;.index&quot;和“.log”分别表示为segment索引文件、数据文件。</p><p>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</p><p>文件类似于下面这种形式：</p><pre><code>0000000000000000001.index0000000000000000001.log0000000000000036581.index0000000000000036581.log0000000000000061905.index0000000000000061905.log</code></pre><p>index和data-file的对应关系如下：</p><p><img src="https://i.imgur.com/2Eg7VQH.png" alt=""></p><p>index file 存储索引文件，文件中的元数据指向对应数据文件中message的物理偏移地址。</p><h4 id="2-kafka单机环境搭建"><a class="markdownIt-Anchor" href="#2-kafka单机环境搭建"></a> 2、 Kafka单机环境搭建</h4><p>下载kafka，解压缩</p><p>配置环境变量：</p><pre><code>export KAFKA_HOME=/usr/local/kafka                                                                                                                                                                        export PATH=$PATH:$KAFKA_HOME/bin 重启生效source /etc/profile</code></pre><p>Kafka用到了zeekeeper，所以需要先启动zookeeper，没有安装的需要先安装zk，安装好了以后我们可以启动，我们先来实现单机版的kafka，先启动一个单单例的zk服务，可以在命令的结尾加个&amp;符号，这样就可以启动后离开控制台。</p><pre><code># bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></pre><p>再启动kafka：</p><pre><code># bin/kafka-server-start.sh config/server.properties</code></pre><p>创建topic：</p><pre><code># bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre><p>创建producer，可以在控制台手动输入消息：</p><pre><code># bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test this is a message</code></pre><p>ctrl+c 可以退出发送。</p><p>创建consumer：</p><pre><code># bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginningthis is a message会收到刚才的发送的消息</code></pre><p>我们的一个简单的单机环境就搭建好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-基础知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-基础知识&quot;&gt;&lt;/a&gt; 1、 基础知识&lt;/h4&gt;
&lt;p&gt;有关RabbitMQ,RocketMQ,kafka的区别这个网上很多，了解一下区别性能，分清什么场景使用。分布式环境下
      
    
    </summary>
    
      <category term="kafka" scheme="http://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>hive安装</title>
    <link href="http://blog.rickiyang.cn/posts/c40dabb2.html"/>
    <id>http://blog.rickiyang.cn/posts/c40dabb2.html</id>
    <published>2018-03-11T14:38:12.000Z</published>
    <updated>2018-12-06T02:53:23.041Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hive安装"><a class="markdownIt-Anchor" href="#hive安装"></a> hive安装</h4><ol><li><p>下载hive，我下载的版本是：apache-hive-2.3.2-bin.tar.gz。解压文件：</p><pre><code> #tar -zxvf apache-hive-2.3.2-bin.tar.gz</code></pre></li><li><p>设置环境变量：</p><p>#vi /etc/profile</p><p>export HIVE_HOME=/usr/local/hive<br>export PATH=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">PATH:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>HIVE_HOME/bin</p><p>#source /etc/profile</p></li><li><p>Hive中metastore（元数据存储）的存储方式有三种：</p><ul><li>a)内嵌Derby方式</li><li>b)Local方式</li><li>c)Remote方式</li></ul></li></ol><p>本次选择使用local方式，存储到当前机器的mysql中。没有安装mysql的需要先安装mysql。</p><p>另外，因为hive启动需要从元数据存储器中查找元数据并加载，所以需要将mysql的jar包放在hive安装包下的lib目录下。&lt;mysql-connector-java-5.1.38.jar&gt;下载放入即可。</p><ol start="4"><li>进入hive下的conf目录：将hive-default.xml.template 复制一份存为：<br>hive-site.xml；将hive-env.sh.template修改存为：<span class="exturl" data-url="aHR0cDovL2hpdmUtZW52LnNo" title="http://hive-env.sh">hive-env.sh<i class="fa fa-external-link"></i></span>。<br>修改hive-site.xml中的内容：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive_remote/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.local<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost/hive_remote?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>password<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mysql的用户名和密码写自己的。另外还有两处需要修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.scratdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/hive/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">这个是设定临时文件目录</span><br><span class="line">--------------------------------------</span><br><span class="line">//这个在笔者的文件中没有可以自己添加</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.querylog.location<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/hive/log<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">这个是用于存放hive相关日志的目录</span><br></pre></td></tr></table></figure><p>如果不改启动的时候会报错的！</p><p><span class="exturl" data-url="aHR0cDovL3huLS1oaXZlLWVudi0wbjNtbTI3by5zaA==" title="http://xn--hive-env-0n3mm27o.sh">修改hive-env.sh<i class="fa fa-external-link"></i></span>，添加hadoop的路径：</p><pre><code>HADOOP_HOME=/usr/local/hadoop</code></pre><p>上面我们在hive-site.xml中配置了hive的元数据存放库，那么在mysql中也需要创建相应的库，我使用的用户名是hive如果你想使用root或者别的也是可以的：</p><pre><code>mysql&gt; create database hive_remote;mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'hive'@'%' IDENTIFIED BY 'hive';       </code></pre><p>元数据库创建完毕，需要hive元数据库初始化，执行：</p><pre><code> schematool -dbType mysql -initSchema</code></pre><p>没有出错就是初始化完毕，有出错查看相关错误解决。接下来我们就可以启动hive试一下了，进入bin目录，输入：hive即可：</p><pre><code>[hadoop@hadoopmaster bin]$ hivewhich: no hbase in (/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/java/jdk/bin:/usr/java/jdk/jre/bin:/usr/local/hadoop/bin:/usr/local/hadoop/sbin:/usr/local/zookeeper/bin:/usr/local/hive/bin:/home/hadoop/bin)SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/usr/local/hive/lib/log4j-slf4j-impl-2.6.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/usr/local/hadoop/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Logging initialized using configuration in jar:file:/usr/local/hive/lib/hive-common-2.3.2.jar!/hive-log4j2.properties Async: trueHive-on-MR is deprecated in Hive 2 and may not be available in the future versions. Consider using a different execution engine (i.e. spark, tez) or using Hive 1.X releases.hive&gt; show tables;OKTime taken: 5.91 secondshive&gt; show databases;OKdefaultTime taken: 0.068 seconds, Fetched: 1 row(s)</code></pre><p>如上便是成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;hive安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hive安装&quot;&gt;&lt;/a&gt; hive安装&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载hive，我下载的版本是：apache-hive-2.3.2-bin.tar.gz。解压文件：&lt;
      
    
    </summary>
    
      <category term="大数据学习" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hive" scheme="http://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hive/"/>
    
    
      <category term="大数据" scheme="http://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>git学习（2）</title>
    <link href="http://blog.rickiyang.cn/posts/eed666b7.html"/>
    <id>http://blog.rickiyang.cn/posts/eed666b7.html</id>
    <published>2017-12-16T09:07:12.000Z</published>
    <updated>2018-12-06T09:59:13.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git常用指令一览表"><a class="markdownIt-Anchor" href="#git常用指令一览表"></a> git常用指令一览表</h3><table>    <thead>        <tr>            <td>GIT指令</td>            <td>说明</td>        </tr>    </thead>    <tbody>        <tr>            <td>git add .</td>            <td>将全部文件的内容加到Git索引以便执行commit. 这个指令不会检查文件夹中是否有文件被删除。                要注意的是，只有执行“ git add”时的文件内容会被加入Git 索引。如果后来又修改了文件，                新的文件内容不会在Git索引中。我们必须重新执行“ git add ”指令，才会更新Git索引。</td>        </tr>        <tr>            <td>git add 文件名 文件名 ...</td>            <td>将指定的文件的内容加到Git 索引，以便执行commit 操作。要注意的是，                只有执行“ git add”时，文件内容才会被加入Git 索引。如果后来又修改了文件，                新的文件内容不会在Git 索引中。我们必须重新执行“ git add ”指令，才会更新Git 索引。</td>        </tr>        <tr>            <td>git add -A </td>            <td>除了把全部文件的内容加到Git 索引以外，也会检查文件夹中是否有文件被删除。这些                被删除的文件会标记在Git 索引中，当执行commit 指令的时候，被标记删除的文件也会                从新的commit 节点中被删除。我们可以从Git 丈档库的历史版本中找回被删除的文件。</td>        </tr>        <tr>            <td>git add --update <br>或是<br> git add -u</td>            <td>对比当前文件夹中的文件内容和Git 文档库中的文件内容，把有修改的部分和删除的文                或是件加到Git 索引，以便执行commit 。这个指令不会增加新的文件到Git 索引，只会更新                或是删除文件。</td>        </tr>        <tr>            <td>git blame 文件名<br>            或者 <br>git blame -L 起始行，结束行文件名<br>            或者 <br>git blame -L 起始行，文件名<br>            或者<br> git blame -L 结束行，文件名</td>            <td>显示文件的每一行是由谁修改。可以搭配“－L”选项，指定要从哪一行开始到哪一行                或是结束。如果没有指定起始行，表示是从文件的第一行开始。如果没有指定结束行，                表示要到文件的最后一行。</td>        </tr>        <tr>            <td>git branch 自己取的分支名称<br>[commit 节点标识符或是标签]</td>            <td>按照参数的多少，会有不同的功能：<br>                1. 如果最后指定了commit 节点标识符或是标签，就会从该节点“长”出分支；如果没                有指定commit 节点，就会从最新的commit“长”出分支;<br>                2 “ git branch”指令后面没有接任何参数时，会列出当前文档库中正在开发的所有分支。</td>        </tr>        <tr>            <td>git branch 新分支的名称己经存在的分支</td>            <td>从特定的分支，再长出另一个新的分支。</td>        </tr>        <tr>            <td>git branch -a</td>            <td>列出丈档库和远程文档库中所有的分支。</td>        </tr>        <tr>            <td>git branch -d 要删除的分支名称</td>            <td>删除指定的分支。必须先切换到另一个分支,才能执行这个指令。</td>        </tr>        <tr>            <td>git branch -D 要删除的分支名称</td>            <td>在一般情况下，分支应该先合并到另一个分支，之后才能够被删除。如果我们要删除还                没有合并的分支， Git 会显示错误信息，并且停止删除分支的操作。如果确定要删除还                没有合并的分支，可以使用“－D ”选项，要求Git 强制执行删除分支的操作。</td>        </tr>        <tr>            <td>git branch --list 分支名称样板</td>            <td>显示符合“分支名称样板”的所有分支，例如以下指令范例会显示所有以“ bug/”开头                的分支：git branch --list bug/*</td>        </tr>        <tr>            <td>git branch -m 新的分支名称</td>            <td>更改分支的名称。必须先切换到该分支，才能够执行这个指令。</td>        </tr>        <tr>            <td>git checkout 文件1 文件2 ... <br>                或是<br> git checkout .</td>            <td>Git 会先找索引中有没有该文件，如果有就把它取出：如果没有，就从最新的commit                节点开始，按照时间顺序往前寻找，然后取出第一个找到的文件版本，每一个文件都用                同样的方式处理。如果要取出文档库中全部文件的最新版本，可以执行“ git checkout .”’</td>        </tr>        <tr>            <td>git checkout commit 节点标识符或标签[文件1 文件2..]</td>            <td>从Git 文档库的commit 节点取出指定的文件。如果取出的文件和当前文档库中最新                commit 的文件内容不同，这个取出的文件内容会自动记录在Git 索引中。下次执行"git commit"                指令时，这个取出的文件内容就会存入文档库中成为新的版本。如果要避免这                种情况发生，可以在执行“git checkout"指令之后，立刻执行“ git reset HEAD ”来清除                Git 索引。</td>        </tr>        <tr>            <td>git checkout 分支名称</td>            <td>将当前操作的分支切换到指定的分支。</td>        </tr>        <tr>            <td>git checkout -f 分支名称</td>            <td>在切换分支的时候， Git 会先对比丈档库中当前分支的文件内容是否和将要切换过去的                分支的文件内容相同。针对内容不一样的文件， Git 需要从文档库中取出该文件，这是                为了让文件夹中的文件符合分支原来的状态。但是为了避免数据遗失，当Git 要覆盖                文件夹中的文件时，会检查该文件的内容是否已经加入文档库。如果还没有加入， Git                会显示警告信息，并且停止执行，以免资料遗失。如果我们确定不想保留这些已经修改                却还没有加入文档库的文件，可以加入“－f”选项，这样Git 就会强制覆盖修改后的文件。            </td>        </tr>        <tr>            <td>git checkout -b 新分支的名称[commit 节点标识符或是标签]</td>            <td>创建指定的分支，然后切换到新创建的分支。这个指令等同于先执行“ git branch 新分支的                名称commit 节点标识符或是标签” ， 接着再执行“ git checkout 新分支的名称”。如果最                后指定了commit 节点标识符或是标签，就会从该节点“长”出分支。如果没有指定commit                节点，就会从最新的commit “ 长”出分支。</td>        </tr>        <tr>            <td>git cherry-pick -n commit 节点标识或标签</td>            <td>把指定的commit节点的文件版本合并到文件夹中的文件。在默认情况下                ，执行这个指令会创建一个新的commit 节点。如果不想要创建新节                或标签点， 则可以加上"－n"选项。执行这个指令之前，                文件夹中被修改的文件必须先存入Git 文档库，否则会出现警告信息，并且停止执行。</td>        </tr>        <tr>            <td>git clone “远程Git 文档库”的路径</td>            <td>从“远程Git 文档库”复制一个“本地Git或是文档库”到我们的计算机。                第一种方式适用的情况是“远程Git 文档库”在我们自己的计算机上。                </td>        </tr>        <tr>            <td>git clone --bare[程序项目文件夹名称][“远程Git文档库”的路径]</td>            <td>从“本地Git 文档库”复制出Bare 类型的“远程Git 文档库"            我们通常会帮Bare类型的文档库加上扩展名".git"，例如game.git。            </td>        </tr>        <tr>            <td>git commit -m ‘这次操作的说明’ [--author=‘操作者姓名 [email 邮箱]’]</td>            <td>把当前Git 索引的内容送进文档库存储。每一次执行commit 一定要附加说明和操作者                信息。如果没有使用“－m ” 选项， Git 会启动文字编辑程序让我们输入操作说明。默认                的文字编辑程序是vi ，我们可以使用“ git config ”指令设置其他的文字编辑程序，详                细操作方式请参考第2 单元的说明。除了使用“--author”选项输入操作者信息以                外，也可以把操作者的信息记录在Git 配置文件中， 这样就不用加上“--author” 选项.                </td>        </tr>        <tr>            <td>git commit -a -m ‘这次操作的说明’[--author=‘操作者姓名[email 邮箱]’]            或是  git commit --all -m ‘这次操作的说明’[--author=‘操作者姓名[email 邮箱]’]</td>            <td>这个指令的效果等同于先执行“git add -u"再执行“ git commit -m ‘这次操作的说明’                --author=‘操作者姓名[email 邮箱]’”。首先对比当前文件夹中的文件内容和Git 文                档库中的文件内容，把有修改的部分和删除的文件加到Git 索引，然后执行commit。这                个指令不会把新的文件加到Git 文档库。</td>        </tr>        <tr>            <td>git commit --amend -m ‘新的操作说明’--author=‘操作者姓名[email 邮箱]’)</td>            <td>修改最近一次commit 节点的操作说明，或是操作者信息</td>        </tr>        <tr>            <td>git config -l 或者                git config --global -l            或者 git config --system -l</td>            <td>只有使用“ －l”选项时会显示三个不同层级的配置文件中所有的设置项。低优先权配置                文件的设置项会先显示，最高优先权配置文件的设置项显示在最后。<br>                加入“--global ” 选顶时会显示优先权配置文件中的设置项，也就是登录账号的home                或是directory 里面的.gitconfig 文件中的设置。<br>                加入“--system ”选项时会报示最低优先权配置文件中的设置顶，也就是Git程序安装文                件夹里面的etc\gitconfig 文件夹的设置。</td>        </tr>        <tr>            <td>git config 设置项名称‘设置值’<br>            或者<br> git config --global 设置项名称‘设置值’<br>            或者<br> git config --system 设置项名称‘设置值‘</td>            <td>在Git 配置文件中加入或是修改设置。如果“设置值”中没有空格，可以省略单引号。                如果没有使用任何选项，表示要将设置项写到当前操作中的Git文档库中的配置文件。                如果加入“--global ”选项，表示要将设置项写到登录账号的home directory 里面                的.gitconfig 配置文件中．如果加入“--system”选项，表示要将设置项                写到Git 程序安装文件夹里面的etc\gitconfig配置文件中。            </td>        </tr>        <tr>            <td>Git diff 文件名</td>            <td>判断该文件是否发成冲突或者解决冲突是否成功</td>        </tr>        <tr>            <td>Git fetch            或者 git fetch --all</td>            <td>从“远程Git 文档库”取回当前所在分支的最新数据。完成这项工作之后，我们计算机                上的“远程Git 文档库”的当前分支状态就和实际的情况一致。如果想要一次获取全部                分支最新的数据，可以加上“－all ”选项。</td>        </tr>        <tr>            <td>Git init</td>            <td>在当前的文件夹创建一个Git 文档库。如果这个文件夹己经有Git 文档库，这个指令就                不会再重新创建，也不会修改其中的内容。Git 文档库其实是名称叫作“ .git ”的子文件                夹，默认它会被隐藏起来，我们可以改变文件夹的查看选项让它显示出来。如果删除这                个子文件夹， Git 文档库的内容就会全部消失。            </td>        </tr>        <tr>            <td>Git init -bare Git 文档库文件夹名称</td>            <td>创建Bare 类型的Git 文档库。我们通常会帮Bare 类型的Git 文档库加上扩展名“ .git ”，                例如game.git 。</td>        </tr>        <tr>            <td>git log</td>            <td>按照时间顺序，从最近一次的commit 开始，往前列出每一次commit 的信息，包括标识                符、执行人、日期利时间以及说明。</td>        </tr>        <tr>            <td>Git log -after=’公元年－月－日 时间’[--before＝’公元年－月－日 时间’]</td>            <td>指定要显示某一段时间期间的commit 的信息。“ after＂可以换成“-since ”，“--before ”                可以换成“-until"。</td>        </tr>        <tr>            <td>Git log -author=‘人名’</td>            <td>只显示特定人的commit 节点信息。</td>        </tr>        <tr>            <td>git log --graph --online --all --decorate</td>            <td>加上“--graph ” 选项会用文本模式排列出commit 节点的演进图<br>．加上’--oneline ”选                项会用最精简的方式显示．<br>加上“ --all ”选项会显示所有分支的commit信息。<br>                加上“--decorate ” 选项表示要标示分支的名称。            </td>        </tr>        <tr>            <td>git log --stat<br>            或者<br> git log --shortstat<br>            或者 <br>git log --numstat</td>            <td>显示每一个commit 更改程序代码和文件的情况，包括有多少文件被修改了、                增加了几行程序代码和删除了几行程序代码。</td>        </tr>        <tr>            <td>git ls-file</td>            <td>列出当前Git 文档库中的文件列表。</td>        </tr>        <tr>            <td>git ls-remote</td>            <td>列出“本地Git 文档库”对应的所有“远程Git 文档库”</td>        </tr>        <tr>            <td>git merge 分支名称</td>            <td>把指定的分支合并到当前所在的分支。</td>        </tr>        <tr>            <td>git merge --abort</td>            <td>合并的过程发生冲突之后，执行这个指令可以放弃合并。Git 文档库和文件夫中的文件                内容都会恢复到未执行合并前的状态。</td>        </tr>        <tr>            <td>git merge --no-ff 分支名称</td>            <td>“--no-ff”逃项表示不要使用fast-forward merge 。</td>        </tr>        <tr>            <td>git mv 原来的文件名 新文件名</td>            <td>更改文件夹巾的文件名，或是子文件夹名称，然后把它记录在Git 索引。接着只要执行                “git commit"指令，就可以将更改存入文档库。</td>        </tr>        <tr>            <td>git pull<br>            或者 <br>git pull -all</td>            <td>"git pull"指令会执行两项工作：<br>                1. 从“远程Git 文档库”取回当前所在分支的最新数据。完成这项工作之后，计算机                上的“远程Git 文档库”的当前分支状态就和实际的情况一致。如果想要一次获取全部                分支最新的数据，可以加上“--all ”选项。<br>2. 把“远程Git 文档库”的分支合并到“本                地Git 文档库”的分支。</td>        </tr>        <tr>            <td>git pull --rebase<br>            或者<br> git pull -r</td>            <td>把“ git pull ＂指令的第二个步骤换成“ git rebase” （原来是“ git merge" ）。</td>        </tr>        <tr>            <td>git push</td>            <td>执行这个指令时，屏幕画面会显示一段信息，提示我们需要在Git 的配置文件中如入                push.default 的设置。我们可以执行下列指令，指定push.default 为matching:                <br>git config --global push.default matching<br>                这样的话，如果只下达"git push"指令，后面没有加上任何参数， Git 会                把“本地Git文档库”中所有曾经传送给“远程Git 文档库”的分支，都一并更新.                或者，可以执行下列指令，指定push.default 为simple:                <br>git config --global push.default simple<br>                这样的话，如果只下达“ git push ”指令，后面没有加上任何参数。Git 会检查当前所在                的分支是否在配置文件中记录了它对应的“远程Git 文档库”的分支。如果有，就会                传送更新给“远程Git 文档库”。否则，就不会执行更新。和matching 的设置相比之下，                simple 是比较安全的做法。因为它只会更新当前所在的分支，不会一次更新全部的分支。            </td>        </tr>        <tr>            <td>git push origin 分支名称</td>            <td>把指定分支的最新状态送到origin 属性所对应的“远程Git 文档库”。执行这个指令不                会在配置文件中记录“本地Git 文档库”的分支和“远程Git 文档库”的分支之间的对                应关系．</td>        </tr>        <tr>            <td>git push “远程Git 文档库”的url 分支名称</td>            <td>把指定分支的最新状态送到指定的“远程Git文档库”。执行这个指令不会在配置文件中                记录“本地Git 文档库”的分支和“远程Git文档库”的分支之间的对应关系。</td>        </tr>        <tr>            <td>git push --all</td>            <td>把“本地Git 文档库”中所有的分支传送到“远程Git 文档库”。</td>        </tr>        <tr>            <td>git push “远程Git 文档库”的名称 --delete[分支名称]</td>            <td>删除“远程Git 文档库”中的指定分支。</td>        </tr>        <tr>            <td>git rebase 分支名称</td>            <td>把指定分支的修改运用到当前的分支。当前分支会变成从指定的分支的HEAD 节点长                出来。</td>        </tr>        <tr>            <td>git rebase --abort</td>            <td>如果执行rebase 指令后出现冲突的情况，可以使用这个指令取消rebase 的操作。                Git 文档库会恢复到还没有执行rebase 之前的状态。            </td>        </tr>        <tr>            <td>git rebase --continue</td>            <td>执行rebase 指令后出现冲突的情况，而且我们己经编辑好发生冲突的文件，                接着就可以执行“git add”指令， 把新的文件内容加入Git 索引，                最后再执行这个指令，完成rebase的操作。            </td>        </tr>        <tr>            <td>git reflog HEAD 或是任何分支的名称</td>            <td>显示HEAD 或是任何分支变动的历史记录。如果不加任何参数，默认会列出HEAD 变动                的历史记录。</td>        </tr>        <tr>            <td>git remote -v</td>            <td>显示和“远程Git 文档库”相关的设置。</td>        </tr>        <tr>            <td>git remote add [“远程Git 文档库”的名称] [“远程Git 文档库”的url]</td>            <td>在“本地Git 文档库”的配置文件中加入指定的“远程Git 文档库”名称， 并且设置它                的url</td>        </tr>        <tr>            <td>git remote rm “远程Git 文档库”的名称<br>            或者 <br>git remote remove “远程Git 文档库”的名称</td>            <td>删除“本地Git 文档序”的配置文件指定的“远程Git 文挡库”名称。                一旦删除“远程Git 文档库”的名称，所有属于它的追踪                分支也会一并消失。如果要再还原回来，只要再执行"git remote add"指令                和“ git remote update"指令即可。</td>        </tr>        <tr>            <td>git remote rename 旧名称 新名称</td>            <td>改变“远程Git 文档库”的名称。改变“远程Git 文档库”的名称之后，                和它相关的远程追踪分支的名称也会自动更新。</td>        </tr>        <tr>            <td>git reset HEAD 文件名</td>            <td>将指定文件的内容从Git 索引中删除。如果没有加上文件名，则会清除                Git 索引中所有的内容。</td>        </tr>        <tr>            <td>git reset --soft commit 节点标识符或是标签<br>            或者<br> git reset --mixed commit 节点标识符或是标签<br>            或者<br> git reset --hard commit 节点标识符或是标签</td>            <td>将Git 文档库“消磁”，让Git 文挡库恢复到某一个commit 节点的状态，                如果使用“--soft ＂选项，表示只有文档库中的数据会更改，                Git 索引和文件夹中的文件都不会受到影响。如果使用“--mixed ”选项（这是默                认的选项），表示Git 索引也会恢复到指定节点的状态，但是文件夹中的文件仍然不会                受到影响。如果使用“--hard ” 选项，则文档库、Git索引和文件夹中的文件都会恢复到                指定节点的状态。</td>        </tr>        <tr>            <td>git revert commit 节点</td>            <td>回到指定的commit 节点的前一个节点的文件状态。执行完毕后会新增一个commit 节                点。请注意和“ git reset ”指令的差别。</td>        </tr>        <tr>            <td>git revert --abort</td>            <td>如果执行“git revert”指令的时候发生冲突，可以执行这个指令取消revert 的操作。</td>        </tr>        <tr>            <td>git rm 文件名</td>            <td>Git 会执行两项检查：<br>Git 索引中有没有该文件的内容（也就是                刚刚有没有执行过“git add 文件名”），如果有，表示这个文件的内容和文档库中的不                一样，为了避免遗失数据， Git 会显示提醒信息，然后放弃执行：<br>                2. 文件夹中的文件内容是不是和文档库中的一样，如果不一样， Git 同样会显示提醒                信息，然后放弃执行，以免遗失数据。如果通过以上两项检查， Git 会马上删除文                件夹中的文件，然后在索引中记录要从文档库中删除该文件。最后必须再执行"git                commit"指令才会真正从文档库中删除文件。</td>        </tr>        <tr>            <td>git rm --cached 文件名</td>            <td>把指定的文件从tracked 状态变成untracked状态，也就是说从此以后不需要在文档库中                更新这个文件， 而且Git 索引中这个文件的内容也会被删除，但是Git 不会从文件夹中                删除这个文件(这是加上"--cached”选项最大的差别)。</td>        </tr>        <tr>            <td>git shortlog</td>            <td>按照人名的字母顺序，列出每－个人执行commit 的次数和说明。                加上“--numbered ”选项（或是“ －n " ）可以按照commit 次数，由高至低按序排列。                如果不需要显示commit 说明，可以加上"--summary ＂选项（或是“－s ”）。</td>        </tr>        <tr>            <td>git show commit 节点标识符或是标签</td>            <td>显示特定commit 节点的详细信息。commit节点标识符是一组很长的16 进制数字，指                定commit 节点标识符时，不需要将它完整列出。一般只要使用最前面4 个数字即可，                Git 会向动找出对应的节点。如果找到超过一个以上的节点， Git 会显示错误信息，                这时候换长一点的数字就可以解决。</td>        </tr>        <tr>            <td>git show 文件名</td>            <td>显示指定文件最新版本的修改情况。也就是比较文件最新版本和前一个版本的差异。</td>        </tr>        <tr>            <td>git stash list</td>            <td>显示Git 暂存区的状态。</td>        </tr>        <tr>            <td>git stash pop 或者                git stash apply</td>            <td>取出暂存区的文件，将它们的内容合并到当前文件夹中的文件。</td>        </tr>        <tr>            <td>git stash save</td>            <td>这个指令会执行下列两项工作：                存储文件夹中被Git 追踪的文件和文档库中最新文件版本的差异：                把文件夹中被Git 追踪的文件还原成文档库中最新的文件版本。            </td>        </tr>        <tr>            <td>git status</td>            <td>这个指令会执行以下3 项工作：<br>                ]. 检查Git 索引的内容，看看是否需要执行commit 存入文档库。<br>                2. 对比文件夹中的文件和文档库中的文件，列出修改过的文件列表。<br>                3. 列出untracked 状态的文件。</td>        </tr>        <tr>            <td>git tag 自定义的标签名称[commit 节点标识符或是标签]</td>            <td>指定的commit 节点贴上自定义的标签，之后就可以用这个自定义的标签来指定这个                commit 节点。</td>        </tr>        <tr>            <td>git tag -d commit 节点标签</td>            <td>删除自定义的commit 节点标签。</td>        </tr>        <tr>            <td>gitk --all</td>            <td>启动图形操作模式，如果加入“--all ”选项，表示要显示全部的分支，否则只会显示当前                操作中的分支。</td>        </tr>    </tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;git常用指令一览表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#git常用指令一览表&quot;&gt;&lt;/a&gt; git常用指令一览表&lt;/h3&gt;

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td&gt;G
      
    
    </summary>
    
      <category term="git" scheme="http://blog.rickiyang.cn/categories/git/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>git学习（1）</title>
    <link href="http://blog.rickiyang.cn/posts/fc63c959.html"/>
    <id>http://blog.rickiyang.cn/posts/fc63c959.html</id>
    <published>2017-11-29T14:15:23.000Z</published>
    <updated>2018-12-06T02:53:23.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-git配置文件"><a class="markdownIt-Anchor" href="#1-git配置文件"></a> 1 git配置文件</h3><h4 id="11-git权限控制"><a class="markdownIt-Anchor" href="#11-git权限控制"></a> 1.1 git权限控制</h4><p>git有三个不同的权限控制文件，高优先权的设置会覆盖低优先权的设置项，以下按照优先权从高到低介绍：</p><ol><li>文件夹中&quot;.git&quot; 子文件夹中的confiig文件，这个配置具有最高优先权，<font color="#DC143C" size="3">但是这个配置文件只对他所在的文档有效。</font></li><li>登录账的home directory中的.gitconfig文件。这个配置文件只对此登陆账号有效。</li><li>git程序按照目录中的etc/gitconfig文件。</li></ol><p>只有在前两个配置文件中没有设置的项这个配置传文件才会生效。这是公用的配置传文件，它对所有登录账号和所有git文档库都有效。</p><h4 id="12-git-config-指令的用法"><a class="markdownIt-Anchor" href="#12-git-config-指令的用法"></a> 1.2 git config 指令的用法</h4><p>要显示当前git的设置可以执行下面的指令：</p><pre><code>gitconfig -l</code></pre><p>这个指令会显示三个配置文件中的所有设置项。他的顺序是先显示优先权最低的设置然后再显示高的。</p><p>当然我们也可以设置指定显示单一配置文件的内容：</p><pre><code>git config --system -l #显示git安装目录中的etc/gitconfig的设置git config --global -l #显示登录账号 home directory 中的.gitconfig文件的配置</code></pre><p>我们可以在配置文件中增加配置项，比如在执行&quot;git commit&quot; 的时候会提示你输入操作者的姓名和email，我们可以通过配置文件来设置以后就不用再输入，如果要记录在文档库中的配置文件，可以使用如下命令：</p><pre><code>git config user.name 'your name'git config user.email 'your email'</code></pre><p>如果要记录在登录账号的home directory中的.gitconfig文件内可以使用如下指令：</p><pre><code>git config --global user.name 'your name'git config --global user.email 'your email'</code></pre><p>如果要记录在git安装目录etc/gitconfig内可以执行如下指令：</p><pre><code>git config --system user.name 'your name'git config --system user.email 'your email'</code></pre><p>如果要删除配置传文件中的配置项可以使用“–unset”命令:</p><pre><code>git config --unset user.name</code></pre><p>如果要删除的是其他配置文件中的设置项，则视情况加入&quot;–global&quot;或者&quot;system&quot;选项。</p><p><font face="微软雅黑" color="#D2691E" size="5">补充说明：git指令的长和短</font></p><p><font color="#778899" size="4"><em>我们会发现有的指令使用一个连字符比如：&quot;-m&quot;有的却是两个，比如：&quot;–author&quot;，这是为啥呢。<br>其实使用一个连字符是简单表达形式的意思。我们也可以把它换成完整形式。比如&quot;git commit -m    ‘comment’“的完整形式是&quot;git commit --message=‘comment’”。“git config --list&quot;的完整形式是&quot;git config --list”。</em></font></p><h3 id="2-把git文件存入仓库"><a class="markdownIt-Anchor" href="#2-把git文件存入仓库"></a> 2 把git文件存入仓库</h3><h4 id="21-排除不需要加入文档库的文件"><a class="markdownIt-Anchor" href="#21-排除不需要加入文档库的文件"></a> 2.1 排除不需要加入文档库的文件</h4><p>我们在上传文件到git仓库的时候并不能保证所有上传的文件都是我们需要的，比如编译器编译的文件以及一些资源文件，那么如何保证不把这些文件上传到git仓库呢。git为我们提供了一个文件:.gitignore。我们把需要忽略的文件一一列在这里即可。</p><p>比如我们不想上传.txt为结尾的文件到仓库，那么在.gitignore文件中写入&quot;.txt&quot;即可。.gitignore文件可以使用“#”表示注释，文件夹路径使用“/”，文件名可以使用通配符&quot;*&quot;。使用&quot;!&quot;表示排除。比如以下设置表示排除所有txt文件但是不包含note.txt 文件。</p><pre><code>*.txt!note.txt</code></pre><h4 id="22-控制commit"><a class="markdownIt-Anchor" href="#22-控制commit"></a> 2.2 控制commit</h4><p>我们知道在本地仓库修改完文件之后提交仓库有两个步骤：</p><pre><code>git add #提交修改文件到git索引git commit #从本地git索引推到git仓库</code></pre><p>但是如果我们在执行git add之后反悔了怎么办呢。这时候我们的分两种情况采取以下操作：</p><ol><li><p>文档库中还没有任何文件，即执行&quot;git init&quot;之后没有执行过&quot;git commit&quot;：</p><p><code>使用git rm --cached 文件名</code></p></li><li><p>文档库中已经有文件，即我们已经执行过&quot;git commit&quot;命令：</p><p><code>git reset HEAD 文件名</code></p></li></ol><h4 id="23-查看commit节点"><a class="markdownIt-Anchor" href="#23-查看commit节点"></a> 2.3 查看commit节点</h4><pre><code>git #启动图形查看模式</code></pre><p><img src="https://i.imgur.com/0IdVPfL.jpg" alt=""></p><p>除了使用gitk查看commit节点信息，也可以使用&quot;git log&quot;命令达到同样目的。如果再加上&quot;–graph&quot;选项，会使用文本模式排列出commit节点的演进图。</p><p>显示最近一次代码提交记录：</p><pre><code>git show head</code></pre><h3 id="3-比较文件的差异和从git文档库取回文件"><a class="markdownIt-Anchor" href="#3-比较文件的差异和从git文档库取回文件"></a> 3 比较文件的差异和从git文档库取回文件</h3><h4 id="31-取出指定文件"><a class="markdownIt-Anchor" href="#31-取出指定文件"></a> 3.1 取出指定文件</h4><pre><code>git checkout commit 节点标识符或标签 文件名1 文件名2 #从文档库的任何一个节点取出指定文件</code></pre><p><font color="#A52A2A" size="5">Tips：</font></p><p><font color="#A52A2A" size="4">文件夹中的文件会被取出的文件覆盖</font></p><p><strong>注意：</strong></p><p>如果执行 git checkout 的文件与当前库中最新commit的文件内容不同，那么这个文件会自动记录在git索引中。稍后如果我们执行了git commit命令，那么这个取出的文件会成为新的版本被存入仓库中。为了避免这种情况的发生我们在执行git checkout之后立刻执行&quot;git reset head&quot;命令清除git索引。</p><h4 id="32-使用git-mv命令改变文件或文件夹名字"><a class="markdownIt-Anchor" href="#32-使用git-mv命令改变文件或文件夹名字"></a> 3.2 使用git mv命令改变文件或文件夹名字</h4><pre><code>git mv 原来的文件名 新文件名</code></pre><h3 id="4-获取git文档库的统计数据"><a class="markdownIt-Anchor" href="#4-获取git文档库的统计数据"></a> 4 获取git文档库的统计数据</h3><h4 id="41-git-log-指令"><a class="markdownIt-Anchor" href="#41-git-log-指令"></a> 4.1 git log 指令</h4><p>这个指令会按照时间顺序从最近一次的commit接单开始往前列出每一次commit的数据，包括标识符、执行人、日期以及说明。该指令后面可以接参数，比如：–author=‘A’,即只列出提交人为A的提交记录。</p><pre><code>指定显示某位提交者的提交信息：git log --author='A'指定显示某一段时间内的提交信息：$ git log --after='2017-10-01 00:00:00' --before='2017-11-01 00:00:00'after表示指定的日期之后，before表示指定的日期之前，注意使用方式！</code></pre><p><img src="https://i.imgur.com/BTccOtX.jpg" alt=""></p><p>以上指令只会显示指定日期期间的commit，如果加上&quot;–stat&quot;,或者&quot;–numstat&quot;或者&quot;–shortstat&quot;还可以显示每一个commit变更的情况。</p><p>比如我们执行：</p><pre><code>git log shortstat</code></pre><p><img src="https://i.imgur.com/tpcjfwr.jpg" alt=""></p><p>可以看到会显示该次提交变更的基本信息。</p><p><strong>Tips：</strong></p><p>如果git指令显示的信息炒过了屏幕大小，屏幕会自动暂停，这时候可以使用如下按键继续操作：</p><ol><li>按键 j 表示显示下一行；</li><li>空格表示显示下一页；</li><li>按键 h 表示显示操作说明；</li><li>按键 q 表示结束。</li></ol><h4 id="42-git-shortlog指令"><a class="markdownIt-Anchor" href="#42-git-shortlog指令"></a> 4.2 git shortlog指令</h4><p>这个指令会按照名字的字母顺序，列出每一个人执行commit的次数和说明。</p><p><img src="https://i.imgur.com/EaE6rdB.jpg" alt=""></p><p>我们也可以按照commit的次数从高到低排列，只要加上&quot;–commit&quot;或者是使用缩写：&quot;-n&quot; 即可。如果不需要显示commit说明可以再加上&quot;–summary&quot;或者是使用缩写:&quot;-s&quot;。</p><p>git shortlog -n -s</p><p><img src="https://i.imgur.com/uFP0d8p.jpg" alt=""></p><h4 id="43-git-ls-files-指令"><a class="markdownIt-Anchor" href="#43-git-ls-files-指令"></a> 4.3 git ls-files 指令</h4><p>这个指令会列出当前git文档库中的文件列表：</p><p><img src="https://i.imgur.com/l5mshTr.jpg" alt=""></p><p>我们也可以搭配&quot;xargs&quot;和&quot;wc&quot;这两个指令来计算程序中的代码行数：</p><pre><code>git ls-files | xargs wc -l</code></pre><p><img src="https://i.imgur.com/yivp80J.jpg" alt=""></p><p>前面的数字就是该文件中的代码行数，如果你要计算行数总和可以使用如下指令：</p><pre><code>git ls-files | xargs cat | wc -l</code></pre><h3 id="5-建立分支和解决冲突"><a class="markdownIt-Anchor" href="#5-建立分支和解决冲突"></a> 5 建立分支和解决冲突</h3><h4 id="51-创立分支"><a class="markdownIt-Anchor" href="#51-创立分支"></a> 5.1 创立分支</h4><p>创立分支使用git branch 指令：</p><pre><code>git branch &lt;new branch name&gt; commit &lt;节点标识符或者是标签&gt;</code></pre><p>这个指令会根据后边参数的不同发挥不同的作用：</p><ul><li>如果最后指定了commit节点标识符或者是标签就会从该节点开始的位置长出分支，即该节点之前提交的代码新分支都有，之后的代码新分支是没有的。如果没有指定commit标签那么默认是从最新节点的位置创立分支。</li><li>“git branch” 指令后面没有任何参数的时候会列出当前文档库中正在开发的所有分支。</li></ul><p>建立分支之后可以使用&quot;git checkout &lt;分支名&gt;&quot; 这个指令来切换当前操作的分支。</p><h4 id="52-删除分支"><a class="markdownIt-Anchor" href="#52-删除分支"></a> 5.2 删除分支</h4><p>删除分支我们要注意的是在删除当前分支之前***必须先切换到另外的分支***，不然不能删除当前分支，删除分支使用如下指令：</p><pre><code>git branch -d &lt;要删除的分支&gt;使用该命令需要保证要删除的分支已经合并到别的分支过，不然会报错</code></pre><p><strong>值得注意的是：</strong></p><p><strong>我们知道如果我们新建了一个分支一般都是为了方便多人协作，开发者分别在自己的dev分支上开发然后合并到master，上面这个命令有些反人类，如果当前要删除的分支没有合并到另一个分支，使用上面的命令会报错。需要把&quot;-d&quot;换成&quot;-D&quot;。</strong></p><h4 id="53-修改分支名"><a class="markdownIt-Anchor" href="#53-修改分支名"></a> 5.3 修改分支名</h4><p>修改分支名需要注意的是<strong>你必须的先切换到要修改的分支</strong>之后才能操作：</p><pre><code>git branch -m &lt;新的分支出名&gt;</code></pre><h4 id="54-合并分支"><a class="markdownIt-Anchor" href="#54-合并分支"></a> 5.4 合并分支</h4><p>合并分支使用如下命令：</p><pre><code>git merge 分支名</code></pre><p>该命令会把指定的分支合并到当前分支。比如当前在master分支，想把A分支的代码合并到master使用命令：</p><pre><code>git merge A</code></pre><p>即可。</p><p>如果合并之后你后悔了，想撤回可以使用&quot;git reset&quot;命令。我们想恢复到合并之前的状态执行如下操作：</p><pre><code>git reset --hard HEAD^</code></pre><p>“–hard” 选项表示文件夹中的文件也要一起恢复。</p><h4 id="55-解决冲突"><a class="markdownIt-Anchor" href="#55-解决冲突"></a> 5.5 解决冲突</h4><p>我们先来想一下什么情况会发生冲突：</p><ol><li><p>假如有个一master分支，你在master节点的最新节点新建了一个分支branch1；</p></li><li><p>然后你在branch1分支上新增了一个文件：1.txt,修改了一个文件：test.txt；</p></li><li><p>在你准备合并branch1到master之前，你的工友小B合并了他的分支branch2到master，新增了4个文件，也修改了test.txt文件；</p></li><li><p>然而你并不知情，你也提交了你的分支到master，这时候系统会告诉你你合并不了，因为检测目前的master和你当时新建分支branch1的时候从master最新节点上得到的那一版不一样，这个时候就代表你发生冲突了，需要手动合并。</p><p>git checkout master<br>git merge branch1</p></li></ol><p>然后就会提示代码冲突了。</p><p>一般冲突的部分会用:</p><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD冲突内容=======&gt;&gt;&gt;&gt;&gt;&gt;&gt;draft</code></pre><p>来表示，所以需要你手动的去合并冲突，解决完了冲突之后执行如下指令提交代码：</p><pre><code>git diff</code></pre><p>执行完成如果没有报错说明已经解决冲突。之后我们可以执行如下指令把我们的代码提交到master分支：</p><pre><code>git add .git commit -m '合并branch1到master'</code></pre><h3 id="6-使用rebase指令更新分支的起始点"><a class="markdownIt-Anchor" href="#6-使用rebase指令更新分支的起始点"></a> 6 使用Rebase指令更新分支的起始点</h3><p>之前我们说的合并分支的时候都在说这样的情况：</p><ol><li>有主分支master，我们在master的最新节点上创建了新分支AAA。</li><li>我们在AAA分支上做了更新，然后推送到master节点与master节点合并。</li></ol><p>那么现在我们要说的是另一种情况：</p><ol><li>有主分支master，我们在master的最新节点上创建了新分支AAA；</li><li>我们一直在AAA分支上做开发，这个过程的持续很久；</li><li>在AAA上做开发的过程中，别的程序员也在master的最新节点上创建了新的分支BBB，他开发完成很快就提交代码到master；</li><li>这个时候你在AAA分支上开发，为了保证代码的实效性，你必须的拉master的最新代码到你这里。</li></ol><p>见下图：</p><p><img src="https://i.imgur.com/oVQ5aoB.jpg" alt=""></p><p>我们执行如下命令将master合并到AAA：</p><pre><code># git checkout AAA# git merge master</code></pre><p>执行合并以后可能master会继续有更新，而我们的AAA分支也一直在开发，那么我们的节点图可能一直跟上图这样不停的交叉，到最后可能会看起来越来越复杂。当然这样并没有错，只是看起来不是那么简洁。我们可以用另一种方式让我们的节点图看起来更加简洁和直观：用rebase指令取代merge指令。</p><p>rebase指令的功能和merge一样，但是他在节点的处理上略有不同，我们用一个图来说明：</p><p><img src="https://i.imgur.com/4kIc3Y5.jpg" alt=""></p><p>这幅图我们对比上一幅可以看出：</p><p>rebase指令执行的合并会把以前从commit节点长出来的分支AAA合并到master的最新节点，然后从master的最新节点长出来。但是master和AAA节点的代码其实还是各自不同，AAA包含master的所有代码，master不包含AAA从master最新节点&quot;长出来&quot;之后的代码。图虽然不同，但是功能没有任何区别。</p><p>通过上面这两幅图大家是不是更加清楚这两个指定的区别。下面我们来说一下rebase指令的用法。</p><p>使用rebase很简单，就把以前使用merge的地方换成rebase即可：</p><pre><code># git checkout AAA# git rebase master</code></pre><p>与merge一样rebase也会面临发生冲突的情况，你可以使用上面提供的方法手动修改冲突然后执行 “git diff” 检测是否修改完成所有的冲突，最后提交合并。</p><p>假如你在使用rebase提交合并的时候发生冲突，这时候你决定取消合并，你可以执行如下命令：</p><pre><code># git rebase --abort</code></pre><p>执行如上命令一定是在还没有完成rebase之前，如果你提交合并成功了执行上述命令是不生效的。</p><p>接下来我们说如果执行rebase完全没有错误但是你又反悔了该如何操作。</p><p>如果是上述情况，我们可以使用&quot;git reset&quot;命令来恢复，但是有一个条件是:我们必须先找到执行rebase指令之前head所在的commit节点。我们知道head表示当前工作分支的最新commit节点，那我们如何找到历史的那个head节点呢？<br>git提供了一个指令：</p><pre><code># git reflog head或者是任何分支的分支名</code></pre><p>我们可以使用这个指令查询head或是任何分支的变动情况。该命令得出的结果是按照时间倒序排列。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-git配置文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-git配置文件&quot;&gt;&lt;/a&gt; 1 git配置文件&lt;/h3&gt;
&lt;h4 id=&quot;11-git权限控制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=
      
    
    </summary>
    
      <category term="git" scheme="http://blog.rickiyang.cn/categories/git/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十六）----ThreadLocal的使用</title>
    <link href="http://blog.rickiyang.cn/posts/f58afb00.html"/>
    <id>http://blog.rickiyang.cn/posts/f58afb00.html</id>
    <published>2017-04-15T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.157Z</updated>
    
    <content type="html"><![CDATA[<p>其实ThreadLocal很多接触过多线程的同学都可能会很陌生，他不像current包里面那些耳熟能详的api一样在我们面前经常出现，更多的他作为一个本地类出现在系统设计里面。我们可以说一下Spring，Spring的事务管理器通过AOP切入业务代码，在进入业务代码前，会根据对应的事务管理器提取出相应的事务对象，假如事务管理器是DataSourceTransactionManager，就会从DataSource中获取一个连接对象，通过一定的包装后将其保存在ThreadLocal中。并且Spring也将DataSource进行了包装，重写了其中的getConnection()方法，或者说该方法的返回将由Spring来控制，这样Spring就能让线程内多次获取到的Connection对象是同一个。</p><p>为什么要放在ThreadLocal里面呢？因为Spring在AOP后并不能向应用程序传递参数，应用程序的每个业务代码是事先定义好的，Spring并不会要求在业务代码的入口参数中必须编写Connection的入口参数。此时Spring选择了ThreadLocal，通过它保证连接对象始终在线程内部，任何时候都能拿到，此时Spring非常清楚什么时候回收这个连接，也就是非常清楚什么时候从ThreadLocal中删除这个元素</p><p>从名字上看我们很容易误解，ThreadLocal，本地线程。local有当地的，本地的，局部的意思，这里说的是局部线程，意思是线程的局部变量。我们知道synchronized是独占锁，同一时间只能有一个线程操作被锁住的代码大家排队等待，典型的以时间换空间的策略。那如果我们空间很足时间不够该怎么办呢，ThreadLocal就该派上用场了。ThreadLocal作为线程的局部变量，会为这个线程创建独立的变量副本，在线程的内部，他所创建的对象相当于全局对象。</p><p>说到这里，大家是不是还是没有分清楚ThreadLocal和synchronized有什么区别，下面我们来讲。</p><ul><li>ThreadLocal 不是用来解决共享对象的多线程访问问题的，上面说了ThreadLocal是线程的局部变量。一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。</li><li>ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。</li></ul><p><strong>如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题</strong>。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;  </span><br><span class="line">    Session s = (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在getSession()方法中，首先判断当前线程中有没有放进去session，如果还没有，那么通过sessionFactory().openSession()来创建一个session，再将session set到线程中，实际是放到当前线程的ThreadLocalMap这个map中，这时，对于这个session的唯一引用就是当前线程中的那个ThreadLocalMap，而threadSession作为这个值的key，要取得这个session可以通过threadSession.get()来得到，里面执行的操作实际是先取得当前线程中的ThreadLocalMap，然后将threadSession作为key将对应的值取出。上面我们也讲过每个线程进来创建threadSession 的时候，这个threadSession 只属于他一个人所有，别的线程无法共享到他自己创建的ThreadLocal。这就避免了所有线程共享同一个对象的问题。并且该session创建完成之后，我们不必走到哪里都携带着session这个参数，走到哪里传递到哪里。需要使用的时候只需要从threadlocal中取出即可。这也是极其省事的。</p><p>我们可以举一个 例子来说明ThreadLocal不是用来解决对象共享访问问题的，而是为了处理在多线程环境中，某个方法处理一个业务，需要递归依赖其他方法时，而要在这些方法中共享参数的问题。例如有方法a()，在该方法中调用了方法b()，而在b方法中又调用了方法c()，即a–&gt;b—&gt;c，如果a，b，c都需要使用用户对象，那么我们常用做法就是a(User user)–&gt;b(User user)—c(User user)。但是如果使用ThreadLocal我们就可以用另外一种方式解决：</p><ol><li>在某个接口中定义一个静态的ThreadLocal 对象，例如 public static ThreadLocal  threadLocal=new ThreadLocal ();</li><li>然后让a，b，c方法所在的类假设是类A，类B，类C都实现1中的接口</li><li>在调用a时，使用A.threadLocal.set(user) 把user对象放入ThreadLocal环境</li><li>这样我们在方法a，方法b，方法c可以在不用传参数的前提下，在方法体中使用threadLocal.get()方法就可以得到user对象。</li></ol><p>上面我们说到ThreadLocal的使用，也说了ThreadLocal里面有一个ThreadLocalMap 用于存储当前线程的对象，下面我们简单的看一下源码来理解一下这个过程。先上类图：</p><p><img src="http://i.imgur.com/h6m3uaC.jpg" alt=""></p><p>ThreadLocal里面有一个内部类ThreadLocalMap，在ThreadLocal内部又装了一个Entry，他继承了WeakReference<threadlocal>，我们来看一下Entry：</threadlocal></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">  Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">       <span class="keyword">super</span>(k);</span><br><span class="line">       value = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry对象其实还是ThreadLocal类型的，这里我们看到ThreadLocal用了一个WeakReference包装是为了保证该ThreadLocal对象在没有被引用的时候能够及时的被gc掉。</p><p>下面再看一下ThreadLocal的get和set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal key, Object value)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">       ...</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在set方法中t.threadLocals只要不为空，便创建map对象，我们看到set方法中的key是ThreadLocal，即thread调用ThreadLocal.get()方法既可得到当前thread的threadLocal对象里面的ThreadLocalMap的值！是不是有点绕，是不是不知道为什么当前线程能调用ThreadLocal，我们看一下上面的getMap()方法，返回值是：t.threadLocals，这个t即当前线程，在Thread类里面有一个threadLocals对象，我们可以跟过去看一下，在这里限于篇幅，就只上相关的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">         Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面方法是ThreadLocal中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在源码中看到threadLocals并未进行赋值，他一直都是一个空对象，为什么这么做呢，我们接着看下面的get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在get方法中，如果一个线程当前并未使用ThreadLocal对象那么getMap(t)必然是空，那我们就得想了，难道在Thread类中创建一个空对象threadLocals就这么空着？哈哈，当然不是啦，我也着急了。所以就进入了下面的setInitialValue()方法啦，这里的getMap(t)当然还是空的，那进入createMap(t, value)呗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于在这里拨开云雾见月明！妈妈再也不用担心threadLocals没有人要了！上面分析的比较乱，大家就将就看，用一句话总结那就是：</p><p>在Thread类中有一个对象是threadLocals，如果在该线程运行中有ThreadLocal创建threadLocals会去找到他的！获得你在ThreadLocal中存储的值！</p><p>上面我们已经详细分析了ThreadLocal的使用和实现，那么在真实的环境中使用它有什么弊端没呢。其实使用中还真的是有很多问题的。</p><p>我们知道ThreadLocal是和当前线程绑定的，即他的生命周期是和当前线程共存，当线程结束，ThreadLocal内部的Entity对象才会被gc回收。</p><p>下面我说一个场景大家看会带来什么样的后果：如果现在是线程池对象使用了ThreadLocal来保存变量会发生什么？大家知道线程池的主要目的是为了线程复用，那么线程池中的线程基本不会结束，与jvm的生命周期是一致的。那这个时候谁知道一个携带了ThreadLocal的线程会什么时候结束呢。长久以往必然造成内存泄露。</p><p>另外我们再说一个关于忘记释放的问题。如果你在线程刚开始进来的时候就载入了ThreadLocal用来保存变量，假设你的程序设计的不是很健壮，你忘记了写remove()。这个时候事情就来了。再假设你在ThreadLocal中存放了map对象，真实的业务中Map对象也许包含了很多数据，随着时间流逝，内存中的无用对象越来越多，内存泄露是必然的。</p><p>关于ThreadLocal的内容我们就讲到这里，其实里面还有很多值得我们深究的东西，慢慢一点点的去看吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实ThreadLocal很多接触过多线程的同学都可能会很陌生，他不像current包里面那些耳熟能详的api一样在我们面前经常出现，更多的他作为一个本地类出现在系统设计里面。我们可以说一下Spring，Spring的事务管理器通过AOP切入业务代码，在进入业务代码前，会根
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十四）----(JUC集合)ArrayBlockingQueue和LinkedBlockingQueue介绍</title>
    <link href="http://blog.rickiyang.cn/posts/ed05b021.html"/>
    <id>http://blog.rickiyang.cn/posts/ed05b021.html</id>
    <published>2017-04-12T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.156Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们来了解阻塞队列（BlockingQueue），BlockingQueue接口定义了一种阻塞的FIFO queue，每一个BlockingQueue都有一个容量，当容量满时往BlockingQueue中添加数据时会造成阻塞，当容量为空时取元素操作会阻塞。首先我们来看ArrayBlockingQueue和LinkedBlockingQueue.</p><h4 id="1-arrayblockingqueue"><a class="markdownIt-Anchor" href="#1-arrayblockingqueue"></a> 1 ArrayBlockingQueue</h4><p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。</p><p>我们看他的构造函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是非公平的，初始指定队列容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//该构造方法可以设置队列的公平性。当然如果为公平的，则对性能会产生影响<br>//访问者的公平性是使用可重入锁实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">   <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">   lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">   notEmpty = lock.newCondition();</span><br><span class="line">   notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用很简单我们直接看一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> ProducerAndConsumer(blockingQueue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    Condition pro_con = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    Condition con_con = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerAndConsumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue= blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(flag)</span><br><span class="line">                pro_con.await();</span><br><span class="line">            System.out.println(<span class="string">"正在准备放入数据。。。"</span>);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">100</span>);</span><br><span class="line">            Integer value = <span class="keyword">new</span> Random().nextInt(<span class="number">30</span>);</span><br><span class="line">            blockingQueue.put(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"   放入的数据    "</span>+value);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            con_con.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(!flag)</span><br><span class="line">                con_con.await();</span><br><span class="line">            System.out.println(<span class="string">"正在准备取数据。。。"</span>);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"   取到的数据为"</span>+blockingQueue.take());</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            pro_con.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                put();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                get();</span><br><span class="line">            &#125;</span><br><span class="line">            j=(j+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>正在准备放入数据。。。正在准备放入数据。。。正在准备放入数据。。。正在准备放入数据。。。pool-1-thread-2   放入的数据    13正在准备取数据。。。pool-1-thread-3   放入的数据    4正在准备取数据。。。pool-1-thread-3   取到的数据为13正在准备放入数据。。。pool-1-thread-1   放入的数据    11正在准备取数据。。。pool-1-thread-4   放入的数据    26正在准备取数据。。。pool-1-thread-1   取到的数据为4正在准备放入数据。。。pool-1-thread-2   取到的数据为11正在准备放入数据。。。pool-1-thread-3   放入的数据    18正在准备取数据。。。......</code></pre><h4 id="2-linkedblockingqueue"><a class="markdownIt-Anchor" href="#2-linkedblockingqueue"></a> 2 LinkedBlockingQueue</h4><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。<br>先看一下他的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);  <span class="comment">//MAX_VALUE=2147483647</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是直接开看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义装苹果的篮子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Basket</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 篮子，能够容纳3个苹果</span></span><br><span class="line">        <span class="comment">// BlockingQueue&lt;String&gt; basket = new ArrayBlockingQueue&lt;String&gt;(3);</span></span><br><span class="line">        BlockingQueue&lt;String&gt; basket = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产苹果，放入篮子</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">// put方法放入一个苹果，若basket满了，等到basket有位置</span></span><br><span class="line">            basket.put(<span class="string">"An apple"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费苹果，从篮子中取走</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">// get方法取出一个苹果，若basket为空，等到basket有苹果为止</span></span><br><span class="line">            <span class="keyword">return</span> basket.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 　测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBasket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立一个装苹果的篮子</span></span><br><span class="line">        <span class="keyword">final</span> Basket basket = <span class="keyword">new</span> Basket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义苹果生产者</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> String instance = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">                instance = a;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="comment">// 生产苹果</span></span><br><span class="line">                        System.out.println(<span class="string">"生产者准备生产苹果："</span> + instance);</span><br><span class="line">                        basket.produce();</span><br><span class="line">                        System.out.println(<span class="string">"! 生产者生产苹果完毕："</span> + instance);</span><br><span class="line">                        <span class="comment">// 休眠300ms</span></span><br><span class="line">                        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义苹果消费者</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> String instance = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">                instance = a;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="comment">// 消费苹果</span></span><br><span class="line">                        System.out.println(<span class="string">"消费者准备消费苹果："</span> + instance);</span><br><span class="line">                        basket.consume();</span><br><span class="line">                        System.out.println(<span class="string">"! 消费者消费苹果完毕："</span> + instance);</span><br><span class="line">                        <span class="comment">// 休眠1000ms</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(<span class="string">"P1"</span>);</span><br><span class="line">        Producer producer2 = <span class="keyword">new</span> Producer(<span class="string">"P2"</span>);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(<span class="string">"C1"</span>);</span><br><span class="line">        service.submit(producer);</span><br><span class="line">        service.submit(producer2);</span><br><span class="line">        service.submit(consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 程序运行3s后，所有任务停止</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        service.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueueTest.testBasket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>生产者准备生产苹果：P1消费者准备消费苹果：C1! 生产者生产苹果完毕：P1生产者准备生产苹果：P2! 消费者消费苹果完毕：C1! 生产者生产苹果完毕：P2生产者准备生产苹果：P2! 生产者生产苹果完毕：P2生产者准备生产苹果：P1! 生产者生产苹果完毕：P1生产者准备生产苹果：P2生产者准备生产苹果：P1消费者准备消费苹果：C1! 消费者消费苹果完毕：C1! 生产者生产苹果完毕：P2生产者准备生产苹果：P2消费者准备消费苹果：C1! 消费者消费苹果完毕：C1! 生产者生产苹果完毕：P1生产者准备生产苹果：P1消费者准备消费苹果：C1! 消费者消费苹果完毕：C1! 生产者生产苹果完毕：P2Process finished with exit code 0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们来了解阻塞队列（BlockingQueue），BlockingQueue接口定义了一种阻塞的FIFO queue，每一个BlockingQueue都有一个容量，当容量满时往BlockingQueue中添加数据时会造成阻塞，当容量为空时取元素操作会阻塞。首先我们来看
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十三）----(JUC集合)ConcurrentSkipListMap介绍</title>
    <link href="http://blog.rickiyang.cn/posts/31315379.html"/>
    <id>http://blog.rickiyang.cn/posts/31315379.html</id>
    <published>2017-04-12T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.138Z</updated>
    
    <content type="html"><![CDATA[<p>Queue除了前面介绍的实现外，还有一种双向的Queue实现Deque。这种队列允许在队列头和尾部进行入队出队操作，因此在功能上比Queue显然要更复杂。</p><h4 id="1-linkedblockingdeque"><a class="markdownIt-Anchor" href="#1-linkedblockingdeque"></a> 1 LinkedBlockingDeque</h4><p>我们来看一下该类中的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt;,  <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">387911632671998426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;    </span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123;</span><br><span class="line">            item = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个内部类Node，该类用来标记queue的节点，capacity最大为Integer.MAX_VALUE。然后使用了独占锁和条件机制来保证线程安全和进行阻塞控制。从上面的结构上我们可以看出：</p><ol><li>要想支持阻塞功能，队列的容量一定是固定的，否则无法在入队的时候挂起线程。也就是capacity是final类型的。</li><li>既然是双向链表，每一个结点就需要前后两个引用，这样才能将所有元素串联起来，支持双向遍历。也即需要prev/next两个引用。</li><li>双向链表需要头尾同时操作，所以需要first/last两个节点，当然可以参考LinkedList那样采用一个节点的双向来完成，那样实现起来就稍微麻烦点。</li><li>既然要支持阻塞功能，就需要锁和条件变量来挂起线程。这里使用一个锁两个条件变量来完成此功能。</li></ol><p>上面对LinkedBlockingDeque的结构做了说明，那么原理就很清晰了，无非是用一个独占锁来保持线程安全，然后用Condition来做阻塞操作。双向链表的操作大家都很熟悉就不做过多解释。</p><h4 id="2-concurrentlinkeddeque"><a class="markdownIt-Anchor" href="#2-concurrentlinkeddeque"></a> 2 ConcurrentLinkedDeque</h4><p>ConcurrentLinkedDeque是JSR166y中新增的一个无界并发Deque实现，基于已链接节点的、任选范围的双端队列。在迭代时，队列保持弱一致性，但不会抛出ConcurrentModificationException异常。</p><p>我们看一下类的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Node&lt;Object&gt; PREV_TERMINATOR, NEXT_TERMINATOR;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">prevTerminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;E&gt;) PREV_TERMINATOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">nextTerminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;E&gt;) NEXT_TERMINATOR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到成员变量里面有头节点和尾节点，然后是节点的引用PREV_TERMINATOR, NEXT_TERMINATOR，<br>双向链表的结构都是一样的。ConcurrentLinkedDeque不是阻塞队列所以没有用到条件原语。我们在成员变量里面没有看到使用ReentrantLock,因为所有的操作都是使用原子操作，避免了使用独占锁造成性能问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Queue除了前面介绍的实现外，还有一种双向的Queue实现Deque。这种队列允许在队列头和尾部进行入队出队操作，因此在功能上比Queue显然要更复杂。&lt;/p&gt;
&lt;h4 id=&quot;1-linkedblockingdeque&quot;&gt;&lt;a class=&quot;markdownIt-Anc
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十三）----(JUC集合)ConcurrentSkipListMap介绍</title>
    <link href="http://blog.rickiyang.cn/posts/31315379.html"/>
    <id>http://blog.rickiyang.cn/posts/31315379.html</id>
    <published>2017-04-11T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.155Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够在O(log(n))时间内完成查找、插入、删除操作。</p><h4 id="1-理解skiplist"><a class="markdownIt-Anchor" href="#1-理解skiplist"></a> 1 理解SkipList</h4><p>要想弄明白ConcurrentSkipListMap,我们的先明白他的数据结构实现，先来看SkipList。</p><p>Skip List是一种随机化的数据结构，基于并联的链表，其效率可比拟于二叉查找树（对于大多数操作需要O(log n)平均时间）。基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。所有操作都以对数随机化的时间进行。SkipList可以很好解决有序链表查找特定值的困难。</p><p>Skip List定义：</p><p>一个跳表，应该具有以下特征：</p><ol><li>一个跳表应该有几个层（level）组成；</li><li>跳表的第一层包含所有的元素；</li><li>每一层都是一个有序的链表；</li><li>如果元素x出现在第i层，则所有比i小的层都包含x；</li><li>第i层的元素通过一个down指针指向下一层拥有相同值的元素；</li><li>在每一层中，-1和1两个元素都出现(分别表示INT_MIN和INT_MAX)；</li><li>Top指针指向最高层的第一个元素。</li></ol><p>构建有序链表：</p><p><img src="http://i.imgur.com/IR4pz7d.png" alt=""></p><p>一个跳表如下：</p><p><img src="http://i.imgur.com/qNokG9C.png" alt=""></p><p>Skip List构造步骤：</p><ol><li>给定一个有序的链表。</li><li>选择链表中最大和最小的元素，然后从其他元素中按照一定算法（随机）随即选出一些元素，将这些元素组成有序链表。这个新的链表称为一层，原链表称为其下一层。</li><li>为刚选出的每个元素添加一个指针域，这个指针指向下一层中值同自己相等的元素。Top指针指向该层首元素</li><li>重复2、3步，直到不再能选择出除最大最小元素以外的元素。</li></ol><p>从上图可以看到，跳表具有以下几种特性：</p><ul><li>由很多层组成，level越高的层节点越少，最后一层level用有所有的节点数据</li><li>每一层的节点数据也都是有顺序的</li><li>上面层的节点肯定会在下面层中出现</li><li>每个节点都有两个指针，分别是同一层的下一个节点指针和下一层节点的指针</li></ul><p>使用跳表查询元素的时间复杂度是O(log n)，跟红黑树一样。查询效率还是不错的，但是跳表的存储容量变大了，本来一共只有10个节点的数据，使用跳表之后变成了21个节点。</p><p>所以跳表是一种使用”空间换时间”的概念用来提高查询效率的链表，开源软件Redis、LevelDB都使用到了跳表。跳表相比B树，红黑树，AVL树时间复杂度一样，但是耗费更多存储空间，但是跳表的优势就是它相比树，实现简单，不需要考虑树的一些rebalance问题。</p><h4 id="2-concurrentskiplistmap探索"><a class="markdownIt-Anchor" href="#2-concurrentskiplistmap探索"></a> 2 ConcurrentSkipListMap探索</h4><p>ConcurrentSkipListMap包含了很多内部类，内部类的框架图如下：<br><img src="http://i.imgur.com/mOif8BQ.png" alt=""></p><p>ConcurrentSkipListMap在原始链表的基础上增加了跳表的结构，所以需要两个额外的内部类来封装链表的节点，以及跳表的节点——Node和Index。</p><p>同ConcurrentHashMap的Node节点一样，key为final，是不可变的，value和next通过volatile修饰保证内存可见性。</p><p>Index：跳表的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">       <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">       <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node：链表的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> Object value;</span><br><span class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Index封装了跳表需要的结构，首先node包装了链表的节点，down指向下一层的节点（不是Node，而是Index），right指向同层右边的节点。node和down都是final的，说明跳表的节点一旦创建，其中的值以及所处的层就不会发生变化（因为down不会变化，所以其下层的down都不会变化，那他的层显然不会变化）。Node和Index内部都提供了用于CAS原子更新的<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOC9hcnRpY2xlL2RldGFpbHMvNTQ1ODgxOTg=" title="AtomicReferenceFieldUpdater">AtomicReferenceFieldUpdater<i class="fa fa-external-link"></i></span>对象，该对象前面讲Atomic原子类的时候已经讲过,原理和机制将不再介绍。</p><p>下面我们还是着重介绍ConcurrentSkipListMap的get、put和remove方法。在介绍这三个方法之前我们先看一下这三个方法都会用到的一个辅助方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Comparable&lt;? <span class="keyword">super</span> K&gt; comparable(Object key)</span><br><span class="line">            <span class="keyword">throws</span> ClassCastException &#123;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//有两种封装方法，如果在构造时指定了comparator，则使用comparator封装key</span></span><br><span class="line">    <span class="comment">// 如果没有指定comparator，则key必须是一个继承自Comparable接口的类，否则会抛出ClassCastException</span></span><br><span class="line">    <span class="comment">// 所以ConcurrentSkipListMap的key要么是继承自Comparable接口的类，如果不是的话需要显示提供comparator进行比较</span></span><br><span class="line">      <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ComparableUsingComparator&lt;K&gt;((K)key, comparator);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> (Comparable&lt;? <span class="keyword">super</span> K&gt;)key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparableUsingComparator</span>&lt;<span class="title">K</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> K actualKey;</span><br><span class="line">      <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; cmp;</span><br><span class="line">      ComparableUsingComparator(K key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp) &#123;</span><br><span class="line">          <span class="keyword">this</span>.actualKey = key;</span><br><span class="line">          <span class="keyword">this</span>.cmp = cmp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(K k2)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cmp.compare(actualKey, k2);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentSkipListMap的key必须是能够比较的，这样来确保线程安全。</p><p>我们再来看一下get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object okey)</span> </span>&#123;</span><br><span class="line">     Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(okey);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Loop needed here and elsewhere in case value field goes</span></span><br><span class="line"><span class="comment">       * null just as it is about to be returned, in which case we</span></span><br><span class="line"><span class="comment">       * lost a race with a deletion, so must retry.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; n = findNode(key);</span><br><span class="line">          <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          Object v = n.value;</span><br><span class="line">          <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">return</span> (V)v;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见在get方法中调用了doGet()来进行取值操作，首先调用了comparable（key）方法来确保该次取值的安全性，后面再一个死循环中持续进行 findNode(key)操作。</p><p>再看一下put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K kkey, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">       Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(kkey);</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 从跳表中查找最接近指定key的节点：该节点的key小于等于指定key，且处于最底层</span></span><br><span class="line">          Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">          Node&lt;K,V&gt; n = b.next;</span><br><span class="line">    <span class="comment">//新节点插入在b与n之间</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//n==null则说明b是链表的最后一个节点，则新节点直接插入到链表尾部即可</span></span><br><span class="line">              <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                  <span class="keyword">if</span> (n != b.next)  <span class="comment">// 此处增加判断，避免链表结构已被修改(针对节点b)</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  Object v = n.value;</span><br><span class="line">                  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;     <span class="comment">// n节点已经被删除</span></span><br><span class="line">                      n.helpDelete(b, f);b和f分别为n的前驱和后继节点</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">            <span class="comment">// 这里如果v==n说明n是一个删除标记，用来标记其前继节点已被删除，即b已被删除</span></span><br><span class="line">                  <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>) <span class="comment">// b is deleted</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">int</span> c = key.compareTo(n.key);</span><br><span class="line">            <span class="comment">// 如果指定key&gt;n的key，则判断下一个节点，直到n==null，或者指定key&lt;n的key</span></span><br><span class="line">                  <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      b = n;</span><br><span class="line">                      n = f;</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">            <span class="comment">// 相等，则更新value即可，更新失败，就再来一次，一直到成功为止</span></span><br><span class="line">                  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value))</span><br><span class="line">                          <span class="keyword">return</span> (V)v;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">              &#125;</span><br><span class="line">        <span class="comment">// 创建一个节点，next指向n</span></span><br><span class="line">              Node&lt;K,V&gt; z = <span class="keyword">new</span> Node&lt;K,V&gt;(kkey, value, n);</span><br><span class="line">        <span class="comment">// 将b的next指向新创建的节点，则新的链表为：b--&gt;new--&gt;n，即将新节点插入到b和n之间</span></span><br><span class="line">              <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                  <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">        <span class="comment">// 随机计算一个层级</span></span><br><span class="line">              <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">              <span class="keyword">if</span> (level &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将z插入到该层级</span></span><br><span class="line">                  insertIndex(z, level);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中已经附上了大量的注释，这里再简单的梳理下流程。首先put()方法是调用内部的doPut()方法。Comparable&lt; ? super K&amp;&gt; key = comparable(kkey);这一句将key封装成一个Comparable对象，上面已经介绍了comparable这个方法。接着进入到死循环，循环第一步是调用findPredecessor(key)方法，该方法返回一个key最接近指定key的节点(最接近指的是小于等于)，该节点是处于最底层的，下面介绍下这个方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*在跳表中查找节点的key小于指定key，且处于最底层的节点，即找到指定key的前继节点</span></span><br><span class="line"><span class="comment">*基本逻辑是从head(跳表的最高层链表的头结点)开始自右开始查找，当找到该层链表的最</span></span><br><span class="line"><span class="comment">*接近且小于指定key的节点时，往下开始查找，</span></span><br><span class="line"><span class="comment">*最终找到最底层的那个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Comparable&lt;? <span class="keyword">super</span> K&gt; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// head是跳表的最高层链表的头结点</span></span><br><span class="line">      Index&lt;K,V&gt; q = head;</span><br><span class="line">      Index&lt;K,V&gt; r = q.right;<span class="comment">// head的右边节点</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// r==null说明该层链表已经查找到头，且未找到符合条件的节点，需开始往下查找</span></span><br><span class="line">          <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Node&lt;K,V&gt; n = r.node;<span class="comment">// r的数据节点</span></span><br><span class="line">              K k = n.key;</span><br><span class="line">              <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;<span class="comment">// n的value为null，说明该节点已被删除</span></span><br><span class="line">                  <span class="comment">// 将该节点从链表移除，通过将其(n)前置节点的right指向其(n)的后置节点</span></span><br><span class="line">                  <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                      <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                  r = q.right;         <span class="comment">// reread r 移除value==null的n节点之后，继续从n的下一个节点查找</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">               <span class="comment">// 比较当前查找的节点的key与指定key，如果小于指定key，则继续查找，</span></span><br><span class="line">              <span class="comment">// 大于等于key则q即为该层链表最接近指定key的</span></span><br><span class="line">              <span class="keyword">if</span> (key.compareTo(k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  q = r;</span><br><span class="line">                  r = r.right;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 到这里有两种情况：</span></span><br><span class="line">          <span class="comment">//1)该层链表已经查找完，仍未找到符号条件的节点</span></span><br><span class="line">          <span class="comment">//2)找到一个符合条件的节点</span></span><br><span class="line">          <span class="comment">// 开始往下一层链表进行查找</span></span><br><span class="line">          Index&lt;K,V&gt; d = q.down;</span><br><span class="line">          <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123; <span class="comment">// 从下层对应位置继续查找</span></span><br><span class="line">              q = d;</span><br><span class="line">              r = d.right;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="comment">// 如果无下层链表则直接返回当前节点的node</span></span><br><span class="line">              <span class="keyword">return</span> q.node;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的查找逻辑是：从head(跳表的最高层链表的头结点)开始自右开始查找，当找到该层链表的最接近且小于指定key的节点时，往下开始查找，最终找到最底层的那个节点。具体的代码可以看注释，应该说的挺明白的了，针对Put方法，这个方法返回的节点就是将要插入的节点的前继节点，即新节点将插到该节点后面。下面是查找的示意图:</p><p><img src="http://i.imgur.com/h99sWtC.png" alt=""></p><p>所有的修改操作都是使用CAS，只要失败就会重试，直至成功，所以就算多线程并发操作也不会出现错误，而且通过CAS避免了使用锁，性能比用锁好很多。</p><p>接下来在看一下remove：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object okey, Object value)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(okey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 从跳表中查找最接近指定key的节点：该节点的key小于等于指定key，且处于最底层</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//获取n节点的下一个节点</span></span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            Object v = n.value;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;                    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> c = key.compareTo(n.key);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;<span class="comment">//将该节点移除</span></span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);                  <span class="comment">// Retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findPredecessor(key);           <span class="comment">// Clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (V)v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：doRemove函数的处理流程如下。</p><p>① 根据key值找到前驱结点，查找的过程会删除一个标记为删除的结点。</p><p>② 从前驱结点往后查找该结点。</p><p>③ 在该结点后面添加一个marker结点，若添加成功，则将该结点的前驱的后继设置为该结点之前的后继。</p><p>④ 头结点的next域是否为空，若为空，则减少层级。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够在O(log(n))时间内完成查找、插入、删除操作。&lt;/p&gt;
&lt;h4 id=&quot;1-理解skiplist&quot;&gt;&lt;a class=&quot;markdo
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十三）----(JUC集合)ConcurrentSkipListMap介绍</title>
    <link href="http://blog.rickiyang.cn/posts/31315379.html"/>
    <id>http://blog.rickiyang.cn/posts/31315379.html</id>
    <published>2017-04-07T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.154Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们来看一下并发的Map，ConcurrentHashMap和ConcurrentSkipListMap。ConcurrentHashMap通常只被看做并发效率更高的Map，用来替换其他线程安全的Map容器，比如Hashtable和Collections.synchronizedMap。ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够在O(log(n))时间内完成查找、插入、删除操作。</p><h4 id="1-concurrenthashmap简介"><a class="markdownIt-Anchor" href="#1-concurrenthashmap简介"></a> 1 ConcurrentHashMap简介</h4><p>ConcurrentHashMap是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。</p><p>为了更好的理解 ConcurrentHashMap 高并发的具体实现，让我们先探索它的结构模型。</p><p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。</p><h5 id="11-hashentry类"><a class="markdownIt-Anchor" href="#11-hashentry类"></a> 1.1 HashEntry类：</h5><p>HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">     <span class="keyword">final</span> K key;</span><br><span class="line">     <span class="keyword">volatile</span> V value;</span><br><span class="line">     <span class="keyword">volatile</span> ConcurrentHashMap.HashEntry&lt;K, V&gt; next;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">     HashEntry(<span class="keyword">int</span> var1, K var2, V var3, ConcurrentHashMap.HashEntry&lt;K, V&gt; var4) &#123;</span><br><span class="line">         <span class="keyword">this</span>.hash = var1;</span><br><span class="line">         <span class="keyword">this</span>.key = var2;</span><br><span class="line">         <span class="keyword">this</span>.value = var3;</span><br><span class="line">         <span class="keyword">this</span>.next = var4;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(ConcurrentHashMap.HashEntry&lt;K, V&gt; var1)</span> </span>&#123;</span><br><span class="line">         UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, var1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             UNSAFE = Unsafe.getUnsafe();</span><br><span class="line">             Class var0 = ConcurrentHashMap.HashEntry.class;</span><br><span class="line">             nextOffset = UNSAFE.objectFieldOffset(var0.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception var1) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(var1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="12-segment类"><a class="markdownIt-Anchor" href="#12-segment类"></a> 1.2 Segment类：</h5><p>Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。Segment 中包含HashEntry 的数组，其可以守护其包含的若干个桶（HashEntry的数组）。Segment 在某些意义上有点类似于 HashMap了，都是包含了一个数组，而数组中的元素可以是一个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>?<span class="number">64</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * table 是由 HashEntry 对象组成的数组</span></span><br><span class="line"><span class="comment">     * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class="line"><span class="comment">     * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class="line"><span class="comment">     * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class="line"><span class="comment">     * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> ConcurrentHashMap.HashEntry&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;  <span class="comment">//Segment中元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">//对table的大小造成影响的操作的数量（比如put或者remove操作）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold; <span class="comment">//阈值，Segment里面元素的数量超过这个值依旧就会对Segment进行扩容</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">//负载因子，用于确定threshold</span></span><br><span class="line"></span><br><span class="line">    Segment(<span class="keyword">float</span> var1, <span class="keyword">int</span> var2, ConcurrentHashMap.HashEntry&lt;K, V&gt;[] var3) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = var1;</span><br><span class="line">        <span class="keyword">this</span>.threshold = var2;</span><br><span class="line">        <span class="keyword">this</span>.table = var3;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 的成员变量中，包含了一个 Segment 的数组（final Segment&lt;K,V&gt;[] segments;），而 Segment 是 ConcurrentHashMap 的内部类，然后在 Segment 这个类中，包含了一个 HashEntry 的数组（transient volatile HashEntry&lt;K,V&gt;[] table;）。而 HashEntry 也是 ConcurrentHashMap 的内部类。HashEntry 中，包含了 key 和 value 以及 next 指针（类似于 HashMap 中 Entry），所以 HashEntry 可以构成一个链表。</p><p>所以通俗的讲，ConcurrentHashMap 数据结构为一个 Segment 数组，Segment 的数据结构为 HashEntry 的数组，而 HashEntry 存的是我们的键值对，可以构成链表。</p><h5 id="13-concurrenthashmap结构图"><a class="markdownIt-Anchor" href="#13-concurrenthashmap结构图"></a> 1.3 ConcurrentHashMap结构图</h5><p><img src="http://i.imgur.com/X1ireU8.jpg" alt=""></p><p>ConcurrentHashMap引入了分割，并提供了HashTable支持的所有的功能。在ConcurrentHashMap中，支持多线程对Map做读操作，并且不需要任何的blocking。这得益于CHM将Map分割成了不同的部分，在执行更新操作时只锁住一部分。根据默认的并发级别(concurrency level)，Map被分割成16个部分，并且由不同的锁控制。这意味着，同时最多可以有16个写线程操作Map。试想一下，由只能一个线程进入变成同时可由16个写线程同时进入(读线程几乎不受限制)，性能的提升是显而易见的。但由于一些更新操作，如put(),remove(),putAll(),clear()只锁住操作的部分，所以在检索操作不能保证返回的是最新的结果。</p><p>ConcurrentHashMap默认的并发级别是16，但可以在创建CHM时通过构造函数改变。毫无疑问，并发级别代表着并发执行更新操作的数目，所以如果只有很少的线程会更新Map，那么建议设置一个低的并发级别。另外，ConcurrentHashMap还使用了ReentrantLock来对segments加锁。</p><p>经过前面的铺垫我们来正式对ConcurrentHashMap的使用进行剖析，重点关注get、put、remove这三个操作。</p><p>首先来看一下get的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> var4 = <span class="keyword">this</span>.hash(var1);</span><br><span class="line">    <span class="keyword">long</span> var5 = (<span class="keyword">long</span>)((var4 &gt;&gt;&gt; <span class="keyword">this</span>.segmentShift &amp; <span class="keyword">this</span>.segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    ConcurrentHashMap.Segment var2;</span><br><span class="line">    <span class="keyword">if</span>((var2 = (ConcurrentHashMap.Segment)UNSAFE.getObjectVolatile(<span class="keyword">this</span>.segments, var5)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentHashMap.HashEntry[] var3 = var2.table;</span><br><span class="line">        <span class="keyword">if</span>(var2.table != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ConcurrentHashMap.HashEntry var7 = (ConcurrentHashMap.HashEntry)UNSAFE.getObjectVolatile(var3, ((<span class="keyword">long</span>)(var3.length - <span class="number">1</span> &amp; var4) &lt;&lt; TSHIFT) + TBASE); var7 != <span class="keyword">null</span>; var7 = var7.next) &#123;</span><br><span class="line">                Object var8 = var7.key;</span><br><span class="line">                <span class="keyword">if</span>(var7.key == var1 || var7.hash == var4 &amp;&amp; var1.equals(var8)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> var7.value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>根据key，计算出hashCode；</p></li><li><p>根据步骤1计算出的hashCode定位segment，如果segment不为null &amp;&amp; segment.table也不为null，跳转到步骤3，否则，返回null，该key所对应的value不存在；</p></li><li><p>根据hashCode定位table中对应的hashEntry，遍历hashEntry，如果key存在，返回key对应的value；</p></li><li><p>步骤3结束仍未找到key所对应的value，返回null，该key锁对应的value不存在。</p></li></ol><p>ConcurrentHashMap的get操作高效之处在于整个get操作不需要加锁。如果不加锁，ConcurrentHashMap的get操作是如何做到线程安全的呢？原因是volatile，所有的value都定义成了volatile类型，（上面介绍HashEntry类源码中提到：volatile V value）volatile可以保证线程之间的可见性，这也是用volatile替换锁的经典应用场景。</p><p>再来看一下put操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K var1, V var2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> var4 = <span class="keyword">this</span>.hash(var1);</span><br><span class="line">        <span class="keyword">int</span> var5 = var4 &gt;&gt;&gt; <span class="keyword">this</span>.segmentShift &amp; <span class="keyword">this</span>.segmentMask;</span><br><span class="line">        ConcurrentHashMap.Segment var3;</span><br><span class="line">        <span class="keyword">if</span>((var3 = (ConcurrentHashMap.Segment)UNSAFE.getObject(<span class="keyword">this</span>.segments, (<span class="keyword">long</span>)(var5 &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            var3 = <span class="keyword">this</span>.ensureSegment(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var3.put(var1, var4, var2, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在第7行定义了一个Segment类型的 var3，然后调用了Segment的put方法存入map，我们不妨来看一下Segment的put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K var1, <span class="keyword">int</span> var2, V var3, <span class="keyword">boolean</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.获取锁，保证put操作的线程安全；</span></span><br><span class="line">  ConcurrentHashMap.HashEntry var5 = <span class="keyword">this</span>.tryLock()?<span class="keyword">null</span>:<span class="keyword">this</span>.scanAndLockForPut(var1, var2, var3);</span><br><span class="line"></span><br><span class="line">  Object var6;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      ConcurrentHashMap.HashEntry[] var7 = <span class="keyword">this</span>.table;</span><br><span class="line">      <span class="keyword">int</span> var8 = var7.length - <span class="number">1</span> &amp; var2;</span><br><span class="line">      <span class="comment">//2.定位到HashEntry数组中具体的HashEntry</span></span><br><span class="line">      ConcurrentHashMap.HashEntry var9 = ConcurrentHashMap.entryAt(var7, var8);</span><br><span class="line">      ConcurrentHashMap.HashEntry var10 = var9;</span><br><span class="line">      <span class="comment">//3.遍历HashEntry链表，假若待插入key已存在：</span></span><br><span class="line">      <span class="comment">//需要更新key所对应value（!onlyIfAbsent），更新oldValue -&gt; newValue，跳转到步骤5；</span></span><br><span class="line">      <span class="comment">//否则，直接跳转到步骤5；</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(var10 == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span>(var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  var5.setNext(var9);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  var5 = <span class="keyword">new</span> ConcurrentHashMap.HashEntry(var2, var1, var3, var9);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">int</span> var15 = <span class="keyword">this</span>.count + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span>(var15 &gt; <span class="keyword">this</span>.threshold &amp;&amp; var7.length &lt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.rehash(var5);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  ConcurrentHashMap.setEntryAt(var7, var8, var5);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              ++<span class="keyword">this</span>.modCount;</span><br><span class="line">              <span class="keyword">this</span>.count = var15;</span><br><span class="line">              var6 = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//4.遍历完HashEntry链表，key不存在，插入HashEntry节点，oldValue = null，跳转到步骤5</span></span><br><span class="line">          Object var11 = var10.key;</span><br><span class="line">          <span class="keyword">if</span>(var10.key == var1 || var10.hash == var2 &amp;&amp; var1.equals(var11)) &#123;</span><br><span class="line">              var6 = var10.value;</span><br><span class="line">              <span class="keyword">if</span>(!var4) &#123;</span><br><span class="line">                  var10.value = var3;</span><br><span class="line">                  ++<span class="keyword">this</span>.modCount;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">         var10 = var10.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//5.释放锁，返回oldValue</span></span><br><span class="line">       <span class="keyword">this</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中已经做出解析，需要知道的是Segment的HashEntry数组采用开链法来处理冲突，我们知道散列最大的局限性就是空间利用率低，例如载荷因子为0.7，那么仍有0.3的空间未被利用。使用开链法可以使载荷因子为1，每个链上都挂常数个数据，对于哈希表的开链法来说，其开的空间都是按素数个依次往后开的空间，所以put操作的效率很高。</p><p>再来看一下remove操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> var2 = <span class="keyword">this</span>.hash(var1);</span><br><span class="line">     ConcurrentHashMap.Segment var3 = <span class="keyword">this</span>.segmentForHash(var2);</span><br><span class="line">     <span class="keyword">return</span> var3 == <span class="keyword">null</span>?<span class="keyword">null</span>:var3.remove(var1, var2, (Object)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍旧是调用了Segment的remove方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object var1, <span class="keyword">int</span> var2, Object var3)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//获取锁</span></span><br><span class="line">     <span class="keyword">if</span>(!<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.scanAndLock(var1, var2);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Object var4 = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         ConcurrentHashMap.HashEntry[] var5 = <span class="keyword">this</span>.table;</span><br><span class="line">         <span class="keyword">int</span> var6 = var5.length - <span class="number">1</span> &amp; var2;</span><br><span class="line">         ConcurrentHashMap.HashEntry var7 = ConcurrentHashMap.entryAt(var5, var6);</span><br><span class="line">    </span><br><span class="line">         ConcurrentHashMap.HashEntry var10;</span><br><span class="line">         <span class="keyword">for</span>(ConcurrentHashMap.HashEntry var8 = <span class="keyword">null</span>; var7 != <span class="keyword">null</span>; var7 = var10) &#123;</span><br><span class="line">             <span class="comment">// 所有处于待删除节点之后的节点原样保留在链表中                </span></span><br><span class="line">             var10 = var7.next;</span><br><span class="line">             Object var9 = var7.key;</span><br><span class="line">             <span class="comment">//找到要删除的节点</span></span><br><span class="line">             <span class="keyword">if</span>(var7.key == var1 || var7.hash == var2 &amp;&amp; var1.equals(var9)) &#123;</span><br><span class="line">                 <span class="comment">// 所有处于待删除节点之前的节点被克隆到新链表中</span></span><br><span class="line">                 Object var11 = var7.value;</span><br><span class="line">                 <span class="keyword">if</span>(var3 != <span class="keyword">null</span> &amp;&amp; var3 != var11 &amp;&amp; !var3.equals(var11)) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">    </span><br><span class="line">                 <span class="keyword">if</span>(var8 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     ConcurrentHashMap.setEntryAt(var5, var6, var10);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     var8.setNext(var10);</span><br><span class="line">                 &#125;</span><br><span class="line">    </span><br><span class="line">                 ++<span class="keyword">this</span>.modCount;</span><br><span class="line">                 --<span class="keyword">this</span>.count;</span><br><span class="line">                  <span class="comment">// 把桶链接到新的头结点</span></span><br><span class="line">                 <span class="comment">// 新的头结点是原链表中，删除节点之前的那个节点</span></span><br><span class="line">                 var4 = var11;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">    </span><br><span class="line">             var8 = var7;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看两张图，执行删除前的原链表：</p><p><img src="http://i.imgur.com/L63CbqU.png" alt=""></p><p>删除之后的链表：</p><p><img src="http://i.imgur.com/3xwNdVt.png" alt=""></p><p>从上图可以看出，删除节点 C 之后的所有节点原样保留到新链表中；删除节点 C 之前的每个节点被克隆到新链表中，注意：它们在新链表中的链接顺序被反转了。</p><p>在执行 remove 操作时，原始链表并没有被修改，也就是说：读线程不会受同时执行 remove 操作的并发写线程的干扰。</p><p>综合上面的分析我们可以看出，写线程对某个链表的结构性修改不会影响其他的并发读线程对这个链表的遍历访问。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ul><li>ConcurrentHashMap 允许并发的读和线程安全的更新操作</li><li>在执行写操作时，ConcurrentHashMap 只锁住部分的Map</li><li>并发的更新是通过内部根据并发级别将Map分割成小部分实现的</li><li>高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争</li><li>ConcurrentHashMap 的所有操作都是线程安全</li><li>ConcurrentHashMap 返回的迭代器是弱一致性，fail-safe并且不会抛出ConcurrentModificationException异常</li><li>ConcurrentHashMap 不允许null的键值</li></ul><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们来看一下并发的Map，ConcurrentHashMap和ConcurrentSkipListMap。ConcurrentHashMap通常只被看做并发效率更高的Map，用来替换其他线程安全的Map容器，比如Hashtable和Collections.synchr
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十一）----(JUC集合)CopyOnWriteArraySet和ConcurrentSkipListSet介绍</title>
    <link href="http://blog.rickiyang.cn/posts/5ee7a4a7.html"/>
    <id>http://blog.rickiyang.cn/posts/5ee7a4a7.html</id>
    <published>2017-04-06T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.137Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们来接着介绍JUC集合：CopyOnWriteArraySet和ConcurrentSkipListSet。从名字上来看我们知道CopyOnWriteArraySet与上一节讲到的CopyOnWriteArrayList一样是动态数组实现;ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。下面我们深入细致的分析一下他们的用法。</p><h4 id="1-copyonwritearrayset简介"><a class="markdownIt-Anchor" href="#1-copyonwritearrayset简介"></a> 1 CopyOnWriteArraySet简介</h4><p>它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。对其所有操作使用内部 CopyOnWriteArrayList 的 Set。因此，它共享以下相同的基本属性：</p><ol><li>它最适合于具有以下特征的应用程序：set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。</li><li>它是线程安全的。</li><li>因为通常需要复制整个基础数组，所以可变操作（add、set 和 remove 等等）的开销很大。  迭代器不支持可变 remove操作。</li><li>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</li></ol><p>我们看一下CopyOnWriteArraySet的类体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5457747651344034263L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类有一个成员变量CopyOnWriteArrayList。CopyOnWriteArraySet其所有操作使用内部 CopyOnWriteArrayList 的 Set，所以他的所有的方法其实都是引用了CopyOnWriteArrayList的方法来完成的。有关CopyOnWriteArrayList的使用说明我们在上一节里已经介绍的很详细，有兴趣可以查看上一节里的源码介绍。</p><h4 id="2-concurrentskiplistset简介"><a class="markdownIt-Anchor" href="#2-concurrentskiplistset简介"></a> 2 ConcurrentSkipListSet简介</h4><p>ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。他是一个基于 ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。下面我们看一下方法体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2479143111061671589L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentNavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m = <span class="keyword">new</span> ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) ConcurrentSkipListSet继承于AbstractSet。因此，它本质上是一个集合。</p><p>(2) ConcurrentSkipListSet实现了NavigableSet接口。因此，ConcurrentSkipListSet是一个有序的集合。</p><p>(3) ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的。它包含一个ConcurrentNavigableMap对象m，而m对象实际上是ConcurrentNavigableMap的实现类ConcurrentSkipListMap的实例。ConcurrentSkipListMap中的元素是key-value键值对；而ConcurrentSkipListSet是集合，它只用到了ConcurrentSkipListMap中的key！</p><p>由源码中我们能看到ConcurrentSkipListSet内部所有操作都是在内部由ConcurrentSkipListMap完成。本节我们先不介绍ConcurrentSkipListMap，下节讲到map的时候再细说。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们来接着介绍JUC集合：CopyOnWriteArraySet和ConcurrentSkipListSet。从名字上来看我们知道CopyOnWriteArraySet与上一节讲到的CopyOnWriteArrayList一样是动态数组实现;ConcurrentSki
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十九）----(JUC集合)总体框架介绍</title>
    <link href="http://blog.rickiyang.cn/posts/c00aa264.html"/>
    <id>http://blog.rickiyang.cn/posts/c00aa264.html</id>
    <published>2017-04-04T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.142Z</updated>
    
    <content type="html"><![CDATA[<p>本节我们将继续学习JUC包中的集合类，我们知道jdk中本身自带了一套非线程安全的集合类，我们先温习一下java集合包里面的集合类，然后系统的看一下JUC包里面的集合类到底有什么不同。</p><h4 id="1-java集合类"><a class="markdownIt-Anchor" href="#1-java集合类"></a> 1 java集合类</h4><p>java集合类里面主要包含两大类：一类是Collection接口下的List、Set和Queue接口，一类是Map接口。</p><h5 id="11-list的主要实现类包括"><a class="markdownIt-Anchor" href="#11-list的主要实现类包括"></a> 1.1 List的主要实现类包括：</h5><pre><code>ArrayList：数组实现的队列，它是一个动态数组；它不是线程安全的，只适用于单线程；LinkedList：双重链表实现的队列，它也不是线程安全的，只适用于单线程；Stack：表示后进先出（LIFO）的对象堆栈，继承于Vector，他是线程安全的；Vector：可以实现可增长的对象数组，与数组一样，它包含可以使用整数索引进行访问的组件。此类是线程安全的。</code></pre><h5 id="12-set的主要实现类包括"><a class="markdownIt-Anchor" href="#12-set的主要实现类包括"></a> 1.2 Set的主要实现类包括：</h5><pre><code>HashSet：由哈希表（实际上是一个 HashMap 实例）支持。该集合元素不可重复，它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变，并且此实现不是同步的；TreeSet：基于 TreeMap 的 NavigableSet 实现，也是一个没有重复元素的集合，不过和HashSet不同的是，TreeSet中的元素是有序的；该类的实现也不是同步的；LinkedHashSet：元素是有序的，维护着一个运行于所有条目的双重链接列表；此实现不是同步的；</code></pre><h5 id="13-map的主要实现类包括"><a class="markdownIt-Anchor" href="#13-map的主要实现类包括"></a> 1.3 Map的主要实现类包括：</h5><pre><code>HashMap：基于哈希表的 Map 接口的实现。此实现不是同步的；TreeMap：基于红黑树（Red-Black tree）的 NavigableMap 实现，该类的&lt;k,v&gt;是有序的此实现不是同步的；HashTable：与HashMap一样都是基于哈希表的Map实现，但是此类是线程安全的；WeakHashMap：以弱键 实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。该类是非线程安全的。</code></pre><p>上面这些是传统的java集合类，他们大多数都不是线程安全的，所以在同步并发中对他们的使用率并不高，为了线程安全以及开发人员在使用集合工具的同时不必去维护线程安全，Doug Lea在JUC(java.util.concurrent)包中添加了java集合包中单线程类的对应的支持高并发的类。下面我们一起来看一下这些并发集合类。</p><h4 id="2-juc集合类"><a class="markdownIt-Anchor" href="#2-juc集合类"></a> 2 JUC集合类</h4><h5 id="21-list的主要实现类包括"><a class="markdownIt-Anchor" href="#21-list的主要实现类包括"></a> 2.1 List的主要实现类包括：</h5><p><img src="http://i.imgur.com/aOiGVFA.png" alt=""></p><p>CopyOnWriteArrayList：相当于线程安全的ArrayList，它实现了List接口，他是线程安全的。</p><h5 id="22-set的主要实现类包括"><a class="markdownIt-Anchor" href="#22-set的主要实现类包括"></a> 2.2 Set的主要实现类包括：</h5><p><img src="http://i.imgur.com/1uyGObg.png" alt=""></p><p>CopyOnWriteArraySet：相当于线程安全的HashSet,内部使用 CopyOnWriteArrayList 。</p><p>ConcurrentSkipListSet:一个基于 ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现，内部排序是有序的。</p><h5 id="23-map的主要实现类包括"><a class="markdownIt-Anchor" href="#23-map的主要实现类包括"></a> 2.3 Map的主要实现类包括：</h5><p><img src="http://i.imgur.com/yneZYBY.png" alt=""></p><p>ConcurrentHashMap：支持获取的完全并发和更新的所期望可调整并发的哈希表。</p><p>ConcurrentSkipListMap：可缩放的并发 ConcurrentNavigableMap 实现，内部排序是有序的Map，该类为线程安全的。</p><h5 id="24-queue的主要实现类包括"><a class="markdownIt-Anchor" href="#24-queue的主要实现类包括"></a> 2.4 Queue的主要实现类包括：</h5><p><img src="http://i.imgur.com/JvlUie1.png" alt=""></p><p>ArrayBlockingQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序；</p><p>LinkedBlockingQueue：一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO（先进先出）排序元素；</p><p>LinkedBlockingDeque：一个基于已链接节点的、任选范围的阻塞双端队列；</p><p>ConcurrentLinkedQueue：一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序；</p><p>ConcurrentLinkedDeque：是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。</p><p>下一节我们将一起详细的来分析JUC中的集合工具的使用和原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本节我们将继续学习JUC包中的集合类，我们知道jdk中本身自带了一套非线程安全的集合类，我们先温习一下java集合包里面的集合类，然后系统的看一下JUC包里面的集合类到底有什么不同。&lt;/p&gt;
&lt;h4 id=&quot;1-java集合类&quot;&gt;&lt;a class=&quot;markdownIt-A
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十八）----(线程池)java线程池框架Fork-Join</title>
    <link href="http://blog.rickiyang.cn/posts/5f5c40c1.html"/>
    <id>http://blog.rickiyang.cn/posts/5f5c40c1.html</id>
    <published>2017-04-03T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.136Z</updated>
    
    <content type="html"><![CDATA[<p>还记得我们在初始介绍线程池的时候提到了Executor框架的体系，到现在为止我们只有一个没有介绍，与ThreadPoolExecutor一样继承与AbstractExecutorService的ForkJoinPool.Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>我们通过表面的意思去理解ForkJoin框架：Fork即把一个大任务切割成若干部分并行执行，join即把这些被切分的任务的执行结果合并一起汇总，我们可以用下图来表示：</p><p><img src="http://i.imgur.com/CipMJZK.jpg" alt=""></p><p>Fork / Join的逻辑很简单：</p><pre><code>（1）将每个大任务分离（fork）为较小的任务; （2）在单独的线程中处理每个任务（如果必要，将它们分离成更小的任务）; （3）加入结果。</code></pre><p>Fork/Join框架的核心是由下列两个类组成的。</p><p>①ForkJoinPool：这个类实现了ExecutorService接口和工作窃取算法（Work-Stealing Algorithm）。它管理工作者线程，并提供任务的状态信息，以及任务的执行信息。</p><p>②ForkJoinTask：这个类是一个将在ForkJoinPool中执行的任务的基类。</p><p>理解一个概念的最好方法是在实践中体会他，我们先写一个小程序，在此基础上一点一点来分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        pool.submit(<span class="keyword">new</span> PrintTask(<span class="number">1</span>,<span class="number">100</span>));</span><br><span class="line">        pool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);<span class="comment">//阻塞当前线程直到 ForkJoinPool 中所有的任务都执行结束</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end - start &lt; <span class="number">50</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end; i++)&#123;</span><br><span class="line">                num += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"当前任务结果为： "</span>+num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (end + start)/<span class="number">2</span>;</span><br><span class="line">            PrintTask left = <span class="keyword">new</span> PrintTask(start,mid);</span><br><span class="line">            PrintTask right = <span class="keyword">new</span> PrintTask(mid+<span class="number">1</span>,end);</span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前任务结果为： <span class="number">3775</span></span><br><span class="line">当前任务结果为： <span class="number">1275</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们通过结果可以看到当前任务被分裂为两个子任务去执行。而执行任务的类继承了RecursiveAction这个类，那他到底在Fork-Join框架中发挥什么作用呢？我们不妨看一下：</p><p>首先我们来看一下Fork-Join框架提交任务的方法仍旧还是submit和execute：</p><pre><code>void execute(ForkJoinTask&lt;?&gt; task) //安排（异步）执行给定任务void execute(Runnable task) //在未来的某个时候执行给定的命令&lt;T&gt; ForkJoinTask&lt;T&gt; submit(Callable&lt;T&gt; task) //执行一个有返回值得任务，返回一个Future类型的实例代表任务的结果&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) //提交一个ForkJoinTask类型的任务ForkJoinTask&lt;?&gt; submit(Runnable task) //提交一个Runnable类型的任务，返回一个Future类型的实例代表任务结果 &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Runnable task, T result) //提交一个Runnable类型的任务，返回一个Future类型的实例代表任务结果 </code></pre><p>由execute和submit的参数我们可以看到Fork-join框架可以提交ForkJoinTask，Callable和Runnable类型的任务。这个ForkJoinTask我们之前没见过，先来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到ForkJoinTask实现了Future接口，一个ForkJoinTask是一个轻量级的Future。对ForkJoinTask效率源于一组限制（这只是部分静态强制执行）反映其用途作为计算任务计算纯函数或纯粹孤立的对象操作。主要的协调机制fork()，安排异步执行，而不进行join()，直到任务的结果已经计算。通常我们并不直接继承 ForkJoinTask，它包含了太多的抽象方法。针对特定的问题，我们可以选择 ForkJoinTask 的不同子类来完成任务：</p><pre><code>RecursiveAction：用于任务没有返回结果的场景。RecursiveTask：用于任务有返回结果的场景。</code></pre><p>上面的例子中我们就是继承了RecursiveAction子类用于没有返回结果的场景，下面我们再看一下RecursiveTask用于有返回结果的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRecursiveTask</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer result = <span class="number">0</span>;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> SumTask(<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result+<span class="string">"==========================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"生产完成"</span>+num+<span class="string">"个产品"</span>);</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            SumTask task1 = <span class="keyword">new</span> SumTask(<span class="number">20</span>);</span><br><span class="line">            SumTask task2 = <span class="keyword">new</span> SumTask(num - <span class="number">20</span>);</span><br><span class="line">            task1.fork();</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><pre><code>生产完成20个产品生产完成10个产品30===========================Process finished with exit code 0</code></pre><p>我们看到继承RecursiveTask类指定了返回值类型为Integer，在compute方法中的返回值类型即为Integer类型。</p><p>从以上的例子中可以看到，通过使用 Fork/Join 模式，软件开发人员能够方便地利用多核平台的计算能力。尽管还没有做到对软件开发人员完全透明，Fork/Join 模式已经极大地简化了编写并发程序的琐碎工作。对于符合 Fork/Join 模式的应用，软件开发人员不再需要处理各种并行相关事务，例如同步、通信等，以难以调试而闻名的死锁和 data race 等错误也就不会出现，提升了思考问题的层次。你可以把 Fork/Join 模式看作并行版本的 Divide and Conquer 策略，仅仅关注如何划分任务和组合中间结果，将剩下的事情丢给 Fork/Join 框架。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还记得我们在初始介绍线程池的时候提到了Executor框架的体系，到现在为止我们只有一个没有介绍，与ThreadPoolExecutor一样继承与AbstractExecutorService的ForkJoinPool.Fork/Join框架是Java7提供了的一个用于并行
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十八）----(线程池)java线程池框架Fork-Join</title>
    <link href="http://blog.rickiyang.cn/posts/5f5c40c1.html"/>
    <id>http://blog.rickiyang.cn/posts/5f5c40c1.html</id>
    <published>2017-04-03T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.154Z</updated>
    
    <content type="html"><![CDATA[<p>这一节开始我们正式来介绍JUC集合类。我们按照List、Set、Map、Queue的顺序来进行介绍。这一节我们来看一下CopyOnWriteArrayList。</p><h4 id="1-copyonwritearraylist介绍"><a class="markdownIt-Anchor" href="#1-copyonwritearraylist介绍"></a> 1 CopyOnWriteArrayList介绍</h4><p>CopyOnWriteArrayList是ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p><p>与ArrayList不同处就在于是否会拷贝数组和加锁。</p><p>CopyOnWriteArrayList顾名思义就是写时复制的ArrayList，其意思就是在修改容器的元素时，并不是直接在原数组上修改，而是先拷贝了一份数组，然后在拷贝的数组上进行修改，修改完后将其引用赋值给原数组的引用。这样体现了读写分离，这样无论在任何时候我们都可以对容器进行读取。</p><h4 id="2-copyonwritearraylist源码分析"><a class="markdownIt-Anchor" href="#2-copyonwritearraylist源码分析"></a> 2 CopyOnWriteArrayList源码分析</h4><p>我们看一下CopyOnWriteArrayList的类声明部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">         <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它实现了List接口，所以实现了Collection的功能，另外我们看到还有两个类成员变量lock和array，<br>在后面的源码分析中我们能看到CopyOnWriteArrayList是线程安全的使用动态数组操作机制实现的List。</p><p><strong>所谓动态数组操作机制</strong>：即通过volatile修饰的Object类型数组来进行数组的CRUD操作。在进行add,set,remove等可变操作的时候，都会先新建一个数组把更新的值赋给该数组，然后再传递给上面的array数组来保持该次操作的可见性。这也是CopyOnWriteArrayList命名的由来。这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，即在进行读操作时的效率要远远高于写或是修改操作，这种方法可能比其他替代方法更 有效。</p><p><strong>CopyOnWriteArrayList的线程安全实现</strong>：我们能看到是通过一个全局的Lock和volatile修饰的array来实现的。在进行add,remove,set等可变操作的时候通过赋值给array我们总能保证该变量的内存可见性，其他的线程每次总能读到最新的array变量；同样在每次进行add,remove,set等可变操作时候都会在操作的一开始加入独占锁，操作结束释放锁，以保证本次操作的安全性。</p><p>下面我们就上述分析来看一下他的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;  <span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Object[] elements = getArray();</span><br><span class="line">       <span class="keyword">int</span> len = elements.length;</span><br><span class="line">       <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+len);</span><br><span class="line">       Object[] newElements;</span><br><span class="line">       <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">       <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//如果是在最后一个位置增加就把该数组赋值一份然后新增一个长度</span></span><br><span class="line">           newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则新建数组，然后将"volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组"。</span></span><br><span class="line">           newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">           System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">           System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,numMoved);</span><br><span class="line">       &#125;</span><br><span class="line">       newElements[index] = element;</span><br><span class="line">       setArray(newElements); <span class="comment">//拷贝</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock = l.lock;<span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line">       checkForComodification();</span><br><span class="line">       E x = l.set(index+offset, element);</span><br><span class="line">       expectedArray = l.getArray();<span class="comment">//拷贝</span></span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; <span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Object[] elements = getArray();</span><br><span class="line">       <span class="keyword">int</span> len = elements.length;</span><br><span class="line">       E oldValue = get(elements, index);</span><br><span class="line">       <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。</span></span><br><span class="line">       <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">           setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 否则，新建数组，然后将"volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组"。</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">           System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">           System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,numMoved);</span><br><span class="line">           setArray(newElements); <span class="comment">//拷贝</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面源码部分我们可以看到CopyOnWriteArrayList在修改原数组的过程中比ArrayList多做了2件事：</p><p>1、加锁：保证我在修改数组的时候，其他人不能修改。</p><p>2、拷贝数组：无论是哪个方法，发现都需要拷贝数组。</p><p>上面的两件事就确保了CopyOnWriteArrayList在多线程的环境下可以应对自如。</p><p>我们再来看一下他的迭代器的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到迭代器里面调用了COWIterator这个类，下面来看一下他的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">     <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">         cursor = initialCursor;</span><br><span class="line">         snapshot = elements;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (! hasNext())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">         <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">         <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> cursor;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//不支持remove方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不支持set方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//不支持add方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到COWSubListIterator不支持修改元素的操作。例如，对于remove(),set(),add()等操作，COWSubListIterator都会抛出异常！</p><p>CopyOnWriteArrayList的迭代器并不是快速失败的，也就是说并不会抛出ConcurrentModificationException异常。这是因为他在修改的时候，是针对与拷贝数组而言的，对于原数组没有任何影响。我们可以看出迭代器里面没有锁机制，所以只提供读取，而不支持添加修改和删除（抛出UnsupportedOperationExcetion）。</p><h5 id="3-copyonwritearraylist使用示例"><a class="markdownIt-Anchor" href="#3-copyonwritearraylist使用示例"></a> 3 CopyOnWriteArrayList使用示例</h5><p>上面我们具体的分析了CopyOnWriteArrayList的线程安全机制和实现机制，我们再来就他的使用做一个相应的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyOnWriteArrayList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fixme: list是ArrayList对象时，程序会出错。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">/*private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> TestList(<span class="string">"aa"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        Iterator iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            value = (String)iter.next();</span><br><span class="line">            System.out.print(value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        TestList(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String val = Thread.currentThread().getName();</span><br><span class="line">            list.add(val);</span><br><span class="line">            printAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上程序，当list是ArrayList对象时，程序会出错，报出java.util.ConcurrentModificationException类型异常；当使用CopyOnWriteArrayList对象时，程序可以完成iterator遍历操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节开始我们正式来介绍JUC集合类。我们按照List、Set、Map、Queue的顺序来进行介绍。这一节我们来看一下CopyOnWriteArrayList。&lt;/p&gt;
&lt;h4 id=&quot;1-copyonwritearraylist介绍&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十七）----(线程池)java线程池架构和原理</title>
    <link href="http://blog.rickiyang.cn/posts/b9ed0404.html"/>
    <id>http://blog.rickiyang.cn/posts/b9ed0404.html</id>
    <published>2017-04-02T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.165Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们简单介绍了线程池的使用，但是对于其如何运行我们还不清楚，Executors为我们提供了简单的线程工厂类，但是我们知道ThreadPoolExecutor是线程池的具体实现类。我们先从他开始分析。</p><h4 id="1-threadpoolexecutor初探"><a class="markdownIt-Anchor" href="#1-threadpoolexecutor初探"></a> 1 ThreadPoolExecutor初探</h4><p>ThreadPoolExecutor一共有3个构造方法，我们来看一下其中看起来比较复杂的这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来参数是挺多的，我们不妨耐心看看参数都是什么意思：</p><ol><li><p>corePoolSize：核心池的大小，默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p></li><li><p>maximumPoolSize：线程池最大线程数，它表示在线程池中最多能创建多少个线程；</p></li><li><p>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。</p></li><li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure><ol start="5"><li>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>threadFactory：是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法即可；</p></li><li><p>handler：表示当拒绝处理任务时的策略，也就是参数maximumPoolSize达到后丢弃处理的方法，java提供了4种丢弃处理的方法，当然你也可以自己根据实际情况去重写，主要是要实现接口：RejectedExecutionHandler中的方法： public void rejectedExecution(Runnabler, ThreadPoolExecutor e) java默认的是使用：AbortPolicy，他的作用是当出现这中情况的时候会抛出一个异常；有以下四种取值：</p><p>①ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</p><p>②ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</p><p>③ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p><p>④ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p></li></ol><p>上面说了ThreadPoolExecutor的构造方法，我们继续看他的类的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码我们看出ThreadPoolExecutor继承了AbstractExecutorService类，我们知道AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上我们知道AbstractExecutorService又实现了ExecutorService接口，而ExecutorService是Executor实现类的最直接接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此我们似乎可以明白他们之间的关系：</p><ol><li>Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)；</li><li>ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；</li><li>抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；</li><li>ThreadPoolExecutor继承了类AbstractExecutorService，成为线程池的具体实现类。</li></ol><h4 id="2-线程池的实现"><a class="markdownIt-Anchor" href="#2-线程池的实现"></a> 2 线程池的实现</h4><p>上面我们从ThreadPoolExecutor的构造方法出发提到了线程池的状态，执行，初始化，排队策略等等，下面我们就从这些方面入手，看看线程池的原理。</p><h5 id="3-线程池初始化"><a class="markdownIt-Anchor" href="#3-线程池初始化"></a> 3 线程池初始化</h5><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务（execute或者submit）之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p><ul><li>prestartCoreThread()：初始化一个核心线程</li><li>prestartAllCoreThreads()：初始化所有核心线程</li></ul><p>下面是这两个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">            ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure><p>我们注意到上面两个方法都调用了addWorker方法，我们看一下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">   retry:</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">       <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">           ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">              firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">              ! workQueue.isEmpty()))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">           <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">               wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">               <span class="keyword">break</span> retry;</span><br><span class="line">           c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">           <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">               <span class="keyword">continue</span> retry;</span><br><span class="line">           <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">   Worker w = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">       w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">       <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">       <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mainLock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">               <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">               <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">               <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">               <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                   (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                   workers.add(w);</span><br><span class="line">                   <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                   <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                       largestPoolSize = s;</span><br><span class="line">                   workerAdded = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mainLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">               t.start();</span><br><span class="line">               workerStarted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">           addWorkerFailed(w);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法还是挺好理解：上面的retry是对当前线程池状态进行检查，如果当前线程池未初始化或者未分配则返回false；</p><p>往下是初始化firstTask，我们看到在56行把初始化的firstTask加入workers集合，该集合定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p>集合中包含当前所有的工作线程。<br>看完addWorker的实现，那么上面的prestartCoreThread和prestartAllCoreThreads我们就很好理解，前一个是向当前工作线程池中加入一个工作线程，后一个是循环N次。</p><h5 id="4-线程池的执行"><a class="markdownIt-Anchor" href="#4-线程池的执行"></a> 4 线程池的执行</h5><p>通常你得到线程池后，会调用其中的：submit方法或execute方法去操作；其实你会发现，submit方法最终会调用execute方法来进行操作，只是他提供了一个Future来托管返回值的处理而已，当你调用需要有返回值的信息时，你用它来处理是比较好的；这个Future会包装对Callable信息，并定义一个Sync对象（），当你发生读取返回值的操作的时候，会通过Sync对象进入锁，直到有返回值的数据通知。</p><p>我们先看一下submit方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">   <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">   RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">   execute(ftask);</span><br><span class="line">   <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在源码的第4行实际上是调用了execute()方法来处理包装的RunnableFuture。下面是execute方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个if为非空判断;</p><p>第二个if中的workerCountOf()方法拿到ctl中存储的当前线程总数，如果小于corePoolSize，那么就会走到addWorker()方法中，如果成功创建了Worker的话，那么返回true，直接return，否则重新通过cas拿一次c;</p><p>第三个if中判断当前的线程池是否处于RUNNING状态，如果是，并且workQueue.offer加入队列成功话，那么就重新拿出来一次ctl，再判断如果加入队列之后，线程池如果不是处于RUNNING的状态，并且从队列中remove成功的话，那么就会执行reject操作；判断当前线程数是否为0，如果为0的话，那么就调用addWorker(null,false)，否则如果非Running状态或者加入队列失败的话，那么就会调用addWorker(command,false)如果返回false，说明没有添加成功，就会执行reject操作。</p><h5 id="5-任务缓存队列"><a class="markdownIt-Anchor" href="#5-任务缓存队列"></a> 5 任务缓存队列</h5><p>我们还记得ThreadPoolExecutor的构造函数中有一个参数workQueue，它用来存放等待执行的任务。<br>workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：</runnable></p><p>1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p><p>2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p><h5 id="6-线程池的关闭"><a class="markdownIt-Anchor" href="#6-线程池的关闭"></a> 6 线程池的关闭</h5><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li><li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li></ul><h5 id="7-线程池容量的动态调整"><a class="markdownIt-Anchor" href="#7-线程池容量的动态调整"></a> 7 线程池容量的动态调整</h5><p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()</p><p>setCorePoolSize：设置核心池大小</p><p>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</p><p>当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p><p>下面我们看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> produceTaskSleepTime = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> produceTaskMaxNumber = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造一个线程池</span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= produceTaskMaxNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String task = <span class="string">"task-- "</span> + i;</span><br><span class="line">                System.out.println(<span class="string">"创建任务并提交到线程池中："</span> + task);</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> ThreadPoolTask(task));</span><br><span class="line">                System.out.println(<span class="string">"线程池中线程数目："</span>+threadPool.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">                       threadPool.getQueue().size()+<span class="string">"，已执行完毕的任务数目："</span>+threadPool.getCompletedTaskCount());</span><br><span class="line"></span><br><span class="line">                Thread.sleep(produceTaskSleepTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object attachData;</span><br><span class="line"></span><br><span class="line">    ThreadPoolTask(Object tasks) &#123;</span><br><span class="line">        <span class="keyword">this</span>.attachData = tasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"开始执行任务："</span> + attachData);</span><br><span class="line"></span><br><span class="line">        attachData = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attachData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line"></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">1</span></span><br><span class="line">开始执行任务：task-- <span class="number">1</span></span><br><span class="line">线程池中线程数目：<span class="number">1</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行完毕的任务数目：<span class="number">0</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">2</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行完毕的任务数目：<span class="number">1</span></span><br><span class="line">开始执行任务：task-- <span class="number">2</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">3</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">2</span></span><br><span class="line">开始执行任务：task-- <span class="number">3</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">4</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">3</span></span><br><span class="line">开始执行任务：task-- <span class="number">4</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">5</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">4</span></span><br><span class="line">开始执行任务：task-- <span class="number">5</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">6</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">5</span></span><br><span class="line">开始执行任务：task-- <span class="number">6</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">7</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">6</span></span><br><span class="line">开始执行任务：task-- <span class="number">7</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">8</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">7</span></span><br><span class="line">开始执行任务：task-- <span class="number">8</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">9</span></span><br><span class="line">开始执行任务：task-- <span class="number">9</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行完毕的任务数目：<span class="number">8</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">10</span></span><br><span class="line">开始执行任务：task-- <span class="number">10</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行完毕的任务数目：<span class="number">9</span></span><br></pre></td></tr></table></figure><p>由结果我们可以看到当线程池中线程的数目大于2时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们简单介绍了线程池的使用，但是对于其如何运行我们还不清楚，Executors为我们提供了简单的线程工厂类，但是我们知道ThreadPoolExecutor是线程池的具体实现类。我们先从他开始分析。&lt;/p&gt;
&lt;h4 id=&quot;1-threadpoolexecutor初探&quot;
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十六）----(线程池)java线程池的使用</title>
    <link href="http://blog.rickiyang.cn/posts/e7e539b9.html"/>
    <id>http://blog.rickiyang.cn/posts/e7e539b9.html</id>
    <published>2017-03-28T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.161Z</updated>
    
    <content type="html"><![CDATA[<p>上节我们简单介绍了线程池，这次我们就来使用一下。Executors提供四种线程池，分别是：newCachedThreadPool，newFixedThreadPool ，newScheduledThreadPool ，newSingleThreadExecutor 。下面我们分别来使用下。</p><h4 id="1-newsinglethreadexecutor"><a class="markdownIt-Anchor" href="#1-newsinglethreadexecutor"></a> 1 newSingleThreadExecutor</h4><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>我们来看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newSingleThreadExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService ex = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                    System.out.println(Thread.currentThread().getName());                           </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1</code></pre><p>由输出结果可以看出始终只有一个线程在工作。</p><h4 id="2-newfixedthreadpool"><a class="markdownIt-Anchor" href="#2-newfixedthreadpool"></a> 2 newFixedThreadPool</h4><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><p>我们来看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newFixedThreadPoolTest</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService ex = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-1pool-1-thread-2pool-1-thread-2pool-1-thread-5pool-1-thread-3pool-1-thread-3pool-1-thread-3pool-1-thread-3pool-1-thread-3pool-1-thread-4</code></pre><p>我们启动了10个线程，但是池中只有5个线程工作，所以结果中最多只有5个线程。</p><h4 id="3-newcachedthreadpool"><a class="markdownIt-Anchor" href="#3-newcachedthreadpool"></a> 3 newCachedThreadPool</h4><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，<br>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p><p>我们来看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newCachedThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService ex = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1</code></pre><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。但是如果执行第二个任务时第一个任务没有完成则又是另一番景象，我们把上面的例子稍稍改一下就有所不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newCachedThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService ex = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-1pool-1-thread-3pool-1-thread-2pool-1-thread-5pool-1-thread-4pool-1-thread-6pool-1-thread-7pool-1-thread-8pool-1-thread-9pool-1-thread-10</code></pre><p>第一个任务在执行的时候等待了6秒，所以此时第二个任务执行的时候则是新建一个线程来执行。</p><h4 id="4-newscheduledthreadpool"><a class="markdownIt-Anchor" href="#4-newscheduledthreadpool"></a> 4 newScheduledThreadPool</h4><p>创建一个大小无限的线程池。此线程池支持定时以及<strong>周期性执</strong>行任务的需求。</p><p>在上一篇类类的关系图中我们可以看到该方法直接实现了ScheduledExecutorService接口，而该接口相当于提供了”延时”和”周期执行”功能的ExecutorService，再来看一下该方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值是ScheduledExecutorService类型的，与其他3个方法不同，需要注意。我们来看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newScheduledThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService ex = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.schedule(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//定时执行的线程池</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="number">2</span>, TimeUnit.SECONDS); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre><code>pool-1-thread-2pool-1-thread-4pool-1-thread-1pool-1-thread-5pool-1-thread-3pool-1-thread-2pool-1-thread-3pool-1-thread-5pool-1-thread-1pool-1-thread-4</code></pre><p>启动后会延迟2s之后才开始执行。</p><p>我们再来看一个周期性执行的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newScheduledThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService ex = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//延迟3s后每2s周期性执行一次，不停</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="number">3</span>,<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-3pool-1-thread-4pool-1-thread-2pool-1-thread-5pool-1-thread-1...</code></pre><p>newScheduledThreadPool中有很多另外3个类中没有的方法，我们来看一下：</p><ol><li><p>shedule(Runnable command, long delay, TimeUnit unit): 延迟一定时间后执行Runnable任务；</p></li><li><p>schedule(Callable callable, long delay, TimeUnit unit): 延迟一定时间后执行Callable任务；</p></li><li><p>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit):  延迟一定时间后，以间隔period时间的频率周期性地执行任务；</p></li><li><p>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit):  与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，也就是这一些任务系列的触发时间都是可预知的。</p></li></ol><p>由上我们看到ScheduledExecutorService在执行定时任务方面还是挺强大的。线程池的使用我们就到这里，其实用了这么多我们只是在调用别人写好的方法，但是对于线程池是如何实现的我们还是未知的，下一节我们就深入的去分析线程池的实现，看看到底有什么高深莫测。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上节我们简单介绍了线程池，这次我们就来使用一下。Executors提供四种线程池，分别是：newCachedThreadPool，newFixedThreadPool ，newScheduledThreadPool ，newSingleThreadExecutor 。下面我
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>（十五）----(线程池)java线程池简介</title>
    <link href="http://blog.rickiyang.cn/posts/d72ca9c5.html"/>
    <id>http://blog.rickiyang.cn/posts/d72ca9c5.html</id>
    <published>2017-03-27T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.160Z</updated>
    
    <content type="html"><![CDATA[<p>好的软件设计不建议手动创建和销毁线程。线程的创建和销毁是非常耗 CPU 和内存的，因为这需要 JVM 和操作系统的参与。64位 JVM 默认线程栈是大小1 MB。这就是为什么说在请求频繁时为每个小的请求创建线程是一种资源的浪费。线程池可以根据创建时选择的策略自动处理线程的生命周期。重点在于：在资源（如内存、CPU）充足的情况下，线程池没有明显的优势，否则没有线程池将导致服务器崩溃。有很多的理由可以解释为什么没有更多的资源。例如，在拒绝服务（denial-of-service）攻击时会引起的许多线程并行执行，从而导致线程饥饿（thread starvation）。除此之外，手动执行线程时，可能会因为异常导致线程死亡，程序员必须记得处理这种异常情况。这时我们需要一个管理线程的工具----线程池应运而生。</p><p>在 Java 5 之后，并发编程引入了一堆新的启动、调度和管理线程的API。Executor 框架便是 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用 Executor 在构造器中。</p><h4 id="1-executor简介"><a class="markdownIt-Anchor" href="#1-executor简介"></a> 1 Executor简介</h4><p>我们先看一下Execotor框架的体系：</p><p><img src="http://i.imgur.com/CIzy36s.png" alt=""></p><p>Executor: 所有线程池的接口,只有一个方法。</p><pre><code>void execute(Runnable command);</code></pre><p><strong>ExecutorService</strong>: 增加Executor的行为，是Executor实现类的最直接接口。</p><p><strong>AbstractExecutorService</strong>：AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。</p><p><strong>ScheduledExecutorService</strong>：ScheduledExecutorService是一个接口，它继承于ExecutorService。它相当于提供了&quot;延时&quot;和&quot;周期执行&quot;功能的ExecutorService。ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。</p><p><strong>ForkJoinPool</strong> ：ForkJoinPool 是 Java SE 7 新功能“分叉/结合框架”的核心类，专用于需要将一个任务不断分解成子任务（分叉），再不断进行汇总得到最终结果（结合）的计算过程。比起传统的线程池类ThreadPoolExecutor，ForkJoinPool 实现了工作窃取算法，使得空闲线程能够主动分担从别的线程分解出来的子任务，从而让所有的线程都尽可能处于饱满的工作状态，提高执行效率。</p><p><strong>ScheduledThreadPoolExecutor</strong>：ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了&quot;延时&quot;和&quot;周期执行&quot;功能的ScheduledExecutorService。ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。</p><p><strong>Executors</strong>：Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。</p><p><strong>ThreadPoolExecutor</strong>：线程池的具体实现类,一般用的各种线程池都是基于这个类实现的。</p><p>构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><p>corePoolSize - 池中所保存的线程数，包括空闲线程。</p><p>maximumPoolSize - 池中允许的最大线程数。</p><p>keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</p><p>unit - keepAliveTime 参数的时间单位。</p><p>workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。</p><p>该方法作用为：用给定的初始参数和默认的线程工厂及被拒绝的执行处理程序创建新的 ThreadPoolExecutor。但是使用 Executors 工厂方法比使用此通用构造方法方便得多。（所以一般不用这个方法）</p><p><strong>由该方法我们可以看出一般线程池的工作方式为：</strong></p><p>①线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p><p>②当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><p>⒈如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p><p>⒉如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p><p>⒊如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p><p>⒋如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</p><p>⒌当一个线程完成任务时，它会从队列中取下一个任务来执行。</p><p>⒍当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><h4 id="2-线程池"><a class="markdownIt-Anchor" href="#2-线程池"></a> 2 线程池</h4><h5 id="21-线程池的作用"><a class="markdownIt-Anchor" href="#21-线程池的作用"></a> 2.1 线程池的作用：</h5><p>线程池作用就是限制系统中执行线程的数量。</p><p>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。</p><h5 id="22-为什么要用线程池"><a class="markdownIt-Anchor" href="#22-为什么要用线程池"></a> 2.2 为什么要用线程池:</h5><p>1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p><p>2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。<br><strong>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService</strong>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p><p>1.<strong>newSingleThreadExecutor</strong></p><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>2.<strong>newFixedThreadPool</strong></p><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><p>3.<strong>newCachedThreadPool</strong></p><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，<br>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p><p>4.<strong>newScheduledThreadPool</strong><br>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><p>下节我们分别介绍这些工厂类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好的软件设计不建议手动创建和销毁线程。线程的创建和销毁是非常耗 CPU 和内存的，因为这需要 JVM 和操作系统的参与。64位 JVM 默认线程栈是大小1 MB。这就是为什么说在请求频繁时为每个小的请求创建线程是一种资源的浪费。线程池可以根据创建时选择的策略自动处理线程的生
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十三）----(JUC原子类)引用类型介绍（CAS和ABA的介绍）</title>
    <link href="http://blog.rickiyang.cn/posts/579efe75.html"/>
    <id>http://blog.rickiyang.cn/posts/579efe75.html</id>
    <published>2017-03-25T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.166Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们将探讨引用类型原子类：AtomicReference, AtomicStampedRerence, AtomicMarkableReference。AtomicReference的使用非常简单，根据API我们就可以知道如何用，但是后两个从名字上看起来感觉是很难的样子，其实只是他的样子长得有点吓人，并且确实发挥了很大的作用（解决了ABA问题）。所以并没有那么可怕，就让我们一起来克服困难吧。</p><h4 id="1-atomicreference简介"><a class="markdownIt-Anchor" href="#1-atomicreference简介"></a> 1 AtomicReference简介</h4><p>AtomicReference的使用非常简单，首先我们来看一下他的方法：</p><pre><code>构造函数：AtomicReference()               //使用 null 初始值创建新的 AtomicReference。 AtomicReference(V initialValue) //使用给定的初始值创建新的 AtomicReference。 方法：boolean compareAndSet(V expect, V update) //如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 V get()                        //获取当前值。 V getAndSet(V newValue)        //以原子方式设置为给定值，并返回旧值。 void lazySet(V newValue)       //最终设置为给定值。 void set(V newValue)           //设置为给定值。 String toString()              //返回当前值的字符串表示形式。 boolean weakCompareAndSet(V expect, V update) // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 </code></pre><p>下面我们看一个例子来了解下使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference atomic1 = <span class="keyword">new</span> AtomicReference();</span><br><span class="line">        atomic1.set(<span class="string">"aaa"</span>);</span><br><span class="line">        atomic1.set(<span class="keyword">new</span> StringBuffer(<span class="string">"str"</span>));</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"name"</span>,<span class="string">"xiaoming"</span>);</span><br><span class="line">        atomic1.set(map);</span><br><span class="line">        System.out.println(atomic1.get());</span><br><span class="line"></span><br><span class="line">        String[] s = &#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>&#125;;</span><br><span class="line">        AtomicReference atomic2 = <span class="keyword">new</span> AtomicReference(s);</span><br><span class="line">        System.out.println(atomic2.get());</span><br><span class="line">        atomic2.set(atomic1);</span><br><span class="line">        System.out.println(atomic2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>{name=xiaoming}[Ljava.lang.String;@766e119d{name=xiaoming}Process finished with exit code 0</code></pre><p>由上面程序我们可以看到：AtomicReference可以set任何类型的值并且都是以原子的形式操作的。</p><h4 id="2-cas和aba"><a class="markdownIt-Anchor" href="#2-cas和aba"></a> 2 CAS和ABA</h4><p>在介绍AtomicStampedRerence, AtomicMarkableReference之前我们的先谈一谈CAS和ABA的问题，因为这两个类的设计就是为了避免CAS操作中的ABA问题而设计的.</p><h5 id="21-cas-原子操作的基石"><a class="markdownIt-Anchor" href="#21-cas-原子操作的基石"></a> 2.1 CAS 原子操作的基石</h5><p>我们知道之前我们学过的Synchronized是一种独占锁。一个线程获得该锁，那么其余的线程只能等待该线程释放锁才能获得。这其实是一种悲观锁的形式。那么乐观锁是如何实现的呢？乐观锁是每次都不加锁，假设完成某项任务没有冲突。如果因为冲突失败那就重试，直到成功为止。</p><p>今天我们要说的CAS就是<strong>乐观锁的实现机制</strong>。可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><p>CAS:Compare and Swap，这个操作用C语言来描述就是下面这个样子（代码来自Wikipedia的Compare And Swap词条）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval)</span><br><span class="line">     *reg = newval;</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思就是说，看一看内存*reg里的值是不是oldval，如果是的话，则对其赋值newval。</p><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><p>在使用上，通常会记录下某块内存中的旧值，通过对旧值进行一系列的操作后得到新值，然后通过CAS操作将新值与旧值进行交换。如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行 使内存中的数据变为新值。如果内存中的值在这期间内被修改过，则一般来说旧值会与内存中的数据不同，这时CAS操作将会失败，新值将不会被写入内存。</p><h5 id="22-原子操作"><a class="markdownIt-Anchor" href="#22-原子操作"></a> 2.2 原子操作</h5><p>虽然我们是在用java语言去执行原子操作，但是最终还是对应到处理器上去执行。那么在处理器上是如何执行原子操作的呢？</p><p>32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><p><strong>第一个机制是通过总线锁保证原子性。</strong>。如果多个处理器同时对共享变量进行读改写（i<ins>就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致，举个例子：如果i=1,我们进行两次i</ins>操作，我们期望的结果是3，但是有可能结果是2。</p><p>原因是有可能多个处理器同时从各自的缓存中读取变量i，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p><p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。</p><p><strong>第二个机制是通过缓存锁定保证原子性</strong>。在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p><p>上面说了cpu的原子操作是如何实现的，那么在java中一定也有相应的方法去驱动处理器来实现原子操作。JUC包中的原子类都是基于CAS来实现的，我们不妨以AtomicInteger为例来跟踪一下，看看到底是如何实现原子操作的。</p><p>首先我们能看到在AtomicInteger中的value值是这样定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>我们再来看他的get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回value值，说明在无锁的情况下，通过volatile来做控制，保证值是可见的。</p><p>下面我们接着看一下i++在原子类中是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, newValue))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到，首先把volatile修饰的内存中的原始值赋值给当前变量，为了下面compareAndSet方法拿内存中的值和新值比较进行CAS操作。所以关键就在于这个compareAndSet（）方法，我们接着进入这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到compareAndSet方法中返回的是unsafe类的方法，我们知道java不能直接访问操作系统底层，而是通过本地方法来访问。<strong>Unsafe类提供了硬件级别的原子操作</strong>，这就与硬件相挂钩了。由此我们从java到处理器的通道就打通了。</p><p>具体的compareAndSwapInt()方法的实现属于JDK底层的实现，我们在此不多做说明，有兴趣的可以查阅相关资料，看java的底层c语言源码。大致的过程我们可以说明如下：CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Java并发包(java.util.concurrent)中大量使用了CAS操作,<strong>涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作</strong>。</p><h5 id="23-aba问题"><a class="markdownIt-Anchor" href="#23-aba问题"></a> 2.3 ABA问题</h5><p>上面我们结合着处理器对原子操作的处理机制一起讲了java对原子操作的处理方式，那么难道这种方式就一定是完美的吗。下面我们举出一种情况大家分析看看：</p><ol><li>进程P1在共享变量中读到值为A</li><li>P1被抢占了，进程P2执行</li><li>P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。</li><li>P1回来看到共享变量里的值没有被改变，于是继续执行。</li></ol><p>你觉得这会出现什么问题呢？我们知道java底层代码都是用c语言实现的，虽然java中没有指针，但不代表java底层代码中没有使用。虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，<strong>因为CAS判断的是指针的地址</strong>（c语言的特性）。如果这个地址被重用了呢，问题就很大了。</p><p>现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B:</p><p><img src="http://i.imgur.com/WHz1hpa.png" alt=""></p><p>在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A，此时堆栈结构如下图，而对象B此时已经出栈：</p><p><img src="http://i.imgur.com/JHnfHNT.png" alt=""></p><p>在CAS中c语言的堆栈实现过程大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">push(node):</span><br><span class="line"> curr := head</span><br><span class="line">  old := curr</span><br><span class="line">  node-&gt;next = curr</span><br><span class="line">  <span class="keyword">while</span> (old != (curr = CAS(&amp;head, curr, node))) &#123;</span><br><span class="line">      old = curr</span><br><span class="line">      node-&gt;next = curr</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">pop():</span><br><span class="line">   curr := head</span><br><span class="line">   old := curr</span><br><span class="line">   next = curr-&gt;next</span><br><span class="line">   <span class="keyword">while</span> (old != (curr = CAS(&amp;head, curr, next))) &#123;</span><br><span class="line">       old = curr</span><br><span class="line">       next = curr-&gt;next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure><p>假如，在pop函数中，next = curr-&gt;next 和 while之间，线程被切换走，此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，<strong>但实际上B.next为null，即while此时还没有执行呢</strong>，所以此时的情况变为：</p><p><img src="http://i.imgur.com/ANevGLg.png" alt=""></p><p>其中堆栈中只有B元素的引用地址，C和D组成的链表不再存在于堆栈中，平白无故就把C、D丢掉了。</p><p>如果这个例子你没有看懂的话，我可以再举出一个生活中的例子：</p><p><em>你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。</em></p><p>以上就是ABA问题。</p><h4 id="3-解决aba问题之道"><a class="markdownIt-Anchor" href="#3-解决aba问题之道"></a> 3 解决ABA问题之道</h4><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。<strong>ABA问题的解决思路就是使用版本号</strong>。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 为了避免CAS过程中的ABA问题，并发包提供了两个类，AtomicStampedReference和AtomicMarkableReference。前者相当于一个[引用,integer]的二元组，后者相当于一个[引用,boolean]的二元组。<br>AtomicStampedReference可用来作为带版本号的原子引用，而AtomicMarkableReference可用于表示已删除的节点。</p><p>这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>我们先来看一下AtomicStampedReference的方法，AtomicStampedReference 维护带有整数“标志”的对象引用，可以用原子方式对其进行更新：</p><pre><code>构造方法：AtomicStampedReference(V initialRef, int initialStamp) //创建具有给定初始值的新 AtomicStampedReference方法： boolean attemptStamp(V expectedReference, int newStamp) //如果当前引用 == 预期引用，则以原子方式将该标志的值设置为给定的更新值。 boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) //如果当前引用 == 预期引用，并且当前标志等于预期标志，则以原子方式将该引用和该标志的值设置为给定的更新值。 V get(int[] stampHolder)   //返回该引用和该标志的当前值。 V getReference()           //返回该引用的当前值。 int getStamp()             // 返回该标志的当前值。 void set(V newReference, int newStamp) // 无条件地同时设置该引用和标志的值。 boolean weakCompareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) //如果当前引用 == 预期引用，并且当前标志等于预期标志，则以原子方式将该引用和该标志的值设置为给定的更新值。</code></pre><p>看来看一下AtomicMarkableReference的方法：</p><p>构造方法：<br>AtomicMarkableReference(V initialRef, boolean initialMark) //创建具有给定初始值的新 AtomicMarkableReference。</p><p>方法：<br>boolean attemptMark(V expectedReference, boolean newMark) //如果当前引用 == 预期引用，则以原子方式将该标记的值设置为给定的更新值。<br>boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) //如果当前引用 == 预期引用，并且当前标记等于预期标记，那么以原子方式将引用和标记的值设置为给定的更新值。<br>V get(boolean[] markHolder) // 返回该引用和该标记的当前值。<br>V getReference() //返回该引用的当前值。<br>boolean isMarked() //返回该标记的当前值。<br>void set(V newReference, boolean newMark) //无条件地同时设置该引用和标记的值。<br>boolean weakCompareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) //如果当前引用 == 预期引用，并且当前标记等于预期标记，那么以原子方式将引用和标记的值设置为给定的更新值。</p><p>AtomicMarkableReference类描述的一个(Object,Boolean)的对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。</p><p>AtomicStampedReference类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比AtomicMarkableReference类的(Object,Boolean)，AtomicStampedReference维护的是一种类似(Object,int)的数据结构，其实就是对对象（引用）的一个并发计数。但是与AtomicInteger不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。</p><p>下面我们就AtomicStampedReference 的使用举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInt = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">        atomicInt.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">        atomicInt.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"new value = "</span> + atomicInt.get());</span><br><span class="line">        <span class="keyword">boolean</span> result1 = atomicInt.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">        System.out.println(result1); <span class="comment">// result:true</span></span><br><span class="line"></span><br><span class="line">        AtomicInteger v1 = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">        AtomicInteger v2 = <span class="keyword">new</span> AtomicInteger(<span class="number">101</span>);</span><br><span class="line">        AtomicStampedReference&lt;AtomicInteger&gt; stampedRef = <span class="keyword">new</span> AtomicStampedReference&lt;AtomicInteger&gt;(v1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> stamp = stampedRef.getStamp();</span><br><span class="line">        stampedRef.compareAndSet(v1, v2, stampedRef.getStamp(),</span><br><span class="line">                stampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(stampedRef.getStamp());</span><br><span class="line">        stampedRef.compareAndSet(v2, v1, stampedRef.getStamp(),</span><br><span class="line">                stampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"new value = "</span> + stampedRef.getReference());</span><br><span class="line">        <span class="keyword">boolean</span> result2 = stampedRef.compareAndSet(v1, v2, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">        System.out.println(result2); <span class="comment">// result:false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre><code>new value = 100true1new value = 100falseProcess finished with exit code 0</code></pre><p>上面的输出结果可以看到AtomicInteger 执行cas操作成功，AtomicStampedReference执行cas操作失败。我们可以看到在24行compareAndSet(v1, v2, stamp, stamp + 1)中第三个参数期待的标志位值为1，但是经过上面两次的值变更，stampedRef.getStamp()已经是2了，所以此刻期待值与内存中的标志位值不符，操作失败。</p><p>AtomicMarkableReference的使用方法也是类似，在此就不另做介绍，大家可以多多使用才会知道这些类所带来的好处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们将探讨引用类型原子类：AtomicReference, AtomicStampedRerence, AtomicMarkableReference。AtomicReference的使用非常简单，根据API我们就可以知道如何用，但是后两个从名字上看起来感觉是很难的样
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十四）----(JUC原子类)对象的属性修改类型介绍</title>
    <link href="http://blog.rickiyang.cn/posts/58721c94.html"/>
    <id>http://blog.rickiyang.cn/posts/58721c94.html</id>
    <published>2017-03-25T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.141Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们介绍原子类的最后一个类型----对象的属性修改类型: AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicReferenceFieldUpdater。有了这几个方法，普通的变量也能享受原子操作了。</p><h4 id="1-开胃菜"><a class="markdownIt-Anchor" href="#1-开胃菜"></a> 1 开胃菜</h4><p>由API我们知道AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater通过反射原子更新对象的字段,既然他们的作用是更新字段我们知道有些类型的字段是不可被更新的，所以被更新的字段是有一定的要求：</p><p style="color:red">1. 必须是volatile类型（volatile是线程可见变量，保存在Jvm的主内存中，而不是线程的工作内存里面），<br>2. 字段的描述类型（修饰符public/protected/default/private）是调用者与操作对象字段的关系一致，<br>3. 只能是实例变量，不能是类变量，也就是说不能加static关键字，<br>4. 只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在，<br>5. 对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</p><h4 id="2-使用它"><a class="markdownIt-Anchor" href="#2-使用它"></a> 2 使用它</h4><p>上面我们说了这几个类的作用是让普通类型的字段也能享受到原子操作，假如原本有一个变量是int型，并且很多地方都应用了这个变量，但是在某个场景下，想让int型变成AtomicInteger，但是如果直接改类型，就要改其他地方的应用。AtomicIntegerFieldUpdater就是为了解决这样的问题产生的。</p><p>AtomicIntegerFieldUpdater，AtomicLongFieldUpdater分别是对int和long类型的字段操作，AtomicReferenceFieldUpdater是对引用型的对象操作，并且在API中他们的操作方法与普通的AtomicInteger差不多，所以方法我就不再罗列，我们就直接使用吧。</p><p>我们来看AtomicIntegerFieldUpdater的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* allscore 如果和 score 的结果相同则说明线程是安全的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AA&gt; vv = AtomicIntegerFieldUpdater.newUpdater(AA.class, <span class="string">"score"</span>); <span class="comment">//newUpdater方法为AA类中的score 对象创造一个更新器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger allscore = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AA stu = <span class="keyword">new</span> AA();</span><br><span class="line">        Thread[] t = <span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i] = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Math.random()&gt;<span class="number">0.4</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        vv.incrementAndGet(stu);</span><br><span class="line">                        allscore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"score="</span>+stu.getScore());</span><br><span class="line">        System.out.println(<span class="string">"allscore="</span>+allscore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>score=6032allscore=6032</code></pre><p>AtomicIntegerFieldUpdater包装过的int类型的score与 AtomicInteger 的allscore输出的值是一样的，足以见他们所起到的作用是一样。</p><p>我们说了AtomicIntegerFieldUpdater,那么AtomicLongFieldUpdater与它的用法大同小异，就不再说明。我们说这几个类是基于反射的实用工具，那么到底是怎么个反射法呢，我们不妨看看源码体验一下，上面用到了AtomicIntegerFieldUpdater.newUpdater()方法来指定类中的字段，我们不妨看看这个newUpdater是怎么执行的：</p><p>newUpdater（）方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass, String fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;(tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在newUpdater方法上有一个注解：@CallerSensitive，关于这个注解我们可以探究一天的，暂时先埋一个伏笔哈，我们直接跟进去AtomicIntegerFieldUpdaterImpl方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AtomicIntegerFieldUpdaterImpl(Class&lt;T&gt; tclass, String fieldName, Class&lt;?&gt; caller) &#123;</span><br><span class="line">    Field field = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> modifiers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        field = tclass.getDeclaredField(fieldName);</span><br><span class="line">        modifiers = field.getModifiers();</span><br><span class="line">        sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">            caller, tclass, <span class="keyword">null</span>, modifiers);</span><br><span class="line">        sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class fieldt = field.getType();</span><br><span class="line">    <span class="keyword">if</span> (fieldt != <span class="keyword">int</span>.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be integer type"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be volatile type"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                   caller != tclass) ? caller : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.tclass = tclass;</span><br><span class="line">    offset = unsafe.objectFieldOffset(field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能看到该类里面都是我们常见到的反射的机制，除了sun.reflect.misc.ReflectUtil这个包里面的我们没用到以外。</p><p>我们再看一下AtomicReferenceFieldUpdater的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         TestAA testAA = <span class="keyword">new</span> TestAA(<span class="string">"xiaoming"</span>,<span class="string">"nv"</span>,<span class="number">12</span>);</span><br><span class="line">         AtomicReferenceFieldUpdater Updater = AtomicReferenceFieldUpdater.newUpdater(TestAA.class,String.class,<span class="string">"name"</span>)；</span><br><span class="line">         Updater.compareAndSet(testAA,testAA.name,<span class="string">"liming"</span>);</span><br><span class="line">         System.out.println(testAA.getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAA</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="keyword">volatile</span> String sex;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestAA</span><span class="params">(String name, String sex, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>limingProcess finished with exit code 0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们介绍原子类的最后一个类型----对象的属性修改类型: AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicReferenceFieldUpdater。有了这几个方法，普通的变量也能享受原子操作了。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十二）----(JUC原子类)数组类型介绍</title>
    <link href="http://blog.rickiyang.cn/posts/f9388b3f.html"/>
    <id>http://blog.rickiyang.cn/posts/f9388b3f.html</id>
    <published>2017-03-25T04:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.140Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们介绍过三个基本类型的原子类，这次我们来看一下数组类型： AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray。其中前两个的使用方式差不多，AtomicReferenceArray因为他的参数为引用数组，所以跟前两个的使用方式有所不同。</p><h4 id="1-atomiclongarray介绍"><a class="markdownIt-Anchor" href="#1-atomiclongarray介绍"></a> 1 AtomicLongArray介绍</h4><p>对于AtomicLongArray, AtomicIntegerArray我们还是只介绍一个，另一个使用方式大同小异。</p><p>我们先来看看AtomicLongArray的构造函数和方法：</p><pre><code>构造函数：AtomicLongArray(int length) //创建给定长度的新 AtomicLongArray。 AtomicLongArray(long[] array) //创建与给定数组具有相同长度的新 AtomicLongArray，并从给定数组复制其所有元素。 方法： long addAndGet(int i, long delta) //以原子方式将给定值添加到索引 i 的元素。  boolean compareAndSet(int i, long expect, long update) //如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。  long decrementAndGet(int i)       //以原子方式将索引 i 的元素减1。  long get(int i)                   //获取位置 i 的当前值。  long getAndAdd(int i, long delta) //以原子方式将给定值与索引 i 的元素相加。  long getAndDecrement(int i)       //以原子方式将索引 i 的元素减 1。  long getAndIncrement(int i)       //以原子方式将索引 i 的元素加 1。  long getAndSet(int i, long newValue) //以原子方式将位置 i 的元素设置为给定值，并返回旧值。  long incrementAndGet(int i)       // 以原子方式将索引 i 的元素加1。  void lazySet(int i, long newValue)// 最终将位置 i 的元素设置为给定值。  int length()                      //返回该数组的长度。  void set(int i, long newValue)    //将位置 i 的元素设置为给定值。  String toString()                 //返回数组当前值的字符串表示形式。 </code></pre><h4 id="2-使用方式"><a class="markdownIt-Anchor" href="#2-使用方式"></a> 2 使用方式：</h4><p>我们可以发现AtomicLongArray的使用方式和上一篇介绍的基本类型的原子类差不多，无非是换成了数组类型，另外方法里面的etAndAdd与ncrementAndGet我们要注意使用方式。</p><h4 id="3-atomicreferencearray介绍"><a class="markdownIt-Anchor" href="#3-atomicreferencearray介绍"></a> 3 AtomicReferenceArray介绍</h4><p>我们来看一下他的方法：<br>构造方法：</p><pre><code>AtomicReferenceArray(E[] array) //创建与给定数组具有相同长度的新 AtomicReferenceArray，并从给定数组复制其所有元素。 AtomicReferenceArray(int length) // 创建给定长度的新 AtomicReferenceArray。 方法:boolean compareAndSet(int i, E expect, E update) //如果当前值 == 预期值，则以原子方式将位置 i 的元素设置为给定的更新值。  E get(int i)                    //获取位置 i 的当前值。  E getAndSet(int i, E newValue)  // 以原子方式将位置 i 的元素设置为给定值，并返回旧值。  void lazySet(int i, E newValue) //最终将位置 i 的元素设置为给定值。  int length()                    //返回该数组的长度。  void set(int i, E newValue)     // 将位置 i 的元素设置为给定值。  String toString()               //返回数组当前值的字符串表示形式。  boolean weakCompareAndSet(int i, E expect, E update) // 如果当前值 == 预期值，则以原子方式将位置 i 的元素设置为给定的更新值。 </code></pre><p>由上我们可以看到AtomicReferenceArray与前两个的方法相比少了很多。</p><p>下面我们通过一个小例子来看一下他的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Long[] l = <span class="keyword">new</span> Long[<span class="number">4</span>];</span><br><span class="line">        String[] s = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        Integer[] in = <span class="keyword">new</span> Integer[<span class="number">4</span>];</span><br><span class="line">        AtomicReferenceArray atomicReferenceArray = <span class="keyword">new</span> AtomicReferenceArray(l);</span><br><span class="line">        System.out.println(atomicReferenceArray.length());</span><br><span class="line">        System.out.println(atomicReferenceArray.get(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        AtomicReferenceArray atomic = <span class="keyword">new</span> AtomicReferenceArray(<span class="number">4</span>);</span><br><span class="line">        atomic.set(<span class="number">0</span>,<span class="number">432141</span>);</span><br><span class="line">        atomic.set(<span class="number">2</span>,<span class="string">"fsafefeq"</span>);</span><br><span class="line">        atomic.set(<span class="number">3</span>,i);</span><br><span class="line">        System.out.println(atomic.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre><code>exclude patterns:4null[432141, null, fsafefeq, [I@357b2b99]Process finished with exit code 0</code></pre><p>说明：<br>1.当我们使用AtomicReferenceArray(E[] array)这个构造方法传入一个数组对象时，该数组对象必须是引用类型，int[]不可以，但是Integer[]的可以。<br>2.当我们使用AtomicReferenceArray(int length)这个构造函数的时候，只要为他指定了数组大小之后，你为数组的每一位设置什么值是没有要求的，类似于Map的形式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们介绍过三个基本类型的原子类，这次我们来看一下数组类型： AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray。其中前两个的使用方式差不多，AtomicReferenceArray因为他的参数为引用数组，
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十一）----(JUC原子类)基本类型介绍</title>
    <link href="http://blog.rickiyang.cn/posts/8ca24763.html"/>
    <id>http://blog.rickiyang.cn/posts/8ca24763.html</id>
    <published>2017-03-24T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.140Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们说到了基本原子类的简单介绍，这一节我们先来看一下基本类型: AtomicInteger, AtomicLong, AtomicBoolean。AtomicInteger和AtomicLong的使用方法差不多，AtomicBoolean因为比较简单所以方法比前两个都少，那我们这节主要挑AtomicLong来说，会使用一个，其余的大同小异。</p><h4 id="1-原子操作与一般操作异同"><a class="markdownIt-Anchor" href="#1-原子操作与一般操作异同"></a> 1 原子操作与一般操作异同</h4><p>我们在说原子操作之前为了有个对比为什么需要这些原子类而不是普通的基本数据类型就能满足我们的使用要求，那就不得不提原子操作不同的地方。</p><p>当你在操作一个普通变量时，你在Java实现的每个操作，在程序编译时会被转换成几个机器能读懂的指令。例如，当你分配一个值给变量，在Java你只使用了一个指令，但是当你编译这个程序时，这个指令就被转换成多个JVM 语言指令。这样子的话当你在操作多个线程且共享一个变量时，就会导致数据不一致的错误。</p><p>为了避免这样的问题，Java引入了原子变量。当一个线程正在操作一个原子变量时，即使其他线程也想要操作这个变量，类的实现中含有一个检查那步骤操作是否完成的机制。 基本上，操作获取变量的值，改变本地变量值，然后尝试以新值代替旧值。如果旧值还是一样，那么就改变它。如果不一样，方法再次开始操作。这个操作称为 Compare and Set（简称CAS，比较并交换的意思）。</p><p>原子变量不使用任何锁或者其他同步机制来保护它们的值的访问。他们的全部操作都是基于CAS操作。它保证几个线程可以同时操作一个原子对象也不会出现数据不一致的错误，并且它的性能比使用受同步机制保护的正常变量要好。</p><h4 id="2-atomiclong简介"><a class="markdownIt-Anchor" href="#2-atomiclong简介"></a> 2 AtomicLong简介</h4><p>由字面意义我们可以知道AtomicLong可以用原子方式更新的 long 值，下面我们看一下他的构造方法和一般方法：</p><pre><code>构造方法：AtomicLong()                  //创建具有初始值 0 的新 AtomicLong。 AtomicLong(long initialValue) //创建具有给定初始值的新 AtomicLong。 方法： long addAndGet(long delta)   //以原子方式将给定值添加到当前值。  boolean compareAndSet(long expect, long update) //如果当前值 == 预期值，则以原子方式将该值                                                   设置为给定的更新值。  long decrementAndGet()       //以原子方式将当前值减 1。  double doubleValue()         //以 double 形式返回指定的数值。  float floatValue()           //以 float 形式返回指定的数值。  long get()                   //获取当前值。  long getAndAdd(long delta)   //以原子方式将给定值添加到当前值。  long getAndDecrement()       //以原子方式将当前值减 1。  long getAndIncrement()       //以原子方式将当前值加 1。  long getAndSet(long newValue)// 以原子方式设置为给定值，并返回旧值。  long incrementAndGet()       //以原子方式将当前值加 1。  int intValue()               // 以 int 形式返回指定的数值。  void lazySet(long newValue)  //最后设置为给定值。  long longValue()             // 以 long 形式返回指定的数值。  void set(long newValue)      //设置为给定值。  String toString()            // 返回当前值的字符串表示形式。  boolean weakCompareAndSet(long expect, long update) //如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 </code></pre><h4 id="3-使用atomiclong"><a class="markdownIt-Anchor" href="#3-使用atomiclong"></a> 3 使用AtomicLong</h4><h5 id="31-创建atomiclong"><a class="markdownIt-Anchor" href="#31-创建atomiclong"></a> 3.1 创建AtomicLong</h5><p>创建AtomicLong的过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（）;</span><br></pre></td></tr></table></figure><p>此示例创建一个初始值为0的AtomicLong 。</p><p>如果你想创建一个带有初始值的AtomicLong ，你可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（<span class="number">123</span>）;</span><br></pre></td></tr></table></figure><p>此示例将值123作为参数传递给AtomicLong装订器，该装置将AtomicLong实例的初始值设置为123 。</p><h5 id="32-获取atomiclong值"><a class="markdownIt-Anchor" href="#32-获取atomiclong值"></a> 3.2 获取AtomicLong值</h5><p>您可以通过get()方法get() AtomicLong实例的值。 这里是一个AtomicLong.get()示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（<span class="number">123</span>）;</span><br><span class="line"><span class="keyword">long</span> theValue = atomicLong.get（）;</span><br></pre></td></tr></table></figure><p>设置AtomicLong值</p><p>您可以通过set()方法set() AtomicLong实例的值。 这里是一个AtomicLong.set()示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（<span class="number">123</span>）;</span><br><span class="line">  </span><br><span class="line">atomicLong.set（<span class="number">234</span>）;</span><br></pre></td></tr></table></figure><p>此示例创建一个初始值为123的AtomicLong示例，然后在下一行中将其值设置为234 。</p><h5 id="33-比较并设置atomiclong值"><a class="markdownIt-Anchor" href="#33-比较并设置atomiclong值"></a> 3.3 比较并设置AtomicLong值</h5><p>AtomicLong类也有一个原子compareAndSet()方法。 此方法将AtomicLong实例的当前值与AtomicLong进行比较，如果这两个值相等， AtomicLong实例设置新值。 这里是一个AtomicLong.compareAndSet()示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（<span class="number">123</span>）;</span><br><span class="line"><span class="keyword">long</span> expectedValue = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">long</span> newValue = <span class="number">234</span>;</span><br><span class="line">atomicLong.compareAndSet（expectedValue，newValue）;</span><br></pre></td></tr></table></figure><p>此示例首先创建一个初始值为123的AtomicLong实例。 然后，它将AtomicLong的值与期望值123进行比较，如果它们相等，则AtomicLong的新值变为234 ;</p><h5 id="34-添加到atomiclong值"><a class="markdownIt-Anchor" href="#34-添加到atomiclong值"></a> 3.4 <strong>添加到AtomicLong值</strong></h5><p>AtomicLong类包含几个方法，您可以使用这些方法向AtomicLong添加值并返回其值。<strong>这里我们要重点关注一下，因为这几个方法会如果我们使用不当会造成歧义</strong>。 这些方法是：</p><pre><code>addAndGet()getAndAdd()getAndIncrement()incrementAndGet()</code></pre><ul><li>第一种方法addAndGet()向AtomicLong添加一个数字，并在添加后返回其值。</li><li>第二种方法getAndAdd()还向AtomicLong添加一个数字，但返回AtomicLong在添加值之前的值。</li></ul><p>您应该使用这两种方法中的哪一种取决于您的用例。 这里有两个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（）;</span><br><span class="line">System.out.println（atomicLong.getAndAdd（<span class="number">10</span>））;</span><br><span class="line">System.out.println（atomicLong.addAndGet（<span class="number">10</span>））;</span><br></pre></td></tr></table></figure><p>此示例将打印出值0和20 。 首先，示例在添加10之前获取AtomicLong的值。 它的值在加法之前为0.然后示例将10添加到AtomicLong ，并获取添加后的值。 该值现在为20。</p><p><strong>您也可以通过这两种方法向AtomicLong添加负数。 结果实际上是一个减法。</strong></p><p>方法getAndIncrement()和incrementAndGet()工作原理像getAndAdd()和addAndGet()但只是添加1到AtomicLong的值。</p><h5 id="35-从atomiclong值中减去"><a class="markdownIt-Anchor" href="#35-从atomiclong值中减去"></a> 3.5 从AtomicLong值中减去</h5><p>AtomicLong类还包含一些用于从AtomicLong值中以AtomicLong值的方法。 这些方法是：</p><pre><code>decrementAndGet()getAndDecrement()</code></pre><p>decrementAndGet()从AtomicLong值中减去1，并在AtomicLong后返回其值。 getAndDecrement()也从AtomicLong值中减去1，但返回AtomicLong在AtomicLong之前的值。</p><p>由上我们大致知道了AtomicLong的用法，AtomicBoolean，AtomicInteger也与它的用法差不多，我们看一下API他们各自的方法就知道该如何使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们说到了基本原子类的简单介绍，这一节我们先来看一下基本类型: AtomicInteger, AtomicLong, AtomicBoolean。AtomicInteger和AtomicLong的使用方法差不多，AtomicBoolean因为比较简单所以方法比前两个都
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十）----JUC原子类介绍</title>
    <link href="http://blog.rickiyang.cn/posts/db147845.html"/>
    <id>http://blog.rickiyang.cn/posts/db147845.html</id>
    <published>2017-03-23T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.139Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来看一下JUC包中的原子类，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程），原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分。将整个操作视作一个整体是原子性的核心特征。</p><p><img src="http://i.imgur.com/1cgiAcM.png" alt=""></p><p>在atomic包中的这些原子类我们可以大致给他分类为：</p><ol><li>基本类型: AtomicInteger, AtomicLong, AtomicBoolean ;</li><li>数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ;</li><li>引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ;</li><li>对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。</li></ol><p>下一节我们详细的分析这些原子类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来看一下JUC包中的原子类，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程），原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（九）----(JUC)CyclicBarrier</title>
    <link href="http://blog.rickiyang.cn/posts/f5e73779.html"/>
    <id>http://blog.rickiyang.cn/posts/f5e73779.html</id>
    <published>2017-03-21T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.143Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们介绍了CountDownlatch，我们知道CountDownlatch是“在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待”，即CountDownLatch的作用是允许1或N个线程等待其他线程完成执行，而我们今天要介绍的CyclicBarrier则是允许N个线程相互等待。</p><h4 id="1-cyclicbarrier简介"><a class="markdownIt-Anchor" href="#1-cyclicbarrier简介"></a> 1 CyclicBarrier简介</h4><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。   在JDK中对CyclicBarrier是这样说的“允许一组线程全部等待彼此到达公共屏障点的同步辅助。 循环障碍在涉及必须偶尔彼此等待的固定大小的线程程序中是有用的。屏障称为循环 ，因为它可以在等待线程释放后重新使用”。CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</p><p>我们先来看一下他的构造方法和使用方式：</p><pre><code>构造函数：CyclicBarrier(int parties) //其参数表示屏障拦截的线程数量，每个线程调用await方法告                             诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。CyclicBarrier (int parties, Runnable barrierAction) //创建一个新的CyclicBarrier ，                            当给定数量的参与者（线程）等待它时，它将跳闸，当障碍跳闸时，它                            将执行 给定的障碍动作(Runnable参数提供)，由最后一个线程进入障碍。方法：int await()   //在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。                  方法之前将一直等待,或者超出了指定的等待时间。int getNumberWaiting()  //返回当前在屏障处等待的参与者数目。    int getParties()        //返回要求启动此 barrier 的参与者数目。boolean isBroken()      //查询此屏障是否处于损坏状态。void reset()            //将屏障重置为其初始状态。</code></pre><p>下面我们来看一个小程序了解一下CyclicBarrier的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在等待..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在等待..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"人够了，出发吧 当前有 "</span>+c.getParties()+<span class="string">" 个人参与比赛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre><code>Thread-0正在等待...main正在等待...人够了，出发吧 当前有 2 个人参与比赛Process finished with exit code 0</code></pre><p>在上面程序中如果我们把&quot;static CyclicBarrier c = new CyclicBarrier(2);&quot;中的参数2修改为3的话改程序中的线程Thread-0和main则会一直等待下去，因为CyclicBarrier是让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，而这最后一个线程迟迟不来，所以屏障也不会被打开。</p><p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。我们来看一下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>,<span class="keyword">new</span> PrioExecut());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在等待..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在等待..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"人够了，出发吧 当前有 "</span>+c.getParties()+<span class="string">" 个人参与比赛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioExecut</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我会先跑5秒，不管你信不信！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><pre><code>我会先跑5秒，不管你信不信！Thread-0正在等待...main正在等待...人够了，出发吧 当前有 2 个人参与比赛Process finished with exit code 0</code></pre><p>我们可以看到构造方法中的参数：new PrioExecut()中的线程会优先执行。</p><h4 id="2-cyclicbarrier的应用场景"><a class="markdownIt-Anchor" href="#2-cyclicbarrier的应用场景"></a> 2 CyclicBarrier的应用场景</h4><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。比如在支付业务中，我们可以按照事先划分好的片区的形式来统计日收支流水，然后根据片区的计算结果，使用Runnable barrierAction来进行汇总这是一个很好的实现。</p><h4 id="3-cyclicbarrier和countdownlatch的区别"><a class="markdownIt-Anchor" href="#3-cyclicbarrier和countdownlatch的区别"></a> 3 CyclicBarrier和CountDownLatch的区别</h4><p>在javadoc里面的描述是这样的：</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><blockquote><p>CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.</p></blockquote><ul><li><p>根据我的理解：对于CountDownLatch来说，重点是那个“一个线程”, 它在等待其余线程执行完毕他才能执行，而另外那N的线程在把“某个事情”做完之后可以继续等待，可以终止。比如上文说的跑步的例子，只有5位跑步者同时准备好了，裁判才能下令开始跑步；CyclicBarrier强调的是n个线程，大家相互等待，只要有一个没完成，所有人都得等着。</p></li><li><p>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇我们介绍了CountDownlatch，我们知道CountDownlatch是“在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待”，即CountDownLatch的作用是允许1或N个线程等待其他线程完成执行，而我们今天要介绍的CyclicBarri
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（七）----（JUC）ReadWriteLock</title>
    <link href="http://blog.rickiyang.cn/posts/de2aa32e.html"/>
    <id>http://blog.rickiyang.cn/posts/de2aa32e.html</id>
    <published>2017-03-19T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.162Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经分析过JUC包里面的Lock锁，ReentrantLock锁和semaphore信号量机制。Lock锁实现了比synchronized更灵活的锁机制，Reentrantlock是Lock的实现类，是一种可重入锁，都是每次只有一次线程对资源进行处理；semaphore实现了多个线程同时对一个资源的访问；今天我们要讲的ReadWriteLock锁将实现另外一种很重要的功能：读写分离锁。</p><p>假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写，也就是说：<strong>读-读能共存，读-写不能共存，写-写不能共存</strong>。这就需要一个读/写锁来解决这个问题。</p><h4 id="1-readwritelock简介"><a class="markdownIt-Anchor" href="#1-readwritelock简介"></a> 1 ReadWriteLock简介</h4><p>我们在JUC包可以看到ReadWriteLock是一个接口，他有一个实现类：ReentrantReadWriteLock，先让我们对读写访问资源的条件做个概述：</p><pre><code>- 读取： 没有线程正在做写操作，且没有线程在请求写操作。- 写入： 没有线程正在做读写操作。</code></pre><p>如果某个线程想要读取资源，只要没有线程正在对该资源进行写操作且没有线程请求对该资源的写操作即可。同样当有线程想要写资源，但是此刻有线程正在读取资源，那么此刻写资源的操作是不能继续下去的。<br>我们来看一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> ExecutorService exService = Executors.newFixedThreadPool(threadCount);</span><br><span class="line">            <span class="keyword">final</span> ScoreBoard scoreBoard = <span class="keyword">new</span> ScoreBoard();</span><br><span class="line">            exService.execute(<span class="keyword">new</span> ScoreUpdateThread(scoreBoard));</span><br><span class="line">            exService.execute(<span class="keyword">new</span> ScoreHealthThread(scoreBoard));</span><br><span class="line">            exService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreBoard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> scoreUpdated = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    String health = <span class="string">"不可用"</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rrwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMatchHealth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rrwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (scoreUpdated) &#123;</span><br><span class="line">            rrwl.readLock().unlock();</span><br><span class="line">            rrwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (scoreUpdated) &#123;</span><br><span class="line">                    score = fetchScore();</span><br><span class="line">                    scoreUpdated = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rrwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rrwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (score % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                health = <span class="string">"Bad Score"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                health = <span class="string">"Good Score"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rrwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> health;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rrwl.writeLock().lock();</span><br><span class="line">            scoreUpdated = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rrwl.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fetchScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calendar calender = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">return</span> calender.get(Calendar.MILLISECOND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreHealthThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ScoreBoard scoreBoard;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScoreHealthThread</span><span class="params">(ScoreBoard scoreTable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scoreBoard = scoreTable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Match Health: "</span>+ scoreBoard.getMatchHealth());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreUpdateThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ScoreBoard scoreBoard;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScoreUpdateThread</span><span class="params">(ScoreBoard scoreTable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scoreBoard = scoreTable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Score Updated."</span>);</span><br><span class="line">            scoreBoard.updateScore();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><pre><code>Score Updated.Match Health: Good ScoreScore Updated.Match Health: Good ScoreScore Updated.Match Health: Good ScoreScore Updated.Match Health: Good ScoreScore Updated.Match Health: Good Score</code></pre><p>基本用法见上例，读写分离锁很好的控制了多个线程对同一个资源的访问。</p><h4 id="2-reentrantreadwritelock"><a class="markdownIt-Anchor" href="#2-reentrantreadwritelock"></a> 2 ReentrantReadWriteLock</h4><p>由名字我们可以看到读写锁也有可重入的实现类。ReentrantReadWriteLock具有关联的读取和写入锁定，可以重新获取锁定。它可表现为公平和不公平的模式两者。 默认行为是不公平的。 非公平锁的性能更好，虽然有可能读写器或写入器锁可以被推迟许多次，并且持续地尝试锁定。 在公平锁定的情况下，锁定请求按照最长等待的单个写入器锁或读取锁定组请求的顺序来完成，无论谁具有最长等待时间将获得对共享资源的锁定。 在重入ReentrantReadWriteLock可以写入<strong>锁定降级读锁</strong>。 这意味着如果线程已经获得写锁定，它可以将其锁从写降级到读锁。 顺序将是首先获得写锁定，执行写操作，然后获取读锁，然后解锁写锁，并且在读操作后最终解锁读锁。</p><p>ReentrantReadWriteLock 也是基于 AbstractQueuedSynchronizer 实现的，它具有下面这些属性：</p><ul><li>获取顺序</li></ul><p>此类不会将读取者优先或写入者优先强加给锁访问的排序。但是，它确实支持可选的公平 策略。</p><p>1.非公平模式（默认）</p><p>当非公平地（默认）构造时，未指定进入读写锁的顺序，受到 reentrancy 约束的限制。连续竞争的非公平锁可能无限期地推迟一个或多个 reader 或 writer 线程，但吞吐量通常要高于公平锁。</p><p>2.公平模式</p><p>当公平地构造线程时，线程利用一个近似到达顺序的策略来争夺进入。当释放当前保持的锁时，可以为等待时间最长的单个 writer 线程分配写入锁，如果有一组等待时间大于所有正在等待的 writer 线程 的 reader 线程，将为该组分配写入锁。</p><p>如果保持写入锁，或者有一个等待的 writer 线程，则试图获得公平读取锁（非重入地）的线程将会阻塞。直到当前最旧的等待 writer 线程已获得并释放了写入锁之后，该线程才会获得读取锁。当然，如果等待 writer 放弃其等待，而保留一个或更多 reader 线程为队列中带有写入锁自由的时间最长的 waiter，则将为那些 reader 分配读取锁。</p><p>试图获得公平写入锁的（非重入地）的线程将会阻塞，除非读取锁和写入锁都自由（这意味着没有等待线程）。（注意，非阻塞 ReentrantReadWriteLock.ReadLock.tryLock() 和 ReentrantReadWriteLock.WriteLock.tryLock() 方法不会遵守此公平设置，并将获得锁（如果可能），不考虑等待线程）。</p><ul><li>重入</li></ul><p>此锁允许 reader 和 writer 按照 ReentrantLock 的样式重新获取读取锁或写入锁。在写入线程保持的所有写入锁都已经释放后，才允许重入 reader 使用它们。</p><p>此外，writer 可以获取读取锁，但反过来则不成立。在其他应用程序中，当在调用或回调那些在读取锁状态下执行读取操作的方法期间保持写入锁时，重入很有用。如果 reader 试图获取写入锁，那么将永远不会获得成功。</p><ul><li>锁降级</li></ul><p>重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</p><ul><li>锁获取的中断</li></ul><p>读取锁和写入锁都支持锁获取期间的中断。</p><ul><li>Condition 支持</li></ul><p>写入锁提供了一个 Condition 实现，对于写入锁来说，该实现的行为与 ReentrantLock.newCondition() 提供的 Condition 实现对 ReentrantLock 所做的行为相同。当然，此 Condition 只能用于写入锁。读取锁不支持 Condition，readLock().newCondition() 会抛出 UnsupportedOperationException。</p><ul><li>监测</li></ul><p>此类支持一些确定是保持锁还是争用锁的方法。这些方法设计用于监视系统状态，而不是同步控制。</p><p>此类行为的序列化方式与内置锁的相同：反序列化的锁处于解除锁状态，无论序列化该锁时其状态如何。</p><p>下面的代码展示了如何利用重入来执行升级缓存后的锁降级（为简单起见，省略了异常处理）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         rwl.readLock().lock();</span><br><span class="line">         <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 在获得写锁之前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="comment">// Recheck state because another thread might have acquired</span></span><br><span class="line">            <span class="comment">//   write lock and changed state before we did.</span></span><br><span class="line">            <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">              data = ...</span><br><span class="line">              cacheValid = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过在释放写锁之前获得读锁来降级</span></span><br><span class="line">            rwl.readLock().lock();</span><br><span class="line">            rwl.writeLock().unlock(); <span class="comment">// 解锁写锁，但是任然持有读锁</span></span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">        use(data);</span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-与互斥锁对比"><a class="markdownIt-Anchor" href="#3-与互斥锁对比"></a> 3 与互斥锁对比</h4><p>互斥锁一次只允许一个线程访问共享数据，哪怕进行的是只读操作；读写锁允许对共享数据进行更高级别的并发访问：对于写操作，一次只有一个线程（write线程）可以修改共享数据，对于读操作，允许任意数量的线程同时进行读取。</p><p>与互斥锁相比，使用读写锁能否提升性能则取决于读写操作期间读取数据相对于修改数据的频率，以及数据的争用——即在同一时间试图对该数据执行读取或写入操作的线程数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们已经分析过JUC包里面的Lock锁，ReentrantLock锁和semaphore信号量机制。Lock锁实现了比synchronized更灵活的锁机制，Reentrantlock是Lock的实现类，是一种可重入锁，都是每次只有一次线程对资源进行处理；semapho
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（七）----（JUC）ReadWriteLock</title>
    <link href="http://blog.rickiyang.cn/posts/de2aa32e.html"/>
    <id>http://blog.rickiyang.cn/posts/de2aa32e.html</id>
    <published>2017-03-19T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.142Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch 是一个非常实用的多线程控制工具类。&quot; Count Down &quot; 在英文中意为倒计数， Latch 为门问的意思。如果翻译成为倒计数门阀， 我想大家都会觉得不知所云吧! 因此，这里简单地称之为倒计数器。在这里， 门问的含义是:把门锁起来，不让里面的线程跑出来。因此，这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束， 再开始执行。</p><p>CountDown Latch 的构造函数接收一个整数作为参数，即当前这个计数器的计数个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure><p>CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。一个CountDownLatch初始化为给定的计数 。 调用await方法阻塞，直到当前计数为零，在调用countDown()方法之后，所有等待的线程被释放，任何后续调用await立即返回。 这是一次性的现象 - 计数不能重置。 如果需要重置计数，考虑使用CyclicBarrier ，CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</p><p>主要方法：</p><pre><code>// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。void await()// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。boolean await(long timeout, TimeUnit unit)// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。void countDown()// 返回当前计数。long getCount()</code></pre><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNER_NUMBER = <span class="number">5</span>; <span class="comment">// 运动员个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于判断发令之前运动员是否已经完全进入准备状态，需要等待5个运动员，所以参数为5</span></span><br><span class="line">        CountDownLatch readyLatch = <span class="keyword">new</span> CountDownLatch(RUNNER_NUMBER);</span><br><span class="line">        <span class="comment">// 用于判断裁判是否已经发令，只需要等待一个裁判，所以参数为1</span></span><br><span class="line">        CountDownLatch startLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RUNNER_NUMBER; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner((i + <span class="number">1</span>) + <span class="string">"号运动员"</span>, readyLatch, startLatch));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readyLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        startLatch.countDown();</span><br><span class="line">        System.out.println(<span class="string">"裁判：所有运动员准备完毕，开始..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch readyLatch;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch startLatch;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Runner</span><span class="params">(String name, CountDownLatch readyLatch, CountDownLatch startLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.readyLatch = readyLatch;</span><br><span class="line">            <span class="keyword">this</span>.startLatch = startLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readyTime = RANDOM.nextInt(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(name + <span class="string">"：我需要"</span> + readyTime + <span class="string">"秒时间准备."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(readyTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">"：我已经准备完毕."</span>);</span><br><span class="line">            readyLatch.countDown();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startLatch.await();  <span class="comment">// 等待裁判发开始命令</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">"：开跑..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><pre><code>1号运动员：我需要547秒时间准备.2号运动员：我需要281秒时间准备.4号运动员：我需要563秒时间准备.5号运动员：我需要916秒时间准备.3号运动员：我需要461秒时间准备.2号运动员：我已经准备完毕.3号运动员：我已经准备完毕.1号运动员：我已经准备完毕.4号运动员：我已经准备完毕.5号运动员：我已经准备完毕.裁判：所有运动员准备完毕，开始...3号运动员：开跑...2号运动员：开跑...1号运动员：开跑...4号运动员：开跑...5号运动员：开跑...Process finished with exit code 0</code></pre><p>注意：计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CountDownLatch 是一个非常实用的多线程控制工具类。&amp;quot; Count Down &amp;quot; 在英文中意为倒计数， Latch 为门问的意思。如果翻译成为倒计数门阀， 我想大家都会觉得不知所云吧! 因此，这里简单地称之为倒计数器。在这里， 门问的含义是:
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（六）----（JUC）Semaphore</title>
    <link href="http://blog.rickiyang.cn/posts/7afb7337.html"/>
    <id>http://blog.rickiyang.cn/posts/7afb7337.html</id>
    <published>2017-03-19T03:12:00.000Z</published>
    <updated>2018-12-04T09:28:26.141Z</updated>
    
    <content type="html"><![CDATA[<p>Semaphore,从字面意义上我们知道他是信号量的意思。在java中，一个计数信号量维护了一个许可集。Semaphore 只对可用许可的号码进行计数，并采取相应的行动。拿到信号量的线程可以进入代码，否则就等待。通过acquire()和release()获取和释放访问许可。</p><p>信号量Semaphore是一个控制访问多个共享资源的计数器，它本质上是一个“共享锁”。</p><p>Java并发提供了两种加锁模式：共享锁和独占锁。前面介绍的ReentrantLock就是独占锁。对于独占锁而言，它每次只能有一个线程持有，而共享锁则不同，它允许多个线程并行持有锁，并发访问共享资源。</p><p>独占锁它所采用的是一种悲观的加锁策略，  对于写而言为了避免冲突独占是必须的，但是对于读就没有必要了，因为它不会影响数据的一致性。如果某个只读线程获取独占锁，则其他读线程都只能等待了，这种情况下就限制了不必要的并发性，降低了吞吐量。而共享锁则不同，它放宽了加锁的条件，采用了乐观锁机制，它是允许多个读线程同时访问同一个共享资源的。</p><p>举一个生活中的例子，有一条单行道路口有一红绿灯在正常的绿灯时间内如果骑车速度都很平均只能过去20辆车，这就意味着排在前面的20辆肯定能过去红绿灯，后面的就只能等下一个绿灯了。但是如果这个时候有车不想过去这个路口它驶向了边上别的路，那么后面的车就有机会。下面我们来看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> A(<span class="string">"car"</span>+(j++),semaphore),<span class="string">"Thread"</span>+(j++));</span><br><span class="line">            <span class="comment">//new Thread(new A("car"+(j++),semaphore),"Thread"+(j++)).start();</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"最后还有"</span>+semaphore.availablePermits()+<span class="string">"个许可可用"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"最后还有"</span>+semaphore.availablePermits()+<span class="string">"个许可可用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    String carName;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String carName, Semaphore semaphore)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carName = carName;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this car is get the way"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(semaphore.availablePermits() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                getWay();</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"请等待========"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Semaphore,从字面意义上我们知道他是信号量的意思。在java中，一个计数信号量维护了一个许可集。Semaphore 只对可用许可的号码进行计数，并采取相应的行动。拿到信号量的线程可以进入代码，否则就等待。通过acquire()和release()获取和释放访问许可。
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（五）----（JUC）ReentrantLock</title>
    <link href="http://blog.rickiyang.cn/posts/d68e6b33.html"/>
    <id>http://blog.rickiyang.cn/posts/d68e6b33.html</id>
    <published>2017-03-18T17:02:00.000Z</published>
    <updated>2018-12-05T06:13:34.099Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们了解了Lock接口的一些简单的说明，知道Lock锁的常用形式，那么这节我们正式开始进入JUC锁（java.util.concurrent包下的锁，简称JUC锁）。下面我们来看一下Lock最常用的实现类ReentrantLock。</p><h4 id="1-reentrantlock简介"><a class="markdownIt-Anchor" href="#1-reentrantlock简介"></a> 1 ReentrantLock简介</h4><p>由单词意思我们可以知道这是可重入的意思。那么可重入对于锁而言到底意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了 synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的 synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续） synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个 synchronized 块时，才释放锁。</p><h5 id="11-公平锁与非公平锁"><a class="markdownIt-Anchor" href="#11-公平锁与非公平锁"></a> 1.1 公平锁与非公平锁</h5><p>我们查看ReentrantLock的源码可以看到无参构造函数是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync()方法为一个非公平锁的实现方法，另外Reentrantlock还有一个有参的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它允许您选择想要一个 公平（fair）锁，还是一个 不公平（unfair）锁。公平锁使线程按照请求锁的顺序依次获得锁；而不公平锁则允许直接获取锁，在这种情况下，线程有时可以比先请求锁的其他线程先得到锁。</p><p>为什么我们不让所有的锁都公平呢？毕竟，公平是好事，不公平是不好的，不是吗？（当孩子们想要一个决定时，总会叫嚷“这不公平”。我们认为公平非常重要，孩子们也知道。）在现实中，公平保证了锁是非常健壮的锁，有很大的性能成本。要确保公平所需要的记帐（bookkeeping）和同步，就意味着被争夺的公平锁要比不公平锁的吞吐率更低。作为默认设置，应当把公平设置为 false ，除非公平对您的算法至关重要，需要严格按照线程排队的顺序对其进行服务。</p><p>下面我们先来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReentrantLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        set();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestReentrantLock ss = <span class="keyword">new</span> TestReentrantLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(ss).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ss).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ss).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>101012121111Process finished with exit code 0</code></pre><p>由结果我们可以看出同一个线程进入了同一个ReentrantLock锁两次。</p><h4 id="2-condition条件变量"><a class="markdownIt-Anchor" href="#2-condition条件变量"></a> 2 condition条件变量</h4><p>我们知道根类 Object 包含某些特殊的方法，用来在线程的 wait() 、 notify() 和 notifyAll() 之间进行通信。那么为了在对象上 wait 或 notify ，您必须持有该对象的锁。就像 Lock 是同步的概括一样， Lock 框架包含了对 wait 和 notify 的概括，这个概括叫作 条件（Condition）。 Condition 的方法与 wait 、 notify 和 notifyAll 方法类似，分别命名为 await 、 signal 和signalAll ，因为它们不能覆盖 Object 上的对应方法。</p><p>首先我们来计算一道题：<br>我们要打印1到9这9个数字，由A线程先打印1，2，3，然后由B线程打印4,5,6，然后再由A线程打印7，8，9. 这道题有很多种解法，我们先用Object的wait，notify方法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printAndIncrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">"prints "</span> + val);</span><br><span class="line">        val++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print 1,2,3 7,8,9</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (val &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                printAndIncrease();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print 1,2,3 then notify printerB</span></span><br><span class="line">            <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"PrinterA printed 1,2,3; notify PrinterB"</span>);</span><br><span class="line">                WaitNotifyDemo.<span class="keyword">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (val &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"wait in printerA"</span>);</span><br><span class="line">                        WaitNotifyDemo.<span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"wait end printerA"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (val &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                printAndIncrease();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"PrinterA exits"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print 4,5,6 after printA print 1,2,3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out</span><br><span class="line">                                .println(<span class="string">"printerB wait for printerA printed 1,2,3"</span>);</span><br><span class="line">                        WaitNotifyDemo.<span class="keyword">this</span>.wait();</span><br><span class="line">                        System.out</span><br><span class="line">                                .println(<span class="string">"printerB waited for printerA printed 1,2,3"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (val &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">                printAndIncrease();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"notify in printerB"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">                WaitNotifyDemo.<span class="keyword">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"notify end printerB"</span>);</span><br><span class="line">            System.out.println(<span class="string">"PrinterB exits."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotifyDemo demo = <span class="keyword">new</span> WaitNotifyDemo();</span><br><span class="line">        demo.doPrint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PrinterA pa = <span class="keyword">new</span> PrinterA();</span><br><span class="line">        PrinterB pb = <span class="keyword">new</span> PrinterB();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(pa);</span><br><span class="line">        a.setName(<span class="string">"printerA"</span>);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(pb);</span><br><span class="line">        b.setName(<span class="string">"printerB"</span>);</span><br><span class="line">        <span class="comment">// 必须让b线程先执行，否则b线程有可能得不到锁，执行不了wait，而a线程一直持有锁，会先notify了</span></span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><pre><code>printerB wait for printerA printed 1,2,3printerA prints 1printerA prints 2printerA prints 3PrinterA printed 1,2,3; notify PrinterBwait in printerAprinterB waited for printerA printed 1,2,3printerB prints 4printerB prints 5printerB prints 6notify in printerBnotify end printerBwait end printerAprinterA prints 7printerA prints 8printerA prints 9PrinterA exitsPrinterB exits.Process finished with exit code 0</code></pre><p>我们来分析一下上面的程序：</p><ol><li><p>首先在main方法中我们看到是先启动了B线程，因为B线程持有wait()对象，而A线程则持有notify(),如果先启动A有可能会造成死锁的状态。<br>B线程启动以后进入run()方法：</p><p>while (val &lt; 3) {<br>synchronized (WaitNotifyDemo.this) {<br>try {<br>System.out.println(“printerB wait for printerA printed 1,2,3”);<br>WaitNotifyDemo.this.wait();<br>System.out.println(“printerB waited for printerA printed 1,2,3”);<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}<br>}<br>}<br>while (val &lt;= 6) {<br>printAndIncrease();<br>}</p></li></ol><p>这里有一个while循环，如果val的值小于3，那么在WaitNotifyDemo的实例的同步块中调用WaitNotifyDemo.this.wait()方法，这里要注意无论是wait，还是notify，notifyAll方法都需要在其实例对象的同步块中执行，这样当前线程才能获得同步实例的同步控制权，如果不在同步块中执行wait或者notify方法会出java.lang.IllegalMonitorStateException异常。另外还要注意在wait方法两边的同步块会在wait执行完毕之后释放对象锁。</p><p>这样PrinterB就进入了等待状态，我们再看下PrinterA的run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (val &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">    printAndIncrease();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print 1,2,3 then notify printerB</span></span><br><span class="line"><span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"PrinterA printed 1,2,3; notify PrinterB"</span>);</span><br><span class="line">    WaitNotifyDemo.<span class="keyword">this</span>.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (val &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"wait in printerA"</span>);</span><br><span class="line">            WaitNotifyDemo.<span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"wait end printerA"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先打印了1、2、3，然后在同步块中调用了WaitNotifyDemo实例的notify方法，这样PrinterB就得到了继续执行的通知，然后PrinterA进入等待状态，等待PrinterB通知。</p><p>我们再看下PrinterB run方法剩下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (val &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">    printAndIncrease();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"notify in printerB"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">    WaitNotifyDemo.<span class="keyword">this</span>.notify();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"notify end printerB"</span>);</span><br><span class="line">System.out.println(<span class="string">"PrinterB exits."</span>);</span><br></pre></td></tr></table></figure><p>PrinterB首先打印了4、5、6，然后在同步块中调用了notify方法，通知PrinterA开始执行。</p><p>PrinterA得到通知后，停止等待，打印剩下的7、8、9三个数字，如下是PrinterA run方法中剩下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (val &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">    printAndIncrease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个程序就分析完了，下面我们再来使用Condition来做这道题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberWrapper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化可重入锁</span></span><br><span class="line">        <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个条件当屏幕上输出到3</span></span><br><span class="line">        <span class="keyword">final</span> Condition reachThreeCondition = lock.newCondition();</span><br><span class="line">        <span class="comment">//第二个条件当屏幕上输出到6</span></span><br><span class="line">        <span class="keyword">final</span> Condition reachSixCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//NumberWrapper只是为了封装一个数字，一边可以将数字对象共享，并可以设置为final</span></span><br><span class="line">        <span class="comment">//注意这里不要用Integer, Integer 是不可变对象</span></span><br><span class="line">        <span class="keyword">final</span> NumberWrapper num = <span class="keyword">new</span> NumberWrapper();</span><br><span class="line">        <span class="comment">//初始化A线程</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//需要先获得锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA start write"</span>);</span><br><span class="line">                    <span class="comment">//A线程先输出前3个数</span></span><br><span class="line">                    <span class="keyword">while</span> (num.value &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        System.out.println(num.value);</span><br><span class="line">                        num.value++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//输出到3时要signal，告诉B线程可以开始了</span></span><br><span class="line">                    reachThreeCondition.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待输出6的条件</span></span><br><span class="line">                    reachSixCondition.await();</span><br><span class="line">                    System.out.println(<span class="string">"threadA start write"</span>);</span><br><span class="line">                    <span class="comment">//输出剩余数字</span></span><br><span class="line">                    <span class="keyword">while</span> (num.value &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                        System.out.println(num.value);</span><br><span class="line">                        num.value++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (num.value &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="comment">//等待3输出完毕的信号</span></span><br><span class="line">                        reachThreeCondition.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="comment">//已经收到信号，开始输出4，5，6</span></span><br><span class="line">                    System.out.println(<span class="string">"threadB start write"</span>);</span><br><span class="line">                    <span class="keyword">while</span> (num.value &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">                        System.out.println(num.value);</span><br><span class="line">                        num.value++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4，5，6输出完毕，告诉A线程6输出完了</span></span><br><span class="line">                    reachSixCondition.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动两个线程</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本思路就是首先要A线程先写1，2，3，这时候B线程应该等待reachThredCondition信号，而当A线程写完3之后就通过signal告诉B线程“我写到3了，该你了”，这时候A线程要等嗲reachSixCondition信号，同时B线程得到通知，开始写4，5，6，写完4，5，6之后B线程通知A线程reachSixCondition条件成立了，这时候A线程就开始写剩下的7，8，9了。</p><p>我们可以看到上例中我们创建了两个Condition,在不同的情况下可以使用不同的Condition，与wait和notify相比提供了更细致的控制。</p><h4 id="3-线程阻塞原语locksupport"><a class="markdownIt-Anchor" href="#3-线程阻塞原语locksupport"></a> 3 线程阻塞原语–LockSupport</h4><p>我们一再提线程、锁等概念，但锁是如果实现的呢？又是如何知道当前阻塞线程的又是哪个对象呢？LockSupport是JDK中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞原语。</p><p>java锁和同步器框架的核心 <span>AQS:</span> <span>AbstractQueuedSynchronizer，就是通过调用 <span>LockSupport</span> .park()和 <span>LockSupport</span> .unpark()实现线程的阻塞和唤醒 </span><span>的。</span> <span><span>LockSupport</span> 很类似于二元信号量(只有1个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继 </span><span>续</span> <span>执行；如果许可已经被占用，当前线</span> <span>程阻塞，等待获取许可。<br>LockSupport是针对特定线程来进行阻塞和解除阻塞操作的；而Object的wait()/notify()/notifyAll()是用来操作特定对象的等待集合的。<br>LockSupport的两个主要方法是park()和Unpark()，我们来看一下他们的实现：</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   setBlocker(t, blocker);</span><br><span class="line">   unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">   setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">       unsafe.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码我们可见在park方法内部首先获得当前线程然后阻塞当前线程，unpark方法传入一个可配置的线程来为该线程解锁。以“线程”作为方法的参数， 语义更清晰，使用起来也更方便。而wait/notify的实现使得“线程”的阻塞/唤醒对线程本身来说是被动的，要准确的控制哪个线程、什么时候阻塞/唤醒很困难， 要不随机唤醒一个线程（notify）要不唤醒所有的（notifyAll）。</p><p>下面我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setName(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">                System.out.println(<span class="string">"in"</span> + getName());</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把&quot;LockSupport.unpark(t1);&quot;这一句注掉的话我们会发现程序陷入死锁。而且我们看到再main方法中unpark是在t1和t2启动之后才执行，但是为什么t1启动之后，t2也启动了呢？注意，**unpark函数可以先于park调用。比如线程B调用unpark函数，给线程A发了一个“许可”，那么当线程A调用park时，它发现已经有“许可”了，那么它会马上再继续运行。**unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。</p><p>除了有定时阻塞的功能外,还支持中断影响,但是和其他接收中断函数不一样,他不会抛出<br>InterruptedException异常,他只会默默的返回,但是我们可以从Thread.Interrupted()等方法获得中断标记.<br>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setName(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">                System.out.println(<span class="string">"in "</span> + getName());</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                    System.out.println(getName() + <span class="string">" 被中断了!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName() + <span class="string">" 执行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>in t1t1 被中断了!t1 执行结束in t2t2 执行结束Process finished with exit code 0</code></pre><p>由run方法中的终端异常捕获我们可以看到线程在中断时并没有抛出异常而是正常执行下去了。<br>关于LockSupport其实要介绍的东西还是很多，因为这个类实现了底层的一些方法，各种的锁实现都是这个基础上发展而来的。以后会专门用一个篇章来学习jdk内部的阻塞机制。说前面我们讲到Object的wait和notify，讲到Condition条件，讲到jdk中不对外部暴露的LockSupport阻塞原语，那么在JUC包中还有另外一个阻塞机制—信号量机制（Semaphore），下一节我们一起探讨一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们了解了Lock接口的一些简单的说明，知道Lock锁的常用形式，那么这节我们正式开始进入JUC锁（java.util.concurrent包下的锁，简称JUC锁）。下面我们来看一下Lock最常用的实现类ReentrantLock。&lt;/p&gt;
&lt;h4 id=&quot;1-ree
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（四）----（JUC）Lock锁初探</title>
    <link href="http://blog.rickiyang.cn/posts/f4331185.html"/>
    <id>http://blog.rickiyang.cn/posts/f4331185.html</id>
    <published>2017-03-17T17:02:00.000Z</published>
    <updated>2018-12-05T06:13:34.113Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来回忆一下上一节讲过的synchronized关键字，该关键字用于给代码段或方法加锁，使得某一时刻它修饰的方法或代码段只能被一个线程访问。那么试想，当我们遇到这样的情况：当synchronized修饰的方法或代码段因为某种原因（IO异常或是sleep方法）被阻塞了，但是锁有没有被释放，那么其他线程除了等待以外什么事都做不了。当我们遇到这种情况该怎么办呢？我们今天讲到的Lock锁将有机会为此行使他的职责。</p><h4 id="1-为什么需要lock"><a class="markdownIt-Anchor" href="#1-为什么需要lock"></a> 1 为什么需要Lock</h4><p>synchronized 是Java 语言层面的，是内置的关键字；Lock 则是JDK 5 的J.U.C(java/util/currrent)包中出现的一个类，在使用时，synchronized 同步的代码块可以由JVM自动释放；Lock 需要程序员在finally块中手工释放；synchronized是比较古老的实现机制，设计较早，有一些功能上的限制：</p><pre><code>——它无法中断一个正在等候获得锁的线程——也无法通过投票得到锁，如果不想等下去，也就没法得到锁。——同步还要求锁的释放只能在与获得锁所在的堆栈帧相同的堆栈帧中进行</code></pre><p>而且对多线程环境中，使用synchronized后，线程要么获得锁，执行相应的代码，要么无法获得锁处于等待状态，对于锁的处理不灵活。而Lock提供了多种基于锁的处理机制，比如：</p><ol><li>void lock()，获取一个锁，如果锁当前被其他线程获得，当前的线程将被休眠。</li><li>boolean tryLock()，尝试获取一个锁，如果当前锁被其他线程持有，则返回false，不会使当前线程休眠。</li><li>boolean    tryLock(long timeout,TimeUnit  unit)，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false。</li><li>void lockInterruptibly()，如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断。</li></ol><p>可见lock比synchronized提供了更细的粒度、更灵活的控制。</p><h4 id="2-初探lock"><a class="markdownIt-Anchor" href="#2-初探lock"></a> 2 初探Lock</h4><p>在jdk1.5之后，并发包中新增了Lock接口(以及相关实现类)用来实现锁功能，其实真正的实现Lock接口的类就三个，ReentrantLock和ReentrantReadWriteLock的两个内部类（ReadLock和WriteLock实现了Lock的接口），下面我们来看一下Lock的类图：</p><p><img src="http://i.imgur.com/FpFZGXS.png" alt=""></p><p>ReentrantLock：一个可重入的互斥锁，为lock接口的主要实现。</p><p>ReentrantReadWriteLock：</p><p>ReadWriteLock、ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。</p><p>Semaphore：一个计数信号量。</p><p>Condition:锁的关联条件，目的是允许线程获取锁并且查看等待的某一个条件是否满足。</p><p>CyclicBarrier：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点。</p><p>①首先我们来看一下Lock的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"> </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常使用Lock的用法最多就是这样，ReentrantLock是Lock的实现类们也是最常使用的。如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并在finally块释放锁，以保证锁一定被被释放，防止死锁的发生。</p><p>②我们也可以这样使用Lock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则直接做其他事情    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取）则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p>这一节我们简单了解一下Lock接口，由于Lock锁的内容实在是太多，包括互斥锁，公平锁，非公平锁，共享锁以及相关的条件机制，信号量机制等等，我会一点点的把他们都啃下来，下面才是我们的重头戏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们来回忆一下上一节讲过的synchronized关键字，该关键字用于给代码段或方法加锁，使得某一时刻它修饰的方法或代码段只能被一个线程访问。那么试想，当我们遇到这样的情况：当synchronized修饰的方法或代码段因为某种原因（IO异常或是sleep方法）被阻塞了，
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(三)Channel</title>
    <link href="http://blog.rickiyang.cn/posts/12968bae.html"/>
    <id>http://blog.rickiyang.cn/posts/12968bae.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.162Z</updated>
    
    <content type="html"><![CDATA[<p>通道（Channel）是java.nio的第二个主要创新。它们既不是一个扩展也不是一项增强，而是全新、极好的Java I/O示例，提供与I/O服务的直接连接。Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。</p><h4 id="channel介绍"><a class="markdownIt-Anchor" href="#channel介绍"></a> <strong>channel介绍</strong></h4><p>通道是访问I/O服务的导管。I/O可以分为广义的两大类别：File I/O和Stream I/O。那么相应地有两种类型的通道也就不足为怪了，它们是文件（file）通道和套接字（socket）通道。我们看到在api里有一个FileChannel类和三个socket通道类：SocketChannel、ServerSocketChannel和DatagramChannel。</p><p>通道可以以多种方式创建。Socket通道有可以直接创建新socket通道的工厂方法。但是一个FileChannel对象却只能通过在一个打开的RandomAccessFile、FileInputStream或FileOutputStream对象上调用getChannel( )方法来获取。你不能直接创建一个FileChannel对象。</p><p>我们先来看一下FileChannel的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件输出字节流</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>);</span><br><span class="line"><span class="comment">//得到文件通道</span></span><br><span class="line">FileChannel fc = fos.getChannel();</span><br><span class="line"><span class="comment">//往通道写入ByteBuffer</span></span><br><span class="line">fc.write(ByteBuffer.wrap(<span class="string">"Some text "</span>.getBytes()));</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">fos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机访问文件</span></span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">//得到文件通道</span></span><br><span class="line">fc = raf.getChannel();</span><br><span class="line"><span class="comment">//设置通道的文件位置 为末尾</span></span><br><span class="line">fc.position(fc.size()); </span><br><span class="line"><span class="comment">//往通道写入ByteBuffer</span></span><br><span class="line">fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">raf.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件输入流</span></span><br><span class="line">FileInputStream fs = <span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>);</span><br><span class="line"><span class="comment">//得到文件通道</span></span><br><span class="line">fc = fs.getChannel();</span><br><span class="line"><span class="comment">//分配ByteBuffer空间大小</span></span><br><span class="line">ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line"><span class="comment">//从通道中读取ByteBuffer</span></span><br><span class="line">fc.read(buff);</span><br><span class="line"><span class="comment">//调用此方法为一系列通道写入或相对获取 操作做好准备</span></span><br><span class="line">buff.flip();</span><br><span class="line"><span class="comment">//从ByteBuffer从依次读取字节并打印</span></span><br><span class="line"><span class="keyword">while</span> (buff.hasRemaining())&#123;</span><br><span class="line">   System.out.print((<span class="keyword">char</span>) buff.get());</span><br><span class="line">&#125;</span><br><span class="line">fs.close();</span><br></pre></td></tr></table></figure><p>再来看一下SocketChannel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open( );</span><br><span class="line">sc.connect (<span class="keyword">new</span> InetSocketAddress (<span class="string">"somehost"</span>, someport)); </span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open( ); </span><br><span class="line">ssc.socket( ).bind (<span class="keyword">new</span> InetSocketAddress (somelocalport)); </span><br><span class="line">DatagramChannel dc = DatagramChannel.open( );</span><br></pre></td></tr></table></figure><p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    <span class="comment">//wait, or do something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端的使用经常会考虑到非阻塞socket通道，因为它们使同时管理很多socket通道变得更容易。但是，在客户端使用一个或几个非阻塞模式的socket通道也是有益处的，例如，借助非阻塞socket通道，GUI程序可以专注于用户请求并且同时维护与一个或多个服务器的会话。在很多程序上，非阻塞模式都是有用的。</p><p>调用finishConnect( )方法来完成连接过程，该方法任何时候都可以安全地进行调用。假如在一个非阻塞模式的SocketChannel对象上调用finishConnect( )方法，将可能出现下列情形之一：</p><ul><li>connect( )方法尚未被调用。那么将产生NoConnectionPendingException异常。</li><li>连接建立过程正在进行，尚未完成。那么什么都不会发生，finishConnect( )方法会立即返回false值。</li><li>在非阻塞模式下调用connect( )方法之后，SocketChannel又被切换回了阻塞模式。那么如果有必要的话，调用线程会阻塞直到连接建立完成，finishConnect( )方法接着就会返回true值。在初次调用connect( )或最后一次调用finishConnect( )之后，连接建立过程已经完成。那么SocketChannel对象的内部状态将被更新到已连接状态，finishConnect( )方法会返回true值，然后SocketChannel对象就可以被用来传输数据了。</li><li>连接已经建立。那么什么都不会发生，finishConnect( )方法会返回true值。</li></ul><p>Socket通道是线程安全的。并发访问时无需特别措施来保护发起访问的多个线程，不过任何时候都只有一个读操作和一个写操作在进行中。请记住，sockets是面向流的而非包导向的。它们可以保证发送的字节会按照顺序到达但无法承诺维持字节分组。某个发送器可能给一个socket写入了20个字节而接收器调用read( )方法时却只收到了其中的3个字节。剩下的17个字节还是传输中。由于这个原因，让多个不配合的线程共享某个流socket的同一侧绝非一个好的设计选择。</p><p>最后再看一下DatagramChannel：</p><p>最后一个socket通道是DatagramChannel。正如SocketChannel对应Socket，ServerSocketChannel对应ServerSocket，每一个DatagramChannel对象也有一个关联的DatagramSocket对象。不过原命名模式在此并未适用：“DatagramSocketChannel”显得有点笨拙，因此采用了简洁的“DatagramChannel”名称。</p><p>正如SocketChannel模拟连接导向的流协议（如TCP/IP），DatagramChannel则模拟包导向的无连接协议（如UDP/IP）：</p><p>创建DatagramChannel的模式和创建其他socket通道是一样的：调用静态的open( )方法来创建一个新实例。新DatagramChannel会有一个可以通过调用socket( )方法获取的对等DatagramSocket对象。DatagramChannel对象既可以充当服务器（监听者）也可以充当客户端（发送者）。如果你希望新创建的通道负责监听，那么通道必须首先被绑定到一个端口或地址/端口组合上。绑定DatagramChannel同绑定一个常规的DatagramSocket没什么区别，都是委托对等socket对象上的API实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open( );</span><br><span class="line">DatagramSocket socket = channel.socket( ); </span><br><span class="line">socket.bind (<span class="keyword">new</span> InetSocketAddress (portNumber));</span><br></pre></td></tr></table></figure><p>DatagramChannel是无连接的。每个数据报（datagram）都是一个自包含的实体，拥有它自己的目的地址及不依赖其他数据报的数据净荷。与面向流的的socket不同，DatagramChannel可以发送单独的数据报给不同的目的地址。同样，DatagramChannel对象也可以接收来自任意地址的数据包。每个到达的数据报都含有关于它来自何处的信息（源地址）。</p><p>一个未绑定的DatagramChannel仍能接收数据包。当一个底层socket被创建时，一个动态生成的端口号就会分配给它。绑定行为要求通道关联的端口被设置为一个特定的值（此过程可能涉及安全检查或其他验证）。不论通道是否绑定，所有发送的包都含有DatagramChannel的源地址（带端口号）。未绑定的DatagramChannel可以接收发送给它的端口的包，通常是来回应该通道之前发出的一个包。已绑定的通道接收发送给它们所绑定的熟知端口（wellknown port）的包。数据的实际发送或接收是通过send( )和receive( )方法来实现的。</p><p>**注意：**<em>假如您提供的ByteBuffer没有足够的剩余空间来存放您正在接收的数据包，没有被填充的字节都会被悄悄地丢弃。</em></p><h4 id="scattergather"><a class="markdownIt-Anchor" href="#scattergather"></a> <strong>Scatter/Gather</strong></h4><p>通道提供了一种被称为Scatter/Gather的重要新功能（有时也被称为矢量I/O）。它是指在多个缓冲区上实现一个简单的I/O操作。对于一个write操作而言，数据是从几个缓冲区按顺序抽取（称为gather）并沿着通道发送的。缓冲区本身并不需要具备这种gather的能力（通常它们也没有此能力）。该gather过程的效果就好比全部缓冲区的内容被连结起来，并在发送数据前存放到一个大的缓冲区中。对于read操作而言，从通道读取的数据会按顺序被散布（称为scatter）到多个缓冲区，将每个缓冲区填满直至通道中的数据或者缓冲区的最大空间被消耗完。</p><p>scatter / gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p><p>Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述：</p><p><img src="http://i.imgur.com/3Oj21dk.png" alt=""></p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocateDirect (<span class="number">10</span>); </span><br><span class="line">ByteBuffer body = ByteBuffer.allocateDirect (<span class="number">80</span>); </span><br><span class="line">ByteBuffer [] buffers = &#123; header, body &#125;; </span><br><span class="line"><span class="keyword">int</span> bytesRead = channel.read (buffers);</span><br></pre></td></tr></table></figure><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述：</p><p><img src="http://i.imgur.com/g6xjbxP.png" alt=""></p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocateDirect (<span class="number">10</span>); </span><br><span class="line">ByteBuffer body = ByteBuffer.allocateDirect (<span class="number">80</span>); </span><br><span class="line">ByteBuffer [] buffers = &#123; header, body &#125;; </span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p>使用得当的话，Scatter/Gather会是一个极其强大的工具。它允许你委托操作系统来完成辛苦活：将读取到的数据分开存放到多个存储桶（bucket）或者将不同的数据区块合并成一个整体。这是一个巨大的成就，因为操作系统已经被高度优化来完成此类工作了。它节省了您来回移动数据的工作，也就避免了缓冲区拷贝和减少了您需要编写、调试的代码数量。既然您基本上通过提供数据容器引用来组合数据，那么按照不同的组合构建多个缓冲区阵列引用，各种数据区块就可以以不同的方式来组合了。下面的例子好地诠释了这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatheringTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEMOGRAPHIC = <span class="string">"output.txt"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reps = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            reps = Integer.parseInt(argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(DEMOGRAPHIC);</span><br><span class="line">        GatheringByteChannel gatherChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer[] bs = utterBS(reps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gatherChannel.write(bs) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 不做操作，让通道把数据输出到文件写完</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Mindshare paradigms synergized to "</span> + DEMOGRAPHIC);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String [] col1 = &#123; <span class="string">"Aggregate"</span>, <span class="string">"Enable"</span>, <span class="string">"Leverage"</span>,</span><br><span class="line">                                      <span class="string">"Facilitate"</span>, <span class="string">"Synergize"</span>, <span class="string">"Repurpose"</span>,</span><br><span class="line">                                      <span class="string">"Strategize"</span>, <span class="string">"Reinvent"</span>, <span class="string">"Harness"</span></span><br><span class="line">                                    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String [] col2 = &#123; <span class="string">"cross-platform"</span>, <span class="string">"best-of-breed"</span>, <span class="string">"frictionless"</span>,</span><br><span class="line">                                      <span class="string">"ubiquitous"</span>, <span class="string">"extensible"</span>, <span class="string">"compelling"</span>,</span><br><span class="line">                                      <span class="string">"mission-critical"</span>, <span class="string">"collaborative"</span>, <span class="string">"integrated"</span></span><br><span class="line">                                    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String [] col3 = &#123; <span class="string">"methodologies"</span>, <span class="string">"infomediaries"</span>, <span class="string">"platforms"</span>, <span class="string">"schemas"</span>, <span class="string">"mindshare"</span>, <span class="string">"paradigms"</span>, <span class="string">"functionalities"</span>, <span class="string">"web services"</span>, <span class="string">"infrastructures"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String newline = System.getProperty (<span class="string">"line.separator"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer [] utterBS (<span class="keyword">int</span> howMany) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; howMany; i++) &#123;</span><br><span class="line">            list.add(pickRandom(col1, <span class="string">" "</span>));</span><br><span class="line">            list.add(pickRandom(col2, <span class="string">" "</span>));</span><br><span class="line">            list.add(pickRandom(col3, newline));</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuffer[] bufs = <span class="keyword">new</span> ByteBuffer[list.size()];</span><br><span class="line">        list.toArray(bufs);</span><br><span class="line">        <span class="keyword">return</span> (bufs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random( );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strings</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> suffix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">pickRandom</span> <span class="params">(String [] strings, String suffix)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String string = strings [rand.nextInt (strings.length)];</span><br><span class="line">        <span class="keyword">int</span> total = string.length() + suffix.length( );</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate (total);</span><br><span class="line">        buf.put (string.getBytes (<span class="string">"US-ASCII"</span>));</span><br><span class="line">        buf.put (suffix.getBytes (<span class="string">"US-ASCII"</span>));</span><br><span class="line">        buf.flip( );</span><br><span class="line">        <span class="keyword">return</span> (buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>Reinvent integrated web servicesAggregate best-of-breed platformsHarness frictionless platformsRepurpose extensible paradigmsFacilitate ubiquitous methodologiesRepurpose integrated methodologiesFacilitate mission-critical paradigmsSynergize compelling methodologiesReinvent compelling functionalitiesFacilitate extensible platforms</code></pre><p>虽然这种输出没有什么意义，但是gather确是很容易的让我们把它输出出来。</p><h4 id="pipe"><a class="markdownIt-Anchor" href="#pipe"></a> <strong>Pipe</strong></h4><p>java.nio.channels包中含有一个名为Pipe（管道）的类。广义上讲，管道就是一个用来在两个实体之间单向传输数据的导管。<br><em><strong>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取</strong></em>。Pipe类创建一对提供环回机制的Channel对象。这两个通道的远端是连接起来的，以便任何写在SinkChannel对象上的数据都能出现在SourceChannel对象上。</p><p>下面我们来创建一条Pipe，并向Pipe中写数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Pipe.open()方法打开管道</span></span><br><span class="line">Pipe pipe = Pipe.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//要向管道写数据，需要访问sink通道</span></span><br><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过调用SinkChannel的write()方法，将数据写入SinkChannel</span></span><br><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看如何从管道中读取数据：</p><p>读取管道的数据，需要访问source通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure><p>调用source通道的read()方法来读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = sourceChannel.read(buf);</span><br></pre></td></tr></table></figure><p>read()方法返回的int值会告诉我们多少字节被读进了缓冲区。</p><p>到此我们就把通道的简单用法讲完了，要想会用还是得多去练习，多模拟使用，这样才知道什么时候用以及怎么用，下节我们来讲选择器-Selectors。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通道（Channel）是java.nio的第二个主要创新。它们既不是一个扩展也不是一项增强，而是全新、极好的Java I/O示例，提供与I/O服务的直接连接。Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。&lt;/p&gt;
&lt;h4 
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(六)-LengthFieldBasedFrameDecoder解码器</title>
    <link href="http://blog.rickiyang.cn/posts/2b5f20ba.html"/>
    <id>http://blog.rickiyang.cn/posts/2b5f20ba.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.151Z</updated>
    
    <content type="html"><![CDATA[<p>在TCP协议中我们知道当我们在接收消息时候，我们如何判断我们一次读取到的包就是整包消息呢，特别是对于使用了长连接和使用了非阻塞I/O的程序。上节我们也说了上层应用协议为了对消息进行区分一般采用4种方式。前面三种我们都说了，第四种是：通过在消息头定义长度字段来标识消息总长度。这个我们还没讲。当然Netty也提供了相应的解码器：LengthFieldBasedFrameDecoder。</p><p>大多数的协议（私有或者公有），协议头中会携带长度字段，用于标识消息体或者整包消息的长度，例如SMPP、HTTP协议等。由于基于长度解码需求 的通用性，Netty提供了LengthFieldBasedFrameDecoder，自动屏蔽TCP底层的拆包和粘 包问题，只需要传入正确的参数，即可轻松解决“读半包“问题。</p><p>我们先来看一下他的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LengthFieldBasedFrameDecoder</span><span class="params">(ByteOrder byteOrder, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> maxFrameLength, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> lengthFieldOffset, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> lengthFieldLength, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> lengthAdjustment, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> initialBytesToStrip, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">boolean</span> failFast)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>byteOrder：表示字节流表示的数据是大端还是小端，用于长度域的读取；</p></li><li><p>maxFrameLength：表示的是包的最大长度，超出包的最大长度netty将会做一些特殊处理；</p></li><li><p>lengthFieldOffset：指的是长度域的偏移量，表示跳过指定长度个字节之后的才是长度域；</p></li><li><p>lengthFieldLength：记录该帧数据长度的字段本身的长度；</p></li><li><p>lengthAdjustment：该字段加长度字段等于数据帧的长度，包体长度调整的大小，长度域的数值表示的长度加上这个修正值表示的就是带header的包；</p></li><li><p>initialBytesToStrip：从数据帧中跳过的字节数，表示获取完一个完整的数据包之后，忽略前面的指定的位数个字节，应用解码器拿到的就是不带长度域的数据包；</p></li><li><p>failFast：如果为true，则表示读取到长度域，TA的值的超过maxFrameLength，就抛出一个 TooLongFrameException，而为false表示只有当真正读取完长度域的值表示的字节之后，才会抛出 TooLongFrameException，默认情况下设置为true，建议不要修改，否则可能会造成内存溢出。</p></li></ul><p>LengthFieldBasedFrameDecoder定义了一个长度的字段来表示消息的长度，因此能够处理可变长度的消息。将消息分为消息头和消息体，消息头固定位置增加一个表示长度的字段，通过长度字段来获取整包的信息。LengthFieldBasedFrameDecoder继承了ByteToMessageDecoder，即转换字节这样的工作是由ByteToMessageDecoder来完成，而LengthFieldBasedFrameDecoder只用安心完成他的解码工作就好。Netty在解耦和方面确实做的不错。</p><p>既然我们知道了LengthFieldBasedFrameDecoder处理的是带有消息头和消息体的消息类型，那么我们完全可以来定义一个我们自己的消息，我们来写一个消息类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息体</span></span><br><span class="line">    <span class="keyword">private</span> String msgBody;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">byte</span> type, <span class="keyword">int</span> length, String msgBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.msgBody = msgBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">byte</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsgBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msgBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgBody</span><span class="params">(String msgBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgBody = msgBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来写服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FRAME_LENGTH = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_LENGTH = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_OFFSET = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_ADJUSTMENT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_BYTES_TO_STRIP = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap sbs = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                    .group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> NewServerChannelInitializer(MAX_FRAME_LENGTH,LENGTH_FIELD_LENGTH,LENGTH_FIELD_OFFSET,LENGTH_ADJUSTMENT,INITIAL_BYTES_TO_STRIP))</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = sbs.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Server start listen at "</span> + port );</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NewServer server = <span class="keyword">new</span> NewServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到服务端我们在上面定义了5个参数，这5个参数是为了传入LengthFieldBasedFrameDecoder里面用的，因为我们的LengthFieldBasedFrameDecoder写在了NewServerChannelInitializer类里面，所以这几个参数采用可配置的方式也更符合可扩展性，我们分别说一下这几个参数定值的含义：</p><ul><li>MAX_FRAME_LENGTH = 1024 * 1024 ：这个没什么说的，消息体的最大长度；</li><li>LENGTH_FIELD_LENGTH = 4        ：指的就是我们的Message类中的length的长度，int占4位</li><li>LENGTH_FIELD_OFFSET = 1        ：偏移多少位之后才是我们的消息体，因为我们消息头只有type一个参数，byte类型占1位，所以是1；</li><li>LENGTH_ADJUSTMENT = 0          ：该字段加长度字段等于数据帧的长度，一般数据帧长度都是这样定义(即我们在设置Message中的length属性)，加入你的消息体是20位，再加上</li><li>LENGTH_FIELD_LENGTH就是24位，所以在此处为了正确的解析出消息体，需要偏移4位才能解析出消息体的正确位置，我们在发送的消息里面设置的就是消息体本身的长度，所以无需偏移。</li><li>INITIAL_BYTES_TO_STRIP = 0       ：这里我们也不需要跳过数据帧中的字节数，因为我们的消息体和长度是分别发送的，详情见下面EnCoder代码。</li></ul><p>然后我们写ChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> MAX_FRAME_LENGTH;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_LENGTH;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_OFFSET;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_ADJUSTMENT;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_BYTES_TO_STRIP;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewServerChannelInitializer</span><span class="params">(<span class="keyword">int</span> MAX_FRAME_LENGTH, <span class="keyword">int</span> LENGTH_FIELD_LENGTH, <span class="keyword">int</span> LENGTH_FIELD_OFFSET, <span class="keyword">int</span> LENGTH_ADJUSTMENT, <span class="keyword">int</span> INITIAL_BYTES_TO_STRIP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.MAX_FRAME_LENGTH = MAX_FRAME_LENGTH;</span><br><span class="line">        <span class="keyword">this</span>.LENGTH_FIELD_LENGTH = LENGTH_FIELD_LENGTH;</span><br><span class="line">        <span class="keyword">this</span>.LENGTH_FIELD_OFFSET = LENGTH_FIELD_OFFSET;</span><br><span class="line">        <span class="keyword">this</span>.LENGTH_ADJUSTMENT = LENGTH_ADJUSTMENT;</span><br><span class="line">        <span class="keyword">this</span>.INITIAL_BYTES_TO_STRIP = INITIAL_BYTES_TO_STRIP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> NewDecoder(MAX_FRAME_LENGTH,LENGTH_FIELD_LENGTH,LENGTH_FIELD_OFFSET,LENGTH_ADJUSTMENT,INITIAL_BYTES_TO_STRIP,<span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> NewServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到了我们自己写的Decoder，接下来定义一个Decoder，继承LengthFieldBasedFrameDecoder，以方便我们做一些改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewDecoder</span> <span class="keyword">extends</span> <span class="title">LengthFieldBasedFrameDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们在Message类中定义了type和length，这都放在消息头部</span></span><br><span class="line"><span class="comment">     * type占1个字节，length占4个字节所以头部总长度是5个字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEADER_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">private</span> String msgBody;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxFrameLength   网络字节序，默认为大端字节序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldOffset 消息中长度字段偏移的字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldLength 数据帧的最大长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthAdjustment 该字段加长度字段等于数据帧的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBytesToStrip 从数据帧中跳过的字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> failFast 如果为true，则表示读取到长度域，TA的值的超过maxFrameLength，就抛出一个 TooLongFrameException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewDecoder</span><span class="params">(<span class="keyword">int</span> maxFrameLength, <span class="keyword">int</span> lengthFieldOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> lengthFieldLength, <span class="keyword">int</span> lengthAdjustment, <span class="keyword">int</span> initialBytesToStrip,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> failFast)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength,</span><br><span class="line">                lengthAdjustment, initialBytesToStrip, failFast);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &lt; HEADER_SIZE)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"错误的消息"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过源码我们能看到在读的过程中</span></span><br><span class="line"><span class="comment">         * 每读一次读过的字节即被抛弃</span></span><br><span class="line"><span class="comment">         * 即指针会往前跳</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        type = in.readByte();</span><br><span class="line"></span><br><span class="line">        length = in.readByte();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &lt; length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"消息不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = in.readBytes(length);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(b);</span><br><span class="line"></span><br><span class="line">        msgBody = <span class="keyword">new</span> String(b,<span class="string">"UTF-8"</span>);</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(type,length,msgBody);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的NewDecoder中有一个HEADER_SIZE-消息头。上面也解释过了，我们在Message中定义的type和length分别占一个字节和4个字节（别问我为啥是4个哈）。所以我们的消息头就是5个字节啦。</p><p>接下来就是服务端的handler了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Message) &#123;</span><br><span class="line">            Message msg = (Message)o;</span><br><span class="line">            System.out.println(<span class="string">"Client-&gt;Server:"</span>+channelHandlerContext.channel().remoteAddress()+<span class="string">" send "</span>+msg.getMsgBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler中我们用来接收已经被NewDecoder解码过后的客户端发送过来的消息。</p><p>下面是客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> NewClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NewClient client = <span class="keyword">new</span> NewClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewClientChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> NewEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> NewClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端中我们又定义了一个编码器NewEncoder，继承了MessageToByteEncoder，该类用于将文本信息转换为流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(message == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"未获得消息内容"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        String msgBody = message.getMsgBody();</span><br><span class="line">        <span class="keyword">byte</span>[] b = msgBody.getBytes(Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">        byteBuf.writeByte(message.getType());</span><br><span class="line">        byteBuf.writeByte(b.length);</span><br><span class="line">        byteBuf.writeBytes(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是我们的客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String m = <span class="string">"你好啊,Netty。昂昂"</span>;</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message((<span class="keyword">byte</span>)<span class="number">0xCA</span>, m.length(), m);</span><br><span class="line">        ctx.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在handler中我们发送了一个Message对象。然后会由NewEncoder编码发送出去，服务端对消息解码获得消息头和消息体。分别启动服务端和客户端，打印结果为：</p><p><img src="http://i.imgur.com/uYXV45n.png" alt=""></p><p>我们的消息就发送出去了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在TCP协议中我们知道当我们在接收消息时候，我们如何判断我们一次读取到的包就是整包消息呢，特别是对于使用了长连接和使用了非阻塞I/O的程序。上节我们也说了上层应用协议为了对消息进行区分一般采用4种方式。前面三种我们都说了，第四种是：通过在消息头定义长度字段来标识消息总长度。
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(八)-Netty的心跳机制</title>
    <link href="http://blog.rickiyang.cn/posts/9afa0af8.html"/>
    <id>http://blog.rickiyang.cn/posts/9afa0af8.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.153Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道在TCP长连接或者WebSocket长连接中一般我们都会使用心跳机制–即发送特殊的数据包来通告对方自己的业务还没有办完，不要关闭链接。那么心跳机制可以用来做什么呢？我们知道网络的传输是不可靠的，当我们发起一个链接请求的过程之中会发生什么事情谁都无法预料，或者断电，服务器重启，断网线之类。如果有这种情况的发生对方也无法判断你是否还在线。所以这时候我们引入心跳机制，在长链接中双方没有数据交互的时候互相发送数据(可能是空包，也可能是特殊数据)，对方收到该数据之后也回复相应的数据用以确保双方都在线，这样就可以确保当前链接是有效的。</p><h4 id="1-如何实现心跳机制"><a class="markdownIt-Anchor" href="#1-如何实现心跳机制"></a> <strong>1. 如何实现心跳机制</strong></h4><p>一般实现心跳机制由两种方式：</p><ul><li>TCP协议自带的心跳机制来实现；</li><li>在应用层来实现。</li></ul><p>但是TCP协议自带的心跳机制系统默认是设置的是2小时的心跳频率。它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。另外该心跳机制是与TCP协议绑定的，那如果我们要是使用UDP协议岂不是用不了？所以一般我们都不用。</p><p>而一般我们自己实现呢大致的策略是这样的：</p><ol><li>Client启动一个定时器，不断发送心跳；</li><li>Server收到心跳后，做出回应；</li><li>Server启动一个定时器，判断Client是否存在，这里做判断有两种方法：时间差和简单标识。</li></ol><p>时间差：</p><ol><li>收到一个心跳包之后记录当前时间；</li><li>判断定时器到达时间，计算多久没收到心跳时间=当前时间-上次收到心跳时间。如果改时间大于设定值则认为超时。</li></ol><p>简单标识：</p><ol><li>收到心跳后设置连接标识为true;</li><li>判断定时器到达时间，如果未收到心跳则设置连接标识为false;</li></ol><p>今天我们来看一下Netty的心跳机制的实现，在Netty中提供了IdleStateHandler类来进行心跳的处理，它可以对一个 Channel 的 读/写设置定时器, 当 Channel 在一定事件间隔内没有数据交互时(即处于 idle 状态), 就会触发指定的事件。</p><p>该类可以对三种类型的超时做心跳机制检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">int</span> readerIdleTimeSeconds, <span class="keyword">int</span> writerIdleTimeSeconds, <span class="keyword">int</span> allIdleTimeSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">long</span>)readerIdleTimeSeconds, (<span class="keyword">long</span>)writerIdleTimeSeconds, (<span class="keyword">long</span>)allIdleTimeSeconds, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readerIdleTimeSeconds：设置读超时时间；</li><li>writerIdleTimeSeconds：设置写超时时间；</li><li>allIdleTimeSeconds：同时为读或写设置超时时间；</li></ul><p>下面我们还是通过一个例子来讲解IdleStateHandler的使用。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartBeatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> HeartBeatServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeartBeatServer server = <span class="keyword">new</span> HeartBeatServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>,<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HeartBeatServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里IdleStateHandler也是handler的一种，所以加入addLast。我们分别设置4个参数：读超时时间为3s，写超时和读写超时为0，然后加入时间控制单元。</p><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loss_connect_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">"Server :"</span> + msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="comment">//服务端对应着读事件，当为READER_IDLE时触发</span></span><br><span class="line">                IdleStateEvent event = (IdleStateEvent)evt;</span><br><span class="line">            <span class="keyword">if</span>(event.state() == IdleState.READER_IDLE)&#123;</span><br><span class="line">                loss_connect_time++;</span><br><span class="line">                System.out.println(<span class="string">"接收消息超时"</span>);</span><br><span class="line">                <span class="keyword">if</span>(loss_connect_time &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"关闭不活动的链接"</span>);</span><br><span class="line">                    ctx.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.userEventTriggered(ctx,evt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在handler中调用了userEventTriggered方法，IdleStateEvent的state()方法一个有三个值：<br>READER_IDLE，WRITER_IDLE，ALL_IDLE。正好对应读事件写事件和读写事件。</p><p>再来写一下客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatsClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartBeatsClient</span><span class="params">(<span class="keyword">int</span> port, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> HeartBeatsClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeartBeatsClient client = <span class="keyword">new</span> HeartBeatsClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatsClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HeartBeatClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们设置了IdleStateHandler的写超时为3秒，客户端执行的动作为写消息到服务端，服务端执行读动作。</p><p>客户端handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf HEARTBEAT_SEQUENCE = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="string">"Heartbeat"</span>,</span><br><span class="line">            CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRY_TIMES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"激活时间是："</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"链接已经激活"</span>);</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"停止时间是："</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"关闭链接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前轮询时间："</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                <span class="keyword">if</span>(currentTime &lt;= TRY_TIMES)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"currentTime:"</span>+currentTime);</span><br><span class="line">                    currentTime++;</span><br><span class="line">                    ctx.channel().writeAndFlush(HEARTBEAT_SEQUENCE.duplicate());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String message = (String) msg;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="keyword">if</span> (message.equals(<span class="string">"Heartbeat"</span>)) &#123;</span><br><span class="line">            ctx.write(<span class="string">"has read message from server"</span>);</span><br><span class="line">            ctx.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务端和客户端我们看到输出为：</p><p><img src="http://i.imgur.com/Gkhgtwh.png" alt=""></p><p>我们再来屡一下思路：</p><ol><li>首先客户端激活channel，因为客户端中并没有发送消息所以会触发客户端的IdleStateHandler，它设置的写超时时间为3s；</li><li>然后触发客户端的事件机制进入userEventTriggered方法，在触发器中计数并向客户端发送消息；</li><li>服务端接收消息；</li><li>客户端触发器继续轮询发送消息，直到计数器满不再向服务端发送消息；</li><li>服务端在IdleStateHandler设置的读消息超时时间5s内未收到消息，触发了服务端中handler的userEventTriggered方法，于是关闭客户端的链接。</li></ol><p>大体我们的简单心跳机制就是这样的思路，通过事件触发机制以及计数器的方式来实现，上面我们的案例中最后客户端没有发送消息的时候我们是强制断开了客户端的链接，那么既然可以关闭，我们是不是也可是重新链接客户端呢？因为万一客户端本身并不想关闭而是由于别的原因导致他无法与服务端通信。下面我们来说一下重连机制。</p><p>当我们的服务端在未读到客户端消息超时而关闭客户端的时候我们一般在客户端的finally块中方的是关闭客户端的代码，这时我们可以做一下修改的，finally是一定会被执行新的，所以我们可以在finally块中重新调用一下启动客户端的代码，这样就又重新启动了客户端了，上客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本Client为测试netty重连机制</span></span><br><span class="line"><span class="comment"> * Server端代码都一样，所以不做修改</span></span><br><span class="line"><span class="comment"> * 只用在client端中做一下判断即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatsClient2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line">    ChannelFuture future;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartBeatsClient2</span><span class="params">(<span class="keyword">int</span> port, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> HeartBeatsClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//group.shutdownGracefully();</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.channel() != <span class="keyword">null</span> &amp;&amp; future.channel().isOpen()) &#123;</span><br><span class="line">                    future.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"准备重连"</span>);</span><br><span class="line">            start();</span><br><span class="line">            System.out.println(<span class="string">"重连成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeartBeatsClient2 client = <span class="keyword">new</span> HeartBeatsClient2(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余部分的代码与上面的实例并无异同，只需改造客户端即可，我们再运行服务端和客户端会看到客户端虽然被关闭了，但是立马又被重启：</p><p><img src="http://i.imgur.com/Q7eee7J.png" alt=""></p><p>当然生产级别的代码应该不是这样实现的吧，哈哈，下一节我们再好好探讨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道在TCP长连接或者WebSocket长连接中一般我们都会使用心跳机制–即发送特殊的数据包来通告对方自己的业务还没有办完，不要关闭链接。那么心跳机制可以用来做什么呢？我们知道网络的传输是不可靠的，当我们发起一个链接请求的过程之中会发生什么事情谁都无法预料，或者断电，服
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(五)-DelimiterBasedFrameDecoder</title>
    <link href="http://blog.rickiyang.cn/posts/87e472dc.html"/>
    <id>http://blog.rickiyang.cn/posts/87e472dc.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.149Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们说了LineBasedframeDecoder来解决粘包拆包的问题，TCP以流的方式进行数据传输，上层应用协议为了对消息进行区分，一般采用如下4种方式：</p><ol><li>消息长度固定，累计读取到消息长度总和为定长Len的报文之后即认为是读取到了一个完整的消息。计数器归位，重新读取。</li><li>将回车换行符作为消息结束符。</li><li>将特殊的分隔符作为消息分隔符，回车换行符是他的一种。</li><li>通过在消息头定义长度字段来标识消息总长度。</li></ol><p>LineBasedframeDecoder属于第二种，今天我们要说的DelimiterBasedFrameDecoder和FixedLengthFrameDecoder属于第三种和第一种。DelimiterBasedFrameDecoder用来解决以特殊符号作为消息结束符的粘包问题，FixedLengthFrameDecoder用来解决定长消息的粘包问题。下面首先来用DelimiterBasedFrameDecoder来写一个例子，我们看一下效果然后接着分析用法。</p><h4 id="1-delimiterbasedframedecoder使用"><a class="markdownIt-Anchor" href="#1-delimiterbasedframedecoder使用"></a> <strong>1. DelimiterBasedFrameDecoder使用</strong></h4><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWordServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWordServer server = <span class="keyword">new</span> HelloWordServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端ServerChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">"\t"</span>.getBytes());</span><br><span class="line">        pipeline.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">2048</span>,delimiter));    </span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> ServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String body = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"server receive order : "</span> + body + <span class="string">";the counter is: "</span> + ++counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端ClientChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个地方的 必须和服务端对应上。否则无法正常解码和编码</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span>       </span><br><span class="line">        ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">"\t"</span>.getBytes());</span><br><span class="line">        pipeline.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">2048</span>,delimiter)); </span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端的逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] req;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         req = (<span class="string">"Unless required by applicable law or agreed to in writing, software\t"</span> +</span><br><span class="line">                <span class="string">"  distributed under the License is distributed on an \"AS IS\" BASIS,\t"</span> +</span><br><span class="line">                <span class="string">"  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\t"</span> +</span><br><span class="line">                <span class="string">"  See the License for the specific language governing permissions and\t"</span> +</span><br><span class="line">                <span class="string">"  limitations under the License.This connector uses the BIO implementation that requires the JSSE\t"</span> +</span><br><span class="line">                <span class="string">"  style configuration. When using the APR/native implementation, the\t"</span> +</span><br><span class="line">                <span class="string">"  penSSL style configuration is required as described in the APR/native\t"</span> +</span><br><span class="line">                <span class="string">"  documentation.An Engine represents the entry point (within Catalina) that processes\t"</span> +</span><br><span class="line">                <span class="string">"  every request.  The Engine implementation for Tomcat stand alone\t"</span> +</span><br><span class="line">                <span class="string">"  analyzes the HTTP headers included with the request, and passes them\t"</span> +</span><br><span class="line">                <span class="string">"  on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software\t"</span> +</span><br><span class="line">                <span class="string">"# distributed under the License is distributed on an \"AS IS\" BASIS,\t"</span> +</span><br><span class="line">                <span class="string">"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\t"</span> +</span><br><span class="line">                <span class="string">"# See the License for the specific language governing permissions and\t"</span> +</span><br><span class="line">                <span class="string">"# limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log\t"</span> +</span><br><span class="line">                <span class="string">"# each component that extends LifecycleBase changing state:\t"</span> +</span><br><span class="line">                <span class="string">"#org.apache.catalina.util.LifecycleBase.level = FINE\t"</span></span><br><span class="line">                ).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf message;</span><br><span class="line"></span><br><span class="line">        message = Unpooled.buffer(req.length);</span><br><span class="line">        message.writeBytes(req);</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String buf = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"Now is : "</span> + buf + <span class="string">" ; the counter is : "</span>+ (++counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><pre><code>server receive order : Unless required by applicable law or agreed to in writing, software;the counter is: 1server receive order :   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,;the counter is: 2server receive order :   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.;the counter is: 3server receive order :   See the License for the specific language governing permissions and;the counter is: 4server receive order :   limitations under the License.This connector uses the BIO implementation that requires the JSSE;the counter is: 5server receive order :   style configuration. When using the APR/native implementation, the;the counter is: 6server receive order :   penSSL style configuration is required as described in the APR/native;the counter is: 7server receive order :   documentation.An Engine represents the entry point (within Catalina) that processes;the counter is: 8server receive order :   every request.  The Engine implementation for Tomcat stand alone;the counter is: 9server receive order :   analyzes the HTTP headers included with the request, and passes them;the counter is: 10server receive order :   on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software;the counter is: 11server receive order : # distributed under the License is distributed on an &quot;AS IS&quot; BASIS,;the counter is: 12server receive order : # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.;the counter is: 13server receive order : # See the License for the specific language governing permissions and;the counter is: 14server receive order : # limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log;the counter is: 15server receive order : # each component that extends LifecycleBase changing state:;the counter is: 16server receive order : #org.apache.catalina.util.LifecycleBase.level = FINE;the counter is: 17</code></pre><p>启动服务端和客户端，我们能看到服务端接收客户端发过来的消息一共分17次接收。那么为什么是17次呢？而且我们并没有使用在上一篇中解决拆包和粘包问题的LineBasedFrameDecoder，并且这次我们的消息每一行的末尾也换成了&quot;\t&quot;。下面就来讲解一下DelimiterBasedFrameDecoder的使用。</p><p>DelimiterBasedFrameDecoder是将特殊的字符作为消息的分隔符，本例中用到的是&quot;\t&quot;。而LineBasedFrameDecoder是默认将换行符&quot;\n&quot;作为消息分隔符。首先我们注意到在ServerChannelInitializer中我们在添加解码器时跟以前有点不一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">"\t"</span>.getBytes());</span><br><span class="line">pipeline.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">2048</span>, delimiter));</span><br></pre></td></tr></table></figure><p>这里我们添加DelimiterBasedFrameDecoder解码器并且手动指定消息分隔符为：&quot;\t&quot;。我们可以看一下DelimiterBasedFrameDecoder的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelimiterBasedFrameDecoder</span><span class="params">(<span class="keyword">int</span> maxFrameLength, <span class="keyword">boolean</span> stripDelimiter, ByteBuf delimiter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(maxFrameLength, stripDelimiter, <span class="keyword">true</span>, delimiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>maxFrameLength：解码的帧的最大长度</p><p>stripDelimiter：解码时是否去掉分隔符</p><p>failFast：为true，当frame长度超过maxFrameLength时立即报TooLongFrameException异常，为false，读取完整个帧再报异常</p><p>delimiter：分隔符</p><p>这个时候大家应该明白了为什么服务端分17次收到消息。我们在消息的每一行都加了一个&quot;\t&quot;,自然解码器在度消息时遇到&quot;\t&quot;就会认为这是一条消息的结束。用这种方式我们可以把&quot;\t&quot;换成任何我们自定义的字符对象。换成&quot;\n&quot;也是可以的。</p><h4 id="2-fixedlengthframedecoder使用"><a class="markdownIt-Anchor" href="#2-fixedlengthframedecoder使用"></a> <strong>2. FixedLengthFrameDecoder使用</strong></h4><p>FixedLengthFrameDecoder是固定长度解码器，它能够按照指定的长度对消息进行自动解码。使用它也没有什么特别费力的事情，在ServerChannelInitializer类中添加：</p><p>pipeline.addLast(new FixedLengthFrameDecoder(23));//参数为一次接受的数据长度</p><p>即可，同时也别忘了把刚才使用的DelimiterBasedFrameDecoder注释掉啊，不然达不到效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们说了LineBasedframeDecoder来解决粘包拆包的问题，TCP以流的方式进行数据传输，上层应用协议为了对消息进行区分，一般采用如下4种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息长度固定，累计读取到消息长度总和为定长Len的报文之后即认为是读取到了一个完整的
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(三）-Netty重要接口讲解</title>
    <link href="http://blog.rickiyang.cn/posts/d48afec7.html"/>
    <id>http://blog.rickiyang.cn/posts/d48afec7.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.151Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们写了一个HelloWorld，对于Netty的运行有了一定的了解，知道Netty是如何启动客户端和服务器端。这一节我们简要的讲解一下几个重要的接口，初步探讨Netty的运行机制，当然刚学Netty就深入原理肯定是很枯燥的，所以我们就点到为止。</p><h4 id="1-channelpipeline和channelhandler"><a class="markdownIt-Anchor" href="#1-channelpipeline和channelhandler"></a> 1 <strong>ChannelPipeLine和ChannelHandler</strong></h4><p>在上一篇中我们在ChannelInitializer类的initChannel方法中使用了ChannelPipeline，然后在ChannelPipeline中使用了handler来处理业务逻辑。</p><p>ChannelPipeline是ChannelHandler的容器，它负责ChannelHandler的管理和事件拦截与调度。Netty的ChannelPipeline和ChannelHandler机制类似于Servlet 和Filter 过滤器，这类拦截器实际上是职责链模式的一种变形，主要是为了方便事件的拦截和用户业务逻辑的定制。</p><p>Netty的channel运用机制和Filter过滤器机制一样，它将Channel 的数据管道抽象为ChannelPipeline. 消息在ChannelPipeline中流动和传递。ChannelPipeline 持有I/O事件拦截器ChannelHandler 的链表，由ChannelHandler 对I/0 事件进行拦截和处理，可以方便地通过新增和删除ChannelHandler 来实现小同的业务逻辑定制，不需要对已有的ChannelHandler进行修改，能够实现对修改封闭和对扩展的支持。</p><p>通过一张图我们来看一下他们之间的关系：</p><p><img src="http://i.imgur.com/I6jciGg.png" alt=""></p><p>一个Channel中包含一个ChannelPipeline，用来处理Channel中的事件，一个ChannelPipeline中可以包含很多个handler，第二节的示例代码中我们也看到了，使用各种handler来处理通信信息。</p><p>同时我们也注意到在hadler中继承了ChannelInboundHandlerAdapter类并实现了他的一些方法，比如：channelRead，channelActive，channelInactive等等，我们看到这些方法中都有一个参数：ChannelHandlerContext ctx。这个ChannelHandlerContext就是handler的上下文对象，有了这个ChannelHandlerContext你就获得了一切，你可以获得通道，获得事件的控制权。</p><p>事实上，用户不需要自己创建pipeline，因为使用ServerBootstrap 或者Bootstrap 启动<br>服务端或者客户端时， Netty 会为每个Channel 连接创建一个独立的pipeline。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">pipeline.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">8192</span>,Delimiters.lineDelimiter()));</span><br><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的逻辑</span></span><br><span class="line">pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWorldClientHandler());</span><br></pre></td></tr></table></figure><p>ChannelPipeline 是线程安全的， 这意味着N个业务线程可以并发地操作ChannelPipeline<br>而不存在多线程并发问题。但是，ChannelHandler却不是线程安全的，这意味着尽管<br>ChannelPipeline 是线程去全的， 但是仍然需要自己保证ChannelHandler的线程安全。</p><p>Netty 中的事件分为inbound 事件和outbound 事件。inbound 事件通常由I/O线程触发，例如TCP 链路建立事件、链路关闭事件、读事件、异常通知事件等。Outbound 事件通常是I/O 用户主动发起的网络I/O 操作，例如用户发起的连接操作、绑定操作、消息发送等操作。</p><p>我们常用的inbound事件有：</p><ul><li>ChannelHandlerContext fireChannelRegistered()   //channel注册事件</li><li>ChannelHandlerContext fireChannelActive()  //channel激活事件</li><li>ChannelHandlerContext fireExceptionCaught(Throwable var1) //channel异常处理事件</li><li>ChannelHandlerContext fireUserEventTriggered(Object var1) //用户自定义事件</li><li>ChannelHandlerContext fireChannelRead(Object var1) //读事件</li></ul><p>pipeline 中以fireXXX命名的方法都是从I/O 线程流向用户业务Handler的inbound 事件，它们的实现因功能而异，但是处理步骤类似：</p><ol><li><p>调用HeadHandler对应的fireXXX 方法</p></li><li><p>执行事件相关的逻辑操作</p></li></ol><p>常用的outbound事件有：</p><ul><li>ChannelFuture bind(SocketAddress var1, ChannelPromise var2) //绑定地址</li><li>ChannelFuture connect(SocketAddress var1, ChannelPromise var2) //连接服务器</li><li>ChannelFuture write(Object var1) //发送事件</li><li>ChannelHandlerContext flush() //刷新事件</li></ul><p>上面我们说到事件，netty的事件机制是由前至后的，一般来说，都是一个channel的ChannnelActive方法中调用fireChannelActive来触发调用下一个handler中的ChannelActive方法，即你在ChannelPipeline中添加handler的时候，要在第一个handler的channelActive方法中调用fireChannelActive，以此来触发下一个事件。我们再来写一个案例说明一下：</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HWClient</span><span class="params">(<span class="keyword">int</span> port, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().writeAndFlush(<span class="string">"Hello Netty Server ,I am a common client"</span>);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HWClient client = <span class="keyword">new</span> HWClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端ClientChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端的handler</span></span><br><span class="line">        <span class="comment">//先调用handler在ChannnelActive方法中调用fireChannelActive会激活handler1</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HWClientHandler());</span><br><span class="line">        pipeline.addLast(<span class="string">"handler1"</span>, <span class="keyword">new</span> BaseClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server say : "</span>+msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Handler1"</span>);</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的第二个handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Handler2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HWServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HWServer server = <span class="keyword">new</span> HWServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端ServerChannelInitializer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HWServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">"===&gt;server: "</span>+msg.toString());</span><br><span class="line">        ctx.write(<span class="string">"received your msg"</span>);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动服务端和客户端，会发现客户端的两个handler都通过了。</p><p><img src="http://i.imgur.com/NLijyim.png" alt=""></p><p>先调用HWClientHandler，打印出：HWClientHandler channelActive；继而调用了BaseClientHandler ，打印出：BaseClient1Handler channelActive.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们写了一个HelloWorld，对于Netty的运行有了一定的了解，知道Netty是如何启动客户端和服务器端。这一节我们简要的讲解一下几个重要的接口，初步探讨Netty的运行机制，当然刚学Netty就深入原理肯定是很枯燥的，所以我们就点到为止。&lt;/p&gt;
&lt;h4 id
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(七)-Netty编解码技术以及ProtoBuf和Thrift的介绍</title>
    <link href="http://blog.rickiyang.cn/posts/f693139f.html"/>
    <id>http://blog.rickiyang.cn/posts/f693139f.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.152Z</updated>
    
    <content type="html"><![CDATA[<p>在前几节我们学习过处理粘包和拆包的问题，用到了Netty提供的几个解码器对不同情况的问题进行处理。功能很是强大。我们有没有去想这么强大的功能是如何实现的呢？背后又用到了什么技术？这一节我们就来处理这个问题。了解一下编码解码到底是如何处理的。</p><p>通常说的编码(Encoder)也就是发生在发送消息的时候需要将消息编译成字节对象，在Netty中即编译成ByteBuf对象。在java中我们将这种编译称之为序列化(Serializable),即将对象序列化为字节数组，然后用于传输或是持久化啊之类的。那么自然解码（Decoder）就是一个反序列化的过程，使用相应的编码格式对接收到的对做一个解码，以正确解析该对象。</p><h4 id="1-java序列化的弱点"><a class="markdownIt-Anchor" href="#1-java序列化的弱点"></a> <strong>1. java序列化的弱点</strong></h4><p>谈到序列化我们自然想到java提供的Serializable接口，在java中我们如果需要序列化只需要继承该接口就可以通过输入输出流进行序列化和反序列化。但是在提供很用户简单的调用的同时他也存在很多问题：</p><ul><li><p>无法跨语言。当我们进行跨应用之间的服务调用的时候如果另外一个应用使用c语言来开发，这个时候我们发送过去的序列化对象，别人是无法进行反序列化的因为其内部实现对于别人来说完全就是黑盒。</p></li><li><p>序列化之后的码流太大。这个我们可以做一个实验还是上一节中的Message类，我们分别用java的序列化和使用二进制编码来做一个对比，下面我写了一个测试类：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerializable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">"哈哈,我是一条消息"</span>;</span><br><span class="line">    Message msg = <span class="keyword">new</span> Message((<span class="keyword">byte</span>)<span class="number">0xAD</span>,<span class="number">35</span>,str);</span><br><span class="line">    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        os.writeObject(msg);</span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="keyword">byte</span>[] b = out.toByteArray();</span><br><span class="line">        System.out.println(<span class="string">"jdk序列化后的长度： "</span>+b.length);</span><br><span class="line">        os.close();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bt = msg.getMsgBody().getBytes();</span><br><span class="line">        buffer.put(msg.getType());</span><br><span class="line">        buffer.putInt(msg.getLength());</span><br><span class="line">        buffer.put(bt);</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">        buffer.get(result);</span><br><span class="line">        System.out.println(<span class="string">"使用二进制序列化的长度："</span>+result.length);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="http://i.imgur.com/tdJO9ED.png" alt=""></p><p>我们可以看到差距是挺大的，目前的主流编解码框架序列化之后的码流也都比java序列化要小太多。</p><ul><li>序列化效率差，这个我们也可以做一个对比，还是上面写的测试代码我们循环跑100000次对比一下时间：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerializable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">"哈哈,我是一条消息"</span>;</span><br><span class="line">    Message msg = <span class="keyword">new</span> Message((<span class="keyword">byte</span>)<span class="number">0xAD</span>,<span class="number">35</span>,str);</span><br><span class="line">    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)&#123;</span><br><span class="line">            ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">            os.writeObject(msg);</span><br><span class="line">            os.flush();</span><br><span class="line">            <span class="keyword">byte</span>[] b = out.toByteArray();</span><br><span class="line">            <span class="comment">/*System.out.println("jdk序列化后的长度： "+b.length);*/</span></span><br><span class="line">            os.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"jdk序列化100000次耗时："</span> +(endTime - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)&#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bt = msg.getMsgBody().getBytes();</span><br><span class="line">            buffer.put(msg.getType());</span><br><span class="line">            buffer.putInt(msg.getLength());</span><br><span class="line">            buffer.put(bt);</span><br><span class="line">            buffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">            buffer.get(result);</span><br><span class="line">            <span class="comment">/*System.out.println("使用二进制序列化的长度："+result.length);*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"使用二进制序列化100000次耗时："</span> +(endTime1 - startTime1));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="http://i.imgur.com/DE0Lovg.png" alt=""></p><p>结果为毫秒数，这个差距也是不小的。</p><p>结合以上我们看到：目前的序列化过程中使用java本身的肯定是不行，使用二进制编码的话又的我们自己去手写，所以为了让我们少搬砖前辈们早已经写好了工具让我们调用，目前社区比较活跃的有google的Protobuf和Apache的Thrift。</p><h4 id="2-protobuf序列化的使用"><a class="markdownIt-Anchor" href="#2-protobuf序列化的使用"></a> <strong>2. Protobuf序列化的使用</strong></h4><p>我们先来使用Protobuf进行序列化，他和XML，json一样都有自己的语法，xml的后缀是.xml，json文件的后缀是.json，自然Protobuf文件的后缀就是.proto（哈哈，当然不是全称）。</p><p>下面我们使用Protobuf来封装一段消息，通过一个案例简单介绍一下它的使用。</p><p>首先我们用Protobuf的语法格式来写一段需要序列化的对象，命名格式为：Msg.proto</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">option java_package = <span class="string">"cn.edu.hust.netty.demo10"</span>;</span><br><span class="line">option java_outer_classname = <span class="string">"MessageProto"</span>;</span><br><span class="line"></span><br><span class="line">message RequestMsg&#123;</span><br><span class="line">    required bytes msgType = <span class="number">1</span>;</span><br><span class="line">    required string receiveOne = <span class="number">2</span>;</span><br><span class="line">    required string msg = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ResponseMsg&#123;</span><br><span class="line">    required bytes msgType = <span class="number">1</span>;</span><br><span class="line">    required string receiveOne = <span class="number">2</span>;</span><br><span class="line">    required string msg = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Message.proto中的语法格式，详情大家google一下相关的说明，网上很多介绍，再次简单就上面的语法说明一下：</p><ul><li>option java_package：表示生成的.java文件的包名</li><li>option java_outer_classname：生成的java文件的文件名</li><li>message ： 为他的基本类型，如同java中的class一样</li></ul><p>字段修饰符：</p><ul><li>required：一个格式良好的消息一定要含有1个这种字段。表示该值是必须要设置的；</li><li>optional：消息格式中该字段可以有0个或1个值（不超过1个）。</li><li>repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。表示该值可以重复，相当于java中的List。</li></ul><p>字符类型稍微有些不同：double,float,int32,int64,bool(boolean)<br>,string,bytes。稍微有些不同，String，boolean，int有差别。</p><p>另外我们看到上面3个字段分别赋值了，这个值是什么意思呢？消息定义中，每个字段都有唯一的一个<strong>数字标识符</strong>。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。</p><p>关于Protobuf 的语法我们就简单的介绍这么多，更多细节大家自己去查阅文档吧。下面我们开始使用Protobuf 来进行序列化。</p><p>首先我们的在工程中引入protobuf的jar包，目前官方版本最高3.2，我们用3.0的吧：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Protobuf的文件已经定义好了，下就需要把它编译成java代码，这里我们的借助到google为我们提供的脚本工具protoc，<span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmNzZG4ubmV0L2Rvd25sb2FkL2Z1d2VuMTk4OS85NjMwNTk4" title="http://download.csdn.net/download/fuwen1989/9630598">链接在这里，点击下载<i class="fa fa-external-link"></i></span>这里提供的是protoc-3.0.2。要注意protoc的版本需要和Protobuf的版本对应上，不然不同的版本之间会有一些差异解析可能会有问题。现在知道我们为啥非得选用protobuf3.0.2版本吧，因为我没有找到别的版本的protoc。。。</p><p>下载好了我们解压缩然后把刚才写好的Msg.proto文件复制进去。</p><p><img src="http://i.imgur.com/FBV3PSK.png" alt=""></p><p>接着我们进cmd输入如下命令：</p><p><img src="http://i.imgur.com/U9Mzyst.png" alt=""></p><p>主要是第三句命令。如果你输入没有报错的话你的proto文件夹应该会生成一个子文件夹：</p><p><img src="http://i.imgur.com/WvNjIkK.png" alt=""></p><p>进去该文件夹你会看到已经生成了MessageProto.java文件，恭喜你，这时候你已经完成了protobuf序列化文件的生成。<strong>然后你把该文件拷贝至工程目录下</strong>。接下来我们用生成的文件去发消息吧。还是老套路服务端和客户端。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoBufServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProtoBufServer server = <span class="keyword">new</span> ProtoBufServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufDecoder(MessageProto.RequestMsg.getDefaultInstance()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtoBufServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageProto.ResponseMsg.Builder builder = MessageProto.ResponseMsg.newBuilder();</span><br><span class="line">        builder.setMsgType(ByteString.copyFromUtf8(<span class="string">"CBSP"</span>));</span><br><span class="line">        builder.setReceiveOne(<span class="string">"小红"</span>);</span><br><span class="line">        builder.setMsg(<span class="string">"你好，你有啥事"</span>);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageProto.RequestMsg m = (MessageProto.RequestMsg)msg;</span><br><span class="line">        System.out.println(<span class="string">"Client say: "</span>+m.getReceiveOne()+<span class="string">","</span>+m.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoBufClient</span><span class="params">(<span class="keyword">int</span> port, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProtoBufClient client = <span class="keyword">new</span> ProtoBufClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtoBufClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageProto.ResponseMsg m = (MessageProto.ResponseMsg)msg;</span><br><span class="line">        System.out.println(<span class="string">"Server say: "</span>+m.getReceiveOne()+<span class="string">","</span>+m.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageProto.RequestMsg.Builder builder = MessageProto.RequestMsg.newBuilder();</span><br><span class="line">        builder.setMsgType(ByteString.copyFromUtf8(<span class="string">"CBSP"</span>));</span><br><span class="line">        builder.setReceiveOne(<span class="string">"小明"</span>);</span><br><span class="line">        builder.setMsg(<span class="string">"你好，我找你有事"</span>);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务端和客户端，输出如下：</p><p><img src="http://i.imgur.com/bgl32QI.png" alt=""></p><p>最简单的protoBuf应用案例我们就写完了，真实的使用场景大同小异，随机应变即可。</p><h4 id="3-thrift序列化的使用"><a class="markdownIt-Anchor" href="#3-thrift序列化的使用"></a> <strong>3. thrift序列化的使用</strong></h4><p>哈哈，我本来是打算讲thrift的安装和使用的，但是现在却讲不了，因为这玩意儿的安装是个问题。由于我没有linux环境，thrift如果在linux环境下安装使用是挺简单的，但是在windows环境下挺麻烦。thrift在windows下，还使用C++，搭环境是最难的。 libthrift依赖boost libthriftnb依赖boost，libevent 等于你得安装boost，libevent 除此之外，还需要openssl 装openssl，又需要perl，nasm 期间，还会涉及版本兼容问题，总而言之，比较折磨，而这还仅是安装编译。</p><p>所以暂时我就跳过这一部分，等我安装linux环境之后再来讲解吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前几节我们学习过处理粘包和拆包的问题，用到了Netty提供的几个解码器对不同情况的问题进行处理。功能很是强大。我们有没有去想这么强大的功能是如何实现的呢？背后又用到了什么技术？这一节我们就来处理这个问题。了解一下编码解码到底是如何处理的。&lt;/p&gt;
&lt;p&gt;通常说的编码(En
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(四)-TCP粘包和拆包</title>
    <link href="http://blog.rickiyang.cn/posts/278c909d.html"/>
    <id>http://blog.rickiyang.cn/posts/278c909d.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.150Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道TCP是基于字节流的传输协议。那么数据在通信层传播其实就像河水一样并没有明显的分界线，而数据具体表示什么意思什么地方有句号什么地方有分号这个对于TCP底层来说并不清楚。应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段，之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。所以对于这个数据拆分成大包小包的问题就是我们今天要讲的粘包和拆包的问题。</p><h4 id="1-tcp粘包拆包问题说明"><a class="markdownIt-Anchor" href="#1-tcp粘包拆包问题说明"></a> 1 TCP粘包拆包问题说明</h4><p>粘包和拆包这两个概念估计大家还不清楚，通过下面这张图我们来分析一下：</p><p><img src="http://i.imgur.com/QcZkTTz.jpg" alt=""></p><p>假设客户端分别发送两个数据包D1,D2个服务端，但是发送过程中数据是何种形式进行传播这个并不清楚，分别有下列4种情况：</p><ol><li>服务端一次接受到了D1和D2两个数据包，两个包粘在一起，称为粘包；</li><li>服务端分两次读取到数据包D1和D2，没有发生粘包和拆包；</li><li>服务端分两次读到了数据包，第一次读到了D1和D2的部分内容，第二次读到了D2的剩下部分，这个称为拆包；</li><li>服务器分三次读到了数据部分，第一次读到了D1包，第二次读到了D2包的部分内容，第三次读到了D2包的剩下内容。</li></ol><h4 id="2-tcp粘包产生原因"><a class="markdownIt-Anchor" href="#2-tcp粘包产生原因"></a> 2. TCP粘包产生原因</h4><p>我们知道在TCP协议中，应用数据分割成TCP认为最适合发送的数据块，这部分是通过“MSS”（最大数据包长度）选项来控制的，通常这种机制也被称为一种协商机制，MSS规定了TCP传往另一端的最大数据块的长度。这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以往往MSS为1460。通讯双方会根据双方提供的MSS值得最小值确定为这次连接的最大MSS值。</p><p>tcp为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。</p><p>发生粘包拆包的原因主要有以下这些：</p><ol><li><p>应用程序写入数据的字节大小大于套接字发送缓冲区的大小将发生拆包；</p></li><li><p>进行MSS大小的TCP分段。MSS是TCP报文段中的数据字段的最大长度，当TCP报文长度-TCP头部长度&gt;mss的时候将发生拆包；</p></li><li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上,将发生粘包；</p></li><li><p>数据包大于MTU的时候将会进行切片。MTU即(Maxitum Transmission Unit) 最大传输单元,由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64bytes最大不能超过1518bytes,刨去以太网帧的帧头14Bytes和帧尾CRC校验部分4Bytes,那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。这个就是网络层协议非常关心的地方，因为网络层协议比如IP协议会根据这个值来决定是否把上层传下来的数据进行分片。</p></li></ol><h4 id="3-如何解决tcp粘包拆包"><a class="markdownIt-Anchor" href="#3-如何解决tcp粘包拆包"></a> 3. 如何解决TCP粘包拆包</h4><p>我们知道tcp是无界的数据流，且协议本身无法避免粘包，拆包的发生，那我们只能在应用层数据协议上，加以控制。通常在制定传输数据时，可以使用如下方法：</p><ol><li><p>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息；</p></li><li><p>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容；</p></li><li><p>设置消息边界，服务端从网络流中按消息边界分离出消息内容。比如在消息末尾加上换行符用以区分消息结束。</p></li></ol><p>当然应用层还有更多复杂的方式可以解决这个问题，这个就属于网络层的问题了，我们还是用java提供的方式来解决这个问题。我们先看一个例子看看粘包是如何发生的。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWordServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWordServer server = <span class="keyword">new</span> HelloWordServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWordServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String body = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"server receive order : "</span> + body + <span class="string">";the counter is: "</span> + ++counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();         </span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">    </span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端的逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWorldClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] req;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        req = (<span class="string">"Unless required by applicable law or agreed to in writing, software\n"</span> +</span><br><span class="line">                <span class="string">"  distributed under the License is distributed on an \"AS IS\" BASIS,\n"</span> +</span><br><span class="line">                <span class="string">"  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"</span> +</span><br><span class="line">                <span class="string">"  See the License for the specific language governing permissions and\n"</span> +</span><br><span class="line">                <span class="string">"  limitations under the License.This connector uses the BIO implementation that requires the JSSE\n"</span> +</span><br><span class="line">                <span class="string">"  style configuration. When using the APR/native implementation, the\n"</span> +</span><br><span class="line">                <span class="string">"  penSSL style configuration is required as described in the APR/native\n"</span> +</span><br><span class="line">                <span class="string">"  documentation.An Engine represents the entry point (within Catalina) that processes\n"</span> +</span><br><span class="line">                <span class="string">"  every request.  The Engine implementation for Tomcat stand alone\n"</span> +</span><br><span class="line">                <span class="string">"  analyzes the HTTP headers included with the request, and passes them\n"</span> +</span><br><span class="line">                <span class="string">"  on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software\n"</span> +</span><br><span class="line">                <span class="string">"# distributed under the License is distributed on an \"AS IS\" BASIS,\n"</span> +</span><br><span class="line">                <span class="string">"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"</span> +</span><br><span class="line">                <span class="string">"# See the License for the specific language governing permissions and\n"</span> +</span><br><span class="line">                <span class="string">"# limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log\n"</span> +</span><br><span class="line">                <span class="string">"# each component that extends LifecycleBase changing state:\n"</span> +</span><br><span class="line">                <span class="string">"#org.apache.catalina.util.LifecycleBase.level = FINE"</span></span><br><span class="line">                ).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf message;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上面的所有字符串作为一个消息体发送出去</span></span><br><span class="line">        message = Unpooled.buffer(req.length);</span><br><span class="line">        message.writeBytes(req);</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String buf = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"Now is : "</span> + buf + <span class="string">" ; the counter is : "</span>+ (++counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行客户端和服务端我们能看到：</p><p><img src="http://img.blog.csdn.net/20170327234130148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>我们看到这个长长的字符串被截成了2段发送，这就是发生了拆包的现象。同样粘包我们也很容易去模拟，我们把BaseClientHandler中的channelActive方法里面的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message = Unpooled.buffer(req.length);</span><br><span class="line">message.writeBytes(req);</span><br><span class="line">ctx.writeAndFlush(message);</span><br></pre></td></tr></table></figure><p>这几行代码是把我们上面的一长串字符转成的byte数组写进流里发送出去，那么我们可以在这里把上面发送消息的这几行循环几遍这样发送的内容增多了就有可能在拆包的时候把上一条消息的一部分分配到下一条消息里面了，修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    message = Unpooled.buffer(req.length);</span><br><span class="line">    message.writeBytes(req);</span><br><span class="line">    ctx.writeAndFlush(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改完之后我们再运行一下，输出太长不好截图，我们在输出结果中能看到循环3次之后的消息服务端收到的就不是之前的完整的一条了，而是被拆分了4次发送。</p><p>对于上面出现的粘包和拆包的问题，Netty已有考虑，并且有实施的方案：LineBasedFrameDecoder。<br>我们重新改写一下ServerChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">2048</span>));       </span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> BaseServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增：pipeline.addLast(new LineBasedFrameDecoder(2048))。同时，我们还得对上面发送的消息进行改造BaseClientHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] req;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    req = (<span class="string">"Unless required by applicable dfslaw or agreed to in writing, software"</span> +</span><br><span class="line">                <span class="string">"  distributed under the License is distributed on an \"AS IS\" BASIS,"</span> +</span><br><span class="line">                <span class="string">"  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."</span> +</span><br><span class="line">                <span class="string">"  See the License for the specific language governing permissions and"</span> +</span><br><span class="line">                <span class="string">"  limitations under the License.This connector uses the BIO implementation that requires the JSSE"</span> +</span><br><span class="line">                <span class="string">"  style configuration. When using the APR/native implementation, the"</span> +</span><br><span class="line">                <span class="string">"  penSSL style configuration is required as described in the APR/native"</span> +</span><br><span class="line">                <span class="string">"  documentation.An Engine represents the entry point (within Catalina) that processes"</span> +</span><br><span class="line">                <span class="string">"  every request.  The Engine implementation for Tomcat stand alone"</span> +</span><br><span class="line">                <span class="string">"  analyzes the HTTP headers included with the request, and passes them"</span> +</span><br><span class="line">                <span class="string">"  on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software"</span> +</span><br><span class="line">                <span class="string">"# distributed under the License is distributed on an \"AS IS\" BASIS,"</span> +</span><br><span class="line">                <span class="string">"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."</span> +</span><br><span class="line">                <span class="string">"# See the License for the specific language governing permissions and"</span> +</span><br><span class="line">                <span class="string">"# limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log"</span> +</span><br><span class="line">                <span class="string">"# each component that extends LifecycleBase changing state:"</span> +</span><br><span class="line">                <span class="string">"#org.apache.catalina.util.LifecycleBase.level = FINE\n"</span></span><br><span class="line">                ).getBytes();  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf message;</span><br><span class="line"></span><br><span class="line">        message = Unpooled.buffer(req.length);</span><br><span class="line">        message.writeBytes(req);</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String buf = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"Now is : "</span> + buf + <span class="string">" ; the counter is : "</span>+ (++counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉所有的&quot;\n&quot;,只保留字符串末尾的这一个。原因稍后再说。channelActive方法中我们不必再用循环多次发送消息了，只发送一次就好(第一个例子中发送一次的时候是发生了拆包的)，然后我们再次运行，大家会看到这么长一串字符只发送了一串就发送完毕。程序输出我就不截图了。下面来解释一下LineBasedFrameDecoder。</p><p>LineBasedFrameDecoder的工作原理是它依次遍历ByteBuf 中的可读字节，判断看是否有&quot;\n&quot; 或者&quot; \r\n&quot;，如果有，就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。它是以换行符为结束标志的解码器。支持携带结束符或者不携带结束符两种解码方式，同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读到的异常码流。这个对于我们确定消息最大长度的应用场景还是很有帮助。</p><p>对于上面的判断看是否有&quot;\n&quot; 或者&quot; \r\n&quot;以此作为结束的标志我们可能回想，要是没有&quot;\n&quot; 或者&quot; \r\n&quot;那还有什么别的方式可以判断消息是否结束呢。别担心，Netty对于此已经有考虑，还有别的解码器可以帮助我们解决问题，下节我们继续学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们都知道TCP是基于字节流的传输协议。那么数据在通信层传播其实就像河水一样并没有明显的分界线，而数据具体表示什么意思什么地方有句号什么地方有分号这个对于TCP底层来说并不清楚。应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis Generator最完整配置详解</title>
    <link href="http://blog.rickiyang.cn/posts/a9e1e2fd.html"/>
    <id>http://blog.rickiyang.cn/posts/a9e1e2fd.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.164Z</updated>
    
    <content type="html"><![CDATA[<p>转自：【<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2UwOWQyMzcwYjc5NiVFMyU4MCU5MQ==" title="http://www.jianshu.com/p/e09d2370b796%E3%80%91">http://www.jianshu.com/p/e09d2370b796】<i class="fa fa-external-link"></i></span></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;  </span><br><span class="line">&lt;!DOCTYPE generatorConfiguration  </span><br><span class="line">  PUBLIC <span class="string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span>  </span><br><span class="line"><span class="string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;  </span><br><span class="line">&lt;!-- 配置生成器 --&gt;  </span><br><span class="line">&lt;generatorConfiguration&gt;  </span><br><span class="line">&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项  </span><br><span class="line">    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties          </span><br><span class="line">    url：配置资源加载地质，使用URL的方式，比如file:<span class="comment">///C:/myfolder/generatorConfig.properties.  </span></span><br><span class="line">    注意，两个属性只能选址一个;  </span><br><span class="line">  </span><br><span class="line">    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用  </span><br><span class="line">&lt;properties resource=<span class="string">""</span> url=<span class="string">""</span> /&gt;  </span><br><span class="line"> --&gt;  </span><br><span class="line">  </span><br><span class="line"> &lt;!-- 在MBG工作的时候，需要额外加载的依赖包  </span><br><span class="line">     location属性指明加载jar/zip包的全路径  </span><br><span class="line">&lt;classPathEntry location=<span class="string">"/Program Files/IBM/SQLLIB/java/db2java.zip"</span> /&gt;  </span><br><span class="line">  --&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!--   </span><br><span class="line">    context:生成一组对象的环境   </span><br><span class="line">    id:必选，上下文id，用于在生成错误时提示  </span><br><span class="line">    defaultModelType:指定生成对象的样式  </span><br><span class="line">        <span class="number">1</span>，conditional：类似hierarchical；  </span><br><span class="line">        <span class="number">2</span>，flat：所有内容（主键，blob）等全部生成在一个对象中；  </span><br><span class="line">        <span class="number">3</span>，hierarchical：主键生成一个XXKey对象(key <span class="class"><span class="keyword">class</span>)，<span class="title">Blob</span>等单独生成一个对象，其他简单属性在一个对象中(<span class="title">record</span> <span class="title">class</span>)  </span></span><br><span class="line">    targetRuntime:  </span><br><span class="line">        <span class="number">1</span>，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；  </span><br><span class="line">        <span class="number">2</span>，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；  </span><br><span class="line">    introspectedColumnImpl：类全限定名，用于扩展MBG  </span><br><span class="line">--&gt;  </span><br><span class="line">&lt;context id=<span class="string">"mysql"</span> defaultModelType=<span class="string">"hierarchical"</span> targetRuntime=<span class="string">"MyBatis3Simple"</span> &gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 自动识别数据库关键字，默认<span class="keyword">false</span>，如果设置为<span class="keyword">true</span>，根据SqlReservedWords中定义的关键字列表；  </span><br><span class="line">        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"autoDelimitKeywords"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">    &lt;!-- 生成的Java文件的编码 --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"javaFileEncoding"</span> value=<span class="string">"UTF-8"</span>/&gt;  </span><br><span class="line">    &lt;!-- 格式化java代码 --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"javaFormatter"</span> value=<span class="string">"org.mybatis.generator.api.dom.DefaultJavaFormatter"</span>/&gt;  </span><br><span class="line">    &lt;!-- 格式化XML代码 --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"xmlFormatter"</span> value=<span class="string">"org.mybatis.generator.api.dom.DefaultXmlFormatter"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"beginningDelimiter"</span> value=<span class="string">"`"</span>/&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"endingDelimiter"</span> value=<span class="string">"`"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 必须要有的，使用这个配置链接数据库  </span><br><span class="line">        <span class="meta">@TODO</span>:是否可以扩展  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;jdbcConnection driverClass=<span class="string">"com.mysql.jdbc.Driver"</span> connectionURL=<span class="string">"jdbc:mysql:///pss"</span> userId=<span class="string">"root"</span> password=<span class="string">"admin"</span>&gt;  </span><br><span class="line">        &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;  </span><br><span class="line">    &lt;/jdbcConnection&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- java类型处理器   </span><br><span class="line">        用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；  </span><br><span class="line">        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；   </span><br><span class="line">    --&gt;  </span><br><span class="line">    &lt;javaTypeResolver type=<span class="string">"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl"</span>&gt;  </span><br><span class="line">        &lt;!--   </span><br><span class="line">            <span class="keyword">true</span>：使用BigDecimal对应DECIMAL和 NUMERIC数据类型  </span><br><span class="line">            <span class="keyword">false</span>：默认,  </span><br><span class="line">                scale&gt;<span class="number">0</span>;length&gt;<span class="number">18</span>：使用BigDecimal;  </span><br><span class="line">                scale=<span class="number">0</span>;length[<span class="number">10</span>,<span class="number">18</span>]：使用Long；  </span><br><span class="line">                scale=<span class="number">0</span>;length[<span class="number">5</span>,<span class="number">9</span>]：使用Integer；  </span><br><span class="line">                scale=<span class="number">0</span>;length&lt;<span class="number">5</span>：使用Short；  </span><br><span class="line">         --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"forceBigDecimals"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">    &lt;/javaTypeResolver&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- java模型创建器，是必须要的元素  </span><br><span class="line">        负责：<span class="number">1</span>，key类（见context的defaultModelType）；<span class="number">2</span>，java类；<span class="number">3</span>，查询类  </span><br><span class="line">        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；  </span><br><span class="line">        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;javaModelGenerator targetPackage=<span class="string">"com._520it.mybatis.domain"</span> targetProject=<span class="string">"src/main/java"</span>&gt;  </span><br><span class="line">        &lt;!--  <span class="keyword">for</span> MyBatis3/MyBatis3Simple  </span><br><span class="line">            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；  </span><br><span class="line">         --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"constructorBased"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层<span class="keyword">package</span>，最终生成的类放在这个<span class="keyword">package</span>下，默认为<span class="keyword">false</span> --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"enableSubPackages"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- <span class="keyword">for</span> MyBatis3 / MyBatis3Simple  </span><br><span class="line">            是否创建一个不可变的类，如果为<span class="keyword">true</span>，  </span><br><span class="line">            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类  </span><br><span class="line">         --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"immutable"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 设置一个根对象，  </span><br><span class="line">            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项  </span><br><span class="line">            注意：如果在key <span class="class"><span class="keyword">class</span>或者<span class="title">record</span> <span class="title">class</span>中有<span class="title">root</span> <span class="title">class</span>相同的属性，<span class="title">MBG</span>就不会重新生成这些属性了，包括：  </span></span><br><span class="line"><span class="class">                1，属性名相同，类型相同，有相同的<span class="title">getter</span>/<span class="title">setter</span>方法；  </span></span><br><span class="line"><span class="class">         --&gt;  </span></span><br><span class="line"><span class="class">        &lt;<span class="title">property</span> <span class="title">name</span></span>=<span class="string">"rootClass"</span> value=<span class="string">"com._520it.mybatis.domain.BaseDomain"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"trimStrings"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">    &lt;/javaModelGenerator&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 生成SQL map的XML文件生成器，  </span><br><span class="line">        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），  </span><br><span class="line">            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置  </span><br><span class="line">        targetPackage/targetProject:同javaModelGenerator  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;sqlMapGenerator targetPackage=<span class="string">"com._520it.mybatis.mapper"</span> targetProject=<span class="string">"src/main/resources"</span>&gt;  </span><br><span class="line">        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层<span class="keyword">package</span>，最终生成的类放在这个<span class="keyword">package</span>下，默认为<span class="keyword">false</span> --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"enableSubPackages"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">    &lt;/sqlMapGenerator&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口   </span><br><span class="line">        targetPackage/targetProject:同javaModelGenerator  </span><br><span class="line">        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：  </span><br><span class="line">            <span class="number">1</span>，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；  </span><br><span class="line">            <span class="number">2</span>，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；  </span><br><span class="line">            <span class="number">3</span>，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；  </span><br><span class="line">        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER  </span><br><span class="line">    --&gt;  </span><br><span class="line">    &lt;javaClientGenerator targetPackage=<span class="string">"com._520it.mybatis.mapper"</span> type=<span class="string">"ANNOTATEDMAPPER"</span> targetProject=<span class="string">"src/main/java"</span>&gt;  </span><br><span class="line">        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层<span class="keyword">package</span>，最终生成的类放在这个<span class="keyword">package</span>下，默认为<span class="keyword">false</span> --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"enableSubPackages"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查  </span><br><span class="line">        &lt;property name=<span class="string">"rootInterface"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">    &lt;/javaClientGenerator&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素  </span><br><span class="line">        选择的table会生成一下文件：  </span><br><span class="line">        <span class="number">1</span>，SQL map文件  </span><br><span class="line">        <span class="number">2</span>，生成一个主键类；  </span><br><span class="line">        <span class="number">3</span>，除了BLOB和主键的其他字段的类；  </span><br><span class="line">        <span class="number">4</span>，包含BLOB的类；  </span><br><span class="line">        <span class="number">5</span>，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；  </span><br><span class="line">        <span class="number">6</span>，Mapper接口（可选）  </span><br><span class="line">  </span><br><span class="line">        tableName（必要）：要生成对象的表名；  </span><br><span class="line">        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会  </span><br><span class="line">            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：  </span><br><span class="line">            <span class="number">1</span>，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；  </span><br><span class="line">            <span class="number">2</span>，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；  </span><br><span class="line">            <span class="number">3</span>，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；  </span><br><span class="line">            <span class="number">4</span>，否则，使用指定的大小写格式查询；  </span><br><span class="line">        另外的，如果在创建表的时候，使用的<span class="string">""</span>把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；  </span><br><span class="line">        这个时候，请设置delimitIdentifiers=<span class="string">"true"</span>即可保留大小写格式；  </span><br><span class="line">  </span><br><span class="line">        可选：  </span><br><span class="line">        <span class="number">1</span>，schema：数据库的schema；  </span><br><span class="line">        <span class="number">2</span>，catalog：数据库的catalog；  </span><br><span class="line">        <span class="number">3</span>，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName  </span><br><span class="line">        <span class="number">4</span>，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；  </span><br><span class="line">        <span class="number">5</span>，enableInsert（默认<span class="keyword">true</span>）：指定是否生成insert语句；  </span><br><span class="line">        <span class="number">6</span>，enableSelectByPrimaryKey（默认<span class="keyword">true</span>）：指定是否生成按照主键查询对象的语句（就是getById或get）；  </span><br><span class="line">        <span class="number">7</span>，enableSelectByExample（默认<span class="keyword">true</span>）：MyBatis3Simple为<span class="keyword">false</span>，指定是否生成动态查询语句；  </span><br><span class="line">        <span class="number">8</span>，enableUpdateByPrimaryKey（默认<span class="keyword">true</span>）：指定是否生成按照主键修改对象的语句（即update)；  </span><br><span class="line">        <span class="number">9</span>，enableDeleteByPrimaryKey（默认<span class="keyword">true</span>）：指定是否生成按照主键删除对象的语句（即delete）；  </span><br><span class="line">        <span class="number">10</span>，enableDeleteByExample（默认<span class="keyword">true</span>）：MyBatis3Simple为<span class="keyword">false</span>，指定是否生成动态删除语句；  </span><br><span class="line">        <span class="number">11</span>，enableCountByExample（默认<span class="keyword">true</span>）：MyBatis3Simple为<span class="keyword">false</span>，指定是否生成动态查询总条数语句（用于分页的总条数查询）；  </span><br><span class="line">        <span class="number">12</span>，enableUpdateByExample（默认<span class="keyword">true</span>）：MyBatis3Simple为<span class="keyword">false</span>，指定是否生成动态修改语句（只修改对象中不为空的属性）；  </span><br><span class="line">        <span class="number">13</span>，modelType：参考context元素的defaultModelType，相当于覆盖；  </span><br><span class="line">        <span class="number">14</span>，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）  </span><br><span class="line">        <span class="number">15</span>，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为<span class="keyword">false</span>，delimitIdentifiers参考context的属性  </span><br><span class="line">  </span><br><span class="line">        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;table tableName=<span class="string">"userinfo"</span> &gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"constructorBased"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 默认为<span class="keyword">false</span>，如果设置为<span class="keyword">true</span>，在生成的SQL中，table名字不会加上catalog或schema； --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"ignoreQualifiersAtRuntime"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"immutable"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 指定是否只生成domain类，如果设置为<span class="keyword">true</span>，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"modelOnly"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 参考 javaModelGenerator 的 rootClass 属性   </span><br><span class="line">        &lt;property name=<span class="string">"rootClass"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 参考javaClientGenerator 的  rootInterface 属性  </span><br><span class="line">        &lt;property name=<span class="string">"rootInterface"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">        --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog   </span><br><span class="line">        &lt;property name=<span class="string">"runtimeCatalog"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">        --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema   </span><br><span class="line">        &lt;property name=<span class="string">"runtimeSchema"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">        --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename   </span><br><span class="line">        &lt;property name=<span class="string">"runtimeTableName"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">        --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 注意，该属性只针对MyBatis3Simple有用；  </span><br><span class="line">            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；  </span><br><span class="line">         --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"selectAllOrderByClause"</span> value=<span class="string">"age desc,username asc"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 如果设置为<span class="keyword">true</span>，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"useActualColumnNames"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- generatedKey用于生成生成主键的方法，  </span><br><span class="line">            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选  </span><br><span class="line">            column:主键的列名；  </span><br><span class="line">            sqlStatement：要生成的selectKey语句，有以下可选项：  </span><br><span class="line">                Cloudscape:相当于selectKey的SQL为： <span class="function">VALUES <span class="title">IDENTITY_VAL_LOCAL</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                DB2       :相当于selectKey的SQL为： VALUES <span class="title">IDENTITY_VAL_LOCAL</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                DB2_MF    :相当于selectKey的SQL为：SELECT <span class="title">IDENTITY_VAL_LOCAL</span><span class="params">()</span> FROM SYSIBM.SYSDUMMY1  </span></span><br><span class="line"><span class="function">                Derby      :相当于selectKey的SQL为：VALUES <span class="title">IDENTITY_VAL_LOCAL</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                HSQLDB      :相当于selectKey的SQL为：CALL <span class="title">IDENTITY</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                Informix  :相当于selectKey的SQL为：select <span class="title">dbinfo</span><span class="params">(<span class="string">'sqlca.sqlerrd1'</span>)</span> from systables where tabid</span>=<span class="number">1</span>  </span><br><span class="line">                MySql      :相当于selectKey的SQL为：<span class="function">SELECT <span class="title">LAST_INSERT_ID</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                SqlServer :相当于selectKey的SQL为：SELECT <span class="title">SCOPE_IDENTITY</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY  </span></span><br><span class="line"><span class="function">                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys</span>=<span class="string">"true"</span>和keyProperty属性  </span><br><span class="line">        &lt;generatedKey column=<span class="string">""</span> sqlStatement=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!--   </span><br><span class="line">            该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，  </span><br><span class="line">            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；  </span><br><span class="line">            那么就可以设置searchString为<span class="string">"^CUST_"</span>，并使用空白替换，那么生成的Customer对象中的属性名称就不是  </span><br><span class="line">            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；  </span><br><span class="line">  </span><br><span class="line">            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，  </span><br><span class="line">            如果使用了columnOverride元素，该属性无效；  </span><br><span class="line">  </span><br><span class="line">        &lt;columnRenamingRule searchString=<span class="string">""</span> replaceString=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">         &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；  </span><br><span class="line">             column:要重新设置的列名；  </span><br><span class="line">             注意，一个table元素中可以有多个columnOverride元素哈~  </span><br><span class="line">          --&gt;  </span><br><span class="line"></span><br><span class="line">        &lt;!--生成的实体类字段与表中字段名不同，property属性制定实体类字段名称--&gt;</span><br><span class="line">          &lt;columnOverride column=<span class="string">"para_index"</span> property=<span class="string">"index"</span>&gt;</span><br><span class="line">            &lt;/columnOverride&gt;</span><br><span class="line">            </span><br><span class="line">         &lt;columnOverride column=<span class="string">"username"</span>&gt;  </span><br><span class="line">             &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;  </span><br><span class="line">             &lt;property name=<span class="string">"property"</span> value=<span class="string">"userName"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">             &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名  </span><br><span class="line">             &lt;property name=<span class="string">"javaType"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">              --&gt;  </span><br><span class="line">  </span><br><span class="line">             &lt;!-- jdbcType用于指定该列的JDBC类型   </span><br><span class="line">             &lt;property name=<span class="string">"jdbcType"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">              --&gt;  </span><br><span class="line">  </span><br><span class="line">             &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名  </span><br><span class="line">                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler  </span><br><span class="line">                 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述  </span><br><span class="line">             &lt;property name=<span class="string">"jdbcType"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">             --&gt;  </span><br><span class="line">  </span><br><span class="line">             &lt;!-- 参考table元素的delimitAllColumns配置，默认为<span class="keyword">false</span>  </span><br><span class="line">             &lt;property name=<span class="string">"delimitedColumnName"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">              --&gt;  </span><br><span class="line">         &lt;/columnOverride&gt;  </span><br><span class="line">  </span><br><span class="line">         &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现   </span><br><span class="line">             column:指定要忽略的列的名字；  </span><br><span class="line">             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为<span class="keyword">false</span>  </span><br><span class="line">  </span><br><span class="line">             注意，一个table元素中可以有多个ignoreColumn元素  </span><br><span class="line">         &lt;ignoreColumn column=<span class="string">"deptId"</span> delimitedColumnName=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">    &lt;/table&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/context&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：【&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2UwOWQyMzcwYjc5NiVFMyU4MCU5MQ==&quot; title=&quot;http://www.jianshu.com/p/e09d
      
    
    </summary>
    
      <category term="Mybatis" scheme="http://blog.rickiyang.cn/categories/Mybatis/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(一)-为什么选择Netty</title>
    <link href="http://blog.rickiyang.cn/posts/704e9e4d.html"/>
    <id>http://blog.rickiyang.cn/posts/704e9e4d.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.148Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们简单学习了NIO。我们知道java的I/O模型一共有四种，分别是：传统的BIO，伪异步I/O，NIO和AIO。为了澄清概念和分清区别，我们还是先简单的介绍一下他们的概念，然后再去比较优劣。以及探讨我们为什么使用netty。</p><h4 id="1概念澄清"><a class="markdownIt-Anchor" href="#1概念澄清"></a> <strong>1.概念澄清</strong></h4><h5 id="11-bio"><a class="markdownIt-Anchor" href="#11-bio"></a> 1.1 BIO</h5><p>BIO，即Blocking I/O。网络编程的基本模型是Client/Server 模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息(绑定的Ip 地址和监听端口) ，客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建在成功，双方就可以通过网络套接字( Socket ) 进行通信。在基于传统同步阻塞模型开发中， ServerSocket 负责绑定IP 地址，启动监听端口:Socket 负责发起连接操作。连接成功之后，双方通过输入和输出流进行<strong>同步阻塞式通信</strong>。</p><p>BIO通信模型图：</p><p><img src="http://i.imgur.com/y9lBJlB.png" alt=""></p><p>解释一下上图：</p><p>采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端， 统程销毁。这就是典型的一请求一回答通信模型。</p><p>对于这种IO模型我们知道：用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。即在读写数据过程中会发生阻塞现象。</p><h5 id="12-伪异步io"><a class="markdownIt-Anchor" href="#12-伪异步io"></a> 1.2 <strong>伪异步IO</strong></h5><p>为了解决同步阻塞 I/O 面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M: 线程池最大线程数N 的比例关系，其中M 可以远远大于N。通过线程地可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p><p>伪异步IO通信模型图：</p><p><img src="http://i.imgur.com/FrAFXdo.png" alt=""></p><p>采用线程池和任务队列可以实现伪异步I/O通信框架。当有新的客户端接入时，将客户端的Socket 封装成一个Task (该任务实现java.lang.<br>Runnable 接口）投递到后端的线程池中进行处理， JDK 的线程将维护一个消息队列和N个活跃线程， 对消息队列中的任务进行处理。由于统程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的， 无论多少个客户端并发访问， 都不会导致资源的耗尽和省机。</p><p>伪异步I/O 通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。但是由于它底层的通信依然采用同步阻塞模型，因此无法从根本上解决问题。伪异步I/O 实际上仅仅是对之前I/O 线程模型的一个简单优化，它无法从根本上解决同步I/O 导致的通信线程阻塞问题。下面我们就简单分析下通信对方返回应答时间过长会引起的级联故障。</p><ol><li>服务端处理缓慢，返回应答消息耗费60s，平时只需要10ms;</li><li>采用伪异步I/O 的线程在读取故障服务节点的响应，由于读/取输入流是阻塞的，它将会被同步阻塞60s;</li><li>假如所有的可用线程都被故障服务器阻塞，那后续的所有的I/O消息都将在队列中排队;</li><li>由于线程地采用阻塞队列实现，当队列积满之后，后续入队列的操作将被阻塞;</li><li>由于前端只有一个Accptor 线程接收客户端接入，它被阻塞在线程池的同步阻塞队列之后，新的客户端请求消息将被拒绝，客户端会发生大量的连接超时;</li><li>由于几于所有的连接都超时，调用者会认为系统已经崩溃，无法接收新的请求消息。</li></ol><p>如何破解这个难题?下面我们再看一下NIO。</p><h5 id="13-nio"><a class="markdownIt-Anchor" href="#13-nio"></a> 1.3 <strong>NIO</strong></h5><p>NIO,很多人叫他New I/O，由于之前老的I/O 类库是阻塞I/O ，New I/O 类库的目标就是要让Java 支持非阻塞I/O，所以，更多的人喜欢称之为非阻塞I/O(Non-block I/O)。</p><p>与Socket类和ServerSocket 类相对应， NIO也提供了SocketChannel 和ServerSocketChannel两种不同的套接字通道实现。这两种新增的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单，但是性能和可靠性都不好，非阻塞模式则正好相反。开发人员可以根据自己的需要来选择合适的模式。一般来说，低负载、低并发的应用程序可以选择同步阻塞I/O以降低编程复杂度:对于高负载、高并发的网络应用，需要使用NIO 的非阻塞模式进行开发。</p><p>前面我们已经对NIO进行了介绍，我们知道NIO中引入了缓冲区Buffer，通道Channel和多路复用器Selector的概念。一个多路复用器Selector 可以同时轮询多个Channel，而Channel又是全双工的，同时支持读写操作，使用NIO 编程的优点总结如下：</p><ol><li><p>客户端发起的连接操作是异步的，可以通过在多路复用器注册OP_CONNECT 等待后续结果，不需要像之前的客户端那样被同步阻塞。</p></li><li><p>SocketChannel 的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样I/O 通信线程就可以处理其他的链路，不需要同步等待这个链路可用。</p></li><li><p>线程模型的优化:由于JDK 的Selector 在Linux 等主流操作系统上通过epoll 实现，它没有连接句柄数的限制(只受限于操作系统的最大句柄数或者对单个进程的句柄限制)，这意味着一个Selector 线程可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线性下降。因此，它非常适合做高性能、高负载的网络服务器。</p></li></ol><h5 id="14-aio"><a class="markdownIt-Anchor" href="#14-aio"></a> 1.4 <strong>AIO</strong></h5><p>NIO 2.0 引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。异步通道提供以下两种方式获取获取操作结果：</p><pre><code>▷通过java.util.concurrent.Future 类来表示异步操作的结果;▷在执行异步操作的时候传入一个java.nio.channels;</code></pre><p>NIO 2.0 的异步套接字通道是真正的异步非阻塞I/O ，对应于UNIX 网络编程中的事件<br>驱动I/O (AIO) 。它不需要通过多路复用器( Selector) 对注册的通道进行轮询操作即可实<br>现异步读写，从而简化了NIO 的编程模型。</p><p>前面对不同的I/O模型进行了简单介绍，不同的I/O 模型由于线程模型、API 等差别很大，所以用法的差异也非常大。我们用一个表格来做一个统一说明：</p><p><img src="http://i.imgur.com/wwVG3tz.png" alt=""></p><h4 id="2-为什么用netty"><a class="markdownIt-Anchor" href="#2-为什么用netty"></a> 2. 为什么用Netty</h4><p>开发出高质量的NIO 程序并不是一件简单的事情，除去NIO 固有的复杂性和Bug不谈，作为一个NIO 服务端,需要能够处理网络的闪断、客户端的重复接入、客户端的安全认证、消息的编解码、半包读写等情况， 如果你没有足够的NIO 编程经验积累， 一个NIO 框架的稳定往往需要半年甚至更长的时间。更为糟糕的是， 一旦在生产环境中发生问题， 往往会导致跨节点的服务调用中断， 严重的可能<br>会导致整个集群环境都不可用， 需要重启服务器，这种非正常停机会带来巨大的损失。</p><p>从可维护性角度看，由于NIO 采用了异步非阻塞编程模型，而且是一个I/O 线程处理多条链路，它的调试和跟踪非常麻烦， 特别是生产环境中的问题，我们无法进行有效的调试和跟踪， 往往只能靠一些日志来帮助分析，定位难度很大。</p><p>对于java原生的IO我们之所以不选择使用是因为：</p><ol><li><p>NIO的类库和API繁杂使用麻烦，你需要熟练掌握Selectol,ServerSocketChannel,<br>SocketChannel,ByteBuffer 等。</p></li><li><p>需妥具备其他的额外技能做制垫，例如熟悉Java 多线程编程。这是因为NIO编程涉及到Reactor 模式，你必须对多钱程和网络编程非常如悉，才能编写出高质量的NIO程序。</p></li><li><p>可靠性能力补齐， 工作量和难度都非常大。例如客户端面临断连重连、网络间断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题， NI0 编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。</p></li><li><p>JDK NIO的BUG，比如epoll bug，这个BUG会在linux上导致cpu 100%，使得nio server/client不可用，这个BUG直到jdk 6u4才解决，但是直到JDK1.7中仍然有这个问题，该问题并未被完全解决，只是发生的频率降低了而已。</p></li></ol><p>基于上述原因大多数场景下都不建议直接使原生NIO，除非你精通NIO编程或者是有特殊的需要，否则作为服务器编程的NIO可能会带来巨大的生产隐患。</p><p>关于Netty：</p><p>Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty的NIO框架构建。</p><p>与Netty同样功能的NIO框架还有Mina，Netty的主导作者与Mina的主导作者是同一人，在设计理念上与Mina基本上是一致的。Mina出身于开源界的大牛Apache组织，Netty出身于商业开源大亨Jboss。<br>这几年Netty社区相对比较活跃，所以我们就先选择Netty作为入手网络编程的首选，有时间再学习一下Mina。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们简单学习了NIO。我们知道java的I/O模型一共有四种，分别是：传统的BIO，伪异步I/O，NIO和AIO。为了澄清概念和分清区别，我们还是先简单的介绍一下他们的概念，然后再去比较优劣。以及探讨我们为什么使用netty。&lt;/p&gt;
&lt;h4 id=&quot;1概念澄清&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq实战之消息持久化(六)</title>
    <link href="http://blog.rickiyang.cn/posts/af8467f6.html"/>
    <id>http://blog.rickiyang.cn/posts/af8467f6.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.147Z</updated>
    
    <content type="html"><![CDATA[<p>对于activemq消息的持久化我们在第二节的时候就简单介绍过，今天我们详细的来分析一下activemq的持久化过程以及持久化插件。在生产环境中为确保消息的可靠性，我们肯定的面临持久化消息的问题，今天就一起来攻克他吧。</p><h4 id="1-持久化方式介绍"><a class="markdownIt-Anchor" href="#1-持久化方式介绍"></a> <strong>1. 持久化方式介绍</strong></h4><p>前面我们也简单提到了activemq提供的插件式的消息存储，在这里再提一下，主要有以下几种方式：</p><ol><li>AMQ消息存储-基于文件的存储方式，是activemq开始的版本默认的消息存储方式；</li><li>KahaDB消息存储-提供了容量的提升和恢复能力，是现在的默认存储方式；</li><li>JDBC消息存储-消息基于JDBC存储的；</li><li>Memory消息存储-基于内存的消息存储，由于内存不属于持久化范畴，而且如果使用内存队列，可以考虑使用更合适的产品，如ZeroMQ。所以内存存储不在讨论范围内。</li></ol><p>上面几种消息存储方式对于消息存储的逻辑来说并没有什么区别，只是在性能以及存储方式上来说有所不同。但是对于消息发送的方式来说，p2p和Pub/Sub两种类型的消息他们的持久化方式却是不同的：</p><p>对于点对点的消息一旦消费者完成消费这条消息将从broker上删除；对于发布订阅类型的消息，即使所有的订阅者都完成了消费，Broker也不一定会马上删除无用消息，而是保留推送历史，之后会异步清除无用消息。而每个订阅者消费到了哪条消息的offset会记录在Broker，以免下次重复消费。因为消息是顺序消费，先进先出，所以只需要记录上次消息消费到哪里就可以了。</p><p>因为AMQ现在已经被不再使用被KahaDB所替代，所以我们就讲KahaDB，JDBC消息存储在许多对可靠性要求高而对性能要求低一些的大公司还是经常使用的，下面我们就这两种持久化方式的使用做一节专题。</p><h4 id="2-kahadb"><a class="markdownIt-Anchor" href="#2-kahadb"></a> <strong>2. Kahadb</strong></h4><p>说到Kahadb之前我们还是得提到他的前身AMQ，AMQ是一种文件存储形式，他具有写入速度快和容易恢复的特点，消息存储在一个个的文件里，文件默认大小为32M，超过这个大小的消息将会存入下一个文件。当一个文件中的消息已经全部消费，那么这个文件将被标志我可删除，在下一个清除阶段这个文件将被删除。</p><p>如果需要使用持久化，则需要在前文中的配置文件applicationContext-ActiveMQ.xml中增加如下配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;</span><br><span class="line">&lt;amqPersistenceAdapterdirectory=<span class="string">"activemq-data"</span>maxFileLength=<span class="string">"32mb"</span>/&gt;</span><br><span class="line">&lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>directory : 指定持久化消息的存储目录<br>journalMaxFileLength : 指定保存消息的日志文件大小，具体根据你的实际应用配置</p><p>我们的Kahadb也是基于文件的本地数据库存储形式，他虽然没有AMQ快，但是扩展性很强，从activemq5.4版本之后就把Kahadb作为默认的持久化方式。</p><p>Kahadb的配置方式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;  </span><br><span class="line">   &lt;kahaDB directory=<span class="string">"activemq-data"</span>journalMaxFileLength=<span class="string">"32mb"</span>/&gt;  </span><br><span class="line">&lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>KahaDB的属性件下表格：</p><table><tr style="background-color: #737373">    <td>属性名称</td>    <td>属性值</td>    <td>描述</td></tr><tr>    <td>directory</td>    <td>activemq-data</td>    <td>消息文件和日志的存储目录</td></tr><tr>    <td>indexWriteBatchSize</td>    <td>1000</td>    <td>一批索引的大小，当要更新的索引量到达这个值时，更新到消息文件中</td></tr><tr>    <td>indexCacheSize</td>    <td>1000</td>    <td>内存中，索引的页大小</td></tr><tr>    <td>enableIndexWriteAsync</td>    <td>false</td>    <td>索引是否异步写到消息文件中</td></tr><tr>    <td>journalMaxFileLength</td>    <td>32mb</td>    <td>一个消息文件的大小</td></tr><tr>    <td>enableJournalDiskSyncs</td>    <td>true</td>    <td>是否讲非事务的消息同步写入到磁盘</td></tr><tr>    <td>cleanupInterval</td>    <td>30000</td>    <td>清除操作周期，单位ms</td></tr><tr>    <td>checkpointInterval</td>    <td>5000</td>    <td>索引写入到消息文件的周期，单位ms</td></tr><tr>    <td>ignoreMissingJournalfiles</td>    <td>false</td>    <td>忽略丢失的消息文件，false，当丢失了消息文件，启动异常</td></tr><tr>    <td>checkForCorruptJournalFiles</td>    <td>false</td>    <td>检查消息文件是否损坏，true，检查发现损坏会尝试修复</td></tr><tr>    <td>checksumJournalFiles</td>    <td>false</td>    <td>产生一个checksum，以便能够检测journal文件是否损坏。</td></tr><tr>    <td>5.4版本之后有效的属性:</td>    <td></td>    <td></td></tr><tr>    <td>archiveDataLogs</td>    <td>false</td>    <td>当为true时，归档的消息文件被移到directoryArchive,而不是直接删除</td></tr><tr>    <td>directoryArchive</td>    <td>null</td>    <td>存储被归档的消息文件目录</td></tr><tr>    <td>databaseLockedWaitDelay</td>    <td>10000</td>    <td>在使用负载时，等待获得文件锁的延迟时间，单位ms</td></tr><tr>    <td>maxAsyncJobs</td>    <td>10000</td>    <td>同个生产者产生等待写入的异步消息最大量</td></tr><tr>    <td>concurrentStoreAndDispatchTopics</td>    <td>false</td>    <td>当写入消息的时候，是否转发主题消息</td></tr><tr>    <td>concurrentStoreAndDispatchQueues</td>    <td>true</td>    <td>当写入消息的时候，是否转发队列消息</td></tr><tr>    <td>5.6版本之后有效的属性:</td>    <td></td>    <td></td></tr><tr>    <td>archiveCorruptedIndex</td>    <td>false</td>    <td>是否归档错误的索引</td></tr></table><p>由于在ActiveMQ V5.4+的版本中，KahaDB是默认的持久化存储方案。所以即使你不配置任何的KahaDB参数信息，ActiveMQ也会启动KahaDB。这种情况下，KahaDB文件所在位置是你的ActiveMQ安装路径下的/data/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>b</mi><mi>r</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><mi mathvariant="normal">/</mi><mi>K</mi><mi>a</mi><mi>h</mi><mi>a</mi><mi>D</mi><mi>B</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">录</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi></mrow><annotation encoding="application/x-tex">{broker.Name}/KahaDB子目录。其中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">a</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">录</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span></span></span></span>{<span class="exturl" data-url="aHR0cDovL2Jyb2tlci5OYW1l" title="http://broker.Name">broker.Name<i class="fa fa-external-link"></i></span>}代表这个ActiveMQ服务节点的名称。下面我把刚启动服务并发送了消息之后的activemq安装目录打开给大家看看：</p><p><img src="http://img.blog.csdn.net/20170512000936999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>正式的生产环境还是建议在主配置文件中明确设置KahaDB的工作参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook=<span class="string">"false"</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;persistenceAdapter&gt;</span><br><span class="line">    &lt;kahaDB directory=<span class="string">"activemq-data"</span></span><br><span class="line">            journalMaxFileLength=<span class="string">"32mb"</span></span><br><span class="line">            concurrentStoreAndDispatchQueues=<span class="string">"false"</span></span><br><span class="line">            concurrentStoreAndDispatchTopics=<span class="string">"false"</span></span><br><span class="line">            /&gt;</span><br><span class="line">  &lt;/persistenceAdapter&gt;</span><br><span class="line">&lt;/broker&gt;</span><br></pre></td></tr></table></figure><h4 id="3-关系型数据库存储方案"><a class="markdownIt-Anchor" href="#3-关系型数据库存储方案"></a> <strong>3. 关系型数据库存储方案</strong></h4><p>从ActiveMQ 4+版本开始，ActiveMQ就支持使用关系型数据库进行持久化存储——通过JDBC实现的数据库连接。可以使用的关系型数据库囊括了目前市面的主流数据库。</p><p>使用JDBC的方式持久化我们就得修改之前的配置文件：</p><p>将其中的这段配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;</span><br><span class="line">    &lt;kahaDB directory=<span class="string">"$&#123;activemq.base&#125;/data/kahadb"</span>/&gt;</span><br><span class="line">&lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>修改为下面这段内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;</span><br><span class="line">       &lt;jdbcPersistenceAdapter  dataSource=<span class="string">"# mysql-ds "</span>/&gt;</span><br><span class="line">&lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>在结点之后，增加数据源的配置,如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MySql DataSource Sample Setup --&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"mysql-ds"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/activemqdb?relaxAutoCommit=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">        </span><br><span class="line">&lt;!-- Oracle DataSource Sample Setup --&gt;        </span><br><span class="line">&lt;bean id=<span class="string">"oracle-ds"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"oracle.jdbc.driver.OracleDriver"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:oracle:thin:@localhost:1521:activemqdb"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- Oracle DataSource Sample Setup --&gt; </span><br><span class="line">&lt;bean id=<span class="string">"db2-ds"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>  destroy-method=<span class="string">"close"</span>&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"com.ibm.db2.jcc.DB2Driver"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:db2://hndb02.bf.ctc.com:50002/activemq"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"maxActive"</span> value=<span class="string">"200"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt; </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">还是在上一篇的实例工程中，我们改变一下applicationContext-ActiveMQ.xml的配置如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:amq=<span class="string">"http://activemq.apache.org/schema/core"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> /&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                           brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                           userName=<span class="string">"admin"</span></span><br><span class="line">                           password=<span class="string">"admin"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS连接工厂 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"connectionFactory"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"amqConnectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"sessionCacheSize"</span> value=<span class="string">"100"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义消息队列（Queue） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"demoQueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span><br><span class="line">        &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"jmsTemplate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"defaultDestination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">        &lt;!-- <span class="keyword">true</span>是topic，<span class="keyword">false</span>是queue，默认是<span class="keyword">false</span>，此处显示写出<span class="keyword">false</span> --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"pubSubDomain"</span> value=<span class="string">"false"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置消息队列监听者（Queue） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueMessageListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 显示注入消息监听容器（Queue），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueListenerContainer"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"queueMessageListener"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"localhost"</span> dataDirectory=<span class="string">"$&#123;activemq.data&#125;"</span> persistent=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;!--&lt;persistenceAdapter&gt;</span><br><span class="line">             &lt;kahaDB directory=<span class="string">"$&#123;activemq.data&#125;/kahadb"</span>/&gt;</span><br><span class="line">         &lt;/persistenceAdapter&gt; --&gt;</span><br><span class="line">        &lt;persistenceAdapter&gt;</span><br><span class="line">            &lt;jdbcPersistenceAdapter dataDirectory=<span class="string">"$&#123;activemq.data&#125;"</span> dataSource=<span class="string">"#mysql-ds"</span>&gt;</span><br><span class="line">            &lt;/jdbcPersistenceAdapter&gt;</span><br><span class="line">        &lt;/persistenceAdapter&gt;</span><br><span class="line">    &lt;/broker&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"mysql-ds"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://127.0.0.1/activemq?relaxAutoCommit=true"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"password"</span> value=<span class="string">"123456"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"maxActive"</span> value=<span class="string">"200"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>此时，重新启动MQ，就会发现db数据库中多了三张表：activemq_acks，activemq_lock，activemq_msgs，OK，说明activemq已经持久化成功啦！</p><p><img src="http://img.blog.csdn.net/20170512001107632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ol><li><p><strong>activemq_acks</strong>：用于存储订阅关系。如果是持久化Topic，订阅者和服务器的订阅关系在这个表保存，主要数据库字段如下：</p><ul><li>container：消息的destination</li><li>sub_dest：如果是使用static集群，这个字段会有集群其他系统的信息</li><li>client_id：每个订阅者都必须有一个唯一的客户端id用以区分</li><li>sub_name：订阅者名称</li><li>selector：选择器，可以选择只消费满足条件的消息。条件可以用自定义属性实现，可支持多属性and和or操作</li><li>last_acked_id：记录消费过的消息的id</li></ul></li><li><p><strong>activemq_lock</strong>：在集群环境中才有用，只有一个Broker可以获得消息，称为Master Broker，其他的只能作为备份等待Master Broker不可用，才可能成为下一个Master Broker。这个表用于记录哪个Broker是当前的Master Broker。</p></li><li><p><strong>activemq_msgs</strong>：用于存储消息，Queue和Topic都存储在这个表中。主要的数据库字段如下：</p><ul><li>id：自增的数据库主键</li><li>container：消息的destination</li><li>msgid_prod：消息发送者客户端的主键</li><li>msg_seq：是发送消息的顺序，msgid_prod+msg_seq可以组成jms的messageid</li><li>expiration：消息的过期时间，存储的是从1970-01-01到现在的毫秒数</li><li>msg：消息本体的java序列化对象的二进制数据</li><li>priority：优先级，从0-9，数值越大优先级越高</li><li>activemq_acks用于存储订阅关系。如果是持久化topic，订阅者和服务器的订阅关系在这个表保存。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于activemq消息的持久化我们在第二节的时候就简单介绍过，今天我们详细的来分析一下activemq的持久化过程以及持久化插件。在生产环境中为确保消息的可靠性，我们肯定的面临持久化消息的问题，今天就一起来攻克他吧。&lt;/p&gt;
&lt;h4 id=&quot;1-持久化方式介绍&quot;&gt;&lt;a c
      
    
    </summary>
    
      <category term="activeMQ" scheme="http://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq实战整合Spring之Topic模式(五)</title>
    <link href="http://blog.rickiyang.cn/posts/1d6950fa.html"/>
    <id>http://blog.rickiyang.cn/posts/1d6950fa.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.147Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们看一下Topic模式下的消息发布是如何处理的。</p><p>applicationContext-ActiveMQ.xml配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:amq=<span class="string">"http://activemq.apache.org/schema/core"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> /&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                           brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                           userName=<span class="string">"admin"</span></span><br><span class="line">                           password=<span class="string">"admin"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS连接工厂 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"connectionFactory"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"amqConnectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"sessionCacheSize"</span> value=<span class="string">"100"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义消息队列（topic） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"demoTopicDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span><br><span class="line">        &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS模板（topic），Spring提供的JMS工具类，它发送、接收消息。 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"jmsTemplate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"defaultDestination"</span> ref=<span class="string">"demoTopicDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;        </span><br><span class="line">        &lt;property name=<span class="string">"pubSubDomain"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置消息队列监听者（topic） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"topicMessageListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener"</span> /&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"topicMessageListener1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener1"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 显示注入消息监听容器（topic），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueListenerContainer"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoTopicDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"topicMessageListener"</span> /&gt;       </span><br><span class="line">        &lt;!--消息接收超时 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"queueListenerContainerB"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoTopicDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"topicMessageListener1"</span> /&gt;</span><br><span class="line">        &lt;!--消息接收超时 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>这里与queue模式不一样的地方在于订阅者有一个或是多个，有几个订阅者就需要配置监听器。</p><p>applicationContext.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!-- 查找最新的schemaLocation 访问 http:<span class="comment">//www.springframework.org/schema/ --&gt;</span></span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop/spring-aop-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定Sping组件扫描的基本包路径 --&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> &gt;</span><br><span class="line">        &lt;!-- 这里只扫描Controller，不可重复加载Service --&gt;</span><br><span class="line">        &lt;context:include-filter type=<span class="string">"annotation"</span> expression=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span><br><span class="line">    &lt;/context:component-scan&gt;</span><br><span class="line">    &lt;!-- 启用MVC注解 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- JSP视图解析器--&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">        &lt;!--  定义其解析视图的order顺序为<span class="number">1</span> --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"order"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>web.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span><br><span class="line"><span class="string">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span><br><span class="line">         version=<span class="string">"3.0"</span>&gt;</span><br><span class="line">&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:applicationContext-ActiveMQ.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">springMVC</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line">            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 处理编码格式 --&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">UTF</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">forceEncoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">true</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">characterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其余部分与queue模式代码一样，只是需要多配置一个监听器，目录结构如下：</p><p><img src="http://img.blog.csdn.net/20170512000602743?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>ProducerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination,<span class="keyword">final</span> String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProducerServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ProducerService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, <span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 向队列"</span>+destination.toString()+<span class="string">"发送消息---------&gt;"</span>+msg);</span><br><span class="line">        jmsTemplate.send(destination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        String destination = jmsTemplate.getDefaultDestinationName();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 向队列"</span>+destination+<span class="string">"发送消息--------&gt;"</span>+msg);</span><br><span class="line">        jmsTemplate.send(<span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TextMessage <span class="title">receive</span><span class="params">(Destination destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ConsumerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextMessage <span class="title">receive</span><span class="params">(Destination destination)</span></span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) jmsTemplate.receive(destination);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"从队列"</span> + destination.toString() + <span class="string">"收到了消息：\t"</span></span><br><span class="line">                    + textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueueMessageListener.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage tm = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"topicMessageListener监听到了文本消息：\t"</span></span><br><span class="line">                    + tm.getText());</span><br><span class="line">            <span class="comment">//do something ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueueMessageListener1.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueMessageListener1</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage tm = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"topicMessageListener1监听到了文本消息：\t"</span></span><br><span class="line">                    + tm.getText());</span><br><span class="line">            <span class="comment">//do something ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ConsumerService;</span><br><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ProducerService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MessageController.class);</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"demoQueueDestination"</span>)</span><br><span class="line">    <span class="keyword">private</span> Destination destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列消息生产者</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ProducerService producer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列消息消费者</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ConsumerService consumer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/SendMessage"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------开始发送消息"</span>);</span><br><span class="line">        producer.sendMessage(msg);</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------发送完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value= <span class="string">"/ReceiveMessage"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------开始接受消息"</span>);</span><br><span class="line">        TextMessage tm = consumer.receive(destination);</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------接受完毕"</span>);</span><br><span class="line">        <span class="keyword">return</span> tm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动工程，在地址栏中输入：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL1NlbmRNZXNzYWdlP21zZz1uaWhhbyVFRiVCQyU4Qw==" title="http://localhost:8080/SendMessage?msg=nihao%EF%BC%8C">http://localhost:8080/SendMessage?msg=nihao，<i class="fa fa-external-link"></i></span><br>代码很简单我就没有写前台页面啦，msg部分你可以随便写。回车之后我们去看一下控制台两个订阅者都接收到消息。</p><p><img src="http://img.blog.csdn.net/20170512000659974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们看一下Topic模式下的消息发布是如何处理的。&lt;/p&gt;
&lt;p&gt;applicationContext-ActiveMQ.xml配置：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="activeMQ" scheme="http://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq消息机制和持久化介绍(三)</title>
    <link href="http://blog.rickiyang.cn/posts/28fe9931.html"/>
    <id>http://blog.rickiyang.cn/posts/28fe9931.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.146Z</updated>
    
    <content type="html"><![CDATA[<p>前面一节简单学习了activemq的使用，我们知道activemq的使用方式非常简单有如下几个步骤：</p><ol><li>创建连接工厂</li><li>创建连接</li><li>创建会话</li><li>创建目的地</li><li>创建生产者或消费者</li><li>生产或消费消息</li><li>关闭生产或消费者、关闭会话、关闭连接</li></ol><p>前面我们的实例代码中已经按照这个步骤完成了P2P和Pub/Sub模式的消息发送和接收。那么这一节我们就针对他的消息传播机制和持久化方式做一个简单的学习。在会用的同时我们也需要理解一些基本的概念，这样才不至于在出错后无从下手。</p><h4 id="1activemq服务器工作模型"><a class="markdownIt-Anchor" href="#1activemq服务器工作模型"></a> <strong>1.activemq服务器工作模型</strong></h4><p>我们先看一下消息发送的时序图：</p><p><img src="http://img.blog.csdn.net/20170502232257791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>ConnectionFactory 对象创建一个连接工厂，消息的发送和接受服务均由此进行；</p><p>ConnectionFactory 创建一个活动Connection作为当前使用的连接；</p><p>Session 是一个用于生成和使用消息的单线程上下文，它用于创建发送的生产者和接收消息的消费者，并为所发送的消息定义发送顺序。会话通过大量确认选项或通过事务来支持可靠传送。</p><p>户端使用 MessageProducer 向指定的物理目标发送消息，生产者可指定一个默认传送模式（持久性消息与非持久性消息）、优先级和有效期值，以控制生产者向物理目标发送的所有消息；</p><p>消费者可以支持同步或异步消息接收。异步使用可通过向消费者注册 MessageListener 来实现。当会话线程调用 MessageListener 对象的 onMessage 方法时，客户端将使用消息。</p><h4 id="2activemq消息传送模型"><a class="markdownIt-Anchor" href="#2activemq消息传送模型"></a> <strong>2.ActiveMQ消息传送模型</strong></h4><p>ActiveMQ 支持两种消息传送模型：PTP（即点对点模型）和Pub/Sub（即发布 /订阅模型）,前面我们已经讲过，在此就不赘述。</p><h4 id="3消息选择器"><a class="markdownIt-Anchor" href="#3消息选择器"></a> <strong>3.消息选择器</strong></h4><p>ActiveMQ提供了一种机制，使用它，消息服务可根据消息选择器中的标准来执行消息过滤。生产者可在消息中放入应用程序特有的属性，而消费者可使用基于这些属性的选择标准来表明对消息是否感兴趣。</p><p>消息选择器是根据 header 和 properties 允许客户端选择性的制定需要接收的消息，消息选择器是无法利用 消息主体(Body)进行过滤的。无论你的消息主题是什么类型， 文本、或者对象、或者键值对。下面我们讲一下消息选择器的语法以及使用规范：</p><p>可接收的类型包括：byte,int,double,boolean,String;</p><h5 id="属性标识符定义"><a class="markdownIt-Anchor" href="#属性标识符定义"></a> 属性标识符定义：</h5><pre><code>变量名与java定义一样； 要么在heads中定义 要么在 properties中定义，如果在sender中是在heads中定义而receiver中却从properties中寻找的话，找不到的情况下他是不会自动去heads中寻找的，而是会返回null；根据不同类型的变量选择不同的方法：message.setIntProperty(&quot;test&quot;,14);那么在接收端可以对该变量进行拦截：session.createConsumer(destination,&quot;test &gt; 14&quot;)；属性标志符是区分大小写的；</code></pre><h5 id="拦截器中的部分表示方式"><a class="markdownIt-Anchor" href="#拦截器中的部分表示方式"></a> 拦截器中的部分表示方式：</h5><pre><code>可以是条件表达式可以是算术表达式可以是比较运算和逻辑运算组成的表达式</code></pre><p>支持 () 左右括号；</p><p>支持逻辑运算的优先顺序表达式 例如: NOT , AND , OR；</p><p>比较运算符有: = , &gt; , &gt;= , &lt; , &lt;= , &lt;&gt; (not equal)；</p><p>eg：</p><pre><code>标识符是null&quot;prop_name IS NULL&quot;标识符非空 not null&quot;prop_name IS NOT NULL&quot;&quot;age BETWEEN 15 AND 19&quot; is equivalent to &quot;age &gt;= 15 AND age &lt;= 19&quot;&quot;Country NOT IN (' UK', 'US', 'France') &quot;</code></pre><p>代码很简单，只需要在Sender端做如下改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextMessage message = session.createTextMessage();</span><br><span class="line">message.setIntProperty(<span class="string">"test"</span>,<span class="number">14</span>);</span><br><span class="line">message.setText(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><p>Receiver端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer = session.createConsumer(destination,<span class="string">"test &gt; 14"</span>);</span><br></pre></td></tr></table></figure><p>对发送端的特定字符做一个判断符合条件即被拦截</p><h4 id="4消息确认机制"><a class="markdownIt-Anchor" href="#4消息确认机制"></a> <strong>4.消息确认机制</strong></h4><p>jms消息只有在被确认之后才认为成功消费了这条消息。消息的成功消费通常包括三个步骤：</p><p>（1）client接收消息</p><p>（2）client处理消息</p><p>（3）消息被确认（也就是client给一个确认消息）</p><p>在事务性会话中当一个事务被提交的时候，确认自动发生，和应答模式没关系，这个值可以随便写。（这里多提一句异步消息接收中不能使用事务性会话）。</p><p>在非事务性会话中消息何时被确认取决于创建的session中设置的消息应答模式（acknowledge model）该参数有三个值：</p><ol><li>Session.AUTO_ACKNOWLEDGE：当client端成功的从receive方法或从onMessage(Message message) 方法返回的时候，会话自动确认client收到消息。</li><li>Session.CLIENT_ACKNOWLEDGE: 客户单通过调用acknowledge方法来确认客户端收到消息。但需要注意在这种应答模式下，确认是在会话层上进行的，确认一个被消费的消息将自动确认所有已消费的其他消息。比如一个消费者已经消费了10条消息，然后确认了第5条消息被消费，则这10条都被确认消费了。、</li></ol><p>acknowledge（）通知方法是在Message对象上，同步接收，调用acknowledge（）方法进行确认如下所示：</p><p>consumer = session.createConsumer(queue);<br>Message message = consumer.receive();<br>message.acknowledge();</p><p>异步接受，调用acknowledge（）方法进行确认：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String value = textMessage.getText();</span><br><span class="line">            System.out.println(<span class="string">"value: "</span> + value);</span><br><span class="line">            message.acknowledge(); <span class="comment">//消息消费确认通知</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.Session.DUPS_ACKNOWLEDGE：不是必须签收，消息可能会重复发送。在第二次重新传送消息的时候，消息头的JmsDelivered会被置为true标示当前消息已经传送过一次，客户端需要进行消息的重复处理控制。</p><h4 id="5-持久化消息"><a class="markdownIt-Anchor" href="#5-持久化消息"></a> <strong>5. 持久化消息</strong></h4><p>JMS 支持以下两种消息提交模式：</p><h5 id="51-ersistent-持久消息"><a class="markdownIt-Anchor" href="#51-ersistent-持久消息"></a> 5.1 ERSISTENT 持久消息</h5><p>是activemq默认的传送方式，此方式下的消息在配合activemq.xml中配置的消息存储方式，会被存储在特定的地方，直到有消费者将消息消费或者消息过期进入DLQ队列，消息生命周期才会结束。此模式下可以保证消息只会被成功传送一次和成功使用一次，消息具有可靠性。在消息传递到目标消费者，在消费者没有成功应答前，消息不会丢失。所以很自然的，需要一个地方来持久性存储。如果消息消费者在进行消费过程发生失败，则消息会被再次投递。</p><p>DeliveryMode.PERSISTENT  指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失。 消息持久化在硬盘中，ActiveMQ持久化有三种方式：AMQ、KahaDB、JDBC。</p><p>AMQ</p><p>AMQ是一种文件存储形式，它具有写入速度快和容易恢复的特点。消息存储在一个个文件中，文件的默认大小为32M，如果一条消息的大小超过了32M，那么这个值必须设置大一点。当一个存储文件中的消息已经全部被消费，那么这个文件将被标识为可删除，在下一个清除阶段，这个文件被删除。AMQ适用于ActiveMQ5.3之前的版本。</p><p>KahaDB</p><p>KahaDB是基于文件的本地数据库储存形式，虽然没有AMQ的速度快，但是它具有强扩展性，恢复的时间比AMQ短，从5.4版本之后KahaDB做为默认的持久化方式。</p><p>JDBC</p><p>可以将消息存储到数据库中，例如：Mysql、SQL Server、Oracle、DB2。</p><p>具体使用方式大家下去查一下，限于篇幅在此就不做太详细的介绍。</p><h5 id="52-non_persistent-非持久消息"><a class="markdownIt-Anchor" href="#52-non_persistent-非持久消息"></a> <strong>5.2 NON_PERSISTENT 非持久消息</strong></h5><p>非持久的消息适用于不重要的，可以接受消息丢失的哪一类消息，这种消息只会被投递一次，消息不会在持久性存储中存储，也不会保证消息丢失后的重新投递。</p><p>DeliveryMode.NON_PERSISTENT  不要求JMS provider持久保存消息，消息存放在内存中，读写速度快，在JMS服务停止后消息会消失，没有持久化到硬盘。</p><h4 id="6-activemq消息过期设置"><a class="markdownIt-Anchor" href="#6-activemq消息过期设置"></a> <strong>6. ActiveMQ消息过期设置</strong></h4><p>允许消息过期 。默认情况下，消息永不会过期。如果消息在特定周期内失去意义，那么可以设置过期时间。<br>有两种方法设置消息的过期时间，时间单位为毫秒：</p><ol><li>使用 setTimeToLive 方法为所有的消息设置过期时间；</li><li>使用 send 方法为每一条消息设置过期时间。</li></ol><p>消息过期时间，send 方法中的 timeToLive 值加上发送时刻的 GMT 时间值。如果 timeToLive 值等于零，则 JMSExpiration 被设为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除。</p><p>这一节对activemq的消息机制和持久化我们就简单介绍到这里，后面我们结合具体的工程来把它应用到生产中，再来讲解如何持久化如何高效的应用于生产环境。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面一节简单学习了activemq的使用，我们知道activemq的使用方式非常简单有如下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建连接工厂&lt;/li&gt;
&lt;li&gt;创建连接&lt;/li&gt;
&lt;li&gt;创建会话&lt;/li&gt;
&lt;li&gt;创建目的地&lt;/li&gt;
&lt;li&gt;创建生产者或消费者&lt;/li&gt;
      
    
    </summary>
    
      <category term="activeMQ" scheme="http://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq入门(二)</title>
    <link href="http://blog.rickiyang.cn/posts/a042465a.html"/>
    <id>http://blog.rickiyang.cn/posts/a042465a.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.145Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们了解了JMS规范并且知道了JMS规范的良好实现者-activemq。今天我们就去了解一下activemq的使用。另外我们应该抱着目的去学习，别忘了我们为什么要使用消息中间件：解耦系统之间的联系，同步或异步的消息传输，尤其是异步的消息传输，分布式环境下，可靠、高效的消息传输，可以保证消息的重发性和顺序性。即解决业务系统比较多或者是分布式环境下的系统之间安全有效通信的问题，带着这样的目的我们来学习消息中间件就有了方向。</p><h4 id="1-为什么用activemq"><a class="markdownIt-Anchor" href="#1-为什么用activemq"></a> <strong>1. 为什么用activemq</strong></h4><p>在设计分布式应用程序时，应用程序间的耦合（或称集成）方式很重要。耦合意味着两个或者多个应用程序或系统的相互依赖关系。一种简单的方式是在所有的应用程序中从架构上设计他们与其他应用程序间的交叉实现。这样必然导致，一个应用程序的改变，直接导致另一个应用程序的改变。</p><p>ActiveMQ采用松耦合方式，应用程序将消息发送给ActiveMQ而并不关心什么时间以何种方式消息投递给接收者。同样的，消息接收者也不会关心消息来源于哪里和消息是怎样投递给ActiveMQ的。对于多语言编写的复杂应用环境中，允许客户端使用不同的编程语言甚至不同的消息包装协议。ActiveMQ作为消息的中间件，允许复杂的多语言应用程序以一种一步的方式集成和交互。所以说，ActiveMQ是一种好的，提供松散耦合的，能够为多语言交叉应用提供集成的中间件。</p><h4 id="2-什么时候用activemq"><a class="markdownIt-Anchor" href="#2-什么时候用activemq"></a> <strong>2. 什么时候用activemq</strong></h4><p>ActiveMQ的设计目标是提供标准的，面向消息的，能够跨越多语言和多系统的应用集成消息通信中间件。大多数情况下ActiveMQ被用于做系统之间的数据交换。</p><p>只要是两个应用程序间需要通信的情况，都可以考虑使用JMS，不论这种通信是在本地的（就是通信的两个应用程序在同一台主机上），还是分布在不同机器上。尽管是在同一个主机上的两个应用程序需要通信也可以使用ActiveMQ。ActiveMQ可以确保消息投递成功并采用异步方式通信。</p><h4 id="3-activemq特性"><a class="markdownIt-Anchor" href="#3-activemq特性"></a> <strong>3. activemq特性</strong></h4><p>支持JMS规范：ActiveMQ完全实现了JMS1.1规范。</p><p>连接方式的多样化：ActiveMQ提供了广泛的连接模式，包括HTTP/S、JGroups、JXTA、muticast、SSL、TCP、UDP、XMPP等。提供了如此多的连接模式表明了ActiveMQ具有较高的灵活性。</p><p>与其他的Java容器紧密集成：ActiveMQ提供了和其它流行的Java容器的结合，包括Apache Geronimo、Apache Tomcat、JBoss、Jetty等。</p><p>客户端API：ActiveMQ提供了多种客户端可访问的API，包括Java、C/C++，.NET，Perl、PHP、Python、Ruby等。当然，ActiveMQ中介必须运行在Java虚拟机中，但是使用它的客户端可以使用其他的语言来实现。</p><p>中介集群：多个ActiveMQ中介可以一起协同工作，来完成某项复杂的工作，这被称为网络型中介（network of brokers），这种类型的中介将会支持多种拓扑类型。</p><h4 id="4-使用activemq"><a class="markdownIt-Anchor" href="#4-使用activemq"></a> <strong>4. 使用activemq</strong></h4><p>首先我们去apache上下载activemq，<span class="exturl" data-url="aHR0cDovL2FjdGl2ZW1xLmFwYWNoZS5vcmcv" title="http://activemq.apache.org/">点此下载<i class="fa fa-external-link"></i></span>。</p><p>接下来我是使用maven来管理jar的，如果你不用maven的话就去刚下载的activemq包中找到jar包导入即可。maven引入jar：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.14.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后我们进入刚下载的activemq，我进入的路径如下：apache-activemq-5.14.5-bin\apache-activemq-5.14.5\bin\win64\activemq.bat<br>,我用的是64位的系统，如果你是32位的同理进入相应文件夹下点击activemq.bat启动activemq客户端，启动完成之后，直接访问ActiveMQ管理页面http://localhost:8161/admin/ 默认用户名密码admin/admin。</p><p>客户端界面如下：</p><p><img src="http://i.imgur.com/C7gRpOs.jpg" alt=""></p><p>接下来该我们写代码的时候了，首先我们还是先写一个P2P(点对点)模式的客户端。代码如下：</p><p>Sender.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Connection;</span><br><span class="line"><span class="keyword">import</span> javax.jms.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.DeliveryMode;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageProducer;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ConnectionFactory是连接工厂，JMS用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Connection JMS客户端到JMS provider的连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Session 一个发送或者接收消息的线程</span></span><br><span class="line">        Session session;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Destination 消息发送目的地，消息发送给谁接收</span></span><br><span class="line">        Destination destination;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MessageProducer 消息发送者</span></span><br><span class="line">        MessageProducer messageProducer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造ConnectionFactory 实例对象，此处采用ActiveMQ的实现jar</span></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">            connection.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个Queue，名称为FirstQueue</span></span><br><span class="line">            destination = session.createQueue(<span class="string">"FirstQueue"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到消息生产者【发送者】</span></span><br><span class="line">            messageProducer = session.createProducer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置不持久化，根据实际情况而定</span></span><br><span class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个消息对象</span></span><br><span class="line">            TextMessage message = session.createTextMessage();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把我们的消息写入msg对象中</span></span><br><span class="line">            BufferedReader b=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Enter Msg, end to terminate:"</span>);</span><br><span class="line">                String s=b.readLine();</span><br><span class="line">                <span class="keyword">if</span> (s.equals(<span class="string">"end"</span>))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                message.setText(s);</span><br><span class="line">                <span class="comment">//发送消息</span></span><br><span class="line">                messageProducer.send(message);</span><br><span class="line">                System.out.println(<span class="string">"Message successfully sent."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != connection)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Receiver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Connection;</span><br><span class="line"><span class="keyword">import</span> javax.jms.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageConsumer;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//connectionFactory 连接工厂，JMS用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//connection JMS客户端到JMS provider 的连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//session一个发送或者接收的线程</span></span><br><span class="line">        Session session;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//destination 消息目的地，发送给谁接收</span></span><br><span class="line">        Destination destination;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费者消息接收者</span></span><br><span class="line">        MessageConsumer consumer;</span><br><span class="line"></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">            connection.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">            destination = session.createQueue(<span class="string">"FirstQueue"</span>);</span><br><span class="line">            consumer = session.createConsumer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//设置接收者收消息的时间，为了方便测试，这里暂定设置为100s</span></span><br><span class="line">                TextMessage message = (TextMessage)consumer.receive(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != message)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息==="</span>+message.getText());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != connection)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码已经注释过了，就不多做解释，接着我们先运行Sender,需要你在控制台输入你要发送的消息，当你输入&quot;end&quot;的时候才会结束输入，否则你每一次输入按回车都是发送一条消息。然后去看一下activemq的控制台，点击一下菜单栏上的Queues：</p><p><img src="http://i.imgur.com/XqBRQr4.jpg" alt=""></p><p>因为我刚发送了两条消息在这里会显示，消息会由activemq这个中间人统一管理，当接受者需要接受消息的时候，他会来请求activemq，从这里获取消息而不是发送端一直等着接收端。</p><p>下面你可以运行一下Receiver，这时候就把刚才这两条消息消费了。消息队列此刻就是空的。之所以强调这一点是为了和接下来的 发布/订阅 模式做一个比较，限于篇幅我就不截图了，大家可以尝试。</p><p>下面我们接着写一个Pub/Sub模式的例子，并没有多大的变化，在创建消息队列的时候改为topic模式：</p><p>TopicSender.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/4/25.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ConnectionFactory是连接工厂，JMS用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Connection JMS客户端到JMS provider的连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Session 一个发送或者接收消息的线程</span></span><br><span class="line">        Session session;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Destination 消息发送目的地，消息发送给谁接收</span></span><br><span class="line">        Topic destination;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MessageProducer 消息发送者</span></span><br><span class="line">        MessageProducer messageProducer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造ConnectionFactory 实例对象，此处采用ActiveMQ的实现jar</span></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">            connection.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个Queue，SecondQueue 此处使用的是Topic模式</span></span><br><span class="line">            destination = session.createTopic(<span class="string">"SecondQueue"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到消息生产者【发送者】</span></span><br><span class="line">            messageProducer = session.createProducer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置不持久化，根据实际情况而定</span></span><br><span class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个消息对象</span></span><br><span class="line">            TextMessage message = session.createTextMessage();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把我们的消息写入msg对象中</span></span><br><span class="line">            BufferedReader b=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            message.setText(<span class="string">"你好"</span>);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            messageProducer.send(message);</span><br><span class="line">            System.out.println(<span class="string">"Message successfully sent."</span>);</span><br><span class="line"></span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != connection)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理接受方也是如此：</p><p>TopicReciever.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReciever</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//connectionFactory 连接工厂，JMS用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//connection JMS客户端到JMS provider 的连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//session一个发送或者接收的线程</span></span><br><span class="line">        <span class="keyword">final</span> Session session;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//destination 消息目的地，发送给谁接收 这里注意改成Topic类型的</span></span><br><span class="line">        Topic destination;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费者消息接收者</span></span><br><span class="line">        <span class="keyword">final</span> MessageConsumer consumer;</span><br><span class="line"></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">            connection.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//此处使用的是Topic模式</span></span><br><span class="line">            destination = session.createTopic(<span class="string">"SecondQueue"</span>);</span><br><span class="line">            consumer = session.createConsumer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//设置接收者收消息的时间</span></span><br><span class="line">                TextMessage message = (TextMessage)consumer.receive(<span class="number">10000</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != message)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息==="</span>+message.getText());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以把Reciever同样的代码再复制一份Reciever1，然后我们先把两个接收端启动，再启动发送端，这时候我们发现消息被接受到了；但是如果我们先启动发送端再启动接收端，这时候虽然消息是被发送出去了，但是接收端并未收到，这是为什么呢？这就是我前面在讲P2P模式的时候留下的一个对比点：</p><p>P2P模式是1V1的，我发送只对当前声明的这个标识，接受者也只接受该标识所对应的消息。一旦接受者获取该消息，该标识对应的消息即从消息队列中移除；</p><p>Pub/Sub模式是1 V N 的，1个发送端发出的消息，可以有多个接收端去消费，但是有一个前提：想消费这条消息的接收端必须先注册，即先启动接收端去activemq的客户端注册，发送端就根据注册的情况主动把消息推送到订阅过该消息的消费者。</p><p><img src="http://img.blog.csdn.net/20170426234611917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>我们看到消息队列里面有一条消息，然后有两位消费者来订阅这一条消息，上面我们看到两个消费者分别取队列取一次消息，然后activemq会创建两个临时生产者去他们服务把消息给他们。</p><p>好拉，这一节的入门知识就讲到这里，既然是入门我们就不必太深刻，不然适得其反啊！哈哈。下面开始我们就详细的探讨activemq的一些特性以及消息中间件在集群环境中的应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们了解了JMS规范并且知道了JMS规范的良好实现者-activemq。今天我们就去了解一下activemq的使用。另外我们应该抱着目的去学习，别忘了我们为什么要使用消息中间件：解耦系统之间的联系，同步或异步的消息传输，尤其是异步的消息传输，分布式环境下，可靠、高效的
      
    
    </summary>
    
      <category term="activeMQ" scheme="http://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq实战之整合Spring(四)</title>
    <link href="http://blog.rickiyang.cn/posts/64e3c39e.html"/>
    <id>http://blog.rickiyang.cn/posts/64e3c39e.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.163Z</updated>
    
    <content type="html"><![CDATA[<p>前面的理论准备已经很充分，这一节我们来实战：将activemq整合到Spring框架才行中，因为Spring已经集成了JMS，这也为我们配置activermq带来了方便。</p><h4 id="1-spring对jms的支持"><a class="markdownIt-Anchor" href="#1-spring对jms的支持"></a> 1. Spring对jms的支持</h4><p>因为Spring已经将JMS集成到框架里面了，对jms做了自己的封装，我们使用起来更加方便，在Spring中使用jms比较麻烦的就是配置，在Spring中配置JMS大体需要8个部分：</p><ol><li>ConnectionFactory： 和jms服务器的连接, 可以是外部的jms server, 也可以使用embedded ActiveMQ Broker；</li><li>Destination： 有topic和queue两种方式；</li><li>JmsTemplate： spring提供的jms模板；</li><li>MessageConverter： 消息转换器；</li><li>MessageProducer： 消息生产者；</li><li>MessageConsumer： 消息消费者；</li><li>MessageListener： 消息监听器；</li><li>MessageListenerContainer： 消息监听容器。</li></ol><p>下面我把完整的配置文件按照上面的步骤拆开分别讲解：</p><p><strong>1.1首先我们配置ConnectionFactory：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                   brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                   userName=<span class="string">"admin"</span></span><br><span class="line">                   password=<span class="string">"admin"</span> /&gt;</span><br></pre></td></tr></table></figure><p>brokerURL是指要连接的activeMQ server的地址，该配置即使用activemq独立的消息存储环境，即使服务器重启消息也不会丢失。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置JMS连接工厂 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"connectionFactory"</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span><br><span class="line">    &lt;constructor-arg ref=<span class="string">"amqConnectionFactory"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"sessionCacheSize"</span> value=<span class="string">"100"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>我们从Spring给我们提供的connectionFactory中获取Connection，并且把该connectionFactory注册到上面定义的activemq server中。</p><p><strong>1.2 Destination：</strong></p><p>由前面我们知道Destination有两种形式：P2P和Pub/Sub。那么在配置中表示就是：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 定义消息队列（Queue） --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"demoQueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span><br><span class="line">    &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 定义消息队列（topic） --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"demoQueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span><br><span class="line">    &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>1.3 JmsTemplate：</strong></p><p>将connectionFactory和defaultDestination注入JmsTemplate中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"jmsTemplate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"defaultDestination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">    &lt;!-- <span class="keyword">true</span>是topic，<span class="keyword">false</span>是queue，默认是<span class="keyword">false</span>，此处显示写出<span class="keyword">false</span> --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"pubSubDomain"</span> value=<span class="string">"false"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在Java相关处理文件中添加(这里用的是@Inject注解，当然也可以用@Autowired)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line"><span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">TextMessage textMessage = (TextMessage) jmsTemplate.receive(destination);</span><br></pre></td></tr></table></figure><p><strong>1.4 MessageConverter</strong></p><p>MessageConverter实现的是org.springframework.jms.support.converter.MessageConverter接口, 提供消息的转换功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"defaultMessageConverter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.DefaultMessageConverter"</span> /&gt;</span><br></pre></td></tr></table></figure><p><strong>1.5 MessageProducer和MessageConsumer</strong></p><p>此处灵活使用，可以以服务的形式提供也可以以工具类的形式提供，详情见下面的示例代码。</p><p><strong>1.6 MessageListener</strong></p><p>消息的消费者应有的有对应的Listener。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置消息队列监听者（Queue） --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"queueMessageListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener"</span> /&gt; =</span><br></pre></td></tr></table></figure><p><strong>1.7 MessageListenerContainer</strong></p><p>MessageListenerContainer即Listener的容器，用来对Listener坐一些配置，每一个listener都对应着一个Container：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 显示注入消息监听容器（Queue），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"queueListenerContainer"</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"queueMessageListener"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>Spring为我们听过了两种类型的MessageListenerContainer：SimpleMessageListenerContainer和DefaultMessageListenerContainer。</p><ul><li>SimpleMessageListenerContainer会在一开始的时候就创建一个会话Session和消费者Consumer，并且会适用标准的JMS的MessageConsumer.setMessageListener()方法注册监听器让JMS提供调用监听器的回调函数。它不会动态的适应运行时需要和参与外部的事务管理。兼容性方面，它非常接近于独立的JMS规范，但一般不兼容J2EE的JMS限制。大多数情况下，我们还是使用DefaultMessageListenerContainer。</li><li>DefaultMessageListenerContainer，与SimpleMessageListenerContainer相比，它会动态的适应运行时的需求，并且能够参与外部的事务管理。</li></ul><p>上面就是mq的配置文件部分，如果从上到下的配置部分都清楚地话使用起来肯定没有问题，我们再做一个简要的总结：</p><ol><li>可以有一个或者多个消息生产者向同一个destination发送消息；</li><li>queue类型的只能有一个消息消费者；</li><li>topic类型的可以有多个消息消费者；</li><li>每个消费者对应一个MessageListener和一个MessageListenerContainer。</li></ol><p>下面我们看一下整合的全部代码：</p><p>首先上pom.xml看一下依赖的jar包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;q&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;q&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;name&gt;q Maven Webapp&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http:<span class="comment">//maven.apache.org&lt;/url&gt;</span></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;springframework&gt;4.3.0.RELEASE&lt;/springframework&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- spring --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- xbean 如&lt;amq:connectionFactory /&gt; --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.16&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- activemq --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.7.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.12.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;q&lt;/finalName&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;source&gt;1.6&lt;/source&gt;</span><br><span class="line">          &lt;target&gt;1.6&lt;/target&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>然后是我们的Spring配置文件applicationContext.xml:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!-- 查找最新的schemaLocation 访问 http:<span class="comment">//www.springframework.org/schema/ --&gt;</span></span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop/spring-aop-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定Sping组件扫描的基本包路径 --&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> &gt;</span><br><span class="line">        &lt;!-- 这里只扫描Controller，不可重复加载Service --&gt;</span><br><span class="line">        &lt;context:include-filter type=<span class="string">"annotation"</span> expression=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span><br><span class="line">    &lt;/context:component-scan&gt;</span><br><span class="line">    &lt;!-- 启用MVC注解 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- JSP视图解析器--&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">        &lt;!--  定义其解析视图的order顺序为<span class="number">1</span> --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"order"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>activemq的配置文件applicationContext-ActiveMQ.xml：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:amq=<span class="string">"http://activemq.apache.org/schema/core"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> /&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                           brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                           userName=<span class="string">"admin"</span></span><br><span class="line">                           password=<span class="string">"admin"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS连接工厂 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"connectionFactory"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"amqConnectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"sessionCacheSize"</span> value=<span class="string">"100"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义消息队列（Queue） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"demoQueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span><br><span class="line">        &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"jmsTemplate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"defaultDestination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">        &lt;!-- <span class="keyword">true</span>是topic，<span class="keyword">false</span>是queue，默认是<span class="keyword">false</span>，此处显示写出<span class="keyword">false</span> --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"pubSubDomain"</span> value=<span class="string">"false"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置消息队列监听者（Queue） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueMessageListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 显示注入消息监听容器（Queue），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueListenerContainer"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"queueMessageListener"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>配置的介绍在上面我已经讲过了，不明白的地方翻到上面去看看。</p><p>web.xml文件的配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span><br><span class="line"><span class="string">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span><br><span class="line">         version=<span class="string">"3.0"</span>&gt;</span><br><span class="line">&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:applicationContext-ActiveMQ.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">springMVC</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line">            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 处理编码格式 --&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">UTF</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">forceEncoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">true</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">characterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们的工程目录结构如下：</p><p><img src="http://img.blog.csdn.net/20170505081848348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>上service的代码：</p><p>ProducerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination,<span class="keyword">final</span> String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProducerServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ProducerService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, <span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 向队列"</span>+destination.toString()+<span class="string">"发送消息---------&gt;"</span>+msg);</span><br><span class="line">        jmsTemplate.send(destination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        String destination = jmsTemplate.getDefaultDestinationName();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 向队列"</span>+destination+<span class="string">"发送消息--------&gt;"</span>+msg);</span><br><span class="line">        jmsTemplate.send(<span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TextMessage <span class="title">receive</span><span class="params">(Destination destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ConsumerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextMessage <span class="title">receive</span><span class="params">(Destination destination)</span></span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) jmsTemplate.receive(destination);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"从队列"</span> + destination.toString() + <span class="string">"收到了消息：\t"</span></span><br><span class="line">                    + textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueueMessageListener.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage tm = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"QueueMessageListener监听到了文本消息：\t"</span></span><br><span class="line">                    + tm.getText());</span><br><span class="line">            <span class="comment">//do something ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ConsumerService;</span><br><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ProducerService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MessageController.class);</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"demoQueueDestination"</span>)</span><br><span class="line">    <span class="keyword">private</span> Destination destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列消息生产者</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ProducerService producer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列消息消费者</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ConsumerService consumer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/SendMessage"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------开始发送消息"</span>);</span><br><span class="line">        producer.sendMessage(msg);</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------发送完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value= <span class="string">"/ReceiveMessage"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------开始接受消息"</span>);</span><br><span class="line">        TextMessage tm = consumer.receive(destination);</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------接受完毕"</span>);</span><br><span class="line">        <span class="keyword">return</span> tm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是上面这些，我们先启动acticemq server，然后下启动工程，在地址栏中输入：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL1NlbmRNZXNzYWdlP21zZz1uaWhhbyVFRiVCQyU4Qw==" title="http://localhost:8080/SendMessage?msg=nihao%EF%BC%8C">http://localhost:8080/SendMessage?msg=nihao，<i class="fa fa-external-link"></i></span><br>代码很简单我就没有写前台页面啦，msg部分你可以随便写。回车之后我们去看一下控制台消息就发送出去了。</p><p><img src="http://img.blog.csdn.net/20170505081958553?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面的理论准备已经很充分，这一节我们来实战：将activemq整合到Spring框架才行中，因为Spring已经集成了JMS，这也为我们配置activermq带来了方便。&lt;/p&gt;
&lt;h4 id=&quot;1-spring对jms的支持&quot;&gt;&lt;a class=&quot;markdownIt-A
      
    
    </summary>
    
      <category term="activeMQ" scheme="http://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq安全机制</title>
    <link href="http://blog.rickiyang.cn/posts/413284da.html"/>
    <id>http://blog.rickiyang.cn/posts/413284da.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.135Z</updated>
    
    <content type="html"><![CDATA[<p>activemq作为消息中间件这样一个独立的个体存在，连通用户和服务器。如果没有一套完备的安全机制去设置用户权限设置消息分发机制可想后果是非常严重。ActiveMQ如果不加入安全机制的话，任何人只要知道消息服务的具体地址(包括ip，端口，消息地址[队列或者主题地址，)，都可以肆无忌惮的发送、接收消息。今天我们就探讨一下他的安全机制。</p><h4 id="1安全机制介绍"><a class="markdownIt-Anchor" href="#1安全机制介绍"></a> <strong>1.安全机制介绍</strong></h4><p>我们讨论安全机制一般包括两个部分：</p><ol><li>验证(Authentication)：就是要验证一个用户的有效性，即用户名、密码是否正确;</li><li>授权(Authorization)：就是授予用户某种角色，以使用户只能访问具有相应角色的资源。</li></ol><p>activemq考虑到安全方案效率问题，他提供了可插拔的安全机制，你可以使用不同的安全插件灵活为你的系统配置安全访问方式。目前activemq提供两种安全控制插件：</p><ol><li>简单认证插件(Simple authentication plugin-in)</li><li>JAAS认证插件(Java Authentication and Authorization Service)</li></ol><p>下面我们分别就这两种插件的使用做一个说明。</p><h4 id="2简单认证插件"><a class="markdownIt-Anchor" href="#2简单认证插件"></a> <strong>2.简单认证插件</strong></h4><p>简单认证插件的目的就是让用户简单配置。我们打开activemq服务的目录apache-activemq，在 conf目录下找到activemq.xml。进去找到：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shutdownHooks&gt;</span><br><span class="line">    &lt;bean xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.hooks.SpringContextHook"</span> /&gt;</span><br><span class="line">&lt;/shutdownHooks&gt;</span><br></pre></td></tr></table></figure><p>在他下面添加如下即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;simpleAuthenticationPlugin&gt;</span><br><span class="line">        &lt;users&gt;</span><br><span class="line">            &lt;authenticationUser username=<span class="string">"admin"</span> password=<span class="string">"admin"</span> groups=<span class="string">"users,admins"</span>/&gt;</span><br><span class="line">           &lt;authenticationUser username=<span class="string">"user"</span> password=<span class="string">"password"</span> groups=<span class="string">"users"</span>/&gt;     </span><br><span class="line">        &lt;/users&gt;</span><br><span class="line">    &lt;/simpleAuthenticationPlugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>☆注意：<strong>此处添加的用户名和密码要和你在项目中配置的activemq用户名密码是一致的，如果在项目中不是此处已经配置过的用户发送消息的话，activemq客户端不会受理该消息。这样就达到了对非命中用户拦截的目的。</strong></p><p>比如说你有客户端使用的用户是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                           brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                           userName=<span class="string">"admin"</span></span><br><span class="line">                           password=<span class="string">"admin"</span> /&gt;</span><br></pre></td></tr></table></figure><p>那你就把该用户配置到activemq的配置文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;authenticationUser username=<span class="string">"admin"</span> password=<span class="string">"admin"</span> groups=<span class="string">"users,admins"</span>/&gt;</span><br></pre></td></tr></table></figure><p>上面是对用户进行限制，我们也可以对ip进行限制，还是在刚才的配置里面加上下面这一句：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">     &lt;simpleAuthenticationPlugin&gt;</span><br><span class="line">            &lt;users&gt;</span><br><span class="line">                &lt;authenticationUser username=<span class="string">"admin"</span> password=<span class="string">"admin"</span> groups=<span class="string">"users,admins"</span>/&gt;</span><br><span class="line">               &lt;!-- &lt;authenticationUser username=<span class="string">"user"</span> password=<span class="string">"password"</span> groups=<span class="string">"users"</span>/&gt;</span><br><span class="line">                &lt;authenticationUser username=<span class="string">"guest"</span> password=<span class="string">"password"</span> groups=<span class="string">"guests"</span>/&gt;--&gt;</span><br><span class="line">            &lt;/users&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;transportConnectors&gt;</span><br><span class="line">         &lt;transportConnector name=<span class="string">"connection1"</span> uri=<span class="string">"tcp://0.0.0.0:61616"</span> /&gt;</span><br><span class="line">        &lt;/transportConnectors&gt;</span><br><span class="line">    &lt;/simpleAuthenticationPlugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>0.0.0.0代表本网络中的所有主机，意味着该网段的所有主机都是可以通讯的。如果改成localhost或者127.0.0.1这种的那就只有本机了。这样我们就达到了通过IP限制的目的。</p><h4 id="3jaas认证插件"><a class="markdownIt-Anchor" href="#3jaas认证插件"></a> <strong>3.JAAS认证插件</strong></h4><p>JAAS(Java Authentication and Authorization Service)也就是java的验证Authentication)、授权(Authorization)服务。简单来说，验证Authentication就是要验证一个用户的有效性，即用户名、密码是否正确。授权Authorization就是授予用户某种角色，可以访问哪些资源。JAASAuthentication Plugin依赖标准的JAAS机制来实现认证。通常情况下，你需要通过设置Java.security.auth.login.config系统属性来配置login<br>modules的配置文件。如果没有指定这个系统属性，那么JAAS Authentication Plugin会缺省使用login.config作为文件名。</p><p>首先我们需要编写一个login.config文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">activemq &#123;  </span><br><span class="line">    org.apache.activemq.jaas.PropertiesLoginModule required  </span><br><span class="line">    debug=<span class="keyword">true</span></span><br><span class="line">        org.apache.activemq.jaas.properties.user=<span class="string">"users.properties"</span>  </span><br><span class="line">        org.apache.activemq.jaas.properties.group=<span class="string">"groups.properties"</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>users.properties文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admin=admin  </span><br><span class="line">user=ad1</span><br><span class="line">guest=ad1</span><br></pre></td></tr></table></figure><p>group.properties文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admins=admin  </span><br><span class="line">users=user  </span><br><span class="line">guests=guest</span><br></pre></td></tr></table></figure><p>☆需要注意的是，PropertiesLoginModule使用本地文件的查找方式，而且查找时采用的base directory即login.config文件所在的目录，所以说这三个文件需要在同一个目录里才会找得到。另外，activemq 5.9 默认提供了以上的配置文件，我们来看一下文件目录：</p><p><img src="http://i.imgur.com/AR7vabh.jpg" alt=""></p><p>然后我们还是在activemq.xml配置文件中添加插件。还是上面简单插件添加的位置，添加以下插件即可，只不过你的把之前添加的简单插件注释掉。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;jaasAuthenticationPlugin configuration=<span class="string">"activemq-domain"</span> /&gt;     </span><br><span class="line">    &lt;authorizationPlugin&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;authorizationMap&gt;</span><br><span class="line">                &lt;authorizationEntries&gt;</span><br><span class="line">                 &lt;!-- .表示通配符,例如USERS.&gt;表示以USERS.开头的主题,&gt;表示所有主题,read表示读的权限,write表示写的权限，admin表示角色组--&gt;</span><br><span class="line">                    &lt;authorizationEntry queue=<span class="string">"&gt;"</span> read=<span class="string">"admins,guests"</span> write=<span class="string">"guests"</span> admin=<span class="string">"admins,guests"</span> /&gt;</span><br><span class="line">                    &lt;authorizationEntry queue=<span class="string">"USERS.&gt;"</span> read=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</span><br><span class="line">                    &lt;authorizationEntry queue=<span class="string">"GUEST.&gt;"</span> read=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;authorizationEntry topic=<span class="string">"&gt;"</span> read=<span class="string">"admins"</span> write=<span class="string">"admins"</span> admin=<span class="string">"admins"</span> /&gt;</span><br><span class="line">                    &lt;authorizationEntry topic=<span class="string">"USERS.&gt;"</span> read=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</span><br><span class="line">                    &lt;authorizationEntry topic=<span class="string">"GUEST.&gt;"</span> read=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;authorizationEntry topic=<span class="string">"ActiveMQ.Advisory.&gt;"</span> read=<span class="string">"guests,users"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span>/&gt;</span><br><span class="line">                &lt;/authorizationEntries&gt;</span><br><span class="line">            &lt;/authorizationMap&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/authorizationPlugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>添加完以上配置部分，重启avtivemq服务端，就会按照上面配置的用户进行读写的权限配置。</p><p>从上面看JAAS插件的权限分配要比简单插件的权限更加细致，不同的用户可以分别配置读写的权限，admin用户拥有创建topic或是queue的特权等等这样细致的划分，不同的用户各司其职，减少了误操作，或是刻意破换的可能性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;activemq作为消息中间件这样一个独立的个体存在，连通用户和服务器。如果没有一套完备的安全机制去设置用户权限设置消息分发机制可想后果是非常严重。ActiveMQ如果不加入安全机制的话，任何人只要知道消息服务的具体地址(包括ip，端口，消息地址[队列或者主题地址，)，都可
      
    
    </summary>
    
      <category term="activeMQ" scheme="http://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(一)简介</title>
    <link href="http://blog.rickiyang.cn/posts/ec039d95.html"/>
    <id>http://blog.rickiyang.cn/posts/ec039d95.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.143Z</updated>
    
    <content type="html"><![CDATA[<h4 id="io简介"><a class="markdownIt-Anchor" href="#io简介"></a> <strong>I/O简介</strong></h4><p>在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。</p><p>Java NIO即Java Non-blocking IO(Java非阻塞I/O)，因为是在Jdk1.4之后增加的一套新的操作I/O工具包，所以一般会被叫做Java New IO。NIO是为提供I/O吞吐量而专门设计，其卓越的性能甚至可以与C媲美。NIO是通过Reactor模式的事件驱动机制来达到Non blocking的，那么什么是Reactor模式呢？Reactor翻译成中文是“反应器”，就是我们将事件注册到Reactor中，当有相应的事件发生时，Reactor便会告知我们有哪些事件发生了，我们再根据具体的事件去做相应的处理。</p><p>NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式–块I/O。块 I/O 的效率可以比流 I/O 高许多。NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p><p>面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p><p>一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><h4 id="nio介绍"><a class="markdownIt-Anchor" href="#nio介绍"></a> <strong>NIO介绍</strong></h4><p>NIO有三个核心模块：Selector(选择器)、Channel(通道)、Buffer(缓冲区)，另外java.nio.charsets包下新增的字符集类也是nio一个重要的模块，但个人觉得不算是NIO的核心，只是一个供NIO核心类使用的工具类。</p><h4 id="通道和缓冲区"><a class="markdownIt-Anchor" href="#通道和缓冲区"></a> <strong>通道和缓冲区</strong></h4><h5 id="什么是通道"><a class="markdownIt-Anchor" href="#什么是通道"></a> <strong>什么是通道</strong></h5><p>通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p><p>Channel是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。<br>正如前面提到的，所有数据都通过 Buffer 对象来处理。你永远不会将字节直接写入通道中，相反，你是将数据写入包含一个或者多个字节的缓冲区。同样，你不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p><p>下面是JAVA NIO中的一些主要Channel的实现：</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p><h4 id="什么是缓冲区"><a class="markdownIt-Anchor" href="#什么是缓冲区"></a> <strong>什么是缓冲区</strong></h4><p>Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，将数据直接写入或者将数据直接读到 Stream 对象中。在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>Buffer与chennel的关系如下：</p><p><img src="http://i.imgur.com/q3fA02A.png" alt=""></p><p>最常用的缓冲区类型是 ByteBuffer。一个 ByteBuffer 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。ByteBuffer 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>每一个 Buffer 类都是 Buffer 接口的一个实例。 除了 ByteBuffer，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I/O 操作都使用 ByteBuffer，所以它具有所有共享的缓冲区操作以及一些特有的操作。</p><h5 id="什么是selector"><a class="markdownIt-Anchor" href="#什么是selector"></a> <strong>什么是Selector</strong></h5><p>在并发型服务器程序中使用NIO，实际上是通过网络事件驱动模型实现的。我们应用Select 机制，不用为每一个客户端连接新启线程处理，而是将其注册到特定的Selector 对象上，这就可以在单线程中利用Selector 对象管理大量并发的网络连接，更好的利用了系统资源；采用非阻塞I/O的通信方式，不要求阻塞等待I/O 操作完成即可返回，从而减少了管理I/O 连接导致的系统开销，大幅度提高了系统性能。</p><p>当有读或写等任何注册的事件发生时，可以从Selector 中获得相应的SelectionKey ， 从SelectionKey 中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。由于在非阻塞网络I/O 中采用了事件触发机制，处理程序可以得到系统的主动通知，从而可以实现底层网络I/O无阻塞、流畅地读写，而不像在原来的阻塞模式下处理程序需要不断循环等待。使用NIO，可以编写出性能更好、更易扩展的并发型服务器程序。</p><p>这是在一个单线程中使用一个Selector处理4个Channel的图示：</p><p><img src="http://i.imgur.com/iWvaX0f.png" alt=""></p><p>要使用Selector，得先向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子比如有新连接进来或是数据接收等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;io简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#io简介&quot;&gt;&lt;/a&gt; &lt;strong&gt;I/O简介&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(五)NIO学习总结以及NIO新特性介绍</title>
    <link href="http://blog.rickiyang.cn/posts/da918f82.html"/>
    <id>http://blog.rickiyang.cn/posts/da918f82.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.380Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道是NIO是在2002年引入到J2SE 1.4里的，很多Java开发者比如我还是不知道怎么充分利用NIO，更少的人知道在Java SE 7里引入了更新的输入/输出 API（NIO.2）。但是对于普通的开发者来说基本的I/O操作就够用了，而NIO则是在处理I/O性能优化方面带来显著性效果。更快的速度则意味着NIO和NIO.2的API暴露了更多低层次的系统操作的入口，这对于开发者而言则意味着更复杂的操作和精巧的程序设计。从前面的几节的讲解来看NIO的操作无不繁琐。要完全掌握还是有点难度的。前面我们讲解了Buffer，Channel，Selector,都是从大的面上去探讨NIO的主要组件。这一节我们则从NIO的特性方面去探讨更细节的一些问题。</p><h4 id="1nio的新特性"><a class="markdownIt-Anchor" href="#1nio的新特性"></a> 1.NIO的新特性</h4><p>总的来说java 中的IO 和NIO的区别主要有3点：</p><ol><li>IO是面向流的，NIO是面向缓冲的；</li><li>IO是阻塞的，NIO是非阻塞的；</li><li>IO是单线程的，NIO 是通过选择器来模拟多线程的；</li></ol><p>NIO在基础的IO流上发展处新的特点，分别是：内存映射技术，字符及编码，非阻塞I/O和文件锁定。下面我们分别就这些技术做一些说明。</p><h4 id="2-内存映射"><a class="markdownIt-Anchor" href="#2-内存映射"></a> 2. 内存映射</h4><p>这个功能主要是为了提高大文件的读写速度而设计的。内存映射文件(memory-mappedfile)能让你创建和修改那些大到无法读入内存的文件。有了内存映射文件，你就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问了。将文件的一段区域映射到内存中，比传统的文件处理速度要快很多。内存映射文件它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。</p><p>NIO中内存映射主要用到以下两个类：</p><ol><li>java.nio.MappedByteBuffer</li><li>java.nio.channels.FileChannel</li></ol><p>下面我们通过一个例子来看一下内存映射读取文件和普通的IO流读取一个150M大文件的速度对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c://1.pdf"</span>,<span class="string">"rw"</span>);</span><br><span class="line">            FileChannel channel = file.getChannel();</span><br><span class="line">            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,channel.size());</span><br><span class="line">            ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> len = file.length();</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//读取内存映射文件</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;file.length();i+=<span class="number">1024</span>*<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (len - i &gt; <span class="number">1024</span>) &#123;</span><br><span class="line">                    buffer.get(b);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    buffer.get(<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)(len - i)]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"使用内存映射方式读取文件总耗时： "</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//普通IO流方式</span></span><br><span class="line">            <span class="keyword">long</span> startTime1 = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span>(channel.read(buffer1) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                buffer1.flip();</span><br><span class="line">                buffer1.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> endTime1 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"使用普通IO流方式读取文件总耗时： "</span>+(endTime1 - startTime1));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果为：</p><p><img src="http://i.imgur.com/biLgFkf.png" alt=""></p><p>效果对比还是挺明显的。我们看到在上面程序中调用FileChannel类的map方法进行内存映射，第一个参数设置映射模式,现在支持3种模式：</p><ol><li><p>FileChannel.MapMode.READ_ONLY：只读缓冲区，在缓冲区中如果发生写操作则会产生ReadOnlyBufferException；</p></li><li><p>FileChannel.MapMode.READ_WRITE：读写缓冲区，任何时刻如果通过内存映射的方式修改了文件则立刻会对磁盘上的文件执行相应的修改操作。别的进程如果也共享了同一个映射，则也会同步看到变化。而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；</p></li><li><p>FileChannel.MapMode.PRIVATE ：这个比较狠，可写缓冲区，但任何修改是缓冲区私有的，不会回到文件中。所以尽情的修改吧，结局跟突然停电是一样的。</p></li></ol><p>我们注意到FileChannel类中有map方法来建立内存映射，按理说是否应用的有相应的unmap方法来卸载映射内存呢。但是竟然没有找到该方法。一旦建立映射保持有效，直到MappedByteBuffer对象被垃圾收集。 此外，映射缓冲区不会绑定到创建它们的通道。 关闭相关的FileChannel不会破坏映射; 只有缓冲对象本身的处理打破了映射。</p><p>内存映射文件的优点：</p><ol><li>用户进程将文件数据视为内存，因此不需要发出read()或write()系统调用。</li><li>当用户进程触摸映射的内存空间时，将自动生成页面错误，以从磁盘引入文件数据。 如果用户修改映射的内存空间，受影响的页面将自动标记为脏，并随后刷新到磁盘以更新文件。</li><li>操作系统的虚拟内存子系统将执行页面的智能缓存，根据系统负载自动管理内存。</li><li>数据始终是页面对齐的，不需要缓冲区复制。</li><li>可以映射非常大的文件，而不消耗大量内存来复制数据。</li></ol><p>下面我们再写一个复制文件的例子来看一下对于一个120M的文件通过这种方式到底能有多快速度的提升：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemMapReadWrite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">readFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(fileName, <span class="string">"rw"</span>);</span><br><span class="line">            len = (<span class="keyword">int</span>) file.length();</span><br><span class="line">            FileChannel channel = file.getChannel();</span><br><span class="line">            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> buffer.get(<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> readFileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeFileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String readFileName, String writeFileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(writeFileName, <span class="string">"rw"</span>);</span><br><span class="line">            FileChannel channel = file.getChannel();</span><br><span class="line">            ByteBuffer buffer = readFile(readFileName);</span><br><span class="line"></span><br><span class="line">            MappedByteBuffer bytebuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, len);</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                bytebuffer.put(i, buffer.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            bytebuffer.flip();</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"写文件耗时： "</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String readFileName = <span class="string">"c://1.pdf"</span>;</span><br><span class="line">        String writeFileName = <span class="string">"c://2.pdf"</span>;</span><br><span class="line"></span><br><span class="line">        writeFile(readFileName, writeFileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="http://i.imgur.com/bMsFKdn.png" alt=""></p><p>这个速度还是相当惊人的！</p><h4 id="2-字符及编码"><a class="markdownIt-Anchor" href="#2-字符及编码"></a> 2. 字符及编码</h4><p>说到字符和编码，我们的先说一个概念，<strong>字符编码方案</strong>：</p><p><em>编码方案定义了如何把字符编码的序列表达为字节序列。字符编码的数值不需要与编码字节相同，也不需要是一对一或一对多个的关系。原则上，把字符集编码和解码近似视为对象的序列化和反序列化。</em></p><p>通常字符数据编码是用于网络传输或文件存储。编码方案不是字符集，它是映射；但是因为它们之间的紧密联系，大部分编码都与一个独立的字符集相关联。例如，UTF-8，仅用来编码Unicode字符集。尽管如此，用一个编码方案处理多个字符集还是可能发生的。例如，EUC可以对几个亚洲语言的字符进行编码。</p><p>目前字符编码方案有US-ASCII,UTF-8,GB2312, BIG5,GBK,GB18030,UTF-16BE, UTF-16LE, UTF-16,UNICODE。其中Unicode试图把全世界所有语言的字符集统一到全面的映射之中。虽然战友一定的市场份额，但是目前其余的字符方案仍然广被采用。<strong>大部分的操作系统在I/O与文件存储方面仍是以字节为导向的，所以无论使用何种编码，Unicode或其他编码，在字节序列和字符集编码之间仍需要进行转化。</strong></p><p>由java.nio.charset包组成的类满足了这个需求。这不是Java平台第一次处理字符集编码，但是它是最系统、最全面、以及最灵活的解决方式。<br>下面我们通过一个小例子来看一下通过不同的Charset实现如何把字符翻译成字节序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharsetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = input.next();</span><br><span class="line">        String[] charsetNames = &#123;<span class="string">"US-ASCII"</span>, <span class="string">"ISO-8859-1"</span>, <span class="string">"UTF-8"</span>, <span class="string">"UTF-16BE"</span>,</span><br><span class="line">                <span class="string">"UTF-16LE"</span>, <span class="string">"UTF-16"</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charsetNames.length; i++) &#123;</span><br><span class="line">            doEncode(Charset.forName(charsetNames[i]), str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doEncode</span><span class="params">(Charset cs, String input)</span> </span>&#123;</span><br><span class="line">        ByteBuffer bb = cs.encode(input);</span><br><span class="line">        System.out.println(<span class="string">"Charset: "</span> + cs.name());</span><br><span class="line">        System.out.println(<span class="string">" Input: "</span> + input);</span><br><span class="line">        System.out.println(<span class="string">"Encoded: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; bb.hasRemaining(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> b = bb.get();</span><br><span class="line">            <span class="keyword">int</span> ival = ((<span class="keyword">int</span>) b) &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>) ival;</span><br><span class="line">            <span class="comment">// Keep tabular alignment pretty</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">10</span>) System.out.print(<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// 打印索引序列</span></span><br><span class="line">            System.out.print(<span class="string">" "</span> + i + <span class="string">": "</span>);</span><br><span class="line">            <span class="comment">// Better formatted output is coming someday...</span></span><br><span class="line">            <span class="keyword">if</span> (ival &lt; <span class="number">16</span>)</span><br><span class="line">                System.out.print(<span class="string">"0"</span>);</span><br><span class="line">            <span class="comment">// 输出该字节位值的16进制形式</span></span><br><span class="line">            System.out.print(Integer.toHexString(ival));</span><br><span class="line">            <span class="comment">// 打印出刚才我们输入的字符，如果是空格或者标准字符集中没有包含</span></span><br><span class="line">            <span class="comment">//该字符输出空格，否则输出该字符</span></span><br><span class="line">            <span class="keyword">if</span> (Character.isWhitespace(c) || Character.isISOControl(c)) &#123;</span><br><span class="line">                System.out.println(<span class="string">""</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">" ("</span> + c + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>abcCharset: US-ASCII Input: abcEncoded:   0: 61 (a)  1: 62 (b)  2: 63 (c)Charset: ISO-8859-1 Input: abcEncoded:   0: 61 (a)  1: 62 (b)  2: 63 (c)Charset: UTF-8 Input: abcEncoded:   0: 61 (a)  1: 62 (b)  2: 63 (c)Charset: UTF-16BE Input: abcEncoded:   0: 00  1: 61 (a)  2: 00  3: 62 (b)  4: 00  5: 63 (c)Charset: UTF-16LE Input: abcEncoded:   0: 61 (a)  1: 00  2: 62 (b)  3: 00  4: 63 (c)  5: 00Charset: UTF-16 Input: abcEncoded:   0: fe (þ)  1: ff (ÿ)  2: 00  3: 61 (a)  4: 00  5: 62 (b)  6: 00  7: 63 (c)Process finished with exit code 0</code></pre><h5 id="21-字符集编码器和解码器"><a class="markdownIt-Anchor" href="#21-字符集编码器和解码器"></a> 2.1 字符集编码器和解码器</h5><p>字符的编码和解码是使用很频繁的，试想如果使用UTF-8字符集进行编码，但是却是用UTF-16字符集进行解码，那么这条信息对于用户来说其实是无用的。因为没人能看得懂。在NIO中提供了两个类CharsetEncoder和CharsetDecoder来实现编码转换方案。</p><p>CharsetEncoder类是一个状态编码引擎。实际上，编码器有状态意味着它们不是线程安全的：CharsetEncoder对象不应该在线程中共享。CharsetEncoder对象是一个状态转换引擎：字符进去，字节出来。一些编码器的调用可能需要完成转换。编码器存储在调用之间转换的状态。</p><p>字符集解码器是编码器的逆转。通过特殊的编码方案把字节编码转化成16-位Unicode字符的序列。与CharsetEncoder类似的, CharsetDecoder也是状态转换引擎。</p><h4 id="3-非阻塞io"><a class="markdownIt-Anchor" href="#3-非阻塞io"></a> 3. 非阻塞IO</h4><p>一般来说 I/O 模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞 四种IO模型。</p><p>同步阻塞 IO ：</p><p>在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。 JAVA传统的 IO 模型属于此种方式！</p><p>同步非阻塞 IO:</p><p>在此种方式下，用户进程发起一个 IO 操作以后可以返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 JAVA 的 NIO 就属于同步非阻塞 IO 。</p><p>异步阻塞 IO ：</p><p>此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！</p><p>异步非阻塞 IO:</p><p>在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为 真正的 IO读取或者写入操作已经由 内核完成了。目前 Java 中还没有支持此种 IO 模型。</p><p>上面我们说到nio是使用了同步非阻塞模型。我们知道典型的非阻塞IO模型一般如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    data = socket.read();</span><br><span class="line">    <span class="keyword">if</span>(data!= error)&#123;</span><br><span class="line">        处理数据</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。所以这就不得不说到下面这个概念–多路复用IO模型。</p><p>多路复用IO模型</p><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p><p>NIO 的非阻塞 I/O 机制是围绕 选择器和 通道构建的。 Channel 类表示服务器和客户机之间的一种通信机制。Selector 类是 Channel 的多路复用器。 Selector 类将传入客户机请求多路分用并将它们分派到各自的请求处理程序。NIO 设计背后的基石是反应器(Reactor)设计模式。</p><p>关于Reactor模式在此就不多做介绍，网上很多。Reactor负责IO事件的响应，一旦有事件发生，便广播发送给相应的handler去处理。而NIO的设计则是完全按照Reactor模式来设计的。Selector发现某个channel有数据时，会通过SelectorKey来告知，然后实现事件和handler的绑定。</p><p>在Reactor模式中，包含如下角色：</p><ul><li>Reactor 将I/O事件发派给对应的Handler</li><li>Acceptor 处理客户端连接请求</li><li>Handlers 执行非阻塞读/写</li></ul><p>我们简单写一个利用了Reactor模式的NIO服务端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(selector.selectNow() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取注册的channel</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//遍历所有的key</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">//如果通道上有事件发生</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//获取该通道</span></span><br><span class="line">                    ServerSocketChannel acceptServerSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel socketChannel = acceptServerSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    LOGGER.info(<span class="string">"Accept request from &#123;&#125;"</span>, socketChannel.getRemoteAddress());</span><br><span class="line">                    <span class="comment">//同时将SelectionKey标记为可读，以便读取。</span></span><br><span class="line">                    SelectionKey readKey = socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">//利用SelectionKey的attache功能绑定Acceptor 如果有事情，触发Acceptor</span></span><br><span class="line">                    <span class="comment">//Processor对象为自定义处理请求的类</span></span><br><span class="line">                    readKey.attach(<span class="keyword">new</span> Processor());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    Processor processor = (Processor) key.attachment();</span><br><span class="line">                    processor.process(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Processor类中设置一个线程池来处理请求，</span></span><br><span class="line"><span class="comment"> * 这样就可以充分利用多线程的优势</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Processor.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ByteBuffer buffer = <span class="keyword">null</span>;</span><br><span class="line">                SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                        selectionKey.cancel();</span><br><span class="line">                        LOGGER.info(<span class="string">"&#123;&#125;\t Read ended"</span>, socketChannel);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                LOGGER.info(<span class="string">"&#123;&#125;\t Read message &#123;&#125;"</span>, socketChannel, <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式带来的好处也是不言而喻的。利用多路复用机制避免了线程的阻塞，提高了连接的数量。一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。虽然多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p><p>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</p><h4 id="4-文件锁定"><a class="markdownIt-Anchor" href="#4-文件锁定"></a> 4. 文件锁定</h4><p>NIO中的文件通道（FileChannel）在读写数据的时候主 要使用了阻塞模式，它不能支持非阻塞模式的读写，而且FileChannel的对象是不能够直接实例化的， 他的实例只能通过getChannel()从一个打开的文件对象上边读取（RandomAccessFile、 FileInputStream、FileOutputStream），并且通过调用getChannel()方法返回一个 Channel对象去连接同一个文件，也就是针对同一个文件进行读写操作。</p><p>文件锁的出现解决了很多Java应用程序和非Java程序之间共享文件数据的问题，在以前的JDK版本中，没有文件锁机制使得Java应用程序和其他非Java进程程序之间不能够针对同一个文件共享 数据，有可能造成很多问题，JDK1.4里面有了FileChannel，它的锁机制使得文件能够针对很多非 Java应用程序以及其他Java应用程序可见。但是Java里面 的文件锁机制主要是基于共 享锁模型，在不支持共享锁模型的操作系统上，文件锁本身也起不了作用，JDK1.4使用文件通道读写方式可以向一些文件 发送锁请求，<br>FileChannel的 锁模型主要针对的是每一个文件，并不是每一个线程和每一个读写通道，也就是以文件为中心进行共享以及独占，也就是文件锁本身并不适合于同一个JVM的不同 线程之间。</p><p>我们简要看一下相关API：</p><pre><code>// 如果请求的锁定范围是有效的，阻塞直至获取锁 public final FileLock lock()  // 尝试获取锁非阻塞，立刻返回结果   public final FileLock tryLock()     // 第一个参数：要锁定区域的起始位置  // 第二个参数：要锁定区域的尺寸,  // 第三个参数：true为共享锁，false为独占锁   public abstract FileLock lock (long position, long size, boolean shared)   public abstract FileLock tryLock (long position, long size, boolean shared) </code></pre><p>锁定区域的范围不一定要限制在文件的size值以内，锁可以扩展从而超出文件尾。因此，我们可以提前把待写入数据的区域锁定，我们也可以锁定一个不包含任何文件内容的区域，比如文件最后一个字节以外的区域。如果之后文件增长到达那块区域，那么你的文件锁就可以保护该区域的文件内容了。相反地，如果你锁定了文件的某一块区域，然后文件增长超出了那块区域，那么新增加 的文件内容将不会受到您的文件锁的保护。</p><p>我们写一个简单实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c://1.txt"</span>, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        <span class="comment">// 写入4个字节</span></span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(<span class="string">"abcd"</span>.getBytes()));</span><br><span class="line">        <span class="comment">// 将前2个字节区域锁定（共享锁）</span></span><br><span class="line">        FileLock lock1 = fileChannel.lock(<span class="number">0</span>, <span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 当前锁持有锁的类型（共享锁/独占锁）</span></span><br><span class="line">        lock1.isShared();</span><br><span class="line">        <span class="comment">// IOException 不能修改只读的共享区域</span></span><br><span class="line">        <span class="comment">// fileChannel.write(ByteBuffer.wrap("a".getBytes()));</span></span><br><span class="line">        <span class="comment">// 可以修改共享锁之外的区域，从第三个字节开始写入</span></span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(<span class="string">"ef"</span>.getBytes()), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// OverlappingFileLockException 重叠的文件锁异常</span></span><br><span class="line">        <span class="comment">// FileLock lock2 = fileChannel.lock(0, 3, true);</span></span><br><span class="line">        <span class="comment">// FileLock lock3 = fileChannel.lock(0, 3, false);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到创建锁的通道</span></span><br><span class="line">        lock1.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁的起始位置</span></span><br><span class="line">        <span class="keyword">long</span> position = lock1.position();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁的范围</span></span><br><span class="line">        <span class="keyword">long</span> size = lock1.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断锁是否与指定文件区域有重叠</span></span><br><span class="line">        lock1.overlaps(position, size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记得用try/catch/finally&#123;release()&#125;方法释放锁</span></span><br><span class="line">        lock1.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们总结了NIO的4个新特性，对于IO来说都是很重要的功能以及性能的升级。下面我们写一个完整的NIO Socket客户端和服务端，总结一下NIO 的用法，每一行都加了注释：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识数字/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缓冲区大小/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> BLOCK = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">//接受数据缓冲区/</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer sendbuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="comment">//发送数据缓冲区/</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer receivebuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">7788</span>;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server(port);</span><br><span class="line">        server.listen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 打开服务器套接字通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 服务器配置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 检索与此通道关联的服务器套接字</span></span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        <span class="comment">// 进行服务的绑定</span></span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        <span class="comment">// 通过open()方法找到Selector</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">// 注册到selector，等待连接</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">"Server Start----7788:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 选择一组键，并且相应的通道已经打开</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 返回此选择器的已选择键集。</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handleKey(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleKey</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 接受请求</span></span><br><span class="line">        ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">        SocketChannel client = <span class="keyword">null</span>;</span><br><span class="line">        String receiveText;</span><br><span class="line">        String sendText;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 测试此键的通道是否已准备好接受新的套接字连接。</span></span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">// 接受到此通道套接字的连接。</span></span><br><span class="line">            <span class="comment">// 此方法返回的套接字通道（如果有）将处于阻塞模式。</span></span><br><span class="line">            client = server.accept();</span><br><span class="line">            <span class="comment">// 配置为非阻塞</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到selector，等待连接</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            client = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//将缓冲区清空以备下次读取</span></span><br><span class="line">            receivebuffer.clear();</span><br><span class="line">            <span class="comment">//读取服务器发送来的数据到缓冲区中</span></span><br><span class="line">            count = client.read(receivebuffer);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                receiveText = <span class="keyword">new</span> String(receivebuffer.array(), <span class="number">0</span>, count);</span><br><span class="line">                System.out.println(<span class="string">"服务器端接受客户端数据--:"</span> + receiveText);</span><br><span class="line">                client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">            <span class="comment">//将缓冲区清空以备下次写入</span></span><br><span class="line">            sendbuffer.clear();</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            client = (SocketChannel) selectionKey.channel();</span><br><span class="line">            sendText = <span class="string">"message from server--"</span> + flag++;</span><br><span class="line">            <span class="comment">//向缓冲区中输入数据</span></span><br><span class="line">            sendbuffer.put(sendText.getBytes());</span><br><span class="line">            <span class="comment">//将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位</span></span><br><span class="line">            sendbuffer.flip();</span><br><span class="line">            <span class="comment">//输出到通道</span></span><br><span class="line">            client.write(sendbuffer);</span><br><span class="line">            System.out.println(<span class="string">"服务器端向客户端发送数据--："</span> + sendText);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标识数字/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缓冲区大小/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> BLOCK = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">//接受数据缓冲区/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer sendbuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="comment">//发送数据缓冲区/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer receivebuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="comment">//服务器端地址/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> InetSocketAddress SERVER_ADDRESS = <span class="keyword">new</span> InetSocketAddress(</span><br><span class="line">            <span class="string">"localhost"</span>, <span class="number">7788</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 打开socket通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置为非阻塞方式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 打开选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 注册连接服务端socket动作</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="comment">// 连接</span></span><br><span class="line">        socketChannel.connect(SERVER_ADDRESS);</span><br><span class="line">        <span class="comment">// 分配缓冲区大小内存</span></span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator;</span><br><span class="line">        SelectionKey selectionKey;</span><br><span class="line">        SocketChannel client;</span><br><span class="line">        String receiveText;</span><br><span class="line">        String sendText;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//选择一组键，其相应的通道已为 I/O 操作准备就绪。</span></span><br><span class="line">            <span class="comment">//此方法执行处于阻塞模式的选择操作。</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//返回此选择器的已选择键集。</span></span><br><span class="line">            selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//System.out.println(selectionKeys.size());</span></span><br><span class="line">            iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                selectionKey = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"client connect"</span>);</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">// 判断此通道上是否正在进行连接操作。</span></span><br><span class="line">                    <span class="comment">// 完成套接字通道的连接过程。</span></span><br><span class="line">                    <span class="keyword">if</span> (client.isConnectionPending()) &#123;</span><br><span class="line">                        client.finishConnect();</span><br><span class="line">                        System.out.println(<span class="string">"完成连接!"</span>);</span><br><span class="line">                        sendbuffer.clear();</span><br><span class="line">                        sendbuffer.put(<span class="string">"Hello,Server"</span>.getBytes());</span><br><span class="line">                        sendbuffer.flip();</span><br><span class="line">                        client.write(sendbuffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//将缓冲区清空以备下次读取</span></span><br><span class="line">                    receivebuffer.clear();</span><br><span class="line">                    <span class="comment">//读取服务器发送来的数据到缓冲区中</span></span><br><span class="line">                    count = client.read(receivebuffer);</span><br><span class="line">                    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        receiveText = <span class="keyword">new</span> String(receivebuffer.array(), <span class="number">0</span>, count);</span><br><span class="line">                        System.out.println(<span class="string">"客户端接受服务器端数据--:"</span> + receiveText);</span><br><span class="line">                        client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">                    sendbuffer.clear();</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    sendText = <span class="string">"message from client--"</span> + (flag++);</span><br><span class="line">                    sendbuffer.put(sendText.getBytes());</span><br><span class="line">                    <span class="comment">//将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位</span></span><br><span class="line">                    sendbuffer.flip();</span><br><span class="line">                    client.write(sendbuffer);</span><br><span class="line">                    System.out.println(<span class="string">"客户端向服务器端发送数据--："</span> + sendText);</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            selectionKeys.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道是NIO是在2002年引入到J2SE 1.4里的，很多Java开发者比如我还是不知道怎么充分利用NIO，更少的人知道在Java SE 7里引入了更新的输入/输出 API（NIO.2）。但是对于普通的开发者来说基本的I/O操作就够用了，而NIO则是在处理I/O性能优化
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(九)-Netty编解码技术之Marshalling</title>
    <link href="http://blog.rickiyang.cn/posts/ccb5d663.html"/>
    <id>http://blog.rickiyang.cn/posts/ccb5d663.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.166Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们讲过protobuf的使用，主流的编解码框架其实还有很多种：</p><pre><code>①JBoss的Marshalling包②google的Protobuf③基于Protobuf的Kyro④Apache的Thrift</code></pre><p>JBoss Marshalling是一个Java对象的序列化API包，修正了JDK自带的序列化包的很多问题，但又保持跟java.io.Serializable接口的兼容；同时增加了一些可调的参数和附加的特性，并且这些参数和特性可通过工厂类进行配置。</p><p>相比于传统的Java序列化机制，它的优点如下：</p><pre><code>1) 可插拔的类解析器，提供更加便捷的类加载定制策略，通过一个接口即可实现定制；2) 可插拔的对象替换技术，不需要通过继承的方式；3) 可插拔的预定义类缓存表，可以减小序列化的字节数组长度，提升常用类型的对象序列化性能；4) 无须实现java.io.Serializable接口，即可实现Java序列化；5) 通过缓存技术提升对象的序列化性能。</code></pre><p>相比于protobuf和thrift的两种编解码框架，JBoss Marshalling更多是在JBoss内部使用，应用范围有限。</p><p>Protobuf全称Google Protocol Buffers，它由谷歌开源而来，在谷歌内部久经考验。它将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。</p><p>它的特点如下：</p><pre><code>1) 结构化数据存储格式（XML，JSON等）；2) 高效的编解码性能；3) 语言无关、平台无关、扩展性好；4) 官方支持Java、C++和Python三种语言。</code></pre><p>首先我们来看下为什么不使用XML，尽管XML的可读性和可扩展性非常好，也非常适合描述数据结构，但是XML解析的时间开销和XML为了可读性而牺牲的空间开销都非常大，因此不适合做高性能的通信协议。Protobuf使用二进制编码，在空间和性能上具有更大的优势。</p><p>Protobuf另一个比较吸引人的地方就是它的数据描述文件和代码生成机制，利用数据描述文件对数据结构进行说明的优点如下：</p><pre><code>1) 文本化的数据结构描述语言，可以实现语言和平台无关，特别适合异构系统间的集成；2) 通过标识字段的顺序，可以实现协议的前向兼容；3) 自动代码生成，不需要手工编写同样数据结构的C++和Java版本；4) 方便后续的管理和维护。相比于代码，结构化的文档更容易管理和维护。</code></pre><hr><p>Thrift源于Facebook，在2007年Facebook将Thrift作为一个开源项目提交给Apache基金会。对于当时的Facebook来说，创造Thrift是为了解决Facebook各系统间大数据量的传输通信以及系统之间语言环境不同需要跨平台的特性，因此Thrift可以支持多种程序语言，如C++、C#、Cocoa、Erlang、Haskell、Java、Ocami、Perl、PHP、Python、Ruby和Smalltalk。</p><p>在多种不同的语言之间通信，Thrift可以作为高性能的通信中间件使用，它支持数据（对象）序列化和多种类型的RPC服务。Thrift适用于静态的数据交换，需要先确定好它的数据结构，当数据结构发生变化时，必须重新编辑IDL文件，生成代码和编译，这一点跟其他IDL工具相比可以视为是Thrift的弱项。Thrift适用于搭建大型数据交换及存储的通用工具，对于大型系统中的内部数据传输，相对于JSON和XML在性能和传输大小上都有明显的优势。</p><p>Thrift主要由5部分组成：</p><pre><code>1) 语言系统以及IDL编译器：负责由用户给定的IDL文件生成相应语言的接口代码；2) TProtocol：RPC的协议层，可以选择多种不同的对象序列化方式，如JSON和Binary；3) TTransport：RPC的传输层，同样可以选择不同的传输层实现，如socket、NIO、MemoryBuffer等；4) TProcessor：作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口；5) TServer：聚合TProtocol、TTransport和TProcessor等对象。</code></pre><p>我们重点关注的是编解码框架，与之对应的就是TProtocol。由于Thrift的RPC服务调用和编解码框架绑定在一起，所以，通常我们使用Thrift的时候会采取RPC框架的方式。但是，它的TProtocol编解码框架还是可以以类库的方式独立使用的。</p><p>与Protobuf比较类似的是，Thrift通过IDL描述接口和数据结构定义，它支持8种Java基本类型、Map、Set和List，支持可选和必选定义，功能非常强大。因为可以定义数据结构中字段的顺序，所以它也可以支持协议的前向兼容。</p><p>Thrift支持三种比较典型的编解码方式：</p><pre><code>1) 通用的二进制编解码；2) 压缩二进制编解码；3) 优化的可选字段压缩编解码。</code></pre><p>由于支持二进制压缩编解码，Thrift的编解码性能表现也相当优异，远远超过Java序列化和RMI等。</p><p>这一节我们来讲解JBoss的Marshalling的使用。</p><p>和protobuf的使用不同，netty默认支持protobuf，所以为他预设了一个编解码器：ProtobufVarint32LengthFieldPrepender，ProtobufVarint32FrameDecoder。那如果采用jboss-marshalling进行编解码，则没有这么好的运气我们需要自己优先创建一个编解码的工厂类，供信息通讯时候对信息的编解码。</p><p>pom文件如下，需要新增两个jar包：jboss-marshalling，jboss-marshalling-serial。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;cn.edu.hust.netty&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;netty&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;name&gt;netty Maven Webapp&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http:<span class="comment">//maven.apache.org&lt;/url&gt;</span></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.5.Final&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.jboss.marshalling&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jboss-marshalling-river&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.4.10.Final&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.jboss.marshalling&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jboss-marshalling-serial&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.4.11.Final&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;netty&lt;/finalName&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>我们先来写一个工厂类，手动创建编解码器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.handler.codec.marshalling.*;</span><br><span class="line"><span class="keyword">import</span> org.jboss.marshalling.MarshallerFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.marshalling.Marshalling;</span><br><span class="line"><span class="keyword">import</span> org.jboss.marshalling.MarshallingConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marshalling工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MarshallingCodeCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Jboss Marshalling解码器MarshallingDecoder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MarshallingDecoder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MarshallingDecoder <span class="title">buildMarshallingDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先通过Marshalling工具类的精通方法获取Marshalling实例对象 参数serial标识创建的是java序列化工厂对象。</span></span><br><span class="line">        <span class="keyword">final</span> MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(<span class="string">"serial"</span>);</span><br><span class="line">        <span class="comment">//创建了MarshallingConfiguration对象，配置了版本号为5 </span></span><br><span class="line">        <span class="keyword">final</span> MarshallingConfiguration configuration = <span class="keyword">new</span> MarshallingConfiguration();</span><br><span class="line">        configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//根据marshallerFactory和configuration创建provider</span></span><br><span class="line">        UnmarshallerProvider provider = <span class="keyword">new</span> DefaultUnmarshallerProvider(marshallerFactory, configuration);</span><br><span class="line">        <span class="comment">//构建Netty的MarshallingDecoder对象，俩个参数分别为provider和单个消息序列化后的最大长度</span></span><br><span class="line">        MarshallingDecoder decoder = <span class="keyword">new</span> MarshallingDecoder(provider, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> decoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Jboss Marshalling编码器MarshallingEncoder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MarshallingEncoder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MarshallingEncoder <span class="title">buildMarshallingEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(<span class="string">"serial"</span>);</span><br><span class="line">        <span class="keyword">final</span> MarshallingConfiguration configuration = <span class="keyword">new</span> MarshallingConfiguration();</span><br><span class="line">        configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">        MarshallerProvider provider = <span class="keyword">new</span> DefaultMarshallerProvider(marshallerFactory, configuration);</span><br><span class="line">        <span class="comment">//构建Netty的MarshallingEncoder对象，MarshallingEncoder用于实现序列化接口的POJO对象序列化为二进制数组</span></span><br><span class="line">        MarshallingEncoder encoder = <span class="keyword">new</span> MarshallingEncoder(provider);</span><br><span class="line">        <span class="keyword">return</span> encoder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWordServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWordServer server = <span class="keyword">new</span> HelloWordServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(MarshallingCodeCFactory.buildMarshallingDecoder());</span><br><span class="line">        pipeline.addLast(MarshallingCodeCFactory.buildMarshallingEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWordServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们在这里加入了刚才我们写的编解码器哈，顺序没有关系。</p><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            System.out.println(msg.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="string">"received your msg"</span>);</span><br><span class="line">            Msg m = (Msg)msg;</span><br><span class="line">            System.out.println(<span class="string">"client: "</span>+m.getBody());</span><br><span class="line">            m.setBody(<span class="string">"人生苦短，快用python"</span>);</span><br><span class="line">            ctx.writeAndFlush(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().writeAndFlush(<span class="string">"Hello Netty Server ,I am a common client"</span>);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pipeline.addLast(MarshallingCodeCFactory.buildMarshallingDecoder());</span><br><span class="line">        pipeline.addLast(MarshallingCodeCFactory.buildMarshallingEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端的逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWorldClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样这里也加入编解码器。</p><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Msg m = (Msg)msg;</span><br><span class="line">            System.out.println(<span class="string">"client: "</span>+m.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Msg msg = <span class="keyword">new</span> Msg();</span><br><span class="line">        msg.setHeader((<span class="keyword">byte</span>)<span class="number">0xa</span>);</span><br><span class="line">        msg.setLength(<span class="number">34</span>);</span><br><span class="line">        msg.setBody(<span class="string">"放纵自己，你好兄弟"</span>);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意上面有一个Msg对象，这个就是我们自己定义的一个对象，用于网络传输用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义一个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> header;</span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(<span class="keyword">byte</span> header)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.header = header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBody</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">long</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">byte</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们运行客户端和服务端，可以看到消息已经发出去了：</p><p><img src="http://i.imgur.com/t6Q6bw4.jpg" alt=""></p><p><img src="http://i.imgur.com/QCNI69O.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们讲过protobuf的使用，主流的编解码框架其实还有很多种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;①JBoss的Marshalling包

②google的Protobuf

③基于Protobuf的Kyro

④Apache的Thrift
&lt;/code&gt;&lt;/pre&gt;
&lt;
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（三）----线程的同步</title>
    <link href="http://blog.rickiyang.cn/posts/71e4d230.html"/>
    <id>http://blog.rickiyang.cn/posts/71e4d230.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-05T06:13:34.116Z</updated>
    
    <content type="html"><![CDATA[<p>在现实开发中，我们或多或少的都经历过这样的情景：某一个变量被多个用户并发式的访问并修改，如何保证该变量在并发过程中对每一个用户的正确性呢？今天我们来聊聊线程同步的概念。</p><p>一般来说，程序并行化是为了获得更高的执行效率，但前提是，高效率不能以牺牲正确性为代价。如果程序并行化后， 连基本的执行结果的正确性都无法保证， 那么并行程序本身也就没有任何意义了。因此， 线程安全就是并行程序的根本和根基。解决这些问题从<strong>临界区</strong>的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。</p><p>java为我们提供了同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界 区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。临界区有如下的规则：</p><blockquote><ol><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</li><li>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li></ol></blockquote><p>java语言为解决同步问题帮我们提供了两种机制来实现：</p><pre><code>1. synchronized关键字；2. Lock锁及其实现；</code></pre><h4 id="1-synchronized的作用"><a class="markdownIt-Anchor" href="#1-synchronized的作用"></a> 1 synchronized的作用</h4><p>关键字synchronized 的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次， 只能有一个线程进入同步块，从而保证线程间的安全性。</p><p>关键宇synchronized 可以有多种用法。这里做一个简单的整理。</p><pre><code>· 指定加锁对象: 对给定对象加锁，进入同步代码前要获得给定对象的锁。· 直接作用于实例方法: 相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。. 直接作用于静态方法: 相当于对当前类加锁， 进入同步代码前要获得当前类的锁。</code></pre><p>1.给指定对象加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync() ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i =O;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span>(<span class="keyword">int</span> j=O; j&lt;lOOOOOOO; j++)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (instance) &#123;   <span class="comment">//对象锁</span></span><br><span class="line">            i++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> <span class="title">InterruptedException</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Thread t1=new Thread(instance)</span></span>;</span><br><span class="line">    Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static void main(String[] args) throws InterruptedException (</span></span><br><span class="line"><span class="comment">    Thread t1=new Thread(new AccountingSync());</span></span><br><span class="line"><span class="comment">    Thread t2=new Thread(new AccountingSync());</span></span><br><span class="line"><span class="comment">    t1.start();</span></span><br><span class="line"><span class="comment">    t2.start();</span></span><br><span class="line"><span class="comment">    t1.join();</span></span><br><span class="line"><span class="comment">    t2.join();</span></span><br><span class="line"><span class="comment">    System.out.println(i);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>知道我为什么要给出两个main方法让大家参考吗？上述锁对象是锁定AccountingSync实例对象。第一个main方法中t1 和 t2 两个线程同时指向了instance实例，所以第7行的锁对象synchronized (instance)在线程t1 和 线程 t2 获得锁的时候是获取同一个对象的，这个时候的锁是同一把锁。但是在第二个main方法中我们可以看到线程t1 和 线程 t2分别对应的是两个不同的AccountingSync对象，这时候锁对象获得的是不同的AccountingSync实例，安全性是没有保证的，大家可以动手尝试一下。</p><p>2.直接作用于实例方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tester2 a1 = <span class="keyword">new</span> Tester2();</span><br><span class="line">        Th t1 = <span class="keyword">new</span> Th(a1);</span><br><span class="line">        t1.start();</span><br><span class="line">        Th t2 = <span class="keyword">new</span> Th(a1);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(name +<span class="string">","</span>+i+<span class="keyword">new</span> Date().toLocaleString() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Th</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    Tester2 test;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Th</span><span class="params">(Tester2 test1)</span></span>&#123;</span><br><span class="line">        test = test1;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.say(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对Tester2类中的方法使用synchronized很好理解，同一时刻如果t1正在调用say()方法，在他没有执行完毕并退出方法之前其余的线程是无法获得该方法的。只能排队等待知道t1执行完毕。</p><p>3.作用于静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Sale(<span class="number">5</span>));</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producted(<span class="number">5</span>));</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shop</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">40</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a -= b;</span><br><span class="line">        System.out.println(<span class="string">"售出  "</span>+b+<span class="string">"  张大饼，"</span>+<span class="string">"还剩  "</span>+a+<span class="string">" 张大饼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">factory</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        a += c;</span><br><span class="line">        System.out.println(<span class="string">"仓库还有  "</span>+a+<span class="string">"  张大饼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sale</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sale</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125;</span><br><span class="line">        Shop.shopping(b);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            Shop.factory(b-<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producted</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producted</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Shop.factory(b);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            Shop.shopping(b-<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法前加synchronized这个锁等价于锁住了当前类的class对象，因为静态方法或者是静态关键字在本质上是一个类对象，而不是成员对象，在内存中位于方法区被所有的实例共享。即等同于synchronized(Shop.class)。我们需要注意的是锁住了类并不代表锁住了类所在的对象，类本身也是一种对象。它与类的实例是完全不同的两个对象，在加锁时不是相互依赖的，即对类加锁并不与上面例子中的加锁互斥，锁住了子类或子类的对象与锁住父类或父类的对象是不相关的。</p><p>synchronized的使用其实主要是前面两种，对象锁和方法锁，静态方法锁我们并不常用到。其余的操作方式都是在这两种的基础上演变而来，比如大家经常说的“块级锁”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">    <span class="comment">//代码内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁住的其实并不是代码块，而是object这个对象，所以如果在其他的代码中<br>也发生synchronized(object)时就会发生互斥。我们为什么要研究这些呢，因为如果我们不知道我们锁住的是什么，就不清楚锁住了多大范围的内容，自然就不知道是否锁住了想要得到互斥的效果，同时也不知道如何去优化锁的使用。</p><p>因此java中的synchronized就真正能做到临界区的效果，在临界区内多个线程的操作绝对是串行的，这一点java绝对可以保证。同时synchronized造成的开销也是很大的，我们如果无法掌握好他的粒度控制，就会导致频繁的锁征用，进入悲观锁状态。</p><h4 id="2-volatile-轻量级的synchronized"><a class="markdownIt-Anchor" href="#2-volatile-轻量级的synchronized"></a> 2 volatile----轻量级的synchronized</h4><p>既然我们说到了synchronized那就不得不提到volatile，在java中synchronized是控制并发的，我们知道在我们对一个变量执行赋值操作的时候比如：i++，在执行完毕之后i的结果其实是写到缓存中的它并没有及时的写入到内存，后续在某些情况下（比如cpu缓存不够）再将cpu缓存写入内存，假设A线程正在执行i<ins>操作，而此时B线程也来执行。B在执行i</ins>之前是不会自己跑到缓存中去取变量的值的，它只会去内存中读取i，很显然i的值是没有被更新的，为了防止这种情况出现，volatile应运而生。</p><p>Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWithoutVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bChanged;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (bChanged == !bChanged) &#123;  </span><br><span class="line">                        System.out.println(<span class="string">"!="</span>);  </span><br><span class="line">                        System.exit(<span class="number">0</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        Thread.sleep(<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    bChanged = !bChanged;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中我们如果多次运行会出现两种结果，一种是正常打印：&quot;!=&quot;,还有一种就是程序会陷入死循环。但是我们如果给bChanged前面加上volatile的话则每次都会打印出&quot;!=&quot;,请读者朋友们下去可以尝试。<br>在此处没有加volatile之前之所以会出现有时可以出现正确结果有时则卡死的原因就在于两个线程同时在运行的过程中双方都在操作bChanged变量，但是该变量的值对于同时在使用它的另一个线程来说并不总是可见的，运气好的时候线程修改完值之后就写入主存，运气不好的时候线程只在缓存中更新了值并未写入主存。但是在加了volatile修饰之后效果则不同，因为volatile可以保证变量的可见性。<br>说到可见性，我们来看一幅图：</p><p><img src="http://img.blog.csdn.net/20161222222356667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>每一个线程都有相应的工作内存，工作内存中有一份主内存变量的副本，线程对变量的操作都在工作内存中进行（避免再次访问主内存，提高性能），不同线程不能访问彼此的工作内存，而通过将操作后的值刷新到主内存来进行彼此的交互，这就会带来一个变量值对其他线程的可见性问题。当一个任务在工作内存中变量值进行改变，其他任务对此是不可见的，导致每一个线程都有一份不同的变量副本。而volatile恰恰可以解决这个可见性的问题，当变量被volatile修饰，如private volatile int stateFlag = 0; 它将直接通过主内存中被读取或者写入，线程从主内存中加载的值将是最新的。</strong></p><p>但是volatile的使用有着严格的限制，当对变量的操作依赖于以前值（如i++）,或者其值被其他字段的值约束，这个时候volatile是无法实现线程安全的。被volatile修饰的变量必须独立于程序的其他状态。因为volatile只是保证了变量的可见性，并不能保证操作的原子性，所谓原子性，即有“不可分”的意思，如对基本数据类型(java中排除long和double)的赋值操作a=6,如返回操作return a，这些操作都不会被线程调度器中断，同一时刻只有一个线程对它进行操作。<br>看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//这里延迟1毫秒，使得结果明显</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></span><br><span class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> + Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的例子我们可以发现每次运行的结果都不一样，预期结果应该是1000，尽管counter被volatile修饰，保证了可见性，但是counter++并不是一个原子性操作，它被拆分为读取和写入两部分操作，我们需要用synchronized修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicstaticsynchronizedvoid <span class="title">incNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时每次运行结果都是1000，实现了线程安全。synchronized是一种独占锁，它对一段操作或内存进行加锁，当线程要操作被synchronized修饰的内存或操作时，必须首先获得锁才能进行后续操作；但是在同一时刻只能有一个线程获得相同的一把锁，所以它只允许一个线程进行操作。synchronized同样能够将变量最新值刷新到主内存，当一个变量只被synchronized方法操作时,是没有必要用volatile修饰的，所以我们接着把变量声明修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br></pre></td></tr></table></figure><p>多次运行结果依旧是1000。</p><p><strong>说明</strong>：<br>上例中如果你按照上面这样改完之后其实结果并是不1000，我多次运行的结果都是先打印出&quot;运行结果:Counter.count=0&quot;,然后线程卡死。究其原因，我猜可能是第一个线程等待一秒再执行count++，然后后面的线程在这个等待过程中等不及的原因。java线程的运行具有不确定性，不能保证线程会按部就班的顺序执行，所以会出现什么样的后果很难预测。<br>正确结果代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></span><br><span class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> + Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，由于volatile只能保证变量对多个线程的可见性，但不能保证原子性，它的同步机制是比较脆弱的，它在使用过程中有着诸多限制，对使用者也有更高的要求，相对而言，synchronized锁机制是比较安全的同步机制，有时候出于提高性能的考虑，可以利用volatile对synchronized进行代替和优化，但前提是你必须充分理解其使用场景和涵义。</p><p>下一节我们接着分析Lock锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在现实开发中，我们或多或少的都经历过这样的情景：某一个变量被多个用户并发式的访问并修改，如何保证该变量在并发过程中对每一个用户的正确性呢？今天我们来聊聊线程同步的概念。&lt;/p&gt;
&lt;p&gt;一般来说，程序并行化是为了获得更高的执行效率，但前提是，高效率不能以牺牲正确性为代价。如果
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（三）----线程的同步</title>
    <link href="http://blog.rickiyang.cn/posts/71e4d230.html"/>
    <id>http://blog.rickiyang.cn/posts/71e4d230.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.158Z</updated>
    
    <content type="html"><![CDATA[<p>在现实开发中，我们或多或少的都经历过这样的情景：某一个变量被多个用户并发式的访问并修改，如何保证该变量在并发过程中对每一个用户的正确性呢？今天我们来聊聊线程同步的概念。</p><p>一般来说，程序并行化是为了获得更高的执行效率，但前提是，高效率不能以牺牲正确性为代价。如果程序并行化后， 连基本的执行结果的正确性都无法保证， 那么并行程序本身也就没有任何意义了。因此， 线程安全就是并行程序的根本和根基。解决这些问题从<strong>临界区</strong>的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。</p><p>java为我们提供了同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。临界区有如下的规则：</p><blockquote><ol><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</li><li>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li></ol></blockquote><p>java语言为解决同步问题帮我们提供了两种机制来实现：</p><pre><code>1. synchronized关键字；2. Lock锁及其实现；</code></pre><h4 id="synchronized的作用"><a class="markdownIt-Anchor" href="#synchronized的作用"></a> synchronized的作用</h4><p>关键字synchronized 的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次， 只能有一个线程进入同步块，从而保证线程间的安全性。</p><p>关键宇synchronized 可以有多种用法。这里做一个简单的整理。</p><pre><code>· 指定加锁对象: 对给定对象加锁，进入同步代码前要获得给定对象的锁。· 直接作用于实例方法: 相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。. 直接作用于静态方法: 相当于对当前类加锁， 进入同步代码前要获得当前类的锁。</code></pre><p>1.给指定对象加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync() ;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i =O;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span>(<span class="keyword">int</span> j=O; j&lt;lOOOOOOO; j++)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (instance) &#123;   <span class="comment">//对象锁</span></span><br><span class="line">                i++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> <span class="title">InterruptedException</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Thread t1=new Thread(instance)</span></span>;</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public static void main(String[] args) throws InterruptedException (</span></span><br><span class="line"><span class="comment">        Thread t1=new Thread(new AccountingSync());</span></span><br><span class="line"><span class="comment">        Thread t2=new Thread(new AccountingSync());</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        t2.start();</span></span><br><span class="line"><span class="comment">        t1.join();</span></span><br><span class="line"><span class="comment">        t2.join();</span></span><br><span class="line"><span class="comment">        System.out.println(i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道我为什么要给出两个main方法让大家参考吗？上述锁对象是锁定AccountingSync实例对象。第一个main方法中t1 和 t2 两个线程同时指向了instance实例，所以第7行的锁对象synchronized (instance)在线程t1 和 线程 t2 获得锁的时候是获取同一个对象的，这个时候的锁是同一把锁。但是在第二个main方法中我们可以看到线程t1 和 线程 t2分别对应的是两个不同的AccountingSync对象，这时候锁对象获得的是不同的AccountingSync实例，安全性是没有保证的，大家可以动手尝试一下。</p><p>2.直接作用于实例方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tester2 a1 = <span class="keyword">new</span> Tester2();</span><br><span class="line">        Th t1 = <span class="keyword">new</span> Th(a1);</span><br><span class="line">        t1.start();</span><br><span class="line">        Th t2 = <span class="keyword">new</span> Th(a1);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(name +<span class="string">","</span>+i+<span class="keyword">new</span> Date().toLocaleString() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Th</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    Tester2 test;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Th</span><span class="params">(Tester2 test1)</span></span>&#123;</span><br><span class="line">        test = test1;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.say(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对Tester2类中的方法使用synchronized很好理解，同一时刻如果t1正在调用say()方法，在他没有执行完毕并退出方法之前其余的线程是无法获得该方法的。只能排队等待知道t1执行完毕。</p><p>3.作用于静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">                Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Sale(<span class="number">5</span>));</span><br><span class="line">                Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producted(<span class="number">5</span>));</span><br><span class="line">                t1.start();</span><br><span class="line">                t2.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Shop</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">40</span>;</span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            a -= b;</span><br><span class="line">            System.out.println(<span class="string">"售出  "</span>+b+<span class="string">"  张大饼，"</span>+<span class="string">"还剩  "</span>+a+<span class="string">" 张大饼"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">factory</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">            a += c;</span><br><span class="line">            System.out.println(<span class="string">"仓库还有  "</span>+a+<span class="string">"  张大饼"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sale</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Sale</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                Thread.interrupted();</span><br><span class="line">            &#125;</span><br><span class="line">            Shop.shopping(b);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                Shop.factory(b-<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producted</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producted</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Shop.factory(b);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                Shop.shopping(b-<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">静态方法前加<span class="keyword">synchronized</span>这个锁等价于锁住了当前类的<span class="class"><span class="keyword">class</span>对象，因为静态方法或者是静态关键字在本质上是一个类对象，而不是成员对象，在内存中位于方法区被所有的实例共享。即等同于<span class="title">synchronized</span>(<span class="title">Shop</span>.<span class="title">class</span>)。我们需要注意的是锁住了类并不代表锁住了类所在的对象，类本身也是一种对象。它与类的实例是完全不同的两个对象，在加锁时不是相互依赖的，即对类加锁并不与上面例子中的加锁互斥，锁住了子类或子类的对象与锁住父类或父类的对象是不相关的。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">synchronized</span>的使用其实主要是前面两种，对象锁和方法锁，静态方法锁我们并不常用到。其余的操作方式都是在这两种的基础上演变而来，比如大家经常说的“块级锁”：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">```<span class="title">java</span></span></span><br><span class="line"><span class="class"><span class="title">synchronized</span>(<span class="title">object</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//代码内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁住的其实并不是代码块，而是object这个对象，所以如果在其他的代码中<br>也发生synchronized(object)时就会发生互斥。我们为什么要研究这些呢，因为如果我们不知道我们锁住的是什么，就不清楚锁住了多大范围的内容，自然就不知道是否锁住了想要得到互斥的效果，同时也不知道如何去优化锁的使用。</p><p>因此java中的synchronized就真正能做到临界区的效果，在临界区内多个线程的操作绝对是串行的，这一点java绝对可以保证。同时synchronized造成的开销也是很大的，我们如果无法掌握好他的粒度控制，就会导致频繁的锁征用，进入悲观锁状态。</p><p>####volatile----轻量级的synchronized<br>既然我们说到了synchronized那就不得不提到volatile，在java中synchronized是控制并发的，我们知道在我们对一个变量执行赋值操作的时候比如：i++，在执行完毕之后i的结果其实是写到缓存中的它并没有及时的写入到内存，后续在某些情况下（比如cpu缓存不够）再将cpu缓存写入内存，假设A线程正在执行i<ins>操作，而此时B线程也来执行。B在执行i</ins>之前是不会自己跑到缓存中去取变量的值的，它只会去内存中读取i，很显然i的值是没有被更新的，为了防止这种情况出现，volatile应运而生。</p><p>Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWithoutVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bChanged;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (bChanged == !bChanged) &#123;  </span><br><span class="line">                        System.out.println(<span class="string">"!="</span>);  </span><br><span class="line">                        System.exit(<span class="number">0</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        Thread.sleep(<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    bChanged = !bChanged;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中我们如果多次运行会出现两种结果，一种是正常打印：&quot;!=&quot;,还有一种就是程序会陷入死循环。但是我们如果给bChanged前面加上volatile的话则每次都会打印出&quot;!=&quot;,请读者朋友们下去可以尝试。<br>在此处没有加volatile之前之所以会出现有时可以出现正确结果有时则卡死的原因就在于两个线程同时在运行的过程中双方都在操作bChanged变量，但是该变量的值对于同时在使用它的另一个线程来说并不总是可见的，运气好的时候线程修改完值之后就写入主存，运气不好的时候线程只在缓存中更新了值并未写入主存。但是在加了volatile修饰之后效果则不同，因为volatile可以保证变量的可见性。<br>说到可见性，我们来看一幅图：<br><img src="http://img.blog.csdn.net/20161222222356667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>每一个线程都有相应的工作内存，工作内存中有一份主内存变量的副本，线程对变量的操作都在工作内存中进行（避免再次访问主内存，提高性能），不同线程不能访问彼此的工作内存，而通过将操作后的值刷新到主内存来进行彼此的交互，这就会带来一个变量值对其他线程的可见性问题。当一个任务在工作内存中变量值进行改变，其他任务对此是不可见的，导致每一个线程都有一份不同的变量副本。而volatile恰恰可以解决这个可见性的问题，当变量被volatile修饰，如private volatile int stateFlag = 0; 它将直接通过主内存中被读取或者写入，线程从主内存中加载的值将是最新的。</strong></p><p>但是volatile的使用有着严格的限制，当对变量的操作依赖于以前值（如i++）,或者其值被其他字段的值约束，这个时候volatile是无法实现线程安全的。被volatile修饰的变量必须独立于程序的其他状态。因为volatile只是保证了变量的可见性，并不能保证操作的原子性，所谓原子性，即有“不可分”的意思，如对基本数据类型(java中排除long和double)的赋值操作a=6,如返回操作return a，这些操作都不会被线程调度器中断，同一时刻只有一个线程对它进行操作。<br>看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//这里延迟1毫秒，使得结果明显</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></span><br><span class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> + Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的例子我们可以发现每次运行的结果都不一样，预期结果应该是1000，尽管counter被volatile修饰，保证了可见性，但是counter++并不是一个原子性操作，它被拆分为读取和写入两部分操作，我们需要用synchronized修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicstaticsynchronizedvoid <span class="title">incNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时每次运行结果都是1000，实现了线程安全。synchronized是一种独占锁，它对一段操作或内存进行加锁，当线程要操作被synchronized修饰的内存或操作时，必须首先获得锁才能进行后续操作；但是在同一时刻只能有一个线程获得相同的一把锁，所以它只允许一个线程进行操作。synchronized同样能够将变量最新值刷新到主内存，当一个变量只被synchronized方法操作时,是没有必要用volatile修饰的，所以我们接着把变量声明修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br></pre></td></tr></table></figure><p>多次运行结果依旧是1000。</p><p><strong>说明</strong>：<br>上例中如果你按照上面这样改完之后其实结果并是不1000，我多次运行的结果都是先打印出&quot;运行结果:Counter.count=0&quot;,然后线程卡死。究其原因，我猜可能是第一个线程等待一秒再执行count++，然后后面的线程在这个等待过程中等不及的原因。java线程的运行具有不确定性，不能保证线程会按部就班的顺序执行，所以会出现什么样的后果很难预测。<br>正确结果代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></span><br><span class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> + Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，由于volatile只能保证变量对多个线程的可见性，但不能保证原子性，它的同步机制是比较脆弱的，它在使用过程中有着诸多限制，对使用者也有更高的要求，相对而言，synchronized锁机制是比较安全的同步机制，有时候出于提高性能的考虑，可以利用volatile对synchronized进行代替和优化，但前提是你必须充分理解其使用场景和涵义。</p><p>下一节我们接着分析Lock锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在现实开发中，我们或多或少的都经历过这样的情景：某一个变量被多个用户并发式的访问并修改，如何保证该变量在并发过程中对每一个用户的正确性呢？今天我们来聊聊线程同步的概念。&lt;/p&gt;
&lt;p&gt;一般来说，程序并行化是为了获得更高的执行效率，但前提是，高效率不能以牺牲正确性为代价。如果
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件和JMS介绍(一)</title>
    <link href="http://blog.rickiyang.cn/posts/c0d0b105.html"/>
    <id>http://blog.rickiyang.cn/posts/c0d0b105.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.378Z</updated>
    
    <content type="html"><![CDATA[<p>在一个公司创立初期，他可能只有几个应用，系统之间的关联也不是那么大，A系统调用B系统就直接调用B提供的API接口；后来这个公司做大了，他一步步发展有了几十个系统，这时候A系统要调用B系统的接口，但是B系统前几天刚改了一下接口A并不知情。所以A发现调不通于是给B系统管理员打电话，小王啊，改了接口咋不告诉我呢。我还以为我们系统出错了呢。弄得小王一顿尴尬，我这自己改个东西还的通知这个通知那个的。</p><p>####** 1  中间件介绍**<br>我们看到上面的故事中的小王他真的是很累啊。自己修改一个接口还的给所有调用接口的系统管理员打电话告知API发生变化。说到这个问题啊，还是的说我们系统之间的耦合。对于一个小公司来说是无所谓，但是对于一个大公司这种情况简直是致命的。于是最近几年这些越来越大的互联网公司在这种挑战下提出了中间件这个概念：中间件在操作系统软件，网络和数据库之上，应用软件之下，总的作用是为处于自己上层的软件提供灵活的开发环境。因而中间件是指一类软件，是基于分布式处理的软件，最突出的特点是其网络通信功能。也可认为中间件是位于平台和应用之间的通用服务，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，可以有符合接口和协议的多种实现。</p><p><img src="http://i.imgur.com/Y6vUXNA.png" alt=""></p><p>#####** 1.1 中间件分类**<br>中间件可以分为六类：</p><ol><li><p>终端仿真/屏幕转换</p></li><li><p>数据访问中间件（UDA）</p></li><li><p>远程过程调用中间件（RPC）</p></li><li><p>消息中间件（MOM）</p></li><li><p>交易中间件（TPM）</p></li><li><p>对象中间件</p></li></ol><p>然而在实际应用中，一般将中间件分为两大类：</p><p>一类是底层中间件，用于支撑单个应用系统或解决一类问题，包括交易中间件、应用服务器、消息中间件、数据访问中间件等；</p><p>另一类是高层中间件，更多的用于系统整合，包括企业应用集成中间件、工作流中间件、门户中间件等，他们通常会与多个应用系统打交道，在系统中层次较高，并大多基于前一类的底层中间件运行。</p><p><strong>终端仿真/屏幕转换</strong></p><p>此类中间件用于实现客户机图形用户接口与已有的字符接口方式的服务器应用程序之间的互操作，应用与早期的大型机系统，现在已很少使用。</p><p><strong>数据访问中间件</strong></p><p>此类中间件是为了建立数据应用资源互操作的模式，对异构环境下的数据库或文件系统实现联接。</p><p><strong>远程过程调用中间件</strong></p><p>此类中间件可以使开发人员在需要时调用位于远端服务器上的过程，屏蔽了在调用过程中的通信细节。一个应用程序使用RPC来远程执行一个位于不同地址空间里的过程，在效果上看和执行本地调用相同。</p><p><strong>交易中间件</strong></p><p>此类中间件是专门针对联机交易系统而设计的。联机交易系统需要处理大量并发进程，处理并发涉及到操作系统，文件系统，编程语言，数据通信，数据库系统，系统管理，应用软件等。而交易中间件根据分布式交易处理的标准及参考模型，对资源管理，交易管理和应用进行了实现，从而使得基于交易中间件开发应用程序更为简单。交易中间件基本上只适用于联机交易系统，是一种较为专用的中间件。</p><p><strong>消息中间件</strong></p><p>此类中间件是指利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p><p>消息中间件可以即支持同步方式，又支持异步方式。异步中间件比同步中间件具有更强的容错性，在系统故障时可以保证消息的正常传输。异步中间件技术又分为两类：广播方式和发布/订阅方式。由于发布/订阅方式可以指定哪种类型的用户可以接受哪种类型的消息，更加有针对性，事实上已成为异步中间件的非正式标准。目前主流的消息中间件产品有IBM的MQSeries，BEA的MessageQ和Sun的JMS等[1]。</p><p><strong>对象中间件</strong></p><p>传统的对象技术通过封装、继承及多态提供了良好的代码重用功能。但这些对象只存在与一个程序中，外界并不知道它们的存在，也无法访问它们。对象中间件提供了一个标准的构建框架，能使不同厂家的软件通过不同的地址空间，网络和操作系统实现交互访问。对象中间件的目标是为软件用户及开发者提供一种应用级的即插即用的互操作性。目前主流的对象中间件有OMG的CORBA，Microsoft 的COM以及IBM的SOM，Sun的RMI等。</p><p><strong>中间件的特点</strong></p><p>一般来讲，中间件具有以下一些特点：满足大量应用的需求，运行于多种硬件和操作系统平台，支持分布式计算，支持标准接口和协议。开发人员通过调用中间件提供的大量API，实现异构环境的通信，从而屏蔽异构系统中复杂的操作系统和网络协议。</p><p>由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。分布式应用软件借助中间件可以在不同的技术之间共享资源。</p><p>总的来说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少了程序设计的复杂性，将注意力集中与自己的业务上，不必再为程序在不同软件系统上的移植而重复工作，从而大大减少了技术上的负担。</p><h4 id="2-消息中间件"><a class="markdownIt-Anchor" href="#2-消息中间件"></a> ** 2  消息中间件**</h4><p>面向消息的中间件（MOM），提供了以松散耦合的灵活方式集成应用程序的一种机制。它们提供了基于存储和转发的应用程序之间的异步数据发送，即应用程序彼此不直接通信，而是与作为中介的MOM通信。MOM提供了有保证的消息发送（至少是在尽可能地做到这一点），应用程序开发人员无需了解远程过程调用（RPC）和网络/通信协议的细节。</p><p>消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被用程序读走。通过消息队列，应用程序可独立地执行–它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。设计分布式应用的方法主要有：远程过程调用(RPC)–分布式计算环境(DCE)的基础标准成分之一；对象事务监控(OTM)–基于CORBA的面向对象工业标准与事务处理(TP)监控技术的组合；消息队列(MessageQueue)–构造分布式应用的松耦合方法。</p><p>MOM将消息路由给应用程B，这样消息就可以存在于完全不同的计算机上，MOM负责处理网络通信。如果网络连接不可用，MOM会存储消息，直到连接变得可用时，再将消息转发给应用程序B。</p><p>灵活性的另一方面体现在，当应用程序A发送其消息时，应用程序B甚至可以不处于执行状态。MOM将保留这个消息，直到应用程序B开始执行并试着检索消息为止。这还防止了应用程序A因为等待应用程序B检索消息而出现阻塞。这种异步通信要求应用程序的设计与现在大多数应用程序不同，不过，对于时间无关或并行处理，它可能是一个极其有用的方法。</p><h5 id="21-消息中间件的传递模式"><a class="markdownIt-Anchor" href="#21-消息中间件的传递模式"></a> ** 2.1 消息中间件的传递模式**</h5><p>消息中间件一般有两种传递模式：点对点模式(P2P)和发布-订阅模式(Pub/Sub)。</p><p><strong>点对点模式</strong></p><p>Point-to-Point(P2P)我们很容易理解，即生产者和消费者之间的消息往来。<br><img src="http://i.imgur.com/rVHHyTG.jpg" alt=""></p><p>每个消息都被发送到特定的消息队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p><p>P2P的特点：</p><ol><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)；</li><li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列；</li><li>接收者在成功接收消息之后需向队列应答成功。</li></ol><p><strong>发布-订阅模式(Pub/Sub)</strong></p><p>我们可以联想到卖报纸的过程：印刷厂把当天的报纸印好然后送到邮递员手里，邮递员风雨兼程的把报纸送到每一位订阅者手里。由此我们可以看到发布-订阅模式的一些特点：</p><ol><li>每个消息可以有多个消费者；</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态；</li></ol><p><img src="http://i.imgur.com/RBm4pWV.jpg" alt=""></p><p>由上介绍我们可以看出这两种模式各有千秋，如果你需要点对点的发送消息那么使用P2P更专注，如果你是群发消息，显然pub/sub模式更适合。</p><h4 id="3-基于多种协议的消息传递机制"><a class="markdownIt-Anchor" href="#3-基于多种协议的消息传递机制"></a> ** 3 基于多种协议的消息传递机制**</h4><p>目前市场上对于网络消息传递的协议版本很多，不同的协议有不同的规范，我们在使用时要比对实现不同协议的产品。下面我们看一下目前主流的消息传递协议：</p><h5 id="31-amqp协议"><a class="markdownIt-Anchor" href="#31-amqp协议"></a> ** 3.1 AMQP协议**</h5><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP协议是一种二进制协议，提供客户端应用与消息中间件之间异步、安全、高效地交互。</p><p>AMQP是一个应用层的异步消息传递协议，为面向消息的中间件而设计。其目的是通过协议使应用模块之间或应用程序与中间件等进行充分解耦。而在设计初期，AMQP的原始用途只是为金融界提供一个可以彼此协作的消息协议。现在已经有相当一部分遵循AMQP的服务器和客户端供使用。其中RabbitMQ是AMQP的一款开源标准实现。</p><p>支持所有消息中间件的功能：消息交换、文件传输、流传输、远程进程调用等。</p><p>AMQP的服务器(Broker)主要由交换器、消息、队列组成。Broker的主要功能是消息的路由和缓存。对于需要保障可靠性的消息，RabbitMQ可以将消息、队列和交换器的数据写入本地硬盘。而对于响应时间敏感的消息，RabbitMQ可以不配置持久化机制。</p><p>解决的问题：</p><p>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何防止丢失？</p><p>2）如何降低发送者和接收者的耦合度？</p><p>3）如何让Priority高的接收者先接到数据？</p><p>4）如何做到load balance？有效均衡接收者的负载？</p><p>5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。</p><p>6）如何做到可扩展，甚至将这个通信模块发到cluster上？</p><p>7）如何保证接收者接收到了完整，正确的数据？</p><p>AMQP协议解决了以上的问题，而RabbitMQ实现了AMQP。</p><h5 id="32-stomp协议"><a class="markdownIt-Anchor" href="#32-stomp协议"></a> ** 3.2 STOMP协议**</h5><p>STOMP即Simple (or Streaming) Text Orientated Messaging Protocol，简单(流)文本定向消息协议。</p><p>它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。</p><p>STOMP协议的前身是TTMP协议（一个简单的基于文本的协议），专为消息中间件设计。</p><p>STOMP是一个非常简单和容易实现的协议，其设计灵感源自于HTTP的简单性。尽管STOMP协议在服务器端的实现可能有一定的难度，但客户端的实现却很容易。例如，可以使用Telnet登录到任何的STOMP代理，并与STOMP代理进行交互。</p><p>STOMP是除AMQP开放消息协议之外地另外一个选择, 实现了被用在JMS brokers中特定的有线协议，比如OpenWire。它仅仅是实现通用消息操作中的一部分，并非想要覆盖全面的消息API。</p><p>STOMP server就好像是一系列的目的地, 消息会被发送到这里。STOMP协议把目的地当作不透明的字符串，其语法是服务端具体的实现。 此外STOMP没有定义目的地的交付语义是什么，语义的目的地可以从服务器到服务器，甚至从目的地到目的地。这使得服务器有可创造性的语义，去支持STOMP。</p><p>STOMP client的用户代理可以充当两个角色(可能同时)：</p><ol><li>作为生产者，通过SENDframe发送消息到server</li><li>作为消费者，发送SUBSCRIBEframe到目的地并且通过MESSAGEframe从server获取消息。</li></ol><p>STOMP协议工作于TCP协议之上，使用了下列命令：</p><ul><li><p>SEND 发送</p></li><li><p>SUBSCRIBE 订阅</p></li><li><p>UNSUBSCRIBE 退订</p></li><li><p>BEGIN 开始</p></li><li><p>COMMIT 提交</p></li><li><p>ABORT 取消</p></li><li><p>ACK 确认</p></li><li><p>DISCONNECT 断开</p></li></ul><p>目前最流行的STOMP消息代理是Apache ActiveMQ。</p><h5 id="33-jms协议"><a class="markdownIt-Anchor" href="#33-jms协议"></a> ** 3.3 JMS协议**</h5><p>JMS是Java Message Service的缩写，即Java消息服务。</p><p>在大型互联网中，我们采用消息中间件可以进行应用之间的解耦以及操作的异步，这是消息中间件两个最基础的特点，也正是我们所需要的。在此基础上，我们着重思考的是消息的顺序保证、扩展性、可靠性、业务操作与消息发送一致性，以及多集群订阅者等方面的问题。当然，这些我们要思考的东西，JMS都已经想到了，先看下JMS能帮开发者做什么：</p><p><strong>1、定义一组消息公用概念和实用工具</strong></p><p>所有Java应用程序都可以使用JMS中定义的API去完成消息的创建、接收与发送，任何实现了JMS标准的MOM都可以作为消息的中介，完成消息的存储转发</p><p><strong>2、最大化消息应用程序的可移植性</strong></p><p>MOM提供了有保证的消息发送，应用程序开发人员无需了解远程过程调用（RPC）和网络/通信协议的细节，提供了程序的可移植性</p><p><strong>3、最大化降低应用程序与应用程序之间的耦合度</strong></p><p>由于MOM的存在，各个应用程序只关心和MOM之间如何进行消息的接收与发送，而无须关注MOM的另一边，其他程序是如何接收和发送的</p><p>JMS定义了一套通用的接口和相关语义，提供了诸如持久、验证和事务的消息服务，它最主要的目的是允许Java应用程序访问现有的消息中间件。JMS规范没有指定在消息节点间所使用的通讯底层协议，来保证应用开发人员不用与其细节打交道，一个特定的JMS实现可能提供基于TCP/IP、HTTP、UDP或者其它的协议。</p><p>由于没有统一的规范和标准，基于消息中间件的应用不可移植，不同的消息中间件也不能互操作，这大大阻碍了消息中间件的发展。 Java Message Service(JMS, Java消息服务)是SUN及其伙伴公司提出的旨在统一各种消息中间件系统接口的规范。</p><p>目前许多厂商采用并实现了JMS API，现在，JMS产品能够为企业提供一套完整的消息传递功能，目前我们看到的比较流行的JMS商业软件和开源产品：WebLogic、SonicMQ、ActiveMQ、OpenJMS都是基于JMS规范的实现。</p><h4 id="4-jms介绍"><a class="markdownIt-Anchor" href="#4-jms介绍"></a> ** 4 JMS介绍**</h4><p>在 JMS 之前，每一家 MOM 厂商都用专有 API 为应用程序提供对其产品的访问，通常可用于许多种语言，其中包括 Java 语言。JMS 通过 MOM 产品为 Java 程序提供了一个发送和接收消息的标准的、便利的方法。用 JMS 编写的程序可以在任何实现 JMS 标准的 MOM 上运行。</p><p>JMS 可移植性的关键在于：JMS API 是由 Sun 作为一组接口而提供的。提供了 JMS 功能的产品是通过提供一个实现这些接口的提供者来做到这一点的。开发人员可以通过定义一组消息和一组交换这些消息的客户机应用程序建立 JMS 应用程序。</p><p>JMS 支持两种消息类型P2P 和Pub/Sub，在JMS消息模型中，根据点对点模式和发布/订阅模式，这些要素由扩展出了各自的内容：</p><table>        <tr>            <th>JMS标准</th>            <th>点对点模式</th>     <th>发布/订阅模式</th>                  </tr>        <tr>            <th>ConnectionFactory</th>            <th>QueueConnectionFactory</th>      <th>TopicConnectionFactory</th>                 </tr>       <tr>            <th>Connection</th>            <th>QueueConnection</th>      <th>TopicConnection</th>                 </tr><tr>            <th>Destination</th>            <th>Queue</th>      <th>Topic</th>                 </tr><tr>            <th>Session</th>            <th>QueueSession</th>      <th>TopicSession</th>                 </tr><tr>            <th>MessageProducer</th>            <th>QueueSender</th>     <th>TopicPublisher</th>                  </tr><tr>            <th>MessageConsumer</th>            <th>QueueReceiver</th>    <th>TopicSubscriber</th>                   </tr>    </table><p>JMS为发开者提供了很多的要素，看一下比较重要的几个：</p><table>        <tr>            <th>要    素</th>            <th>作    用</th>                   </tr>        <tr>            <th>Destination</th>            <th>表示消息所走通道的目标定义，用来定义消息从发送端发出后要走的通道，而不是接收方。Destination属于管理类对象</th>                   </tr>        <tr>            <th>ConnectionFactory</th>            <th>顾名思义，用于创建连接对象，ConnectionFactory属于管理类的对象</th>                    </tr>        <tr>            <th>Connection</th>            <th>连接接口，所负责的重要工作时创建Session</th>                    </tr> <tr>            <th>Session</th>            <th>会话接口，这是一个非常重要的对象，消息发送者、消息接收者以及消息对象本身，都是通过这个会话对象创建的</th>                    </tr> <tr>            <th>MessageConsumer</th>            <th>消息的消费者，也就是订阅消息并处理消息的对象</th>                    </tr> <tr>            <th>MessageProducer</th>            <th>消息的生产者，也就是用来发送消息的对象</th>                    </tr> <tr>            <th>XXXMessage</th>            <th>指各种类型的消息对象，包括ByteMesage、ObjectMessage、StreamMessage和TextMessage这5种</th>                    </tr>    </table><p><strong>JMS消息模型</strong></p><p>JMS 消息由以下几部分组成：消息头，属性，消息体。</p><ol><li>消息头（header）：JMS消息头包含了许多字段，它们是消息发送后由JMS提供者或消息发送者产生，用来表示消息、设置优先权和失效时间等等，并且为消息确定路由。</li><li>属性（property）：由消息发送者产生，用来添加删除消息头以外的附加信息。</li><li>消息体（body）：由消息发送者产生，JMS中定义了5种消息体：ByteMessage、MapMessage、ObjectMessage、StreamMessage和TextMessage。</li></ol><p><strong>JMS编程模型</strong></p><p>一般来说我们在开发基于JMS协议的客户端由一下几部构成：</p><ol><li><p>用JNDI 得到ConnectionFactory对象；</p></li><li><p>用JNDI 得到目标队列或主题对象，即Destination对象；</p></li><li><p>用ConnectionFactory创建Connection 对象；</p></li><li><p>用Connection对象创建一个或多个JMS Session；</p></li><li><p>用Session 和Destination 创建MessageProducer和MessageConsumer；</p></li><li><p>通知Connection 开始传递消息。</p></li></ol><p>因为jms需要使用到J2EE服务器，我们平常用的tomcat属于J2SE类型的服务器，常见的J2EE服务器包括：Geronimo,JBoss 4, GlassFish,WebLogic 。我们在这里使用glassfish 容器。安装和使用有很多教程，在此就不贴了。首先我们进去glassfish的控制台，设置一下我们的发送者和接受者对象：</p><p><img src="http://i.imgur.com/JolUiw6.jpg" alt=""></p><p><img src="http://i.imgur.com/uSYlT5P.jpg" alt=""></p><p>下面我们用oracle提供的jms接口来写一个服务端，我们先来写一个P2P模式的例子：</p><p>MySender.java</p><pre><code>import java.io.BufferedReader;import java.io.InputStreamReader;import javax.naming.*;import javax.jms.*;public class MySender {    public static void main(String[] args) {        try        {   //1)创建一个connection            InitialContext ctx=new InitialContext();            QueueConnectionFactory f=(QueueConnectionFactory)ctx.lookup(&quot;myQueueConnectionFactory&quot;);            QueueConnection con=f.createQueueConnection();            con.start();            //2) 创建一个会话接口            QueueSession ses=con.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);            //3) 获取会话接口对象            Queue t=(Queue)ctx.lookup(&quot;myQueue&quot;);            //4)创建一个发送者对象            QueueSender sender=ses.createSender(t);            //5) 创建一个消息对象            TextMessage msg=ses.createTextMessage();            //6) 把我们的消息写入msg对象中            BufferedReader b=new BufferedReader(new InputStreamReader(System.in));            while(true)            {                System.out.println(&quot;Enter Msg, end to terminate:&quot;);                String s=b.readLine();                if (s.equals(&quot;end&quot;))                    break;                msg.setText(s);                //7) 发送消息                sender.send(msg);                System.out.println(&quot;Message successfully sent.&quot;);            }            //8) 关闭连接            con.close();        }catch(Exception e){System.out.println(e);}    }}</code></pre><p>MyReceiver.java</p><pre><code>import javax.jms.*;import javax.naming.InitialContext;public class MyReceiver {    public static void main(String[] args) {        try{            //1) 创建一个connection            InitialContext ctx=new InitialContext();            QueueConnectionFactory f=(QueueConnectionFactory)ctx.lookup(&quot;myQueueConnectionFactory&quot;);            QueueConnection con=f.createQueueConnection();            con.start();            //2) 创建一个会话接口            QueueSession ses=con.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);            //3) 获取会话接口对象            Queue t=(Queue)ctx.lookup(&quot;myQueue&quot;);            //4)创建一个发送者对象            QueueReceiver receiver=ses.createReceiver(t);            //5) 创建一个消监听对象            MyListener listener=new MyListener();            //6) 将监听器注册到receiver，用来监听receiver            receiver.setMessageListener(listener);            System.out.println(&quot;Receiver1 is ready, waiting for messages...&quot;);            System.out.println(&quot;press Ctrl+c to shutdown...&quot;);            while(true){                Thread.sleep(1000);            }        }catch(Exception e){System.out.println(e);}    }}</code></pre><p>MyListener.java</p><pre><code>import javax.jms.*;public class MyListener implements MessageListener {    public void onMessage(Message m) {        try{            TextMessage msg=(TextMessage)m;            System.out.println(&quot;following message is received:&quot;+msg.getText());        }catch(JMSException e){System.out.println(e);}    }}</code></pre><p>Pub/Sub模式：</p><p>MySender.java</p><pre><code>import javax.jms.*;import javax.naming.InitialContext;import java.io.BufferedReader;import java.io.InputStreamReader;public class MySender {    public static void main(String[] args) {        try        {   //1)创建一个connection            InitialContext ctx=new InitialContext();            TopicConnectionFactory f=(TopicConnectionFactory)ctx.lookup(&quot;myTopicConnectionFactory&quot;);            TopicConnection con=f.createTopicConnection();            con.start();            //2) 创建一个会话接口            TopicSession ses=con.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);            //3) 获取会话接口对象            Topic t=(Topic)ctx.lookup(&quot;myTopic&quot;);            //4)创建一个发送者对象            TopicPublisher publisher=ses.createPublisher(t);            //5) 创建一个消息对象            TextMessage msg=ses.createTextMessage();            //6) 把我们的消息写入msg对象中            BufferedReader b=new BufferedReader(new InputStreamReader(System.in));            while(true)            {                System.out.println(&quot;Enter Msg, end to terminate:&quot;);                String s=b.readLine();                if (s.equals(&quot;end&quot;))                    break;                msg.setText(s);                //7) 发送消息                publisher.publish(msg);                System.out.println(&quot;Message successfully sent.&quot;);            }            //8) 关闭连接            con.close();        }catch(Exception e){System.out.println(e);}    }}</code></pre><p>MyReceiver.java</p><pre><code>import javax.jms.*;import javax.naming.InitialContext;public class MyReceiver {    public static void main(String[] args) {        try{            //1) 创建一个connection            InitialContext ctx=new InitialContext();            TopicConnectionFactory f=(TopicConnectionFactory)ctx.lookup(&quot;myTopicConnectionFactory&quot;);            TopicConnection con=f.createTopicConnection();            //2) 创建一个会话接口            TopicSession ses=con.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);            //3) 获取会话接口对象            Topic t=(Topic)ctx.lookup(&quot;myTopic&quot;);            //4)创建一个发送者对象            TopicSubscriber receiver=ses.createSubscriber(t);            //5) 创建一个消监听对象            MyListener listener=new MyListener();            //6) 将监听器注册到receiver，用来监听receiver            receiver.setMessageListener(listener);            System.out.println(&quot;Receiver1 is ready, waiting for messages...&quot;);            System.out.println(&quot;press Ctrl+c to shutdown...&quot;);            while(true){                Thread.sleep(1000);            }        }catch(Exception e){System.out.println(e);}    }}</code></pre><p>MyListener.java</p><pre><code>import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;public class MyListener implements MessageListener {    public void onMessage(Message m) {        try{            TextMessage msg=(TextMessage)m;            System.out.println(&quot;following message is received:&quot;+msg.getText());        }catch(JMSException e){System.out.println(e);}    }}</code></pre><p>上面两个案例我们运行可以看到消息成功的发送出去了。熟悉了JMS的语法，使用起来还是很简单。</p><p>上面我们介绍到了JMS，JMS是一个用于提供消息服务的技术规范，它制定了在整个消息服务提供过程中的所有数据结构和交互流程。JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API。　Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p><p>下面我们引入另一个概念：MQ（Message Queue）。</p><p>应用程序通过写和检索出入列队的针对应用程序的数据（消息）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。</p><p>MQ和JMS类似，但不同的是JMS是SUN Java消息中间件服务的一个标准和API定义，而MQ则是遵循了AMQP协议的具体实现和产品。JMS是一个用于提供消息服务的技术规范，它制定了在整个消息服务提供过程中的所有数据结构和交互流程。而MQ则是消息队列服务，是面向消息中间件（MOM）的最终实现，是真正的服务提供者；MQ的实现可以基于JMS，也可以基于其他规范或标准。MQ 有很多产品：IBM的，rabbitmq, activemq 等，rabbitmq 只支持点对点的方式。所以没有完全实现JMS的标准，所以说它不是一个JMS产品，而rabitmq 和Jobss JMS 它们实现了JMS的各项标准，是开源的JMS产品。目前完全实现JMS协议的mq是activemq，所以接下来我们先重点看一下activemq。从activemq入手去探索javaEE的世界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个公司创立初期，他可能只有几个应用，系统之间的关联也不是那么大，A系统调用B系统就直接调用B提供的API接口；后来这个公司做大了，他一步步发展有了几十个系统，这时候A系统要调用B系统的接口，但是B系统前几天刚改了一下接口A并不知情。所以A发现调不通于是给B系统管理员打电
      
    
    </summary>
    
      <category term="activeMQ" scheme="http://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(十)-Netty文件上传</title>
    <link href="http://blog.rickiyang.cn/posts/208253d2.html"/>
    <id>http://blog.rickiyang.cn/posts/208253d2.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.379Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来完成一个使用netty进行文件传输的任务。在实际项目中，文件传输通常采用FTP或者HTTP附件的方式。事实上通过TCP Socket+File的方式进行文件传输也有一定的应用场景，尽管不是主流，但是掌握这种文件传输方式还是比较重要的，特别是针对两个跨主机的JVM进程之间进行持久化数据的相互交换。</p><p>而使用netty来进行文件传输也是利用netty天然的优势：零拷贝功能。很多同学都听说过netty的&quot;零拷贝&quot;功能，但是具体体现在哪里又不知道，下面我们就简要介绍下：</p><p>Netty的“零拷贝”主要体现在如下三个方面：</p><ol><li><p>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p></li><li><p>Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。</p></li><li><p>Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</p></li></ol><p>具体的分析在此就不多做介绍，有兴趣的可以查阅相关文档。我们还是把重点放在文件传输上。Netty作为高性能的服务器端异步IO框架必然也离不开文件读写功能，我们可以使用netty模拟http的形式通过网页上传文件写入服务器，当然要使用http的形式那你也用不着netty！大材小用。netty4中如果想使用http形式上传文件你还得借助第三方jar包：okhttp。使用该jar完成http请求的发送。但是在netty5 中已经为我们写好了，我们可以直接调用netty5的API就可以实现。所以netty4和5的差别还是挺大的，至于使用哪个，那就看你们公司选择哪一个了！本文目前使用netty4来实现文件上传功能。下面我们上代码：</p><p>pom文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.5.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>server端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ClassResolvers;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ObjectDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ObjectEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>).childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.weakCachingConcurrentResolver(<span class="keyword">null</span>))); <span class="comment">// 最大长度</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> FileUploadServerHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                port = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> FileUploadServer().bind(port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> byteRead;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String file_dir = <span class="string">"D:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileUploadFile) &#123;</span><br><span class="line">            FileUploadFile ef = (FileUploadFile) msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = ef.getBytes();</span><br><span class="line">            byteRead = ef.getEndPos();</span><br><span class="line">            String md5 = ef.getFile_md5();<span class="comment">//文件名</span></span><br><span class="line">            String path = file_dir + File.separator + md5;</span><br><span class="line">            File file = <span class="keyword">new</span> File(path);</span><br><span class="line">            RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">            randomAccessFile.seek(start);</span><br><span class="line">            randomAccessFile.write(bytes);</span><br><span class="line">            start = start + byteRead;</span><br><span class="line">            <span class="keyword">if</span> (byteRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ctx.writeAndFlush(start);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                randomAccessFile.close();</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ClassResolvers;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ObjectDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ObjectEncoder;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> port, String host, <span class="keyword">final</span> FileUploadFile fileUploadFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(group).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>).handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ObjectDecoder(ClassResolvers.weakCachingConcurrentResolver(<span class="keyword">null</span>)));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> FileUploadClientHandler(fileUploadFile));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                port = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUploadFile uploadFile = <span class="keyword">new</span> FileUploadFile();</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"c:/1.txt"</span>);</span><br><span class="line">            String fileMd5 = file.getName();<span class="comment">// 文件名</span></span><br><span class="line">            uploadFile.setFile(file);</span><br><span class="line">            uploadFile.setFile_md5(fileMd5);</span><br><span class="line">            uploadFile.setStarPos(<span class="number">0</span>);<span class="comment">// 文件开始位置</span></span><br><span class="line">            <span class="keyword">new</span> FileUploadClient().connect(port, <span class="string">"127.0.0.1"</span>, uploadFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> byteRead;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> lastLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> RandomAccessFile randomAccessFile;</span><br><span class="line">    <span class="keyword">private</span> FileUploadFile fileUploadFile;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileUploadClientHandler</span><span class="params">(FileUploadFile ef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ef.getFile().exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ef.getFile().isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Not a file :"</span> + ef.getFile());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.fileUploadFile = ef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            randomAccessFile = <span class="keyword">new</span> RandomAccessFile(fileUploadFile.getFile(), <span class="string">"r"</span>);</span><br><span class="line">            randomAccessFile.seek(fileUploadFile.getStarPos());</span><br><span class="line">            lastLength = (<span class="keyword">int</span>) randomAccessFile.length() / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[lastLength];</span><br><span class="line">            <span class="keyword">if</span> ((byteRead = randomAccessFile.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fileUploadFile.setEndPos(byteRead);</span><br><span class="line">                fileUploadFile.setBytes(bytes);</span><br><span class="line">                ctx.writeAndFlush(fileUploadFile);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件已经读完"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            start = (Integer) msg;</span><br><span class="line">            <span class="keyword">if</span> (start != -<span class="number">1</span>) &#123;</span><br><span class="line">                randomAccessFile = <span class="keyword">new</span> RandomAccessFile(fileUploadFile.getFile(), <span class="string">"r"</span>);</span><br><span class="line">                randomAccessFile.seek(start);</span><br><span class="line">                System.out.println(<span class="string">"块儿长度："</span> + (randomAccessFile.length() / <span class="number">10</span>));</span><br><span class="line">                System.out.println(<span class="string">"长度："</span> + (randomAccessFile.length() - start));</span><br><span class="line">                <span class="keyword">int</span> a = (<span class="keyword">int</span>) (randomAccessFile.length() - start);</span><br><span class="line">                <span class="keyword">int</span> b = (<span class="keyword">int</span>) (randomAccessFile.length() / <span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">                    lastLength = a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[lastLength];</span><br><span class="line">                System.out.println(<span class="string">"-----------------------------"</span> + bytes.length);</span><br><span class="line">                <span class="keyword">if</span> ((byteRead = randomAccessFile.read(bytes)) != -<span class="number">1</span> &amp;&amp; (randomAccessFile.length() - start) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"byte 长度："</span> + bytes.length);</span><br><span class="line">                    fileUploadFile.setEndPos(byteRead);</span><br><span class="line">                    fileUploadFile.setBytes(bytes);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ctx.writeAndFlush(fileUploadFile);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    randomAccessFile.close();</span><br><span class="line">                    ctx.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件已经读完--------"</span> + byteRead);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public void channelRead(ChannelHandlerContext ctx, Object msg) throws</span></span><br><span class="line">    <span class="comment">// Exception &#123;</span></span><br><span class="line">    <span class="comment">// System.out.println("Server is speek ："+msg.toString());</span></span><br><span class="line">    <span class="comment">// FileRegion filer = (FileRegion) msg;</span></span><br><span class="line">    <span class="comment">// String path = "E://Apk//APKMD5.txt";</span></span><br><span class="line">    <span class="comment">// File fl = new File(path);</span></span><br><span class="line">    <span class="comment">// fl.createNewFile();</span></span><br><span class="line">    <span class="comment">// RandomAccessFile rdafile = new RandomAccessFile(path, "rw");</span></span><br><span class="line">    <span class="comment">// FileRegion f = new DefaultFileRegion(rdafile.getChannel(), 0,</span></span><br><span class="line">    <span class="comment">// rdafile.length());</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// System.out.println("This is" + ++counter + "times receive server:["</span></span><br><span class="line">    <span class="comment">// + msg + "]");</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public void channelReadComplete(ChannelHandlerContext ctx) throws</span></span><br><span class="line">    <span class="comment">// Exception &#123;</span></span><br><span class="line">    <span class="comment">// ctx.flush();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// protected void channelRead0(ChannelHandlerContext ctx, String msg)</span></span><br><span class="line">    <span class="comment">// throws Exception &#123;</span></span><br><span class="line">    <span class="comment">// String a = msg;</span></span><br><span class="line">    <span class="comment">// System.out.println("This is"+</span></span><br><span class="line">    <span class="comment">// ++counter+"times receive server:["+msg+"]");</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还自定义了一个对象，用于统计文件上传进度的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadFile</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> File file;<span class="comment">// 文件</span></span><br><span class="line">    <span class="keyword">private</span> String file_md5;<span class="comment">// 文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> starPos;<span class="comment">// 开始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bytes;<span class="comment">// 文件字节数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> endPos;<span class="comment">// 结尾位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStarPos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> starPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStarPos</span><span class="params">(<span class="keyword">int</span> starPos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.starPos = starPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEndPos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> endPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEndPos</span><span class="params">(<span class="keyword">int</span> endPos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bytes = bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.file = file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFile_md5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_md5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFile_md5</span><span class="params">(String file_md5)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.file_md5 = file_md5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>块儿长度：894长度：8052-----------------------------894byte 长度：894块儿长度：894长度：7158-----------------------------894byte 长度：894块儿长度：894长度：6264-----------------------------894byte 长度：894块儿长度：894长度：5370-----------------------------894byte 长度：894块儿长度：894长度：4476-----------------------------894byte 长度：894块儿长度：894长度：3582-----------------------------894byte 长度：894块儿长度：894长度：2688-----------------------------894byte 长度：894块儿长度：894长度：1794-----------------------------894byte 长度：894块儿长度：894长度：900-----------------------------894byte 长度：894块儿长度：894长度：6-----------------------------6byte 长度：6块儿长度：894长度：0-----------------------------0文件已经读完--------0Process finished with exit code 0</code></pre><p>这样就实现了服务器端文件的上传，当然我们也可以使用http的形式。</p><p>server端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpFileServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpFileServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">        serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">        <span class="comment">//serverBootstrap.handler(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">        serverBootstrap.childHandler(<span class="keyword">new</span> HttpChannelInitlalizer());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture f = serverBootstrap.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HttpFileServer b = <span class="keyword">new</span> HttpFileServer(<span class="number">9003</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(b).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server端initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpChannelInitlalizer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpChannelHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server端hadler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpHeaders.Names.CONTENT_TYPE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpResponseStatus.FORBIDDEN;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpResponseStatus.NOT_FOUND;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpVersion.HTTP_1_1;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelProgressiveFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelProgressiveFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.DefaultFullHttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.DefaultHttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.FullHttpRequest;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.FullHttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpChunkedInput;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponseStatus;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpVersion;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.LastHttpContent;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedFile;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.SystemPropertyUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.activation.MimetypesFileTypeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpChannelHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">FullHttpRequest</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_DATE_FORMAT = <span class="string">"EEE, dd MMM yyyy HH:mm:ss zzz"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_DATE_GMT_TIMEZONE = <span class="string">"GMT"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_CACHE_SECONDS = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 监测解码情况</span></span><br><span class="line">        <span class="keyword">if</span> (!request.getDecoderResult().isSuccess()) &#123;</span><br><span class="line">            sendError(ctx, BAD_REQUEST);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String uri = request.getUri();</span><br><span class="line">        <span class="keyword">final</span> String path = sanitizeUri(uri);</span><br><span class="line">        System.out.println(<span class="string">"get file："</span>+path);</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sendError(ctx, FORBIDDEN);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取要下载的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (file.isHidden() || !file.exists()) &#123;</span><br><span class="line">            sendError(ctx, NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!file.isFile()) &#123;</span><br><span class="line">            sendError(ctx, FORBIDDEN);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomAccessFile raf;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ignore) &#123;</span><br><span class="line">            sendError(ctx, NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> fileLength = raf.length();</span><br><span class="line">        HttpResponse response = <span class="keyword">new</span> DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);</span><br><span class="line">        HttpHeaders.setContentLength(response, fileLength);</span><br><span class="line">        setContentTypeHeader(response, file);</span><br><span class="line">        <span class="comment">//setDateAndCacheHeaders(response, file);</span></span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.isKeepAlive(request)) &#123;</span><br><span class="line">            response.headers().set(<span class="string">"CONNECTION"</span>, HttpHeaders.Values.KEEP_ALIVE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the initial line and the header.</span></span><br><span class="line">        ctx.write(response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the content.</span></span><br><span class="line">        ChannelFuture sendFileFuture =</span><br><span class="line">        ctx.write(<span class="keyword">new</span> HttpChunkedInput(<span class="keyword">new</span> ChunkedFile(raf, <span class="number">0</span>, fileLength, <span class="number">8192</span>)), ctx.newProgressivePromise());</span><br><span class="line">        <span class="comment">//sendFuture用于监视发送数据的状态</span></span><br><span class="line">        sendFileFuture.addListener(<span class="keyword">new</span> ChannelProgressiveFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationProgressed</span><span class="params">(ChannelProgressiveFuture future, <span class="keyword">long</span> progress, <span class="keyword">long</span> total)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123; <span class="comment">// total unknown</span></span><br><span class="line">                    System.err.println(future.channel() + <span class="string">" Transfer progress: "</span> + progress);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.err.println(future.channel() + <span class="string">" Transfer progress: "</span> + progress + <span class="string">" / "</span> + total);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelProgressiveFuture future)</span> </span>&#123;</span><br><span class="line">                System.err.println(future.channel() + <span class="string">" Transfer complete."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the end marker</span></span><br><span class="line">        ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decide whether to close the connection or not.</span></span><br><span class="line">        <span class="keyword">if</span> (!HttpHeaders.isKeepAlive(request)) &#123;</span><br><span class="line">            <span class="comment">// Close the connection when the whole content is written out.</span></span><br><span class="line">            lastContentFuture.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isActive()) &#123;</span><br><span class="line">            sendError(ctx, INTERNAL_SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern INSECURE_URI = Pattern.compile(<span class="string">".*[&lt;&gt;&amp;\"].*"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">sanitizeUri</span><span class="params">(String uri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decode the path.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            uri = URLDecoder.decode(uri, <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!uri.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert file separators.</span></span><br><span class="line">        uri = uri.replace(<span class="string">'/'</span>, File.separatorChar);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Simplistic dumb security check.</span></span><br><span class="line">        <span class="comment">// You will have to do something serious in the production environment.</span></span><br><span class="line">        <span class="keyword">if</span> (uri.contains(File.separator + <span class="string">'.'</span>) || uri.contains(<span class="string">'.'</span> + File.separator) || uri.startsWith(<span class="string">"."</span>) || uri.endsWith(<span class="string">"."</span>)</span><br><span class="line">                || INSECURE_URI.matcher(uri).matches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert to absolute path.</span></span><br><span class="line">        <span class="keyword">return</span> SystemPropertyUtil.get(<span class="string">"user.dir"</span>) + File.separator + uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(ChannelHandlerContext ctx, HttpResponseStatus status)</span> </span>&#123;</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HTTP_1_1, status, Unpooled.copiedBuffer(<span class="string">"Failure: "</span> + status + <span class="string">"\r\n"</span>, CharsetUtil.UTF_8));</span><br><span class="line">        response.headers().set(CONTENT_TYPE, <span class="string">"text/plain; charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the connection as soon as the error message is sent.</span></span><br><span class="line">        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the content type header for the HTTP Response</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     *            HTTP response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     *            file to extract content type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContentTypeHeader</span><span class="params">(HttpResponse response, File file)</span> </span>&#123;</span><br><span class="line">        MimetypesFileTypeMap m = <span class="keyword">new</span> MimetypesFileTypeMap();</span><br><span class="line">        String contentType = m.getContentType(file.getPath());</span><br><span class="line">        <span class="keyword">if</span> (!contentType.equals(<span class="string">"application/octet-stream"</span>)) &#123;</span><br><span class="line">            contentType += <span class="string">"; charset=utf-8"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.headers().set(CONTENT_TYPE, contentType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.DefaultFullHttpRequest;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpMethod;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpRequestEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponseDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpVersion;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDownloadClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载http资源 向服务器下载直接填写要下载的文件的相对路径</span></span><br><span class="line"><span class="comment">     *        （↑↑↑建议只使用字母和数字对特殊字符对字符进行部分过滤可能导致异常↑↑↑）</span></span><br><span class="line"><span class="comment">     *        向互联网下载输入完整路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host 目的主机ip或域名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port 目标主机端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> local 本地存储路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String host, <span class="keyword">int</span> port, String url, <span class="keyword">final</span> String local)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(workerGroup);</span><br><span class="line">            b.channel(NioSocketChannel.class);</span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            b.handler(<span class="keyword">new</span> ChildChannelHandler(local));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(url);</span><br><span class="line">            DefaultFullHttpRequest request = <span class="keyword">new</span> DefaultFullHttpRequest(</span><br><span class="line">                    HttpVersion.HTTP_1_1, HttpMethod.GET, uri.toASCIIString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建http请求</span></span><br><span class="line">            request.headers().set(HttpHeaders.Names.HOST, host);</span><br><span class="line">            request.headers().set(HttpHeaders.Names.CONNECTION,</span><br><span class="line">                    HttpHeaders.Values.KEEP_ALIVE);</span><br><span class="line">            request.headers().set(HttpHeaders.Names.CONTENT_LENGTH,</span><br><span class="line">                    request.content().readableBytes());</span><br><span class="line">            <span class="comment">// 发送http请求</span></span><br><span class="line">            f.channel().write(request);</span><br><span class="line">            f.channel().flush();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildChannelHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">        String local;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChildChannelHandler</span><span class="params">(String local)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.local = local;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 客户端接收到的是httpResponse响应，所以要使用HttpResponseDecoder进行解码</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> HttpResponseDecoder());</span><br><span class="line">            <span class="comment">// 客户端发送的是httprequest，所以要使用HttpRequestEncoder进行编码</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> HttpRequestEncoder());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> HttpDownloadHandler(local));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpDownloadClient client = <span class="keyword">new</span> HttpDownloadClient();</span><br><span class="line">        <span class="comment">//client.connect("127.0.0.1", 9003,"/file/pppp/1.doc","1.doc");</span></span><br><span class="line"><span class="comment">//        client.connect("zlysix.gree.com", 80, "http://zlysix.gree.com/HelloWeb/download/20m.apk", "20m.apk");</span></span><br><span class="line">        client.connect(<span class="string">"www.ghost64.com"</span>, <span class="number">80</span>, <span class="string">"http://www.ghost64.com/qqtupian/zixunImg/local/2017/05/27/1495855297602.jpg"</span>, <span class="string">"1495855297602.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpContent;</span><br><span class="line"><span class="comment">//import io.netty.handler.codec.http.HttpHeaders;</span></span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.LastHttpContent;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.SystemPropertyUtil;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 9:15 on 2017/5/28.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDownloadHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> readingChunks = <span class="keyword">false</span>; <span class="comment">// 分块读取开关</span></span><br><span class="line">    <span class="keyword">private</span> FileOutputStream fOutputStream = <span class="keyword">null</span>;<span class="comment">// 文件输出流</span></span><br><span class="line">    <span class="keyword">private</span> File localfile = <span class="keyword">null</span>;<span class="comment">// 下载文件的本地对象</span></span><br><span class="line">    <span class="keyword">private</span> String local = <span class="keyword">null</span>;<span class="comment">// 待下载文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> succCode;<span class="comment">// 状态码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpDownloadHandler</span><span class="params">(String local)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.local = local;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpResponse) &#123;<span class="comment">// response头信息</span></span><br><span class="line">            HttpResponse response = (HttpResponse) msg;</span><br><span class="line">            succCode = response.getStatus().code();</span><br><span class="line">            <span class="keyword">if</span> (succCode == <span class="number">200</span>) &#123;</span><br><span class="line">                setDownLoadFile();<span class="comment">// 设置下载文件</span></span><br><span class="line">                readingChunks = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println("CONTENT_TYPE:"</span></span><br><span class="line">            <span class="comment">// + response.headers().get(HttpHeaders.Names.CONTENT_TYPE));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpContent) &#123;<span class="comment">// response体信息</span></span><br><span class="line">            HttpContent chunk = (HttpContent) msg;</span><br><span class="line">            <span class="keyword">if</span> (chunk <span class="keyword">instanceof</span> LastHttpContent) &#123;</span><br><span class="line">                readingChunks = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuf buffer = chunk.content();</span><br><span class="line">            <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">            <span class="keyword">if</span> (succCode == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (buffer.isReadable()) &#123;</span><br><span class="line">                    buffer.readBytes(dst);</span><br><span class="line">                    fOutputStream.write(dst);</span><br><span class="line">                    buffer.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != fOutputStream) &#123;</span><br><span class="line">                    fOutputStream.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!readingChunks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fOutputStream) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Download done-&gt;"</span>+ localfile.getAbsolutePath());</span><br><span class="line">                fOutputStream.flush();</span><br><span class="line">                fOutputStream.close();</span><br><span class="line">                localfile = <span class="keyword">null</span>;</span><br><span class="line">                fOutputStream = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置本地参数，准备下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDownLoadFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == fOutputStream) &#123;</span><br><span class="line">            local = SystemPropertyUtil.get(<span class="string">"user.dir"</span>) + File.separator +local;</span><br><span class="line">            <span class="comment">//System.out.println(local);</span></span><br><span class="line">            localfile = <span class="keyword">new</span> File(local);</span><br><span class="line">            <span class="keyword">if</span> (!localfile.exists()) &#123;</span><br><span class="line">                localfile.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            fOutputStream = <span class="keyword">new</span> FileOutputStream(localfile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"管道异常："</span> + cause.getMessage());</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里客户端我放的是网络连接，下载的是一副图片，启动服务端和客户端就可以看到这个图片被下载到了工程的根目录下。</p><p><img src="http://img.blog.csdn.net/20170528141403834?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来完成一个使用netty进行文件传输的任务。在实际项目中，文件传输通常采用FTP或者HTTP附件的方式。事实上通过TCP Socket+File的方式进行文件传输也有一定的应用场景，尽管不是主流，但是掌握这种文件传输方式还是比较重要的，特别是针对两个跨主机的JVM进
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(二)Buffer</title>
    <link href="http://blog.rickiyang.cn/posts/e8d11d6a.html"/>
    <id>http://blog.rickiyang.cn/posts/e8d11d6a.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.144Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要与 NIO Channel 进行交互时, 我们就需要使用到 NIO Buffer, 即数据从 Buffer读取到 Channel 中, 并且从 Channel 中写入到 Buffer 中。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p><h4 id="缓冲区基础"><a class="markdownIt-Anchor" href="#缓冲区基础"></a> <strong>缓冲区基础</strong></h4><p>Buffer 类型有:</p><p><img src="http://i.imgur.com/co6hMaY.png" alt=""></p><p>缓冲区是包在一个对象内的基础数据的数组，Buffer类相比一般简单数组而言其优点是将数据的内容和相关信息放在一个对象里面，这个对象提供了处理缓冲区数据的丰富的API。</p><p>所有缓冲区都有4个属性：capacity、limit、position、mark，并遵循：capacity&gt;=limit&gt;=position&gt;=mark&gt;=0，下面是对这4个属性的解释：</p><ul><li>Capacity:     容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</li><li>Limit:           上界，缓冲区中当前数据量</li><li>Position:      位置，下一个要被读或写的元素的索引</li><li>Mark:           标记，调用mark()来设置mark=position，再调用reset()可以让position恢复到标记的位置即position=mark</li></ul><p>我们通过一个简单的操作流程来说明buffer的使用，下图是新创建的容量为10的缓冲区逻辑视图：</p><p><img src="http://i.imgur.com/HNu79ue.png" alt=""></p><p>然后进行5次调用put：<br>buffer.put((byte)‘A’).put((byte)‘B’).put((byte)‘C’).put((byte)‘D’).put((byte)‘E’)</p><p>5次调用put之后的缓冲区为：<br><img src="http://i.imgur.com/PtNCleq.png" alt=""></p><p>现在缓冲区满了，我们必须将其清空。我们想把这个缓冲区传递给一个通道，以使内容能被全部写出，但现在执行get()无疑会取出未定义的数据。我们必须将 posistion设为0，然后通道就会从正确的位置开始读了，但读到哪算读完了呢？这正是limit引入的原因，它指明缓冲区有效内容的未端。这个操作 在缓冲区中叫做翻转：buffer.flip()。</p><p><img src="http://i.imgur.com/ExlR0LW.png" alt=""></p><h4 id="buffer的基本用法"><a class="markdownIt-Anchor" href="#buffer的基本用法"></a> <strong>Buffer的基本用法</strong></h4><p>使用Buffer读写数据一般遵循以下四个步骤：</p><ol><li>写入数据到Buffer</li><li>调用flip()方法</li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法</li></ol><p>当向buffer写入数据时，buffer会记录下写了多少数据。</p><p>一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p><p>下面我们看一段程序来看一下Buffer的基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">     RandomAccessFile aFile = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//文件流</span></span><br><span class="line">        aFile = <span class="keyword">new</span> RandomAccessFile(fileName, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">//将文件输入到管道</span></span><br><span class="line">         FileChannel inChannel = aFile.getChannel();</span><br><span class="line">        <span class="comment">//为buffer分配1024个字节大小的空间</span></span><br><span class="line">         ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//将buffer中的内容读取到管道中</span></span><br><span class="line">         <span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line">         <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">             <span class="comment">//反转buffer，将写模式改为读模式</span></span><br><span class="line">              buf.flip();</span><br><span class="line">             <span class="keyword">while</span> (buf.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">//获取buffer中的数据</span></span><br><span class="line">                System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">//将上次分配的1024字节的内容清空，为下次接收做准备</span></span><br><span class="line">             buf.clear();</span><br><span class="line">            <span class="comment">//管道重新读取buffer中的内容</span></span><br><span class="line">             bytesRead = inChannel.read(buf);</span><br><span class="line">         &#125;</span><br><span class="line">         aFile.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="字节缓冲区"><a class="markdownIt-Anchor" href="#字节缓冲区"></a> <strong>字节缓冲区</strong></h4><p>我们将进一步观察字节缓冲区。所有的基本数据类型都有相应的缓冲区类（布尔型除外），但字节缓冲区有自己的独特之处。字节是操作系统及其I/O设备使用的基本数据类型。当在JVM和操作系统间传递数据时，将其他的数据类型拆分成构成它们的字节是十分必要的。如我们在后面的章节中将要看到的那样，系统层次的I/O面向字节的性质可以在整个缓冲区的设计以及它们互相配合的服务中感受到。</p><h4 id="直接缓冲区"><a class="markdownIt-Anchor" href="#直接缓冲区"></a> <strong>直接缓冲区</strong></h4><p>我们知道操作系统是在内存中进行I/O操作，这些内存区域，就操作系统方面而言，是相连的字节序列。于是，毫无疑问，只有字节缓冲区有资格参与I/O操作。即操作系统会直接存取进程，那么我们现在在JVM中进行操作，java中的内存空间是由JVM直接进行管理，但是在JVM中，字节数组可能不会在内存中连续存储，或者无用存储单元收集可能随时对其进行移动，这就不能保证I/O操作的目标是连续的。</p><p>出于这一原因，引入了直接缓冲区的概念。直接缓冲区被用于与通道和固有I/O例程交互。它们通过使用固有代码来告知操作系统直接释放或填充内存区域，对用于通道直接或原始存取的内存区域中的字节元素的存储尽了最大的努力。</p><p>直接字节缓冲区通常是I/O操作最好的选择。在设计方面，它们支持JVM可用的最高效I/O机制。非直接字节缓冲区可以被传递给通道，但是这样可能导致性能损耗。通常非直接缓冲不可能成为一个本地I/O操作的目标。如果您向一个通道中传递一个非直接ByteBuffer对象用于写入，通道可能会在每次调用中隐含地进行下面的操作：</p><ol><li>创建一个临时的直接ByteBuffer对象。</li><li>将非直接缓冲区的内容复制到临时缓冲中。</li><li>使用临时缓冲区执行低层次I/O操作。</li><li>临时缓冲区对象离开作用域，并最终成为被回收的无用数据。</li></ol><h4 id="视图缓冲区"><a class="markdownIt-Anchor" href="#视图缓冲区"></a> <strong>视图缓冲区</strong></h4><p>就像我们已经讨论的那样，I/O基本上可以归结成组字节数据的四处传递。在进行大数据量的I/O操作时，很又可能你会使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据，等等。一旦数据到达了你的ByteBuffer，您就需要查看它以决定怎么做或者在将它发送出去之前对它进行一些操作。ByteBuffer类提供了丰富的API来创建视图缓冲区。</p><p>视图缓冲区通过已存在的缓冲区对象实例的工厂方法来创建。这种视图对象维护它自己的属性，容量，位置，上界和标记，但是和原来的缓冲区共享数据元素。但是ByteBuffer类允许创建视图来将byte型缓冲区字节数据映射为其它的原始数据类型。例如，asLongBuffer()函数创建一个将八个字节型数据当成一个long型数据来存取的视图缓冲区。</p><p>但是使用视图缓冲区的话，一旦ByteBuffer对于视图的维护对象产生非常规行的使用，那么对于工厂方法创建的缓冲区而言，asLongBuffer()函数就不在使用这个视窗，那么这个8字节的数据当成一个long类型的数据类型来存取的数据视图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们需要与 NIO Channel 进行交互时, 我们就需要使用到 NIO Buffer, 即数据从 Buffer读取到 Channel 中, 并且从 Channel 中写入到 Buffer 中。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(四)Selector</title>
    <link href="http://blog.rickiyang.cn/posts/e87423e8.html"/>
    <id>http://blog.rickiyang.cn/posts/e87423e8.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.144Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们将探索选择器(selectors)。选择器提供选择执行已经就绪的任务的能力，这使得多元 I/O 成为可能。就像在第一章中描述的那样，就绪选择和多元执行使得单线程能够有效率地同时管理多个 I/O 通道(channels)。C/C++代码的工具箱中，许多年前就已经有 select()和 poll()这两个POSIX（可移植性操作系统接口）系统调用可供使用了。许过操作系统也提供相似的功能，但对Java 程序员来说，就绪选择功能直到 JDK 1.4 才成为可行的方案。</p><p>下面我们来使用选择器：</p><p>通过 Selector.open()方法, 我们可以创建一个选择器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>将 Channel 注册到选择器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p><b style="color:red">***注意, 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的, 即channel.configureBlocking(false);因为 Channel 必须要是非阻塞的, 因此 FileChannel 不能够使用选择器, 因为 FileChannel 都是阻塞的.***</b></p><p>注意到, 在使用 Channel.register()方法时, 第二个参数指定了我们对 Channel 的什么类型的事件感兴趣, 这些事件有:</p><ol><li>Connect, 即连接事件(TCP 连接), 对应于SelectionKey.OP_CONNECT</li><li>Accept, 即确认事件, 对应于SelectionKey.OP_ACCEPT</li><li>Read, 即读事件, 对应于SelectionKey.OP_READ, 表示 buffer 可读.</li><li>Write, 即写事件, 对应于SelectionKey.OP_WRITE, 表示 buffer 可写.</li></ol><p>一个 Channel发出一个事件也可以称为 对于某个事件, Channel 准备好了. 因此一个 Channel 成功连接到了另一个服务器也可以被称为 connect ready.<br>我们可以使用或运算|来组合多个事件, 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p><em>注意, 一个 Channel 仅仅可以被注册到一个 Selector 一次, 如果将 Channel 注册到 Selector 多次, 那么其实就是相当于更新 SelectionKey 的 interest set. 例如:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure><p><em>上面的 channel 注册到同一个 Selector 两次了, 那么第二次的注册其实就是相当于更新这个 Channel 的 interest set 为 SelectionKey.OP_READ | SelectionKey.OP_WRITE.</em></p><p>但是Java NIO的selector允许一个单一线程监听多个channel输入。我们可以注册多个channel到selector上，然后然后用一个线程来挑出一个处于可读或者可写状态的channel。selector机制使得单线程管理多个channel变得容易。</p><p>下面我们写一个完整的例子，看一下Selector的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//注册通道</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">//查看selector中的key是否准备好</span></span><br><span class="line">    <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">    <span class="comment">//小于0超时，等于0没准备好，大于0已经准备完毕</span></span><br><span class="line">    <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//获取选择器中的key</span></span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">    <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="comment">//遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件</span></span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 连接已经被ServerSocketChannel所接受</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">            <span class="comment">// 连接已经被远程终止.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 通道已经准备好读数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 通道已经准备好写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择器的使用还有很多的细节，我们应该多查看api文档了解各个方法的用法。下一节我们做一个综合练习，总结一下NIO的使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们将探索选择器(selectors)。选择器提供选择执行已经就绪的任务的能力，这使得多元 I/O 成为可能。就像在第一章中描述的那样，就绪选择和多元执行使得单线程能够有效率地同时管理多个 I/O 通道(channels)。C/C++代码的工具箱中，许多年前就已经有 
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(二）-Helloworld Netty</title>
    <link href="http://blog.rickiyang.cn/posts/7ab746e7.html"/>
    <id>http://blog.rickiyang.cn/posts/7ab746e7.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.149Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们来讲解Netty，使用Netty之前我们先了解一下Netty能做什么，无为而学，岂不是白费力气！</p><h4 id="1使用netty能够做什么"><a class="markdownIt-Anchor" href="#1使用netty能够做什么"></a> <strong>1.使用Netty能够做什么</strong></h4><ol><li>开发异步、非阻塞的TCP网络应用程序；</li><li>开发异步、非阻塞的UDP网络应用程序；</li><li>开发异步文件传输应用程序；</li><li>开发异步HTTP服务端和客户端应用程序；</li><li>提供对多种编解码框架的集成，包括谷歌的Protobuf、Jboss marshalling、Java序列化、压缩编解码、XML解码、字符串编解码等，这些编解码框架可以被用户直接使用；</li><li>提供形式多样的编解码基础类库，可以非常方便的实现私有协议栈编解码框架的二次定制和开发；</li><li>基于职责链模式的Pipeline-Handler机制，用户可以非常方便的对网络事件进行拦截和定制；</li><li>所有的IO操作都是异步的，用户可以通过Future-Listener机制主动Get结果或者由IO线程操作完成之后主动Notify结果，用户的业务线程不需要同步等待；</li><li>IP黑白名单控制；</li><li>打印消息码流；</li><li>流量控制和整形；</li><li>性能统计；</li><li>基于链路空闲事件检测的心跳检测</li></ol><h4 id="2-netty常用类讲解"><a class="markdownIt-Anchor" href="#2-netty常用类讲解"></a> <strong>2. Netty常用类讲解</strong></h4><p>在这里我们就一些我们常用到的类做大致的讲解，然后再写入门程序的时候大致知道每一行都讲了什么。</p><p><strong>EventLoop,EventLoopGroup</strong></p><p>EventLoop目的是为Channel处理IO操作，一个EventLoop可以为多个Channel服务,EventLoopGroup会包含多个EventLoop。</p><p><strong>BootStrap,ServerBootstrap</strong></p><p>一个Netty应用通常由一个Bootstrap开始，它主要作用是配置整个Netty程序，串联起各个组件。</p><p><strong>ChannelInitializer</strong></p><p>当一个链接建立时，我们需要知道怎么来接收或者发送数据，当然，我们有各种各样的Handler实现来处理它，那么ChannelInitializer便是用来配置这些Handler，它会提供一个ChannelPipeline，并把Handler加入到ChannelPipeline。</p><p><strong>Handler</strong></p><p>为了支持各种协议和处理数据的方式，便诞生了Handler组件。Handler主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p><p><strong>ChannelInboundHandler</strong></p><p>一个最常用的Handler。这个Handler的作用就是处理接收到数据时的事件，也就是说，我们的业务逻辑一般就是写在这个Handler里面的，ChannelInboundHandler就是用来处理我们的核心业务逻辑。</p><p><strong>Future</strong></p><p>在Netty中所有的IO操作都是异步的，因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之，所有的操作都会返回一个ChannelFuture。</p><h4 id="3-第一个helloworld"><a class="markdownIt-Anchor" href="#3-第一个helloworld"></a> <strong>3. 第一个Helloworld</strong></h4><p>上面我们已经对常用类进行说明，下面我们就使用这些类来构建我们的第一个入门程序，本示例我使用的是maven来构建工程，如果你使用的是普通的项目则跳过第一步。</p><p>首先引入maven jar包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.1.5.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>下面我们来写客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = bootstrap.connect(address,port).sync().channel();</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                String msg = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span>(msg == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;             </span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelInitializer用来配置处理数据的handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个地方的 必须和服务端对应上。否则无法正常解码和编码</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 解码和编码 我将会在下一节为大家详细的讲解。暂时不做详细的描述</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * /        </span></span><br><span class="line"><span class="comment">        pipeline.addLast("decoder", new StringDecoder());</span></span><br><span class="line"><span class="comment">        pipeline.addLast("encoder", new StringEncoder());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 我们自己的handler</span></span><br><span class="line"><span class="comment">        pipeline.addLast("handler", new HelloWorldClientHandler());</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>写一个我们自己的handler，用自己的方式来处理数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server say : "</span>+msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is active"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端我们写完了，下面开始写服务器端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWordServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWordServer server = <span class="keyword">new</span> HelloWordServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端的ChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();      </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWordServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端的handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">"===&gt;server: "</span>+msg.toString());</span><br><span class="line">        ctx.write(<span class="string">"received your msg"</span>);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面服务器端和客户端的代码都已经写完，下面我们先启动服务端，然后启动客户端，程序中我是在客户端让手动输入，输入结束之后回车，服务器端即可接受数据。</p><p>客户端：<br><img src="http://i.imgur.com/OMBsop1.png" alt=""></p><p>服务端：<br><img src="http://i.imgur.com/h9vfXoV.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们来讲解Netty，使用Netty之前我们先了解一下Netty能做什么，无为而学，岂不是白费力气！&lt;/p&gt;
&lt;h4 id=&quot;1使用netty能够做什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1使用netty能够做什么&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
      <category term="Netty" scheme="http://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二）----创建并运行java线程</title>
    <link href="http://blog.rickiyang.cn/posts/c845f6f3.html"/>
    <id>http://blog.rickiyang.cn/posts/c845f6f3.html</id>
    <published>2017-03-15T17:02:01.000Z</published>
    <updated>2018-12-04T09:28:26.137Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-实现线程的两种方式"><a class="markdownIt-Anchor" href="#1-实现线程的两种方式"></a> 1 实现线程的两种方式</h4><p>上一节我们了解了关于线程的一些基本知识，下面我们正式进入多线程的实现环节。实现线程常用的有两种方式，一种是继承Thread类，一种是实现Runnable接口。当然还有第三种方式，那就是通过线程池来生成线程，后面我们还会学习，一步一个脚印打好基础。</p><p>Runnable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();      </span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面为Thread类和Runnable类的源码，我们可以看到Thread类也是实现了Runnable接口，即Thread是Runnable的实现，那么他们到底在实现多线程上有什么区别呢？</p><p>Thread和Runnable解析：</p><p>①Runnable接口：</p><p>Runnable接口是java中线程的定义类。所有线程都是通过该接口来实现，该接口中的run（）方法为实现方法，即线程所要实现的内容写入该方法里面，当线程启动时会调用该方法。<br>在大多数情况下，如果只想重写run（）方法而不重写其他方法，应使用Runnable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new了两个线程对象——s1和s2</span></span><br><span class="line">        <span class="comment">//其中两个对象各对应一个内存区域。线程运行过程中运行都是自己内存块中的数据</span></span><br><span class="line">        Shop1 s1 = <span class="keyword">new</span> Shop1(<span class="string">"小武"</span>);</span><br><span class="line">        s1.start();</span><br><span class="line">        </span><br><span class="line">        Shop1 s2 = <span class="keyword">new</span> Shop1(<span class="string">"小潘"</span>);</span><br><span class="line">        s2.start();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //实例化了两个线程对象，所以分配了两块内存空间</span></span><br><span class="line"><span class="comment">        //执行过程中操作的是自己的内存空间</span></span><br><span class="line"><span class="comment">        Shop2 s3 = new Shop2("小武");</span></span><br><span class="line"><span class="comment">        s3.run();</span></span><br><span class="line"><span class="comment">        Shop2 s4 = new Shop2("小潘");</span></span><br><span class="line"><span class="comment">        s4.run();</span></span><br><span class="line"><span class="comment">        //实际实例化了两个线程对象</span></span><br><span class="line"><span class="comment">        //所以同样分配两个内存空间</span></span><br><span class="line"><span class="comment">        Thread t1 = new Thread(new Shop2("小武"));</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        Thread t2 = new Thread(new Shop2("小潘"));</span></span><br><span class="line"><span class="comment">        t2.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//创建了两个线程对象，但是使用的是同一个对象——s6</span></span><br><span class="line">        Shop2 s5 = <span class="keyword">new</span> Shop2(<span class="string">"w"</span>);</span><br><span class="line">        Shop1 s6 = <span class="keyword">new</span> Shop1(<span class="string">"T"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(s6);</span><br><span class="line">        t3.start();</span><br><span class="line">        </span><br><span class="line">        Thread t4 =<span class="keyword">new</span> Thread(s6);</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 武大郎卖烧饼（因为业务的拓展，现在可以实现多窗口的出售）</span></span><br><span class="line"><span class="comment"> * 要求：每天只卖10个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shop1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//private int count = 10;</span></span><br><span class="line">    <span class="comment">//使用静态变量可以有效的实现资源共享（因为在内存中只有一份count）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shop1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否已经卖完</span></span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() +<span class="string">"卖出了一个烧饼"</span> + <span class="string">",现在剩余"</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用接口实现上面的代码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shop2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量，存储剩余烧饼的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//存储当前人的姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shop2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name  = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现销售的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否已经卖完</span></span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"、"</span> + <span class="keyword">this</span>.name +<span class="string">"卖出了一个烧饼"</span> + <span class="string">",现在剩余"</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②Thread类：</p><p>Thread类是Runnable接口的实现，jdk给我们提供了一个不用我们去想如何实现线程的方式供我们使用。同样你在继承Thread类的时候也需要重写run()方法来实现你想在线程中实现的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//传统方式——单任务方式</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            SimpleClass sc1 = new SimpleClass();</span></span><br><span class="line"><span class="comment">            sc1.say("Mike");</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            SimpleClass sc2 = new SimpleClass();</span></span><br><span class="line"><span class="comment">            sc2.say("Han Meimei");</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//创建一个线程</span></span><br><span class="line">            ThreadClass tc1 = <span class="keyword">new</span> ThreadClass(<span class="string">"Mike"</span>);</span><br><span class="line">            <span class="comment">//启动线程</span></span><br><span class="line">            tc1.start();</span><br><span class="line">            <span class="comment">//创建一个线程</span></span><br><span class="line">            ThreadClass tc2 = <span class="keyword">new</span> ThreadClass(<span class="string">"Han Meimei"</span>);</span><br><span class="line">            tc2.start();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hi,Im "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadClass</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将父类（Thread）的run()方法进行重写</span></span><br><span class="line"><span class="comment">     * 在run()方法中包含了需要执行的代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hi,Im "</span> + <span class="keyword">this</span>.getName() + <span class="string">"|"</span> + <span class="keyword">this</span>.getId() +    </span><br><span class="line">            <span class="string">"|"</span> + <span class="keyword">this</span>.getStackTrace());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类中常用方法：</p><ol><li>run()：如果该线程时使用独立的Runnable运行对象构造的，则调用该Runnable对象的run方法。否则，该方法不执行任何操作并返回。</li><li>sleep(longmillls):在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</li><li>yield():暂停当前正在执行的线程对象，并执行其他线程  start()：使该线程开始运行，java虚拟机再调用该线程的run方法 。</li><li>join():等待该线程结束。</li></ol><p><strong>对比：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面给出了Thread和Runnable的实现，我们能看到在使用Runnable的方式实现线程的过程中：</span><br><span class="line"></span><br><span class="line">Shop1 s6 = <span class="keyword">new</span> Shop1(<span class="string">"T"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(s6);</span><br><span class="line">t3.start();</span><br></pre></td></tr></table></figure><p>即把Runnable对象（实现了Runnable接口的对象）还是塞进了Thread中让Thread来实现。那么我们可以new 多个Thread来实现同一个Runnbale对象，即实现了资源的共享，比如在售票系统中多名用户对同一种票的抢购。另一方面，java是单继承多实现的，如果我们使用Thread的话意味着该类只能继承Thread，对于程序的扩展不利，而实现Runnbale接口则没有这个顾虑。考虑程序的健壮性，我们应该尽量使用Runnable来实现我们的线程。</p><h4 id="run和start"><a class="markdownIt-Anchor" href="#run和start"></a> run和start</h4><p>初学多线程我们总是分不清楚run()方法和start()方法的区别，其实我们再看一下上面Thread类的源码就不难发现他们的用法是很容易区分的：</p><ol><li><p>run()方法是线程的实现方法，即你需要线程去做什么事情，那么这些实现的内容写在run()里面，当线程启动时就会调用run()方法继而实现run()内部的代码；</p></li><li><p>start()方法是线程的启动方法，即如果你new Thread()这样并不算完。你还得new Thread().start()才算启动这个线程，启动完之后线程内部会主动的调用run()方法执行该线程的业务逻辑代码。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-实现线程的两种方式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-实现线程的两种方式&quot;&gt;&lt;/a&gt; 1 实现线程的两种方式&lt;/h4&gt;
&lt;p&gt;上一节我们了解了关于线程的一些基本知识，下面我们正式进入多线程的实现环节。实现线程常用的有
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="http://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（一）----线程基础知识</title>
    <link href="http://blog.rickiyang.cn/posts/ac18980b.html"/>
    <id>http://blog.rickiyang.cn/posts/ac18980b.html</id>
    <published>2017-03-15T17:02:00.000Z</published>
    <updated>2018-12-05T06:16:19.834Z</updated>
    
    <content type="html"><![CDATA[<p>在任何的生产环境中我们都不可逃避并发这个问题，多线程作为并发问题的技术支持让我们不得不去了解。这一块知识就像一个大蛋糕一样等着我们去分享，抱着学习的心态，记录下自己对并发的认识。<br>###1.线程的状态：<br>线程状态图：<br><img src="http://img.blog.csdn.net/20161214214726030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="线程状态图"><br>1、新建状态（New）：新创建了一个线程对象。<br>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。<br>3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。<br>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<br>（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。<br>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。<br>（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。<br>5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。<br>###2.线程调度<br>2.1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：<br>static int MAX_PRIORITY<br>线程可以具有的最高优先级，取值为10。<br>static int MIN_PRIORITY<br>线程可以具有的最低优先级，取值为1。<br>static int NORM_PRIORITY<br>分配给线程的默认优先级，取值为5。<br>Thread类的<code>setPriority()</code>和<code>getPriority()</code>方法分别用来设置和获取线程的优先级。<br>每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。<br>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。<br>JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。<br>###3.线程基本方法使用说明：<br>-线程睡眠：Thread.sleep(longmillis)，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。<br>-线程等待：Object类中的wait()，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。<br>-线程让步：Thread.yield()，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。<br>-线程加入：join()，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。<br>-线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。<br><em><strong>注意</strong></em>：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p><p><strong>Java 中的线程可以分为<em>守护线程</em>(Daemon Thread) 和<em>用户线程</em>( User Thread) 。用户线程会阻止JVM 的正常停止，即JVM 正常停止前应用程序中的所有用户线程必须先停止完毕,否则JVM 无法停止。而守护线程则不会影响JVM 的正常停止，即应用程序中有守护线程在运行也不影响JVM 的正常停止。因此，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在任何的生产环境中我们都不可逃避并发这个问题，多线程作为并发问题的技术支持让我们不得不去了解。这一块知识就像一个大蛋糕一样等着我们去分享，抱着学习的心态，记录下自己对并发的认识。&lt;br&gt;
###1.线程的状态：&lt;br&gt;
线程状态图：&lt;br&gt;
&lt;img src=&quot;http:/
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="http://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="http://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rickiyang&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.rickiyang.cn/"/>
  <updated>2018-12-06T10:20:49.321Z</updated>
  <id>https://blog.rickiyang.cn/</id>
  
  <author>
    <name>Rickiyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用table标签生成页面出现大量空白的解决办法</title>
    <link href="https://blog.rickiyang.cn/posts/e4afcbeb.html"/>
    <id>https://blog.rickiyang.cn/posts/e4afcbeb.html</id>
    <published>2018-12-06T03:56:43.000Z</published>
    <updated>2018-12-06T10:20:49.321Z</updated>
    
    <content type="html"><![CDATA[<p>写博客的时候，就发现Hexo中插入HTML表格会留出大量空白。如下所示：</p><table><br>  <tr><br>    <th>姓名</th><br>    <th>性别</th><br>  </tr><br>  <tr><br>    <td>xiaoming</td><br>    <td>1</td><br>  </tr><br></table><p>虽然markdown语法也是可以生成表格的，但是写的时候特别麻烦，所以我一直是直接插入的HTML表格的，仅仅是因为简单高效。<br>后来在hexo的issue中发现这个问题，<a href="https://github.com/hexojs/hexo/issues/2391" target="_blank" rel="noopener">issue</a>,有两种解决办法：</p><p>解决方法1</p><p>将代码改为紧凑模式，修改代码如下</p><table><tr><th>姓名</th><th>性别</th></tr><tr><td>xiaoming</td><td>1</td></tr></table><p>也就是说代码标签之间不要留白，全部改为紧贴着的。</p><table><tr><th>姓名</th><th>性别</th></tr><tr><td>xiaoming</td><td>1</td></tr></table><p>我一般都是使用<a href="http://www.tablesgenerator.com/" target="_blank" rel="noopener">tablesgenerator</a>来生成表格的。</p><p>解决方法2(推荐)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">html tags &amp; content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>  <table>  <tr>    <th>姓名</th>    <th>性别</th>  </tr>  <tr>    <td>xiaoming</td>    <td>1</td>  </tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写博客的时候，就发现Hexo中插入HTML表格会留出大量空白。如下所示：&lt;/p&gt;
&lt;table&gt;&lt;br&gt;  &lt;tr&gt;&lt;br&gt;    &lt;th&gt;姓名&lt;/th&gt;&lt;br&gt;    &lt;th&gt;性别&lt;/th&gt;&lt;br&gt;  &lt;/tr&gt;&lt;br&gt;  &lt;tr&gt;&lt;br&gt;    &lt;td&gt;xiaoming
      
    
    </summary>
    
      <category term="hexo" scheme="https://blog.rickiyang.cn/categories/hexo/"/>
    
    
      <category term="hexo优化" scheme="https://blog.rickiyang.cn/tags/hexo%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java重试工具类:spring-retry和guava-retryer</title>
    <link href="https://blog.rickiyang.cn/posts/73e3dbd9.html"/>
    <id>https://blog.rickiyang.cn/posts/73e3dbd9.html</id>
    <published>2018-12-05T15:20:04.000Z</published>
    <updated>2018-12-05T06:13:34.121Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发中经常遇到调用外部接口失败的情况，这时候我们需要去设置失败重试机制，正常情况我们的重试机制是：如果出错了，一般是网络抖动或者延迟的情况，设置重试一次，或者几次，可能是如下方案：<br>try-catch-redo简单重试模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    redo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想定制什么时候重试，重试几次，就需要我们自己定义重试策略，那么我们的代码就稍微复杂一些，可能是如下方案：<br>try-catch-redo-retry strategy策略重试模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    redo(retryTime,interval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上是我们一般的处理方案，由上我们大致可以看出如果想要实现一个优雅的重试方案，需要我们详细的去考虑重试机制，重试策略，重试失败措施，重试代码如何做到不侵入业务代码等等。所以，这样的一个小功能我们也是可以做成很有意思的小组件的。现代分布式系统中系统调用如此频繁，重试机制也是大家开发中的重复性劳动，所以这种不必要的代码已经有人给我们写好了，分别是Java中的Spring-Retry和Guava-Retrying。</p><p>其中Spring-Retry是基于Throwable类型的重试机制，即针对可捕获异常执行重试策略，并提供相应的回滚策略；而Guava-Retrying提供了更为丰富的重试源定义，譬如多个异常或者多个返回值。</p><p>Spring-Retry:</p><p>引入jar包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>通过构造一个重试模板来执行重试策略，在重试模板中可以设置重试次数，重试间隔和回退策略。我们通过一段代码来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retryDoSomething</span><span class="params">(<span class="keyword">final</span> Map&lt;String, Object&gt; map)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 构建重试模板实例</span></span><br><span class="line">        RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">// 设置重试策略，主要设置重试次数</span></span><br><span class="line">        SimpleRetryPolicy policy = <span class="keyword">new</span> SimpleRetryPolicy(<span class="number">3</span>, Collections.singletonMap(Exception.class, <span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// 设置重试回退操作策略，主要设置重试间隔时间</span></span><br><span class="line">        FixedBackOffPolicy fixedBackOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">        fixedBackOffPolicy.setBackOffPeriod(<span class="number">100</span>);</span><br><span class="line">        retryTemplate.setRetryPolicy(policy);</span><br><span class="line">        retryTemplate.setBackOffPolicy(fixedBackOffPolicy);</span><br><span class="line">        <span class="comment">// 通过RetryCallback 重试回调实例包装正常逻辑逻辑，第一次执行和重试执行执行的都是这段逻辑</span></span><br><span class="line">        <span class="keyword">final</span> RetryCallback&lt;Object, Exception&gt; retryCallback = <span class="keyword">new</span> RetryCallback&lt;Object, Exception&gt;() &#123;</span><br><span class="line">            <span class="comment">//RetryContext 重试操作上下文约定，统一spring-try包装</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"do some thing"</span>);</span><br><span class="line">                Exception e = doSomething(map);</span><br><span class="line">                System.out.println(context.getRetryCount());</span><br><span class="line">                <span class="keyword">throw</span> e;<span class="comment">//这个点特别注意，重试的根源通过Exception返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 通过RecoveryCallback 重试流程正常结束或者达到重试上限后的退出恢复操作实例</span></span><br><span class="line">        <span class="keyword">final</span> RecoveryCallback&lt;Object&gt; recoveryCallback = <span class="keyword">new</span> RecoveryCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"do recory operation"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 由retryTemplate 执行execute方法开始逻辑执行</span></span><br><span class="line">            retryTemplate.execute(retryCallback, recoveryCallback);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>spring-retry是通过RetryTemplate的execute方法来执行重试代码的，execute方法是线程安全的，实现中他将retry的餐参数对象保存在ThreadLocal中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RetryContext context = <span class="keyword">this</span>.open(retryPolicy, state);</span><br><span class="line"><span class="comment">//ThreadLocal中保存context对象</span></span><br><span class="line">RetrySynchronizationManager.register(context);</span><br></pre></td></tr></table></figure><p>以上代码需要注意的是重试的执行逻辑是在RetryCallback类中实现的，触发重试逻辑是在doWithRetry方法中抛出泛型异常。这就意味着如果你的代码并没有异常抛出但是仍然需要在某种返回值的条件下触发重试逻辑的时候，你需要手动的判断该返回值然后抛出异常。这个操作有点强人所难。</p><p>所以在此基础之上，guava-retryer重新做了设计，在支持重试次数和重试频度的基础上，能够兼容支持多个异常或者自定义实体对象的重试源定义。</p><p>引入jar：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.rholder&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava-retrying&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LedgerResult <span class="title">requestRestry</span><span class="params">(NrRequestParams nrRequestParams)</span> </span>&#123;</span><br><span class="line">        Retryer&lt;LedgerResult&gt; retryer = RetryerBuilder.&lt;LedgerResult&gt;newBuilder()</span><br><span class="line">                .retryIfExceptionOfType(BizException.class)</span><br><span class="line">                .retryIfException()</span><br><span class="line">                .retryIfResult(result -&gt; result == <span class="keyword">null</span>)</span><br><span class="line">                .withWaitStrategy(WaitStrategies.fixedWait(<span class="number">5</span>, TimeUnit.MINUTES))</span><br><span class="line">                .withStopStrategy(StopStrategies.stopAfterAttempt(<span class="number">10</span>))</span><br><span class="line">                .withRetryListener(<span class="keyword">new</span> RetryListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">onRetry</span><span class="params">(Attempt&lt;V&gt; attempt)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">long</span> attemptNumber = attempt.getAttemptNumber();</span><br><span class="line">                        <span class="keyword">if</span> (attemptNumber &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                            logger.info(<span class="string">"&lt;=====重试次数:&#123;&#125;,params:&#123;&#125;"</span>, attemptNumber - <span class="number">1</span>, nrRequestParams);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> retryer.call(() -&gt; requestLedger(nrRequestParams));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"&lt;&lt;&lt;&lt;&lt;=====重试失败====参数：&#123;&#125;"</span>, nrRequestParams, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RetryException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"&lt;&lt;&lt;&lt;&lt;=====重试失败====参数：&#123;&#125;"</span>, nrRequestParams, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过RetryerBuilder来构造工厂对象，设置重试策略，比如支持特定异常类型，支持检测返回值类型判定，一个全局的监控方法，更加优雅的重试策略和停止策略设置等等。</p><p>guava的api对于用户来说更加的友好，大家会选择哪一个用于日常开发不言自明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;日常开发中经常遇到调用外部接口失败的情况，这时候我们需要去设置失败重试机制，正常情况我们的重试机制是：如果出错了，一般是网络抖动或者延迟的情况，设置重试一次，或者几次，可能是如下方案：&lt;br&gt;try-catch-redo简单重试模式：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="java开发工具类" scheme="https://blog.rickiyang.cn/categories/java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="工具类" scheme="https://blog.rickiyang.cn/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>hbase基本shell命令</title>
    <link href="https://blog.rickiyang.cn/posts/ebc35787.html"/>
    <id>https://blog.rickiyang.cn/posts/ebc35787.html</id>
    <published>2018-10-07T15:56:43.000Z</published>
    <updated>2018-12-06T02:53:23.041Z</updated>
    
    <content type="html"><![CDATA[<p>启动HBASE，进入shell，退出shell：</p><pre><code>start-hbase.sh hbase shell quit </code></pre><p>进入shell之后遇到命令不知道怎么使用的话，使用’help’命令：</p><p><img src="https://i.imgur.com/kpCjU8M.jpg" alt=""></p><p>help的使用方式：</p><pre><code>help &apos;命令&apos; #命令需要加引号</code></pre><p><strong>需要注意的事： 不知道为什么hbase的shell界面输入字符之后如果想回退按backspace是不行的，我使用的shell客户端是Xshell，同时按住：ctrl+space+backspace可以。</strong></p><p>1.创建表：</p><pre><code>create &apos;表名&apos;, &apos;列族名1&apos;,&apos;列族名2&apos;,&apos;列族名N&apos;</code></pre><p><img src="https://i.imgur.com/CB15x3K.jpg" alt=""></p><p>2.查看表：</p><p><img src="https://i.imgur.com/fGfpYLD.jpg" alt=""></p><p>3.判断表是否启用或禁用：</p><p><img src="https://i.imgur.com/KgrWJqe.jpg" alt=""></p><p>4.添加表数据：</p><pre><code>put  &apos;表名&apos;,&apos;rowKey&apos;,&apos;列族:列&apos;,&apos;值&apos;</code></pre><p><img src="https://i.imgur.com/TN2piuK.jpg" alt=""></p><p>注意到表名后面的rowkey，其实就相当于是行号的概念。</p><p>5.查看rowkey下的所有数据：</p><pre><code>get  &apos;表名&apos;,&apos;rowKey&apos;</code></pre><p><img src="https://i.imgur.com/WhwgiwF.jpg" alt=""></p><p>6.查看表中的记录总数：</p><pre><code>count &apos;表名&apos;</code></pre><p><img src="https://i.imgur.com/yWhFm9C.jpg" alt=""></p><p>7.获取某行数据：</p><pre><code>get &apos;表名&apos;,&apos;rowkey&apos;</code></pre><p><img src="https://i.imgur.com/M6nFyeB.jpg" alt=""></p><p>8.获取某个列族和获取列族的某个列：</p><pre><code>get &apos;表名&apos;,&apos;rowkey&apos;,&apos;列族&apos;get &apos;表名&apos;,&apos;rowkey&apos;,&apos;列族：列&apos;</code></pre><p><img src="https://i.imgur.com/UWNssfq.jpg" alt=""></p><p>9.删除记录(某一行中的某一个值)：</p><pre><code>delete &apos;表名&apos;,&apos;rowkey&apos;,&apos;列族：列&apos;</code></pre><p><img src="https://i.imgur.com/WLuhLWD.jpg" alt=""></p><p>10.删除整行：</p><pre><code>deleteall &apos;表名&apos;,&apos;rowkey&apos;</code></pre><p><img src="https://i.imgur.com/oHwjo2y.jpg" alt=""></p><p>11.删除表：</p><pre><code>先要屏蔽该表，才能对该表进行删除第一步 disable ‘表名’ ，第二步  drop &apos;表名&apos;</code></pre><p><img src="https://i.imgur.com/eMdft4V.jpg" alt=""></p><p>12.清空表：</p><pre><code>truncate &apos;表名&apos;</code></pre><p><img src="https://i.imgur.com/J1bL43f.jpg" alt=""></p><p>13.查看表中某个列的所有数据：</p><pre><code>scan &quot;表名&quot;,{COLUMNS=&gt;&apos;列族名:列名&apos;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;启动HBASE，进入shell，退出shell：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start-hbase.sh 
hbase shell 
quit 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进入shell之后遇到命令不知道怎么使用的话，使用’help’命令：&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
      <category term="大数据学习" scheme="https://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hbase" scheme="https://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hbase/"/>
    
    
      <category term="大数据" scheme="https://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>hive基础知识</title>
    <link href="https://blog.rickiyang.cn/posts/88686410.html"/>
    <id>https://blog.rickiyang.cn/posts/88686410.html</id>
    <published>2018-05-16T14:15:00.000Z</published>
    <updated>2018-12-05T06:15:19.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hive基础知识"><a href="#hive基础知识" class="headerlink" title="hive基础知识"></a>hive基础知识</h2><p>Hive是建立在 Hadoop上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），<br>这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。Hive定义了简单的类 SQL查询语言，称为HQL，<br>它允许熟悉SQL的用户查询数据。同时，这个语言也允许熟悉MapReduce开发者的开发自定义的mapper和reducer来处理<br>内建的mapper和reducer无法完成的复杂的分析工作。</p><h3 id="2-为什么会产生hive"><a href="#2-为什么会产生hive" class="headerlink" title="2.为什么会产生hive"></a>2.为什么会产生hive</h3><p>方便非java编程者（熟悉SQL语言）对hdfs的数据做mapreduce操作。</p><h3 id="3-hive能做什么"><a href="#3-hive能做什么" class="headerlink" title="3.hive能做什么"></a>3.hive能做什么</h3><p>数据仓库： 不与用户交互；存放历史数据；反范式设计，专门引入冗余数据，保证数据完整。数据仓库面向分析，里面存放的数据用来做分析和挖掘。<br>Hive是数据仓库，Hive将SQL转化为MapReduce可以识别的操作，承担解释器、编译器、优化器等角色，Hive运行时，元数据（表的结构、属性）存储在关系型数据库里面。因为元数据信息需要高效的读取。</p><h3 id="4-初识hive"><a href="#4-初识hive" class="headerlink" title="4.初识hive"></a>4.初识hive</h3><h4 id="4-1-hive数据类型"><a href="#4-1-hive数据类型" class="headerlink" title="4.1 hive数据类型"></a>4.1 hive数据类型</h4><p>hive支持的数据类型包括：</p><ul><li>基本类型：tinyint, smallint, int,bigint, boolean, float, double, string,varchar,char</li><li>复杂类型：struct，map，array,data,timestamp</li></ul><h4 id="4-2-hive数据模型"><a href="#4-2-hive数据模型" class="headerlink" title="4.2 hive数据模型"></a>4.2 hive数据模型</h4><p>hive支持四中数据模型：</p><ol><li>external table <b>外部表</b></li><li>table <b>默认为内部表</b></li><li>partion <b>分区表</b></li><li>bucket <b>桶表</b></li></ol><p>内部表：<br><br>为指定表为别的形式的表默认都为内部表，hive会为其建立一个相应的目录保存。删除表时，元数据和数据都会被删除。<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span> (<span class="keyword">name</span> <span class="keyword">string</span> , age <span class="keyword">string</span>) location  <span class="string">'/input/table_data'</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/input/data'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">test</span> ;</span><br></pre></td></tr></table></figure><p>load命令会将/input/data下的数据加载到/input/table_data目录下，当删除test表的时候test表数据和/input/table_data下的数据都被删除。当然/input/data下也没有数据。如果创建内部表的时候没有指定location，就会在hdfs/hive，hdfs的默认目录下新建一个表目录。</p><p>注：本质上load data会转移数据。</p><p>外部表:<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> etest (<span class="keyword">name</span> <span class="keyword">string</span> , age <span class="keyword">string</span>);</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/input/edata'</span> <span class="keyword">into</span> <span class="keyword">table</span> etest;</span><br></pre></td></tr></table></figure><p>当把/input/edata下的数据转移到hdfs的默认目录后执行删除操作，默认目录中已经载入的数据不会被删除，但是/input/edata下的数据已经没有了，相当于做了一次剪切操作。</p><p>分区表：<br><br>hive的表在hdfs上是对应一个文件目录保存的，当使用hive进行查询的时候会对该目录下的文件进行全表扫描，这样是很浪费性能的，这样就引入了partion(分区)和bucket(桶)的概念。</p><p>分区表是指创建表时，指定partition的分区空间:</p><pre><code>partition by(字段名 字段类型)</code></pre><p>分区表又分动态分区和静态分区，静态分区要求在建表的时候指定分区字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dyn_part_test_spark(</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">score <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (</span><br><span class="line">grade <span class="keyword">string</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure><p>在装载完数据之后，分区的列grade和class所对应的值会生成若干个子目录，假如有如下插入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> dyn_part_test_spark <span class="keyword">partition</span>(grade=<span class="string">'grade1'</span>,<span class="keyword">class</span>=<span class="string">'class1'</span>)</span><br></pre></td></tr></table></figure><p>那么查询的时候数据就位于grade1目录下的class1目录里面。</p><p>但是静态分区会有一个问题，那就是在分区之前对应分区的值是需要被确定的，即partition后面的值需要被确定。当值有很多个的时候，就需要重复执行很多类似于上面insert语句这样的插入语句。即在插入的时候需要指定你要插入那个分区，不然插入失败。</p><p>为了解决这个问题，所以提出了动态分区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_created_dynamic_partition (</span><br><span class="line">    orderNumber <span class="keyword">STRING</span>,</span><br><span class="line">    event_time  <span class="keyword">STRING</span></span><br><span class="line">)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (event_month <span class="keyword">string</span>);</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> dyn_part_test_spark <span class="keyword">partition</span>(grade,<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><p>注意到insert语句后面没有指定具体的值，执行成功以后hdfs就会生成相应值对应的文件夹。这就是动态分区的好处。</p><p>要让hive表自动生成分区需要配置开启动态分区，配置如下：</p><pre><code>SET hive.exec.dynamic.partition=true;         //是否开启动态分区，默认为falseSET hive.exec.dynamic.partition.mode=nonstrict; //动态分区的模式，默认为strictSET hive.exec.max.dynamic.partitions.pernode = 1000;//在每个执行MR的节点上最大可创建分区个数，默认值100SET hive.exec.max.dynamic.partitions=1000;//在所有执行MR的节点上，最大可创建多少分区，默认1000</code></pre><p>桶表：<br><br>对于每一个表或者是分区可以进一步组织为桶。在分桶时，对指定字段进行hash运算得到hash值，用hash值除以桶个数取余得到的值作为分桶依据。余数相同的数据会分到同一个桶。做hash运算时hash函数的选择取决于分桶字段的数据类型。分桶之后的查询效率比分区之后的效率要高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="keyword">string</span>, tno <span class="keyword">string</span>,age <span class="built_in">INT</span>)</span><br><span class="line">partitioned <span class="keyword">by</span> (work_date <span class="keyword">string</span>)</span><br><span class="line">clustered <span class="keyword">by</span> (<span class="keyword">id</span>) sorted <span class="keyword">by</span> (<span class="keyword">name</span>) <span class="keyword">into</span> <span class="number">2</span> buckets</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure><p>hive中的table可以拆分为partition,table和partition可以进一步的通过”clustered by”拆分为桶，桶中的数据可以通过”sorted by”进行排序。比如上面的sql语句中通过id进行分桶，每个桶中的数据通过id进行排序。</p><p>插入数据：<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建中间表并插入数据</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp_teacher(<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="keyword">string</span>, tno <span class="keyword">string</span>,age <span class="built_in">INT</span>);</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/data/input/'</span> <span class="keyword">into</span> <span class="keyword">table</span> tmp_teacher;</span><br><span class="line">//将临时表的数据插入到桶表中</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> teacher <span class="keyword">select</span> * <span class="keyword">from</span> tmp_teacher;</span><br><span class="line">//修改桶表中bucket的数量    </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> teacher clustered <span class="keyword">by</span>(<span class="keyword">name</span>) sorted <span class="keyword">by</span>(age) <span class="keyword">into</span> <span class="number">10</span> buckets;</span><br></pre></td></tr></table></figure><h4 id="4-3-hive基本操作"><a href="#4-3-hive基本操作" class="headerlink" title="4.3 hive基本操作"></a>4.3 hive基本操作</h4><p><strong>创建库</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> userdb location <span class="string">'/local/path/'</span> <span class="keyword">comment</span> <span class="string">'is coment message'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>显示数据库的路径</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span> <span class="keyword">database</span> userdb;</span><br></pre></td></tr></table></figure></p><p><strong>删除数据库</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> userdb;</span><br></pre></td></tr></table></figure></p><p>默认情况下，hive是不允许删除含有表的数据库，首先删除表，之后在命令行使用‘CASCADE’关键词，同样可以使用‘RESTRICT’：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> userdb <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure><p><strong>建表</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_order (order_sn <span class="keyword">string</span>, user_id <span class="keyword">string</span>,amount <span class="built_in">int</span>,create_time <span class="built_in">timestamp</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></span><br><span class="line">location <span class="string">'/external/hive/t_order'</span>;</span><br></pre></td></tr></table></figure></p><p>建表指定导入数据的存储格式为每一列中间使用空格分开。<br>导入数据:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/root/order.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> t_order;</span><br></pre></td></tr></table></figure></p><p>order.txt的内容如下： </p><pre><code>3016080910 30086 10 2016-08-19 11:50:503016080911 30086 11 2016-08-19 11:51:223016080912 30000 93016080913 30000 2016-08-19 11:52:123016080914 30010 5rmb 2016-08-19 11:53:59</code></pre><p>我们看到数据中第三第四列是有数据缺失的，第五列有数据格式错误，但是我们执行数据插入之后查询发现：</p><pre><code>hive&gt; select * from t_order;3016080910 30086 10 2016-08-19 11:50:50 NULL    NULL    NULL3016080911 30086 11 2016-08-19 11:51:22 NULL    NULL    NULL3016080912 30000 9      NULL    NULL    NULL3016080913 30000 2016-08-19 11:52:12    NULL    NULL    NULL3016080914 30010 NULL 2016-08-19 11:53:59       NULL    NULL    NULLTime taken: 2.144 seconds, Fetched: 5 row(s)</code></pre><p>数据缺失和格式错误的列会自动改为为NULL值。<br>如果数据文件原本就在hdfs上，当我们加载hdfs上的数据到创建的（内部）表的时候，直接将文件移动到该hdfs文件夹下。    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/order.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> t_order;</span><br></pre></td></tr></table></figure><p>加载后，文件被移动到了对应表的hdfs文件夹下,同样可以直接查询到新增加的数据。<br>external类型的表,表对应的是文件夹，对于文件的位置不做任何限制，放到hdfs任何位置都可以。</p><p><strong>创建临时表</strong>：</p><p>创建表时通过SQL语句得到表结构和数据,用于创建一些临时表存储中间结果,这样的表在hdfs中有相应的目录结构和文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_order_tmp</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> order_sn,user_id <span class="keyword">from</span> t_order;</span><br></pre></td></tr></table></figure><p>这样会将从t_order中查询出来的两列作为t_order_tmp表的列并创建t_order_tmp表。</p><p><strong>复制表结构</strong>（只能复制表结构，无法复制表的内容）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_order_like <span class="keyword">like</span> t_order;</span><br></pre></td></tr></table></figure><p><strong>insert into 是追加数据,overwrite是覆盖写所有表。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> t_order_like <span class="keyword">select</span> * <span class="keyword">from</span> t_order;</span><br></pre></td></tr></table></figure><p><strong>创建分区表</strong></p><blockquote><p>PARTITION(分区)添加一个新字段作为分区字段，在hdfs中表现为在t_order_part文件夹下创建以分区命名的文件夹，只能在创建表的时候就指定好（<em>partitioned关键字必须在row format 之前</em>）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_order_part (order_sn <span class="keyword">string</span>, user_id <span class="keyword">string</span>,amount <span class="built_in">int</span>,create_time <span class="built_in">timestamp</span>)</span><br><span class="line">partitioned <span class="keyword">by</span> (<span class="keyword">month</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure><p>数据集如下：</p><pre><code>2016080910 10086 10 2016-08-19 11:50:50 201608202016080911 10086 11 2016-08-19 11:51:22 201608202016080912 10000 9 2016-08-19 11:51:42 201608202016080913 10000 20 2016-08-19 11:52:12 201608202016080914 10010 100 2016-08-19 11:53:59 201608202016080910 10086 10 2016-08-19 11:50:50 201608212016080911 10086 11 2016-08-19 11:51:22 201608212016080912 10000 9 2016-08-19 11:51:42 201608212016080913 10000 20 2016-08-19 11:52:12 201608212016080914 10010 100 2016-08-19 11:53:59 20160821</code></pre><p>加载数据集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/usr/local/order.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> t_order_part <span class="keyword">partition</span> (<span class="keyword">month</span>=<span class="string">'20160820'</span>);</span><br></pre></td></tr></table></figure><p>因为建表的时候没有指定动态分区，静态分区需要在加载数据集的时候手动指定数据插入那个分区。</p><p><strong>hive函数</strong></p><p>操作符：    </p><ol><li>关系操作符，如=、!=、&gt;、&lt;、is null、is not null、like、rlike</li><li>数学操作符，如+、-、*、/、%、&amp;、|、^、~</li><li>逻辑操作符，如and、or、not、&amp;&amp;、|、!</li><li>复杂类型操作符，如array[iter]、map[key]、struct.sub_item</li></ol><p>函数： </p><ol><li>数学函数，如rand()、ln()、sqrt()、abs()、sin()</li><li>字符串函数，如concat_ws()、length()、lower()、ltrim()、reverse()</li><li>日期函数，如year()、unix_timestamp()</li><li>聚合函数，如count([distinct])、sum()、avg()、max()</li><li>条件函数，if(condition, value_true, value_false)、case when a then b when c then d else e end、case a when b then c when d then e else f end</li><li>类型转换函数，如binary()、cast()</li><li>复杂类型函数，如size()、sort_array()</li></ol><p>相关命令行：  </p><ol><li>SHOW FUNCTIONS – 列出目前hive中所有函数</li><li>DESCRIBE FUNCTION function_name  – 显示函数简单描述</li><li>DESCRIBE FUNCTION EXTENDED function_name – 获取函数详细描述</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hive基础知识&quot;&gt;&lt;a href=&quot;#hive基础知识&quot; class=&quot;headerlink&quot; title=&quot;hive基础知识&quot;&gt;&lt;/a&gt;hive基础知识&lt;/h2&gt;&lt;p&gt;Hive是建立在 Hadoop上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提
      
    
    </summary>
    
      <category term="大数据学习" scheme="https://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hive" scheme="https://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hive/"/>
    
    
      <category term="大数据" scheme="https://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>kafka消息的处理机制（5）</title>
    <link href="https://blog.rickiyang.cn/posts/9b912c1b.html"/>
    <id>https://blog.rickiyang.cn/posts/9b912c1b.html</id>
    <published>2018-04-10T04:45:11.000Z</published>
    <updated>2018-12-06T02:53:23.043Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇我们不在是探讨kafka的使用，前面几篇基本讲解了工作中的使用方式，基本api的使用还需要更深入的去钻研，多使用才会有提高。今天主要是探讨一下kafka的消息复制以及消息处理机制。</p><h4 id="1-broker的注册"><a href="#1-broker的注册" class="headerlink" title="1. broker的注册"></a>1. broker的注册</h4><p>Kafka使用Zookeeper来维护集群成员的信息。每个broker都有一个唯一标识符，这个标识符可以在配置文件里指定，也可以自动生成。在kafka启动的时候，他通过创建临节点把自己的id注册到zk，kafka组件订阅zk的/broker/ids路径(broker在zk上的注册路径)，当有broker加入或者退出集群的时候，这些组件就可以获得通知。</p><p>如果当前id所在的broker已经注册然后启动另一个有相同id的broker，启动会出错，新的broker会试着进行注册，但是不会成功。因为zk中已经有一个相同名字的id注册过了。</p><p>如果broker出现停机或者网络长时间无响应，broker会从zk断开链接，zk中注册的临时节点会删除，下次broker启动需要重新注册。</p><p>如果是关闭broker那么他对应的节点也会消失，但是他的id也许会存在于其他的数据结构中。比如主题对应的副本，在完全关闭一个broker之后如果使用相同的id启动另一个全新的broker，他会立即加入集群，并且会拥有之前broker所有的主题和分区(前提是没有发生重排序，没有第二个新的broker加入)。</p><p>kafka的哪些组件需要注册到zookeeper？</p><p>（1）<strong>Broker注册到zk</strong></p><p>每个broker启动时，都会注册到zk中，把自身的broker.id通知给zk。待zk创建此节点后，kafka会把这个broker的主机名和端口号记录到此节点。</p><p>（2）<strong>Topic注册到zk</strong></p><p>当broker启动时，会到对应topic节点下注册自己的broker.id到对应分区的isr列表中；当broker退出时，zk会自动更新其对应的topic分区的ISR列表，并决定是否需要做消费者的rebalance</p><p>（3）<strong>Consumer注册到zk</strong></p><p>一旦有新的消费者组注册到zk，zk会创建专用的节点来保存相关信息。如果zk发现消费者增加或减少，会自动触发消费者的负载均衡。</p><p>（<strong>==注意，producer不注册到zk==</strong>）</p><h4 id="2-kafka集群leader选举"><a href="#2-kafka集群leader选举" class="headerlink" title="2. kafka集群leader选举"></a>2. kafka集群leader选举</h4><ol><li>在kafka集群中，第一个启动的broker会在zk中创建一个临时节点/controller让自己成为控制器。其他broker启动时也会试着创建这个节点当然他们会失败，因为已经有人创建过了。那么这些节点会在控制器节点上创建zk        watch对象，这样他们就可以收到这个节点变更的通知。任何时刻都确保集群中只有一个leader的存在。</li><li>如果控制器被关闭或者与zk断开连接，zk上的KB是节点马上就会消失。那么其他订阅了leader节点的broker也会收到通知随后他们会尝试让自己成为新的leader，重复第一步的操作。</li><li>如果leader完好但是别的broker离开了集群，那么leader会去确定离开的broker的分区并确认新的分区领导者(即分区副本列表里的下一个副本)。然后向所有包含该副本的follower或者observer发送请求。随后新的分区首领开始处理请求。</li></ol><h4 id="3-kafka副本"><a href="#3-kafka副本" class="headerlink" title="3. kafka副本"></a>3. kafka副本</h4><p>Kafka每个topic的partition有N个副本，其中N是topic的复制因子。Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个Broker失效情况下仍然保证服务可用。在Kafka中发生复制时确保partition的预写式日志有序地写到其他节点上。N个replicas中。其中一个replica为leader，其他都为follower，leader处理partition的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。 </p><p>Kafka必须提供数据复制算法保证,如果leader发生故障或挂掉，一个新leader被选举并接收客户端的消息成功写入。Kafka确保从同步副本列表中选举一个副本为leader,或者换句话说,follower追赶leader数据。leader负责维护和跟踪ISR中所有follower滞后状态。当生产者发送一条消息到Broker,leader写入消息并复制到所有follower。消息提交之后才被成功复制到所有的同步副本。消息复制延迟受最慢的follower限制,重要的是快速检测慢副本,如果follower”落后”太多或者失效,leader将会把它从replicas从ISR移除。</p><h5 id="3-1-kafka创建副本的2种模式——同步复制和异步复制"><a href="#3-1-kafka创建副本的2种模式——同步复制和异步复制" class="headerlink" title="3.1 kafka创建副本的2种模式——同步复制和异步复制"></a>3.1 kafka创建副本的2种模式——同步复制和异步复制</h5><p>Kafka动态维护了一个同步状态的副本的集合（a set of In-Sync Replicas），简称ISR，在这个集合中的节点都是和leader保持高度一致的，任何一条消息只有被这个集合中的每个节点读取并追加到日志中，才会向外部通知说“这个消息已经被提交”。</p><p>只有当消息被所有的副本加入到日志中时，才算是“committed”，只有committed的消息才会发送给consumer，这样就不用担心一旦leader down掉了消息会丢失。消息从leader复制到follower,我们可以通过决定Producer是否等待消息被提交的通知(ack)来区分同步复制和异步复制。</p><p>同步复制流程：</p><ol><li>producer联系zk识别leader；</li><li>向leader发送消息；</li><li>leadr收到消息写入到本地log；</li><li>follower从leader pull消息；</li><li>follower向本地写入log；</li><li>follower向leader发送ack消息；</li><li>leader收到所有follower的ack消息；</li></ol><p>leader向producer回传ack。</p><p>异步复制流程：</p><p>和同步复制的区别在于，leader写入本地log之后，直接向client回传ack消息，不需要等待所有follower复制完成。</p><p>既然卡夫卡支持副本模式，那么其中一个Broker里的挂掉，一个新的leader就能通过ISR机制推选出来，继续处理读写请求。</p><p>kafka判断一个broker节点是否存活，依据2个条件：</p><ol><li>节点必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个节点的连接;</li><li>如果节点是个follower,他必须能及时的同步leader的写操作，延时不能太久。Leader会追踪所有“同步中”的节点，一旦一个down掉了，或是卡住了，或是延时太久，leader就会把它移除。</li></ol><h5 id="3-2-一些名词："><a href="#3-2-一些名词：" class="headerlink" title="3.2 一些名词："></a>3.2 一些名词：</h5><ol><li>Leader副本：每个分区都有多个副本，针对每个分区，都有一个唯一的一个Leader副本，负责该分区的读写请求处理。</li><li>Follower副本：从Leader副本拉取数据，作为Leader副本的热备。</li><li>AR：（Assigned Replica）副本集合（Leader+Follower的总和）</li><li>ISR：（In-Sync Replica）同步副本集合，与leader副本消息镜像“相差”不多的副本集合，又称为“核心副本集”，与kafka 发送端的ACK的几种语义有关，后面会详聊（注意这个集合是动态的，是会剔除和新增的）。</li><li>HW：HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broKer的读取请求，没有HW的限制。6. LEO：(Log End Offset)每个分区都会有的一个标记，标示当前分区的最后一条消息（针对Leader就是Leader上的最后一条消息，针对某个Follower，就是当前该Follower的最后一条消息）</li></ol><h5 id="3-3-图解AR-ISR-HW-LEO："><a href="#3-3-图解AR-ISR-HW-LEO：" class="headerlink" title="3.3 图解AR,ISR,HW,LEO："></a>3.3 图解AR,ISR,HW,LEO：</h5><p>这里我们假设每个副本有三个分区，副本被剔除和加入ISR的临界条件为落后leader 三条消息，kafka判断是否符合ISR的条件有两个:</p><ul><li>Follower落后leader多少条消息，落后超过配置值后将踢出ISR</li><li>Follwer多久没从leader同步消息，超过配置时间没拉取数据将从ISR踢出（kafka0.9后删除了该判断，a为唯一判断标准）。</li></ul><p>下面我们用图来表达下上面的概念的关系：</p><p>1.时刻t1该分区的情况如下，此时ISR与AR一致（Leader，follower1，follower2），follower2 和 leader的消息一致，LEO都为4，follower1的LEO为2，因此leader的HW为2。</p><p><img src="https://i.imgur.com/On1RBAj.png" alt=""></p><p>2.时刻t2 follower full gc：</p><p><img src="https://i.imgur.com/KPBtFa2.png" alt=""></p><p>3.时刻t3，leader接受producer发送来的2条消息5、6，此时发现Follower1已经落后了自己4条消息，将follower1踢出ISR集合：</p><p><img src="https://i.imgur.com/JPeUqqC.png" alt=""></p><p>4.时刻4，follower1从leader拉取到5这条消息，更新HW：</p><p><img src="https://i.imgur.com/etpzcm7.png" alt=""></p><p>5.时刻5，follower1 full gc完成后，发现自己已经落后了很多消息，开始从leader追消息，待消息不落后leader太多时，申请加入ISR中。</p><p><img src="https://i.imgur.com/aV3D61I.png" alt=""></p><p>经过上面的图解分析后，我们来看下几个需要注意的点:</p><ol><li>ISR是AR的一个子集，并且是不断伸缩的，变化的条件为“是否落后太多的消息”</li><li>HW之前的消息代表被集群“commit”的消息，只有commit的消息才对client端（consumer以及request.required.acks为-1时的producer），在前面我们说过，这样能够使kafka在语义上支持不丢消息。我们从producer和consumer两个维度来分析：</li></ol><p>在这之前，我们先说下request.required.acks的取值范围（1，0、-1）</p><ol><li>1:leader成功就返回</li><li>0:无需等待leader响应</li><li>-1:ISR都成功才返回</li></ol><p>从producer的角度：当producer将request.required.acks设置为-1时候，保证了消息已经在多个副本中存在了，此时即便leader挂了，这个消息还是存在的（leader选举会从ISR中选举出新的leader），那么假如ISR迟迟同步不成功怎么办呢？ </p><p>从consumer的角度：如果没有HW，consumer拉取到最新的消息后，而此时leader宕机，很有可能新的leader中并没有此消息。</p><p>当然不能保证消息永远不会丢，极端的情况下，如ISR中只有leader的时候（当然可以配置集群可用的最小核心副本集个数，但会极大的损失可用性），或者所有副本都宕机了（这个。。。没办法。），消息还是会丢的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一篇我们不在是探讨kafka的使用，前面几篇基本讲解了工作中的使用方式，基本api的使用还需要更深入的去钻研，多使用才会有提高。今天主要是探讨一下kafka的消息复制以及消息处理机制。&lt;/p&gt;
&lt;h4 id=&quot;1-broker的注册&quot;&gt;&lt;a href=&quot;#1-broker
      
    
    </summary>
    
      <category term="kafka" scheme="https://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>kafka同步异步消费和消息的偏移量（4）</title>
    <link href="https://blog.rickiyang.cn/posts/b11b90c4.html"/>
    <id>https://blog.rickiyang.cn/posts/b11b90c4.html</id>
    <published>2018-04-09T14:13:32.000Z</published>
    <updated>2018-12-06T02:53:23.042Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-消费者位置-consumer-position"><a href="#1-消费者位置-consumer-position" class="headerlink" title="1. 消费者位置(consumer position)"></a>1. 消费者位置(consumer position)</h4><p>因为kafka服务端不保存消息的状态，所以消费端需要自己去做很多事情。我们每次调用poll()方法他总是返回已经保存在生产者队列中还未被消费者消费的消息。消息在每一个分区中都是顺序的，那么必然可以通过一个偏移量去确定每一条消息的位置。</p><p>偏移量在消费消息的过程中处于重要的作用。如果是自动提交消息，那么poll()方法会去在每次获取消息的时候自动提交获取最后一条消息的偏移量，告诉服务器我们已经消费到这个位置，下次从下一个位置开始消费。</p><p>我们把更新分区当前位置的操作叫做提交。消费者是如何提交偏移量的呢？kafka最新的api是这样做的：创建一个叫做_consumer_offset的特殊主题用来保存消息的偏移量。消费者每次消费都会往这个主题发送消息，消息包含每个分区的偏移量。</p><p>如果消费者一直处于运行的状态那么这个偏移量没有什么用。不过如果这个消费者崩溃或者有新的消费者加入群组触发再均衡策略，那么再均衡之后该分区的消费者如果不是之前的那一位，那么新的小伙伴怎么知道之前的伙计消费到哪里呢。所以提交他自己的offset就发挥作用了。</p><p>Consumer读取partition中的数据是通过调用发起一个fetch请求来执行的。而从KafkaConsumer来看，它有一个poll方法。但是这个poll方法只是可能会发起fetch请求。原因是：Consumer每次发起fetch请求时，读取到的数据是有限制的，通过配置项max.partition.fetch.bytes来限制的。而在执行poll方法时，会根据配置项个max.poll.records来限制一次最多pool多少个record。</p><p>那么就可能出现这样的情况： 在满足max.partition.fetch.bytes限制的情况下，假如fetch到了100个record，放到本地缓存后，由于max.poll.records限制每次只能poll出15个record。那么KafkaConsumer就需要执行7次才能将这一次通过网络发起的fetch请求所fetch到的这100个record消费完毕。其中前6次是每次pool中15个record，最后一次是poll出10个record。</p><p>在consumer中，还有另外一个配置项：max.poll.interval.ms ，它表示最大的poll数据间隔，如果超过这个间隔没有发起pool请求，但heartbeat仍旧在发，就认为该consumer处于 livelock状态。就会将该consumer退出consumer group。所以为了不使Consumer 自己被退出，Consumer 应该不停的发起poll(timeout)操作。而这个动作 KafkaConsumer Client是不会帮我们做的，这就需要自己在程序中不停的调用poll方法了。</p><p>当一个consumer因某种原因退出Group时，进行重新分配partition后，同一group中的另一个consumer在读取该partition时，怎么能够知道上一个consumer该从哪个offset的message读取呢？也是是如何保证同一个group内的consumer不重复消费消息呢？上面说了一次走网络的fetch请求会拉取到一定量的数据，但是这些数据还没有被消息完毕，Consumer就挂掉了，下一次进行数据fetch时，是否会从上次读到的数据开始读取，而导致Consumer消费的数据丢失吗？</p><p>为了做到这一点，当使用完poll从本地缓存拉取到数据之后，需要client调用commitSync方法（或者commitAsync方法）去commit 下一次该去读取 哪一个offset的message。</p><p>而这个commit方法会通过走网络的commit请求将offset在coordinator中保留，这样就能够保证下一次读取（不论是进行rebalance）时，既不会重复消费消息，也不会遗漏消息。</p><p>对于offset的commit，Kafka Consumer Java Client支持两种模式：由KafkaConsumer自动提交，或者是用户通过调用commitSync、commitAsync方法的方式完成offset的提交。</p><h4 id="2-位移管理-offset-management"><a href="#2-位移管理-offset-management" class="headerlink" title="2. 位移管理(offset management)"></a>2. 位移管理(offset management)</h4><h5 id="2-1-自动提交"><a href="#2-1-自动提交" class="headerlink" title="2.1 自动提交"></a>2.1 自动提交</h5><p>Kafka默认是定期帮你自动提交位移的(enable.auto.commit = true)，使用这种简单的方式之前你需要知道可能会带来什么后果。</p><p>假设我们仍然使用默认的5s提交时间间隔，在最近一次提交之后的3s发生了再均衡，再均衡之后，消费者从最后一次提交的偏移量位置开始读取消息。这个时候偏移量已经落后<br>了3s，所以在这3s内到达的消息会被重复处理。可以通过修改提交时间间隔来更频繁地提交偏移量，减小可能出现重复悄息的时间窗，不过这种情况是无也完全避免的。</p><p>在使用自动提交时，每次调用轮询方告都会把上一次调用返回的偏移量提交上去，它并不知道具体哪些消息已经被处理了，所以在再次调用之前最好确保所有当前调用返回的消息都已经处理完毕（在调用close()方法之前也会进行自动提交）。一般情况下不会有什么问题，不过在处理异常或提前退出轮询时要格外小心。</p><h5 id="2-2-手动提交"><a href="#2-2-手动提交" class="headerlink" title="2.2 手动提交"></a>2.2 手动提交</h5><p>在多partition多consumer的场景下自动提交总会发生一些不可控的情况。所以消费者API也为我们提供了另外一种提交偏移量的方式。开发者可以在程序中自己决定何时提交，而不是基于时间间隔。</p><p>在使用手动提交之前我们需要先将：</p><pre><code>properties.put(&quot;enable.auto.commit&quot;, &quot;false&quot;);</code></pre><p>然后使用：</p><pre><code>consumer.commitSync();</code></pre><p>来提交。</p><p>commitSync()方法会提交由poll()方法返回的最新偏移量，提交成功后马上返回，否则跑出异常。</p><p>我们处理消息的逻辑可以变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           consumer.commitSync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"commit failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每处理一次消息我们提交一次offset。</p><p><strong>异步手动提交</strong></p><p>上面我们使用commitSync()的方式提交数据，每次提交都需要等待broker返回确认结果。这样没提交一次等待一次会限制我们的吞吐量。<br>如果采用降低提交频率来保证吞吐量，那么则有增加消息重复消费的风险。所以kafka消费者提供了异步提交的API。我们只管发送提交请求无需等待broker返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commitAsync()方法提交最后一个偏移量。在成功提交或碰到无怯恢复的错误之前，commitAsync()会一直重试，但是commitAsync()不会，这也是commitAsync()不好的一个地方。它之所以不进行重试，是因为在它收到服务器响应的时候， 可能有一个更大的偏移量已经提交成功。假设我们发出一个请求用于提交偏移量2000,这个时候发生了短暂的通信问题，服务器收不到请求，自然也不会作出任何响应。与此同时，我们处理了另外一批消息，并成功提交了偏移量3000。如果commitAsync()重新尝试提交偏移量2000 ，它有可能在偏移量3000之后提交成功。这个时候如果发生再均衡，就会出现重复消息。</p><p>当然使用手动提交最大的好处就是如果发生了错误我们可以记录下来。commitAsync()也支持回调方法，提交offset发生错误我们可以记下当前的偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; map, Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(e != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"commit failed"</span>+map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步和异步组合提交</strong></p><p>一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大问题，因为如果提交失败是因为临时问题导致的，那么后续的提交总会有成功的。但如果这是发生在关闭消费者或再均衡前的最后一次提交，就要确保能够提交成功。因此，在消费者关闭前一般会组合使用commitAsync()和commitSync()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"commit failed"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一切正常我们使用commitAsync()来提交。如果直接关闭消费者，就没有所谓的下一次提交了。使用commitSync()会一直重试，直到提交成功。</p><h5 id="2-3-提交特定偏移量"><a href="#2-3-提交特定偏移量" class="headerlink" title="2.3 提交特定偏移量"></a>2.3 提交特定偏移量</h5><p>上面我们手动提交使用的commitAsync()和commitSync()都是提交每一次消费最后一条消息的偏移量，那么如果我们一次拉取了很多消息但是没有消费完，想提交我们消费完成的位置该怎么处理呢？kafka也有相应的对策。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;TopicPartition,OffsetAndMetadata&gt; currentOffset = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        currentOffset.put(<span class="keyword">new</span> TopicPartition(record.topic(),record.partition()),<span class="keyword">new</span> OffsetAndMetadata(record.offset(),<span class="string">"metadata"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"模拟消息处理失败的情况"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            consumer.commitAsync(currentOffset,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用的是commitAsync()，调用commitSync()也是可以的。代码中模拟我们在处理消息的过程中可能会出错的情况，每次读消息都把当前的offset存入map中，如果出错就提交当前已经消费到的偏移量。</p><h5 id="2-4-再均衡监听器"><a href="#2-4-再均衡监听器" class="headerlink" title="2.4 再均衡监听器"></a>2.4 再均衡监听器</h5><p>前面我们说过当发生consumer退出或者新增，partition新增的时候会触发再均衡。那么发生再均衡的时候如果某个consumer正在消费的任务没有消费完该如何提交当前消费到的offset呢？kafka提供了再均衡监听器，在发生再均衡之前监听到，当前consumer可以在失去分区所有权之前处理offset关闭句柄等。</p><p>消费者API中有一个()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe(Collection&lt;TopicPartition&gt; var1, ConsumerRebalanceListener var2);</span><br></pre></td></tr></table></figure><p>ConsumerRebalanceListener对象就是监听器的接口对象，我们需要实现自己的监听器继承该接口。接口里面有两个方法需要实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; var1)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个方法会在再均衡开始之前和消费者停止读取消息之后被调用。如果在这里提交偏移量，下一个接管分区的消费者就知道该从哪里开始读取了。</p><p>第二个会在重新分配分区之后和消费者开始读取消息之前被调用。、</p><p>我们来模拟一下再均衡的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"page_visits"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map&lt;TopicPartition,OffsetAndMetadata&gt; currentOffset = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleRebance</span> <span class="keyword">implements</span> <span class="title">ConsumerRebalanceListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; collection)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"partition is rebanlance"</span>);</span><br><span class="line">        consumer.commitAsync(currentOffset,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; collection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer.subscribe(topic,<span class="keyword">new</span> HandleRebance());</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        currentOffset.put(<span class="keyword">new</span> TopicPartition(record.topic(),record.partition()),<span class="keyword">new</span> OffsetAndMetadata(record.offset(),<span class="string">"metadata"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"模拟消息处理失败的情况"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            consumer.commitAsync(currentOffset,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先实现了ConsumerRebalanceListener接口，实现方法里面如果监听到发生再均衡我们提交当前处理过的偏移量。</p><h5 id="2-5-从特定偏移量处开始处理"><a href="#2-5-从特定偏移量处开始处理" class="headerlink" title="2.5 从特定偏移量处开始处理"></a>2.5 从特定偏移量处开始处理</h5><p>前面都是consumer.poll()之后读取该批次的消息，kafka还提供了从分区的开始或者末尾读消息的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seekToEnd(Collection&lt;TopicPartition&gt; partitions)</span><br><span class="line">seekToBeginning(Collection&lt;TopicPartition&gt; partitions)</span><br></pre></td></tr></table></figure><p>另外kafka还提供了从指定偏移量处读取消息，可以通过seek()方法来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seek(TopicPartition partition, <span class="keyword">long</span> offset)</span><br></pre></td></tr></table></figure><p>提交当前分区和当前消费位置信息。</p><h5 id="2-6-独立消费者–不属于群组的消费者"><a href="#2-6-独立消费者–不属于群组的消费者" class="headerlink" title="2.6 独立消费者–不属于群组的消费者"></a>2.6 独立消费者–不属于群组的消费者</h5><p>到目前为止我们讨论的都是消费者群组，分区被自动分配给群组的消费者，群组的消费者有变动会触发再均衡。那么是不是可以回归到别的消息队列的方式：不需要群组消费者也可以自己订阅主题？</p><p>kafka也提供了这样的案例，因为kafka的主题有分区的概念，那么如果没有群组就意味着你的自己订阅到特定的一个分区才能消费内容。如果是这样的话，<strong>就不需要订阅主题，而是为自己分配分区。</strong>一个消费者可以订阅主题（井加入消费者群组），或者为自己分配分区，但不能同时做这两件事情。</p><p>下面的例子演示如何为自己分配分区并读取消息的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">List&lt;PartitionInfo&gt; partitionInfoList = consumer.partitionsFor(<span class="string">"page_visits"</span>);</span><br><span class="line">List&lt;TopicPartition&gt; topicPartitionList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(partitionInfoList != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(PartitionInfo partitionInfo : partitionInfoList)&#123;</span><br><span class="line">        topicPartitionList.add(<span class="keyword">new</span> TopicPartition(partitionInfo.topic(),partitionInfo.partition()));</span><br><span class="line">        consumer.assign(topicPartitionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map&lt;TopicPartition,OffsetAndMetadata&gt; currentOffset = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        currentOffset.put(<span class="keyword">new</span> TopicPartition(record.topic(),record.partition()),<span class="keyword">new</span> OffsetAndMetadata(record.offset(),<span class="string">"metadata"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"模拟消息处理失败的情况"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            consumer.commitAsync(currentOffset,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>consumer.partitionsFor(“主题”)方法允许我们获取某个主题的分区信息。</li><li>知道想消费的分区后使用assign()手动为该消费者分配分区。</li></ol><p>除了不会发生再均衡，也不需要手动查找分区，其他的看起来一切正常。不过要记住，如果主题增加了新的分区，消费者并不会收到通知。所以，要么周期性地调用consumer.partitionsFor()方法来检查是否有新分区加入，要么在添加新分区后重启应用程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-消费者位置-consumer-position&quot;&gt;&lt;a href=&quot;#1-消费者位置-consumer-position&quot; class=&quot;headerlink&quot; title=&quot;1. 消费者位置(consumer position)&quot;&gt;&lt;/a&gt;1. 消费者位置(
      
    
    </summary>
    
      <category term="kafka" scheme="https://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>kafka客户端和服务端开发（3）</title>
    <link href="https://blog.rickiyang.cn/posts/34bc78bf.html"/>
    <id>https://blog.rickiyang.cn/posts/34bc78bf.html</id>
    <published>2018-04-08T08:56:33.000Z</published>
    <updated>2018-12-06T02:53:23.042Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经搭建了kafka的单机和集群环境，分别写了简单的实例代码，对于代码里面使用到的参数并没有做解释。下面我们来详细说一下各个参数的作用。</p><h4 id="1-创建kafka生产者"><a href="#1-创建kafka生产者" class="headerlink" title="1. 创建kafka生产者"></a>1. 创建kafka生产者</h4><p>kafka生产者有3个必选的属性：</p><p><strong>bootstrap.servers</strong></p><p>该属性指定broker的地址清单，地址的格式为host:port。清单里不需要包含所有的broker 地址，生产者会从给定的broker里查找到其他broker 的信息。不过建议至少要提供两个broker的信息，一且其中一个若机，生产者仍然能够连接到集群上。</p><p><strong>key.serializer</strong></p><p>broker 希望接收到的消息的键和值都是字节数组。生产者接口允许使用参数化类型，因此可以把Java对象作为键和值发送给broker。这样的代码具有良好的可读性，不过生产者需要知道如何把这些Java 对象转换成字节数组。key.serializer必须被设置为一个实现了org.apache.kafka.common.serialization.Serializer接口的类，生产者会使用这个类把键对象序列化成字节数组。</p><p><strong>要注意， key.serializer是必须设置的，就算你打算只发送值内容。</strong></p><p><strong>value.serializer</strong></p><p>与key.serializer一样,value.serializer指定的类会将值序列化。如果键和值都是字符串，可以使用与key.serializer一样的序列化器。否则就得使用不同的序列化器。</p><p>下面的代码中展示了如何创建一个生产者，这里只指定了必要的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.131.128:9092,192.168.131.130:9092,192.168.131.131:9092"</span>);</span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br></pre></td></tr></table></figure><p>我们的键值都定义为String对象，所以都是用的是内置的StringSerializer。</p><p>实例化生产者对象之后我们就可以发送消息了，发消息主要有一下3种方式：</p><ol><li><p>发送并忘记(fire-and-forget)</p><p> 我们把消息发送给服务器，但井不关心它是否正常到达。大多数情况下，消息会正常到达，因为Kafka 是高可用的，而且生产者会自动尝试重发。不过，使用这种方式有时候也会丢失一些消息。</p></li><li><p>同步发送</p><p> 我们使用send()方怯发送消息， 它会返回一个Future对象，调用get()方法进行等待，就可以知道消息是否发送成功。</p></li><li><p>异步发送</p><p> 我们调用send()方法并且指定一个回调函数，服务器在返回响应时调用该函数。</p></li></ol><p>上面我们已经创建了一个生产者实例，接下来就可以发送消息了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; data = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"page_visits"</span>,<span class="string">"test_key"</span>,<span class="string">"test_msg"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    producer.send(data);</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们构造了一个ProducerRecord对象用来封装topic，消息的key-value。然后用生产者实例的send方法将消息体发送出去。</p><h5 id="1-1-同步发送消息"><a href="#1-1-同步发送消息" class="headerlink" title="1.1 同步发送消息"></a>1.1 同步发送消息</h5><p>最简单的同步发送消息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; data = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"page_visits"</span>,<span class="string">"test_key"</span>,<span class="string">"test_msg"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    producer.send(data).get();</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即producer.send(data)返回的是一个Future对象，然后调用Future的get()方法僧带Kafka的响应。如果服务器返回错误，get()方法会抛异常。没有发生错误的话会得到一个RecordMetadata对象。可以用它来获取消息的偏移量。</p><h5 id="1-2-异步发送消息"><a href="#1-2-异步发送消息" class="headerlink" title="1.2 异步发送消息"></a>1.2 异步发送消息</h5><p>producer发送消息给broker，如果发送成功，会把目标主题，分区信息以及消息偏移量发送回来。但是发送端大多数时候并不关心这些，只在乎是否发送成功。有的时候对于发送是否成功的状态也不是那么的着急需要。在消息量比较大的时候，如果每一条消息都需要同步去确认发送状态很显然是会发生超时的，这个时候异步回调机制很好的帮我们解决了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; data = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"page_visits"</span>,<span class="string">"test_key"</span>,<span class="string">"test_msg"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    producer.send(data,<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"The offset of the record we just sent is: "</span> + metadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现回调需要实现org.apache.kafka.clients.producer.Callback接口，这个接口只有一个onCompletion方法。</p><p>上面我们简单实现了一个生产者，提供了一个基本实现，producer还有很多其余的配置可以灵活使用，下面我们来看一下其余的参数：</p><ul><li>acks ：acks参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有重要影响。该参数有如下选项：</li></ul><pre><code>1. acks=0 生产者在成功写入悄息之前不会等待任何来自服务器的响应。2. acks=1 只要集群的首领节点收到消息， 生产者就会收到一个来自服务器的成功响应。3. acks=all 只有当所有参与复制的节点全部收到消息时， 生产者才会收到一个来自服务器的成功响应。这种模式是最安全的，它可以保证不止一个服务器收到消息，就算有服务器发生崩溃，整个集群仍然可以运行,不过，它的延迟比acks=l 时更高，因为我们要等待不只一个服务器节点接收消息。</code></pre><ul><li>buffer.memory: 该参数用来设置生产者内存缓冲区的大小，生产者用它缓冲要发送到服务器的消息。如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足。</li><li>compression.type : 默认情况下，消息发送时不会被压缩。该参数可以设置为snappy，gzip或lz4，它指定了消息被发送给broker 之前使用哪一种压缩算陆进行压缩。</li><li>retries ： 生产者从服务器收到的错误有可能是临时性的错误（比如分区找不到首领）。在这种情况下，retries参数的值决定了生产者可以重发消息的次数，如果达到这个次数，生产者会放弃重试并返回错民。默认情况下，生产者会在每次重试之间等待lOOms，不过可以通过retry.backoff.ms参数来改变这个时间间隔。</li><li>batch.size : 当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算（而不是消息个数）。当批次被填满，批次里的所有消息会被发送出去。不过生产者井不一定都会等到批次被填满才发送，半满的批次，甚至只包含一个消息的批次也有可能被发送。</li><li>linger.ms : 该参数指定了生产者在发送批次之前等待更多消息加入批次的时间。KafkaProducer会在批次填满或linger.ms达到上限时把批次发送出去。默认情况下,只要有可用的线程，生产者就会把消息发送出去，就算批次里只有一个消息。把linger.ms设置成比0大的数，让生产者在发送批次之前等待一会儿，使更多的消息加入到这个批次。</li><li>partitioner.class :实现Partitioner接口的分区类 </li><li>max.block.ms : 这个配置控制着KafkaProducer.send() 和 KafkaProducer.partitionsFor()会阻塞多久。这个方法会因为缓冲区满了或是元数据不可用而被阻塞。在用户提供的 serializers 或 partitioner 里的阻塞将不会被计算在这个超时里。</li><li>client.id :     发送请求时传递给服务器的一个标识字符串。这样做的目的是能过追踪请求的来源除了除了IP/端口。它是通过允许一个逻辑应用名称被包括在一个服务器端的请求日志来实现的。</li></ul><h5 id="1-3分区和实现自定义分区策略"><a href="#1-3分区和实现自定义分区策略" class="headerlink" title="1.3分区和实现自定义分区策略"></a>1.3分区和实现自定义分区策略</h5><p>在前面的基本知识学习里面我们已经讲过kafka分区的问题，一个topic的消息会对应着一个或者多个partition。如果使用默认的分区器，那么记录将会被随机的发送到主题可用的各个分区上，分区器使用轮询算法均衡的分布到各个分区上。</p><p>kafka给用户提供了灵活的分区策略。如果你不想使用默认的均衡分布策略，而是有自己的逻辑需求，那么你可以自己控制。比如在一个topic下的消息分为两种：一种是用户信息增量更新的消息，一种是任职信息增量更新的消息。那么你可以使用自定义分区功能将两种消息分别散列在同一个topic的各个partition上。</p><p>实现自定义分区策略需要继承Partitioner接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.Cluster;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.PartitionInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePartitioner2</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String USER_INFO_KEY = <span class="string">"simple_user_info"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> partition = <span class="number">0</span>;</span><br><span class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">        <span class="keyword">if</span>(numPartitions != <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> partition;</span><br><span class="line">        &#125;</span><br><span class="line">        String stringKey = (String) key;</span><br><span class="line">        <span class="keyword">if</span>(stringKey.contains(USER_INFO_KEY))&#123;</span><br><span class="line">            partition =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们通过实现Partitioner的partition方法，对消息的key进行硬编码，确定key中是否包含某个标志来区分消息的类型进而确定该消息应该进入哪个分区。</p><h4 id="2-创建kafka消费者"><a href="#2-创建kafka消费者" class="headerlink" title="2. 创建kafka消费者"></a>2. 创建kafka消费者</h4><h5 id="2-1-消费者中的群组"><a href="#2-1-消费者中的群组" class="headerlink" title="2.1 消费者中的群组"></a>2.1 消费者中的群组</h5><p>熟悉JMS消息协议的应该知道，消息的消费应该有两种方式：一种是点对对的消息，一方发送，一方消费。一种是发布-订阅模式，一方发送，所有订阅方都可以消费。kafka也是遵循JMS消息规范的，所以这两种消息模式都是可以支持。但是支持的方式可能和我们想象的有些不一样！</p><p>kafka里面的消费者对应着一个<strong>消费者群组</strong>的概念。与别的消息中间件产品不同的是，每个消费者必须是属于某个消费者群组。一个群组里的消费者订阅的是同一个主题。我们通过kafka的”group.id”参数来配置消费者所属的群组。</p><p>如果你以为kafka的服务端收到一条推送的消息之后，订阅的群组里面所有消费者可以同时消费到这一条消息那你就错了。kafka对于同属一个群组的消费者的定义是：</p><ol><li>同一个分区的消息只能被某个群组中的某个消费者同时消费。</li><li>如果一个群组中的多个消费者订阅了同一个分区，那么只能有一个消费者可以同时获得这一条消息。</li><li>只有一个消费者的群组是可以同时监听到某个主题下的多个分区的。</li><li>同一个群组下的一个消费者可以指定监听多个分区，如果消费者数量和分区数量相等也可以指定1V1的监听模式。但是，如果消费者数量大于分区数量，那么必然会有消费者无法获得消息。</li></ol><p>由上我们得知：<strong>群组的概念并不是消费-订阅模式！</strong></p><p>我们需要严格保证同一个群组下的消费者数量必须小于等于所订阅的topic的分区数量。</p><p>如果存在消费者数量多于分区数量的情况，我们可以将消费者置于不同的分组中，然后再订阅该主题。kafka支持多个分组同时订阅。</p><p>关于具体的消费者的消费模式我们后面详细讨论，先来实现一个简单的消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"192.168.131.128:9092,192.168.131.130:9092,192.168.131.131:9092"</span>);</span><br><span class="line">props.put(ConsumerConfig.GROUP_ID_CONFIG ,<span class="string">"test"</span>) ;</span><br><span class="line">props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line">props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line"></span><br><span class="line">Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br></pre></td></tr></table></figure><p>消费者基本的配置和生产者差不多，我们看到第二个设置，指定了分组id。</p><p>然后需要指定要订阅哪一个topic，当然一个分组是可以订阅多个topic的，所以参数为List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"page_visits"</span>));</span><br></pre></td></tr></table></figure><p>参数也可以是正则匹配。</p><p>消息轮询是消费者API的核心，通过一个简单的轮询向服务器请求数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者必须不停地向kafka轮询，否则会被认为死亡。它的分区会被交给组里的其他消费者。poll()方法里面的参数是一个超时时间，用于设置该次请求的超时时间，如果参数被设置为0 ，请求会立即返回，否则请求会在指定的毫秒数内返回。</p><h5 id="2-2-消费者基本配置项"><a href="#2-2-消费者基本配置项" class="headerlink" title="2.2 消费者基本配置项"></a>2.2 消费者基本配置项</h5><p>消费者也有一些基本的配置项：</p><ul><li>fetch.min.bytes:该属性指定了消费者从服务器获取记录的最小字节数。</li><li>fetch.max.wait.ms:该属性指定了消费者从服务器获取记录的最大等待时间。该参数和fetch.min.bytes参数会互相克制。如果fetch.min.bytes没有得到满足，则会继续等待消息填充，但是如果到了fetch.max.wait.ms设置的时间，那么会直接返回。同理相反也是一样的。</li><li>max.partition.fetch.bytes:该属性指定了服务器从每个分区里返回给消费者的最大字节数。它的默认值是lMB。</li><li>session.timeout.ms:该属性指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是3s。如果消费者没有session.timeout.ms定的时间内发送心跳给群组协调器，就被认为已经死亡，协调器就会触发再均衡，把它的分区分配给群组里的其他消费者。该属性与heartbeat.interval.ms紧密相关heartbeat.interval.ms指定了poll()向服务器发送心跳的频率， session.timeout.ms则指定了消费者可以多久不用给服务器发送心跳。</li><li>auto.offset.reset:该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下（因消费者长时间失效，包含偏移量的记录已经过时井被删除）该作何处理。即指定该从何位置开始读取记录。</li><li>enable.auto.commit:该属性指定了消费者是否自动提交偏移量，默认值是true。为了尽量避免出现重复数据和数据丢失，可以把它为false，由自己控制何时提交偏移量。如果把它设为true ，还可以通过配置auto.commit.interval.ms属性来控制提交的频率。</li><li><p>partition.assignment.strategy:分区会被分配给群组里的消费者。PartitionAssignor根据给定的消费者和主题，决定哪些分区应该被分配给哪个消费者。Kafka有两个默认的分配策略:</p><ol><li><p>range</p><p> 该策略会把主题的若干个连续的分区分配给消费者。假设消费者Cl和消费者C2 同时订阅了主题Tl和主题口，井且每个主题有3 个分区。那么消费者Cl有可能分配到这两个主题的分区0和分区i，而消费者C2分配到这两个主题的分区2。因为每个主题拥有奇数个分区，而分配是在主题内独立完成的，第一个消费者最后分配到比第二个消费者更多的分区。只要使用了Range策略，而且分区数量无法被消费者数量整除，就会出现这种情况。</p></li></ol></li></ul><pre><code>1. RoundRobin    该策略把主题的所有分区逐个分配给消费者。如果使用RoundRobin策略来给消费者Cl和消费者C2分配分区，那么消费者Cl将分到主题Tl的分区0和分区2以及主题T2的分区1 ，消费者C2 将分配到主题Tl 的分区l 以及主题口的分区0 和分区2 。一般来说，如果所有消费者都订阅相同的主题（这种情况很常见）, RoundRobin策略会给所有消费者分配相同数量的分区（或最多就差一个分区）。    可以通过设置partition.assignment.strategy来选择分区策略.</code></pre><ul><li>client.id:该属性可以是任意字符串，broker用它来标识从客户端发送过来的消息，通常被用在日志、度量指标和配额里。</li></ul><p>主要的配置项如上，如果工作中还有别的需要可以去看官网的api查看。</p><p>客户端其实要说的东西还是挺多，下一节学习我们就来看关于自动提交、手动提交和偏移量的关系，又够喝一壶的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们已经搭建了kafka的单机和集群环境，分别写了简单的实例代码，对于代码里面使用到的参数并没有做解释。下面我们来详细说一下各个参数的作用。&lt;/p&gt;
&lt;h4 id=&quot;1-创建kafka生产者&quot;&gt;&lt;a href=&quot;#1-创建kafka生产者&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="kafka" scheme="https://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>kafka集群模式安装（2）</title>
    <link href="https://blog.rickiyang.cn/posts/a74a883e.html"/>
    <id>https://blog.rickiyang.cn/posts/a74a883e.html</id>
    <published>2018-04-07T12:23:15.000Z</published>
    <updated>2018-12-06T02:53:23.042Z</updated>
    
    <content type="html"><![CDATA[<p>我们来安装kafka的集群模式，三台机器：</p><pre><code>192.168.131.128192.168.131.130192.168.131.131</code></pre><p>kafka集群需要依赖zookeeper，所以需要先安装好zk。</p><p>下载kafka安装包：<br>kafka_2.11-1.1.0.tgz</p><p>解压到 /usr/local/下。</p><p>进入到kafka的config目录下：</p><p><img src="https://i.imgur.com/SXELOeW.jpg" alt=""></p><p>我们看到有zk的配置文件，这是kafka自带的zk，如果你没有安装zk，可以使用kafka集成的zk，配置方式和单独安装是一样的。</p><p>我们默认已经安装zk，所以修改server.properties文件，大致的配置项有这些：</p><pre><code>broker.id=0        #每个实例不一样listeners=PLAINTEXT://192.168.131.128:9092    #改为所在主机的ipadvertised.host.name=192.168.131.128　　　　 #改为改为所在主机的ipnum.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=/usr/local/kafka/log                                         #需手动创建，kafka并不会根据配置文件自动创建num.partitions=1num.recovery.threads.per.data.dir=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=192.168.131.128:2181,192.168.131.130:2181,192.168.131.131:2181 #修改为zookeeper所在主机ip:portzookeeper.connection.timeout.ms=6000delete.topic.enable=trueauto.create.topics.enable=false</code></pre><p>需要修改的地方已经标注出来了。</p><p>然后我们需要将kafka同步到另外两台机器上：</p><pre><code>scp -r kafka hadoop@hadoopslaver1:/usr/localscp -r kafka hadoop@hadoopslaver2:/usr/local</code></pre><p>下面我们准备启动，首先确保zk是启动的，如果没有安装可以使用kafka的zk：</p><pre><code>bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></pre><p>然后我们启动kafka：</p><pre><code>bin/kafka-server-start.sh -daemon config/server.properties &amp;</code></pre><p>三台机器上都要执行启动操作，如果偶没有报错就是启动成功了。</p><p>接下来我们可以做一些测试。</p><p>消费端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.Consumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.StringDeserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"192.168.131.128:9092,192.168.131.130:9092,192.168.131.131:9092"</span>);</span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG ,<span class="string">"test"</span>) ;</span><br><span class="line">        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"true"</span>);</span><br><span class="line">        props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="string">"1000"</span>);</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">"page_visits"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Callback;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> events = <span class="number">1</span>;</span><br><span class="line">        Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.131.128:9092,192.168.131.130:9092,192.168.131.131:9092"</span>);</span><br><span class="line">        props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">        props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line">        props.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line">        props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line">        props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        <span class="comment">//配置partitionner选择策略，可选配置</span></span><br><span class="line">        props.put(<span class="string">"partitioner.class"</span>, <span class="string">"com.rickiyang.service.Partitioner"</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> nEvents = <span class="number">0</span>; nEvents &lt; events; nEvents++) &#123;</span><br><span class="line">            <span class="keyword">long</span> runtime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">            String ip = <span class="string">"192.168.2."</span> + rnd.nextInt(<span class="number">255</span>);</span><br><span class="line">            String msg = runtime + <span class="string">",www.example.com,"</span> + ip;</span><br><span class="line">            ProducerRecord&lt;String, String&gt; data = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"page_visits"</span>, ip, msg);</span><br><span class="line">            producer.send(data,</span><br><span class="line">                    <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"The offset of the record we just sent is: "</span> + metadata.offset());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义分区策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.Cluster;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.PartitionInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Partitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> partition = <span class="number">0</span>;</span><br><span class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">        String stringKey = (String) key;</span><br><span class="line">        <span class="keyword">int</span> offset = stringKey.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            partition = Integer.parseInt( stringKey.substring(offset+<span class="number">1</span>)) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行一下：</p><p>Producer：</p><p><img src="https://i.imgur.com/hgj2Q3y.jpg" alt=""></p><p>Consumer</p><p><img src="https://i.imgur.com/uRKHgiy.jpg" alt=""></p><p>客户端可以接受到服务端的消息的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们来安装kafka的集群模式，三台机器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;192.168.131.128
192.168.131.130
192.168.131.131
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;kafka集群需要依赖zookeeper，所以需要先安装好zk。&lt;/p&gt;
      
    
    </summary>
    
      <category term="kafka" scheme="https://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>kafka基本知识入门（1）</title>
    <link href="https://blog.rickiyang.cn/posts/2ea97000.html"/>
    <id>https://blog.rickiyang.cn/posts/2ea97000.html</id>
    <published>2018-04-07T07:15:32.000Z</published>
    <updated>2018-12-06T02:53:23.041Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、-基础知识"><a href="#1、-基础知识" class="headerlink" title="1、 基础知识"></a>1、 基础知识</h4><p>有关RabbitMQ,RocketMQ,kafka的区别这个网上很多，了解一下区别性能，分清什么场景使用。分布式环境下的消息中间件Kafka做的比较不错，在分布式环境下使用频繁，我也不免其俗钻研一下Kafka的使用。</p><p>任何消息队列都遵循AMQP协议，AMQP协议(Advanced Message Queuing Protocol,高级消息队列协议）<br>AMQP是一个标准开放的应用层的消息中间件（Message Oriented Middleware）协议。AMQP定义了通过网络发送的字节流的数据格式。因此兼容性非常好，任何实现AMQP协议的程序都可以和与AMQP协议兼容的其他程序交互，可以很容易做到跨语言，跨平台。</p><p>Kafka是一个分布式的、可分区的、可复制的消息系统。它提供了普通消息系统的功能，但具有自己独特的设计。</p><p>我们先看一些基本的概念：</p><ol><li>消费者：（Consumer）：从消息队列中请求消息的客户端应用程序</li><li>生产者：（Producer） ：向broker发布消息的应用程序</li><li>AMQP服务端（broker）：用来接收生产者发送的消息并将这些消息路由给服务器中的队列，便于fafka将生产者发送的消息，动态的添加到磁盘并给每一条消息一个偏移量，所以对于kafka一个broker就是一个应用程序的实例</li><li>主题（Topic）：一个主题类似新闻中的体育、娱乐、教育等分类概念，在实际工程中通常一个业务一个主题。</li><li>分区（Partition）：一个Topic中的消息数据按照多个分区组织，分区是kafka消息队列组织的最小单位，一个分区可以看作是一个FIFO（ First Input First Output的缩写，先入先出队列）的队列。</li></ol><p>kafka将消息以topic为单位进行归纳，每个broker其实就是一个应用服务器，一个broker中会有很多的topic，每个topic其实就是不同的服务需要消息的消息的聚集地。因为每个topic其实会很大，所以就出现了partition个概念，将每个topic的消息分区存储。</p><p><img src="https://i.imgur.com/lFcOzFz.jpg" alt=""></p><p>kafka中的消费者有一个分组的概念，<strong>每个consumer属于一个consumer group;反过来说,每个group中可以有多个consumer.发送到Topic的消息,只会被订阅此Topic的每个group中的一个consumer消费（而不是该group下的所有consumer，一定要注意这点）</strong></p><ul><li>如果所有的consumer都具有相同的group,这种情况和queue模式很像;消息将会在consumers之间负载均衡.</li><li>如果所有的consumer都具有不同的group,那这就是”发布-订阅”;消息将会广播给所有的消费者.</li></ul><p>在kafka中,<strong>一个partition中的消息只会被group中的一个consumer消费</strong>;每个group中consumer消息消费互相独立;我们可以认为一个group是一个”订阅”者,一个Topic中的每个partions,只会被一个”订阅者”中的一个consumer消费,不过一个consumer可以消费多个partitions中的消息.</p><p>分布式环境中，Kafka默认使用zookeeper作为注册中心，kafka集群几乎不维护任何consumer和producer的信息状态，这些信息都由zookeeper保存，所以consumer和producer非常的轻量级，随时注册和离开都不会对Kafka造成震荡。</p><p><strong>producer和consumer通过zookeeper去发现topic，并且通过zookeeper来协调生产和消费的过程。</strong><br>producer、consumer和broker均采用TCP连接，通信基于NIO实现。Producer和consumer能自动检测broker的增加和减少。</p><p>上面图中没有说明partition的组成，partition物理上由多个<strong>segment</strong>组成，每一个segment 数据文件都有一个索引文件对应。每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做<strong>offset</strong>,用于partition唯一标识一条消息.</p><p>相比传统的消息系统，Kafka可以很好的保证有序性。</p><p>传统的队列在服务器上保存有序的消息，如果多个consumers同时从这个服务器消费消息，服务器就会以消息存储的顺序向consumer分发消息。虽然服务器按顺序发布消息，但是消息是被异步的分发到各consumer上，所以当消息到达时可能已经失去了原来的顺序，这意味着并发消费将导致顺序错乱。为了避免故障，这样的消息系统通常使用“专用consumer”的概念，其实就是只允许一个消费者消费消息，当然这就意味着失去了并发性。</p><p>在这方面Kafka做的更好，通过分区的概念，Kafka可以在多个consumer组并发的情况下提供较好的有序性和负载均衡。将每个分区分只分发给一个consumer组，这样一个分区就只被这个组的一个consumer消费，就可以顺序的消费这个分区的消息。因为有多个分区，依然可以在多个consumer组之间进行负载均衡。注意consumer组的数量不能多于分区的数量，也就是有多少分区就允许多少并发消费。</p><p>Kafka只能保证一个分区之内消息的有序性，在不同的分区之间是不可以的，这已经可以满足大部分应用的需求。如果需要topic中所有消息的有序性，那就只能让这个topic只有一个分区，当然也就只有一个consumer组消费它。</p><h5 id="1-1、-message-被分配到-partition-的过程"><a href="#1-1、-message-被分配到-partition-的过程" class="headerlink" title="1.1、 message 被分配到 partition 的过程"></a>1.1、 message 被分配到 partition 的过程</h5><p>每一条消息被发送到broker时，会根据paritition规则（有两种基本的策略，一是采用Key Hash算法，一是采用Round Robin算法）选择被存储到哪一个partition。如果partition规则设置的合理，所有消息可以均匀分布到不同的partition里，这样就实现了水平扩展。（如果一个topic对应一个文件，那这个文件所在的机器I/O将会成为这个topic的性能瓶颈，而partition解决了这个问题）。</p><p>在发送一条消息时，可以指定这条消息的key，producer根据这个key和partition机制来判断将这条消息发送到哪个parition。paritition机制可以通过指定producer的paritition.class这一参数来指定，该class必须实现kafka.producer.Partitioner接口。</p><h5 id="1-2、-segment文件存储结构"><a href="#1-2、-segment文件存储结构" class="headerlink" title="1.2、 segment文件存储结构"></a>1.2、 segment文件存储结构</h5><p>segment file由2大部分组成，分别为index file和data file，这两个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件。</p><p>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</p><p>文件类似于下面这种形式：</p><pre><code>0000000000000000001.index0000000000000000001.log0000000000000036581.index0000000000000036581.log0000000000000061905.index0000000000000061905.log</code></pre><p>index和data-file的对应关系如下：</p><p><img src="https://i.imgur.com/2Eg7VQH.png" alt=""></p><p>index file 存储索引文件，文件中的元数据指向对应数据文件中message的物理偏移地址。</p><h4 id="2、-Kafka单机环境搭建"><a href="#2、-Kafka单机环境搭建" class="headerlink" title="2、 Kafka单机环境搭建"></a>2、 Kafka单机环境搭建</h4><p>下载kafka，解压缩</p><p>配置环境变量：</p><pre><code>export KAFKA_HOME=/usr/local/kafka                                                                                                                                                                        export PATH=$PATH:$KAFKA_HOME/bin 重启生效source /etc/profile</code></pre><p>Kafka用到了zeekeeper，所以需要先启动zookeeper，没有安装的需要先安装zk，安装好了以后我们可以启动，我们先来实现单机版的kafka，先启动一个单单例的zk服务，可以在命令的结尾加个&amp;符号，这样就可以启动后离开控制台。</p><pre><code># bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></pre><p>再启动kafka：</p><pre><code># bin/kafka-server-start.sh config/server.properties</code></pre><p>创建topic：</p><pre><code># bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre><p>创建producer，可以在控制台手动输入消息：</p><pre><code># bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test this is a message</code></pre><p>ctrl+c 可以退出发送。</p><p>创建consumer：</p><pre><code># bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginningthis is a message会收到刚才的发送的消息</code></pre><p>我们的一个简单的单机环境就搭建好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、-基础知识&quot;&gt;&lt;a href=&quot;#1、-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、 基础知识&quot;&gt;&lt;/a&gt;1、 基础知识&lt;/h4&gt;&lt;p&gt;有关RabbitMQ,RocketMQ,kafka的区别这个网上很多，了解一下区别性能，分清什么场景
      
    
    </summary>
    
      <category term="kafka" scheme="https://blog.rickiyang.cn/categories/kafka/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>hive安装</title>
    <link href="https://blog.rickiyang.cn/posts/c40dabb2.html"/>
    <id>https://blog.rickiyang.cn/posts/c40dabb2.html</id>
    <published>2018-03-11T14:38:12.000Z</published>
    <updated>2018-12-06T02:53:23.041Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hive安装"><a href="#hive安装" class="headerlink" title="hive安装"></a>hive安装</h4><ol><li><p>下载hive，我下载的版本是：apache-hive-2.3.2-bin.tar.gz。解压文件：</p><pre><code>#tar -zxvf apache-hive-2.3.2-bin.tar.gz</code></pre></li><li><p>设置环境变量：</p></li></ol><pre><code>#vi /etc/profileexport HIVE_HOME=/usr/local/hiveexport PATH=$PATH:$HIVE_HOME/bin#source /etc/profile</code></pre><ol start="3"><li>Hive中metastore（元数据存储）的存储方式有三种：</li></ol><pre><code>- a)内嵌Derby方式- b)Local方式- c)Remote方式</code></pre><p>本次选择使用local方式，存储到当前机器的mysql中。没有安装mysql的需要先安装mysql。</p><p>另外，因为hive启动需要从元数据存储器中查找元数据并加载，所以需要将mysql的jar包放在hive安装包下的lib目录下。&lt;mysql-connector-java-5.1.38.jar&gt;下载放入即可。</p><ol start="4"><li>进入hive下的conf目录：将hive-default.xml.template 复制一份存为：<br>hive-site.xml；将hive-env.sh.template修改存为：hive-env.sh。<br>修改hive-site.xml中的内容：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive_remote/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.local<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost/hive_remote?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>password<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mysql的用户名和密码写自己的。另外还有两处需要修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.scratdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/hive/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">这个是设定临时文件目录</span><br><span class="line">--------------------------------------</span><br><span class="line">//这个在笔者的文件中没有可以自己添加</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.querylog.location<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/hive/log<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">这个是用于存放hive相关日志的目录</span><br></pre></td></tr></table></figure><p>如果不改启动的时候会报错的！</p><p>修改hive-env.sh，添加hadoop的路径：</p><pre><code>HADOOP_HOME=/usr/local/hadoop</code></pre><p>上面我们在hive-site.xml中配置了hive的元数据存放库，那么在mysql中也需要创建相应的库，我使用的用户名是hive如果你想使用root或者别的也是可以的：</p><pre><code>mysql&gt; create database hive_remote;mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;hive&apos;@&apos;%&apos; IDENTIFIED BY &apos;hive&apos;;       </code></pre><p>元数据库创建完毕，需要hive元数据库初始化，执行：</p><pre><code>schematool -dbType mysql -initSchema</code></pre><p>没有出错就是初始化完毕，有出错查看相关错误解决。接下来我们就可以启动hive试一下了，进入bin目录，输入：hive即可：</p><pre><code>[hadoop@hadoopmaster bin]$ hivewhich: no hbase in (/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/java/jdk/bin:/usr/java/jdk/jre/bin:/usr/local/hadoop/bin:/usr/local/hadoop/sbin:/usr/local/zookeeper/bin:/usr/local/hive/bin:/home/hadoop/bin)SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/usr/local/hive/lib/log4j-slf4j-impl-2.6.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/usr/local/hadoop/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Logging initialized using configuration in jar:file:/usr/local/hive/lib/hive-common-2.3.2.jar!/hive-log4j2.properties Async: trueHive-on-MR is deprecated in Hive 2 and may not be available in the future versions. Consider using a different execution engine (i.e. spark, tez) or using Hive 1.X releases.hive&gt; show tables;OKTime taken: 5.91 secondshive&gt; show databases;OKdefaultTime taken: 0.068 seconds, Fetched: 1 row(s)</code></pre><p>如上便是成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;hive安装&quot;&gt;&lt;a href=&quot;#hive安装&quot; class=&quot;headerlink&quot; title=&quot;hive安装&quot;&gt;&lt;/a&gt;hive安装&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载hive，我下载的版本是：apache-hive-2.3.2-bin.tar.gz。解
      
    
    </summary>
    
      <category term="大数据学习" scheme="https://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hive" scheme="https://blog.rickiyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/hive/"/>
    
    
      <category term="大数据" scheme="https://blog.rickiyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>git学习（2）</title>
    <link href="https://blog.rickiyang.cn/posts/eed666b7.html"/>
    <id>https://blog.rickiyang.cn/posts/eed666b7.html</id>
    <published>2017-12-16T09:07:12.000Z</published>
    <updated>2018-12-06T09:59:13.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git常用指令一览表"><a href="#git常用指令一览表" class="headerlink" title="git常用指令一览表"></a>git常用指令一览表</h3><table>    <thead>        <tr>            <td>GIT指令</td>            <td>说明</td>        </tr>    </thead>    <tbody>        <tr>            <td>git add .</td>            <td>将全部文件的内容加到Git索引以便执行commit. 这个指令不会检查文件夹中是否有文件被删除。                要注意的是，只有执行“ git add”时的文件内容会被加入Git 索引。如果后来又修改了文件，                新的文件内容不会在Git索引中。我们必须重新执行“ git add ”指令，才会更新Git索引。</td>        </tr>        <tr>            <td>git add 文件名 文件名 ...</td>            <td>将指定的文件的内容加到Git 索引，以便执行commit 操作。要注意的是，                只有执行“ git add”时，文件内容才会被加入Git 索引。如果后来又修改了文件，                新的文件内容不会在Git 索引中。我们必须重新执行“ git add ”指令，才会更新Git 索引。</td>        </tr>        <tr>            <td>git add -A </td>            <td>除了把全部文件的内容加到Git 索引以外，也会检查文件夹中是否有文件被删除。这些                被删除的文件会标记在Git 索引中，当执行commit 指令的时候，被标记删除的文件也会                从新的commit 节点中被删除。我们可以从Git 丈档库的历史版本中找回被删除的文件。</td>        </tr>        <tr>            <td>git add --update <br>或是<br> git add -u</td>            <td>对比当前文件夹中的文件内容和Git 文档库中的文件内容，把有修改的部分和删除的文                或是件加到Git 索引，以便执行commit 。这个指令不会增加新的文件到Git 索引，只会更新                或是删除文件。</td>        </tr>        <tr>            <td>git blame 文件名<br>            或者 <br>git blame -L 起始行，结束行文件名<br>            或者 <br>git blame -L 起始行，文件名<br>            或者<br> git blame -L 结束行，文件名</td>            <td>显示文件的每一行是由谁修改。可以搭配“－L”选项，指定要从哪一行开始到哪一行                或是结束。如果没有指定起始行，表示是从文件的第一行开始。如果没有指定结束行，                表示要到文件的最后一行。</td>        </tr>        <tr>            <td>git branch 自己取的分支名称<br>[commit 节点标识符或是标签]</td>            <td>按照参数的多少，会有不同的功能：<br>                1. 如果最后指定了commit 节点标识符或是标签，就会从该节点“长”出分支；如果没                有指定commit 节点，就会从最新的commit“长”出分支;<br>                2 “ git branch”指令后面没有接任何参数时，会列出当前文档库中正在开发的所有分支。</td>        </tr>        <tr>            <td>git branch 新分支的名称己经存在的分支</td>            <td>从特定的分支，再长出另一个新的分支。</td>        </tr>        <tr>            <td>git branch -a</td>            <td>列出丈档库和远程文档库中所有的分支。</td>        </tr>        <tr>            <td>git branch -d 要删除的分支名称</td>            <td>删除指定的分支。必须先切换到另一个分支,才能执行这个指令。</td>        </tr>        <tr>            <td>git branch -D 要删除的分支名称</td>            <td>在一般情况下，分支应该先合并到另一个分支，之后才能够被删除。如果我们要删除还                没有合并的分支， Git 会显示错误信息，并且停止删除分支的操作。如果确定要删除还                没有合并的分支，可以使用“－D ”选项，要求Git 强制执行删除分支的操作。</td>        </tr>        <tr>            <td>git branch --list 分支名称样板</td>            <td>显示符合“分支名称样板”的所有分支，例如以下指令范例会显示所有以“ bug/”开头                的分支：git branch --list bug/*</td>        </tr>        <tr>            <td>git branch -m 新的分支名称</td>            <td>更改分支的名称。必须先切换到该分支，才能够执行这个指令。</td>        </tr>        <tr>            <td>git checkout 文件1 文件2 ... <br>                或是<br> git checkout .</td>            <td>Git 会先找索引中有没有该文件，如果有就把它取出：如果没有，就从最新的commit                节点开始，按照时间顺序往前寻找，然后取出第一个找到的文件版本，每一个文件都用                同样的方式处理。如果要取出文档库中全部文件的最新版本，可以执行“ git checkout .”’</td>        </tr>        <tr>            <td>git checkout commit 节点标识符或标签[文件1 文件2..]</td>            <td>从Git 文档库的commit 节点取出指定的文件。如果取出的文件和当前文档库中最新                commit 的文件内容不同，这个取出的文件内容会自动记录在Git 索引中。下次执行"git commit"                指令时，这个取出的文件内容就会存入文档库中成为新的版本。如果要避免这                种情况发生，可以在执行“git checkout"指令之后，立刻执行“ git reset HEAD ”来清除                Git 索引。</td>        </tr>        <tr>            <td>git checkout 分支名称</td>            <td>将当前操作的分支切换到指定的分支。</td>        </tr>        <tr>            <td>git checkout -f 分支名称</td>            <td>在切换分支的时候， Git 会先对比丈档库中当前分支的文件内容是否和将要切换过去的                分支的文件内容相同。针对内容不一样的文件， Git 需要从文档库中取出该文件，这是                为了让文件夹中的文件符合分支原来的状态。但是为了避免数据遗失，当Git 要覆盖                文件夹中的文件时，会检查该文件的内容是否已经加入文档库。如果还没有加入， Git                会显示警告信息，并且停止执行，以免资料遗失。如果我们确定不想保留这些已经修改                却还没有加入文档库的文件，可以加入“－f”选项，这样Git 就会强制覆盖修改后的文件。            </td>        </tr>        <tr>            <td>git checkout -b 新分支的名称[commit 节点标识符或是标签]</td>            <td>创建指定的分支，然后切换到新创建的分支。这个指令等同于先执行“ git branch 新分支的                名称commit 节点标识符或是标签” ， 接着再执行“ git checkout 新分支的名称”。如果最                后指定了commit 节点标识符或是标签，就会从该节点“长”出分支。如果没有指定commit                节点，就会从最新的commit “ 长”出分支。</td>        </tr>        <tr>            <td>git cherry-pick -n commit 节点标识或标签</td>            <td>把指定的commit节点的文件版本合并到文件夹中的文件。在默认情况下                ，执行这个指令会创建一个新的commit 节点。如果不想要创建新节                或标签点， 则可以加上"－n"选项。执行这个指令之前，                文件夹中被修改的文件必须先存入Git 文档库，否则会出现警告信息，并且停止执行。</td>        </tr>        <tr>            <td>git clone “远程Git 文档库”的路径</td>            <td>从“远程Git 文档库”复制一个“本地Git或是文档库”到我们的计算机。                第一种方式适用的情况是“远程Git 文档库”在我们自己的计算机上。                </td>        </tr>        <tr>            <td>git clone --bare[程序项目文件夹名称][“远程Git文档库”的路径]</td>            <td>从“本地Git 文档库”复制出Bare 类型的“远程Git 文档库"            我们通常会帮Bare类型的文档库加上扩展名".git"，例如game.git。            </td>        </tr>        <tr>            <td>git commit -m ‘这次操作的说明’ [--author=‘操作者姓名 [email 邮箱]’]</td>            <td>把当前Git 索引的内容送进文档库存储。每一次执行commit 一定要附加说明和操作者                信息。如果没有使用“－m ” 选项， Git 会启动文字编辑程序让我们输入操作说明。默认                的文字编辑程序是vi ，我们可以使用“ git config ”指令设置其他的文字编辑程序，详                细操作方式请参考第2 单元的说明。除了使用“--author”选项输入操作者信息以                外，也可以把操作者的信息记录在Git 配置文件中， 这样就不用加上“--author” 选项.                </td>        </tr>        <tr>            <td>git commit -a -m ‘这次操作的说明’[--author=‘操作者姓名[email 邮箱]’]            或是  git commit --all -m ‘这次操作的说明’[--author=‘操作者姓名[email 邮箱]’]</td>            <td>这个指令的效果等同于先执行“git add -u"再执行“ git commit -m ‘这次操作的说明’                --author=‘操作者姓名[email 邮箱]’”。首先对比当前文件夹中的文件内容和Git 文                档库中的文件内容，把有修改的部分和删除的文件加到Git 索引，然后执行commit。这                个指令不会把新的文件加到Git 文档库。</td>        </tr>        <tr>            <td>git commit --amend -m ‘新的操作说明’--author=‘操作者姓名[email 邮箱]’)</td>            <td>修改最近一次commit 节点的操作说明，或是操作者信息</td>        </tr>        <tr>            <td>git config -l 或者                git config --global -l            或者 git config --system -l</td>            <td>只有使用“ －l”选项时会显示三个不同层级的配置文件中所有的设置项。低优先权配置                文件的设置项会先显示，最高优先权配置文件的设置项显示在最后。<br>                加入“--global ” 选顶时会显示优先权配置文件中的设置项，也就是登录账号的home                或是directory 里面的.gitconfig 文件中的设置。<br>                加入“--system ”选项时会报示最低优先权配置文件中的设置顶，也就是Git程序安装文                件夹里面的etc\gitconfig 文件夹的设置。</td>        </tr>        <tr>            <td>git config 设置项名称‘设置值’<br>            或者<br> git config --global 设置项名称‘设置值’<br>            或者<br> git config --system 设置项名称‘设置值‘</td>            <td>在Git 配置文件中加入或是修改设置。如果“设置值”中没有空格，可以省略单引号。                如果没有使用任何选项，表示要将设置项写到当前操作中的Git文档库中的配置文件。                如果加入“--global ”选项，表示要将设置项写到登录账号的home directory 里面                的.gitconfig 配置文件中．如果加入“--system”选项，表示要将设置项                写到Git 程序安装文件夹里面的etc\gitconfig配置文件中。            </td>        </tr>        <tr>            <td>Git diff 文件名</td>            <td>判断该文件是否发成冲突或者解决冲突是否成功</td>        </tr>        <tr>            <td>Git fetch            或者 git fetch --all</td>            <td>从“远程Git 文档库”取回当前所在分支的最新数据。完成这项工作之后，我们计算机                上的“远程Git 文档库”的当前分支状态就和实际的情况一致。如果想要一次获取全部                分支最新的数据，可以加上“－all ”选项。</td>        </tr>        <tr>            <td>Git init</td>            <td>在当前的文件夹创建一个Git 文档库。如果这个文件夹己经有Git 文档库，这个指令就                不会再重新创建，也不会修改其中的内容。Git 文档库其实是名称叫作“ .git ”的子文件                夹，默认它会被隐藏起来，我们可以改变文件夹的查看选项让它显示出来。如果删除这                个子文件夹， Git 文档库的内容就会全部消失。            </td>        </tr>        <tr>            <td>Git init -bare Git 文档库文件夹名称</td>            <td>创建Bare 类型的Git 文档库。我们通常会帮Bare 类型的Git 文档库加上扩展名“ .git ”，                例如game.git 。</td>        </tr>        <tr>            <td>git log</td>            <td>按照时间顺序，从最近一次的commit 开始，往前列出每一次commit 的信息，包括标识                符、执行人、日期利时间以及说明。</td>        </tr>        <tr>            <td>Git log -after=’公元年－月－日 时间’[--before＝’公元年－月－日 时间’]</td>            <td>指定要显示某一段时间期间的commit 的信息。“ after＂可以换成“-since ”，“--before ”                可以换成“-until"。</td>        </tr>        <tr>            <td>Git log -author=‘人名’</td>            <td>只显示特定人的commit 节点信息。</td>        </tr>        <tr>            <td>git log --graph --online --all --decorate</td>            <td>加上“--graph ” 选项会用文本模式排列出commit 节点的演进图<br>．加上’--oneline ”选                项会用最精简的方式显示．<br>加上“ --all ”选项会显示所有分支的commit信息。<br>                加上“--decorate ” 选项表示要标示分支的名称。            </td>        </tr>        <tr>            <td>git log --stat<br>            或者<br> git log --shortstat<br>            或者 <br>git log --numstat</td>            <td>显示每一个commit 更改程序代码和文件的情况，包括有多少文件被修改了、                增加了几行程序代码和删除了几行程序代码。</td>        </tr>        <tr>            <td>git ls-file</td>            <td>列出当前Git 文档库中的文件列表。</td>        </tr>        <tr>            <td>git ls-remote</td>            <td>列出“本地Git 文档库”对应的所有“远程Git 文档库”</td>        </tr>        <tr>            <td>git merge 分支名称</td>            <td>把指定的分支合并到当前所在的分支。</td>        </tr>        <tr>            <td>git merge --abort</td>            <td>合并的过程发生冲突之后，执行这个指令可以放弃合并。Git 文档库和文件夫中的文件                内容都会恢复到未执行合并前的状态。</td>        </tr>        <tr>            <td>git merge --no-ff 分支名称</td>            <td>“--no-ff”逃项表示不要使用fast-forward merge 。</td>        </tr>        <tr>            <td>git mv 原来的文件名 新文件名</td>            <td>更改文件夹巾的文件名，或是子文件夹名称，然后把它记录在Git 索引。接着只要执行                “git commit"指令，就可以将更改存入文档库。</td>        </tr>        <tr>            <td>git pull<br>            或者 <br>git pull -all</td>            <td>"git pull"指令会执行两项工作：<br>                1. 从“远程Git 文档库”取回当前所在分支的最新数据。完成这项工作之后，计算机                上的“远程Git 文档库”的当前分支状态就和实际的情况一致。如果想要一次获取全部                分支最新的数据，可以加上“--all ”选项。<br>2. 把“远程Git 文档库”的分支合并到“本                地Git 文档库”的分支。</td>        </tr>        <tr>            <td>git pull --rebase<br>            或者<br> git pull -r</td>            <td>把“ git pull ＂指令的第二个步骤换成“ git rebase” （原来是“ git merge" ）。</td>        </tr>        <tr>            <td>git push</td>            <td>执行这个指令时，屏幕画面会显示一段信息，提示我们需要在Git 的配置文件中如入                push.default 的设置。我们可以执行下列指令，指定push.default 为matching:                <br>git config --global push.default matching<br>                这样的话，如果只下达"git push"指令，后面没有加上任何参数， Git 会                把“本地Git文档库”中所有曾经传送给“远程Git 文档库”的分支，都一并更新.                或者，可以执行下列指令，指定push.default 为simple:                <br>git config --global push.default simple<br>                这样的话，如果只下达“ git push ”指令，后面没有加上任何参数。Git 会检查当前所在                的分支是否在配置文件中记录了它对应的“远程Git 文档库”的分支。如果有，就会                传送更新给“远程Git 文档库”。否则，就不会执行更新。和matching 的设置相比之下，                simple 是比较安全的做法。因为它只会更新当前所在的分支，不会一次更新全部的分支。            </td>        </tr>        <tr>            <td>git push origin 分支名称</td>            <td>把指定分支的最新状态送到origin 属性所对应的“远程Git 文档库”。执行这个指令不                会在配置文件中记录“本地Git 文档库”的分支和“远程Git 文档库”的分支之间的对                应关系．</td>        </tr>        <tr>            <td>git push “远程Git 文档库”的url 分支名称</td>            <td>把指定分支的最新状态送到指定的“远程Git文档库”。执行这个指令不会在配置文件中                记录“本地Git 文档库”的分支和“远程Git文档库”的分支之间的对应关系。</td>        </tr>        <tr>            <td>git push --all</td>            <td>把“本地Git 文档库”中所有的分支传送到“远程Git 文档库”。</td>        </tr>        <tr>            <td>git push “远程Git 文档库”的名称 --delete[分支名称]</td>            <td>删除“远程Git 文档库”中的指定分支。</td>        </tr>        <tr>            <td>git rebase 分支名称</td>            <td>把指定分支的修改运用到当前的分支。当前分支会变成从指定的分支的HEAD 节点长                出来。</td>        </tr>        <tr>            <td>git rebase --abort</td>            <td>如果执行rebase 指令后出现冲突的情况，可以使用这个指令取消rebase 的操作。                Git 文档库会恢复到还没有执行rebase 之前的状态。            </td>        </tr>        <tr>            <td>git rebase --continue</td>            <td>执行rebase 指令后出现冲突的情况，而且我们己经编辑好发生冲突的文件，                接着就可以执行“git add”指令， 把新的文件内容加入Git 索引，                最后再执行这个指令，完成rebase的操作。            </td>        </tr>        <tr>            <td>git reflog HEAD 或是任何分支的名称</td>            <td>显示HEAD 或是任何分支变动的历史记录。如果不加任何参数，默认会列出HEAD 变动                的历史记录。</td>        </tr>        <tr>            <td>git remote -v</td>            <td>显示和“远程Git 文档库”相关的设置。</td>        </tr>        <tr>            <td>git remote add [“远程Git 文档库”的名称] [“远程Git 文档库”的url]</td>            <td>在“本地Git 文档库”的配置文件中加入指定的“远程Git 文档库”名称， 并且设置它                的url</td>        </tr>        <tr>            <td>git remote rm “远程Git 文档库”的名称<br>            或者 <br>git remote remove “远程Git 文档库”的名称</td>            <td>删除“本地Git 文档序”的配置文件指定的“远程Git 文挡库”名称。                一旦删除“远程Git 文档库”的名称，所有属于它的追踪                分支也会一并消失。如果要再还原回来，只要再执行"git remote add"指令                和“ git remote update"指令即可。</td>        </tr>        <tr>            <td>git remote rename 旧名称 新名称</td>            <td>改变“远程Git 文档库”的名称。改变“远程Git 文档库”的名称之后，                和它相关的远程追踪分支的名称也会自动更新。</td>        </tr>        <tr>            <td>git reset HEAD 文件名</td>            <td>将指定文件的内容从Git 索引中删除。如果没有加上文件名，则会清除                Git 索引中所有的内容。</td>        </tr>        <tr>            <td>git reset --soft commit 节点标识符或是标签<br>            或者<br> git reset --mixed commit 节点标识符或是标签<br>            或者<br> git reset --hard commit 节点标识符或是标签</td>            <td>将Git 文档库“消磁”，让Git 文挡库恢复到某一个commit 节点的状态，                如果使用“--soft ＂选项，表示只有文档库中的数据会更改，                Git 索引和文件夹中的文件都不会受到影响。如果使用“--mixed ”选项（这是默                认的选项），表示Git 索引也会恢复到指定节点的状态，但是文件夹中的文件仍然不会                受到影响。如果使用“--hard ” 选项，则文档库、Git索引和文件夹中的文件都会恢复到                指定节点的状态。</td>        </tr>        <tr>            <td>git revert commit 节点</td>            <td>回到指定的commit 节点的前一个节点的文件状态。执行完毕后会新增一个commit 节                点。请注意和“ git reset ”指令的差别。</td>        </tr>        <tr>            <td>git revert --abort</td>            <td>如果执行“git revert”指令的时候发生冲突，可以执行这个指令取消revert 的操作。</td>        </tr>        <tr>            <td>git rm 文件名</td>            <td>Git 会执行两项检查：<br>Git 索引中有没有该文件的内容（也就是                刚刚有没有执行过“git add 文件名”），如果有，表示这个文件的内容和文档库中的不                一样，为了避免遗失数据， Git 会显示提醒信息，然后放弃执行：<br>                2. 文件夹中的文件内容是不是和文档库中的一样，如果不一样， Git 同样会显示提醒                信息，然后放弃执行，以免遗失数据。如果通过以上两项检查， Git 会马上删除文                件夹中的文件，然后在索引中记录要从文档库中删除该文件。最后必须再执行"git                commit"指令才会真正从文档库中删除文件。</td>        </tr>        <tr>            <td>git rm --cached 文件名</td>            <td>把指定的文件从tracked 状态变成untracked状态，也就是说从此以后不需要在文档库中                更新这个文件， 而且Git 索引中这个文件的内容也会被删除，但是Git 不会从文件夹中                删除这个文件(这是加上"--cached”选项最大的差别)。</td>        </tr>        <tr>            <td>git shortlog</td>            <td>按照人名的字母顺序，列出每－个人执行commit 的次数和说明。                加上“--numbered ”选项（或是“ －n " ）可以按照commit 次数，由高至低按序排列。                如果不需要显示commit 说明，可以加上"--summary ＂选项（或是“－s ”）。</td>        </tr>        <tr>            <td>git show commit 节点标识符或是标签</td>            <td>显示特定commit 节点的详细信息。commit节点标识符是一组很长的16 进制数字，指                定commit 节点标识符时，不需要将它完整列出。一般只要使用最前面4 个数字即可，                Git 会向动找出对应的节点。如果找到超过一个以上的节点， Git 会显示错误信息，                这时候换长一点的数字就可以解决。</td>        </tr>        <tr>            <td>git show 文件名</td>            <td>显示指定文件最新版本的修改情况。也就是比较文件最新版本和前一个版本的差异。</td>        </tr>        <tr>            <td>git stash list</td>            <td>显示Git 暂存区的状态。</td>        </tr>        <tr>            <td>git stash pop 或者                git stash apply</td>            <td>取出暂存区的文件，将它们的内容合并到当前文件夹中的文件。</td>        </tr>        <tr>            <td>git stash save</td>            <td>这个指令会执行下列两项工作：                存储文件夹中被Git 追踪的文件和文档库中最新文件版本的差异：                把文件夹中被Git 追踪的文件还原成文档库中最新的文件版本。            </td>        </tr>        <tr>            <td>git status</td>            <td>这个指令会执行以下3 项工作：<br>                ]. 检查Git 索引的内容，看看是否需要执行commit 存入文档库。<br>                2. 对比文件夹中的文件和文档库中的文件，列出修改过的文件列表。<br>                3. 列出untracked 状态的文件。</td>        </tr>        <tr>            <td>git tag 自定义的标签名称[commit 节点标识符或是标签]</td>            <td>指定的commit 节点贴上自定义的标签，之后就可以用这个自定义的标签来指定这个                commit 节点。</td>        </tr>        <tr>            <td>git tag -d commit 节点标签</td>            <td>删除自定义的commit 节点标签。</td>        </tr>        <tr>            <td>gitk --all</td>            <td>启动图形操作模式，如果加入“--all ”选项，表示要显示全部的分支，否则只会显示当前                操作中的分支。</td>        </tr>    </tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;git常用指令一览表&quot;&gt;&lt;a href=&quot;#git常用指令一览表&quot; class=&quot;headerlink&quot; title=&quot;git常用指令一览表&quot;&gt;&lt;/a&gt;git常用指令一览表&lt;/h3&gt;
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
       
      
    
    </summary>
    
      <category term="git" scheme="https://blog.rickiyang.cn/categories/git/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>git学习（1）</title>
    <link href="https://blog.rickiyang.cn/posts/fc63c959.html"/>
    <id>https://blog.rickiyang.cn/posts/fc63c959.html</id>
    <published>2017-11-29T14:15:23.000Z</published>
    <updated>2018-12-06T02:53:23.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-git配置文件"><a href="#1-git配置文件" class="headerlink" title="1 git配置文件"></a>1 git配置文件</h3><h4 id="1-1-git权限控制"><a href="#1-1-git权限控制" class="headerlink" title="1.1 git权限控制"></a>1.1 git权限控制</h4><p>git有三个不同的权限控制文件，高优先权的设置会覆盖低优先权的设置项，以下按照优先权从高到低介绍：</p><ol><li>文件夹中”.git” 子文件夹中的confiig文件，这个配置具有最高优先权，<font color="#DC143C" size="3">但是这个配置文件只对他所在的文档有效。</font></li><li>登录账的home directory中的.gitconfig文件。这个配置文件只对此登陆账号有效。</li><li>git程序按照目录中的etc/gitconfig文件。</li></ol><p>只有在前两个配置文件中没有设置的项这个配置传文件才会生效。这是公用的配置传文件，它对所有登录账号和所有git文档库都有效。</p><h4 id="1-2-git-config-指令的用法"><a href="#1-2-git-config-指令的用法" class="headerlink" title="1.2 git config 指令的用法"></a>1.2 git config 指令的用法</h4><p>要显示当前git的设置可以执行下面的指令：</p><pre><code>gitconfig -l</code></pre><p>这个指令会显示三个配置文件中的所有设置项。他的顺序是先显示优先权最低的设置然后再显示高的。</p><p>当然我们也可以设置指定显示单一配置文件的内容：</p><pre><code>git config --system -l #显示git安装目录中的etc/gitconfig的设置git config --global -l #显示登录账号 home directory 中的.gitconfig文件的配置</code></pre><p>我们可以在配置文件中增加配置项，比如在执行”git commit” 的时候会提示你输入操作者的姓名和email，我们可以通过配置文件来设置以后就不用再输入，如果要记录在文档库中的配置文件，可以使用如下命令：</p><pre><code>git config user.name &apos;your name&apos;git config user.email &apos;your email&apos;</code></pre><p>如果要记录在登录账号的home directory中的.gitconfig文件内可以使用如下指令：</p><pre><code>git config --global user.name &apos;your name&apos;git config --global user.email &apos;your email&apos;</code></pre><p>如果要记录在git安装目录etc/gitconfig内可以执行如下指令：</p><pre><code>git config --system user.name &apos;your name&apos;git config --system user.email &apos;your email&apos;</code></pre><p>如果要删除配置传文件中的配置项可以使用“–unset”命令:</p><pre><code>git config --unset user.name</code></pre><p>如果要删除的是其他配置文件中的设置项，则视情况加入”–global”或者”system”选项。</p><font face="微软雅黑" color="#D2691E" size="5">补充说明：git指令的长和短</font><font color="#778899" size="4"><em>我们会发现有的指令使用一个连字符比如：”-m”有的却是两个，比如：”–author”，这是为啥呢。<br>其实使用一个连字符是简单表达形式的意思。我们也可以把它换成完整形式。比如”git commit -m    ‘comment’”的完整形式是”git commit –message=’comment’”。”git config –list”的完整形式是”git config –list”。</em></font><h3 id="2-把git文件存入仓库"><a href="#2-把git文件存入仓库" class="headerlink" title="2 把git文件存入仓库"></a>2 把git文件存入仓库</h3><h4 id="2-1-排除不需要加入文档库的文件"><a href="#2-1-排除不需要加入文档库的文件" class="headerlink" title="2.1 排除不需要加入文档库的文件"></a>2.1 排除不需要加入文档库的文件</h4><p>我们在上传文件到git仓库的时候并不能保证所有上传的文件都是我们需要的，比如编译器编译的文件以及一些资源文件，那么如何保证不把这些文件上传到git仓库呢。git为我们提供了一个文件:.gitignore。我们把需要忽略的文件一一列在这里即可。</p><p>比如我们不想上传.txt为结尾的文件到仓库，那么在.gitignore文件中写入”.txt”即可。.gitignore文件可以使用“#”表示注释，文件夹路径使用“/”，文件名可以使用通配符”*”。使用”!”表示排除。比如以下设置表示排除所有txt文件但是不包含note.txt 文件。</p><pre><code>*.txt!note.txt</code></pre><h4 id="2-2-控制commit"><a href="#2-2-控制commit" class="headerlink" title="2.2 控制commit"></a>2.2 控制commit</h4><p>我们知道在本地仓库修改完文件之后提交仓库有两个步骤：</p><pre><code>git add #提交修改文件到git索引git commit #从本地git索引推到git仓库</code></pre><p>但是如果我们在执行git add之后反悔了怎么办呢。这时候我们的分两种情况采取以下操作：</p><ol><li><p>文档库中还没有任何文件，即执行”git init”之后没有执行过”git commit”：</p><p> <code>使用git rm --cached 文件名</code></p></li></ol><ol><li><p>文档库中已经有文件，即我们已经执行过”git commit”命令：</p><p>   <code>git reset HEAD 文件名</code></p></li></ol><h4 id="2-3-查看commit节点"><a href="#2-3-查看commit节点" class="headerlink" title="2.3 查看commit节点"></a>2.3 查看commit节点</h4><pre><code>git #启动图形查看模式</code></pre><p><img src="https://i.imgur.com/0IdVPfL.jpg" alt=""></p><p>除了使用gitk查看commit节点信息，也可以使用”git log”命令达到同样目的。如果再加上”–graph”选项，会使用文本模式排列出commit节点的演进图。</p><p>显示最近一次代码提交记录：</p><pre><code>git show head</code></pre><h3 id="3-比较文件的差异和从git文档库取回文件"><a href="#3-比较文件的差异和从git文档库取回文件" class="headerlink" title="3 比较文件的差异和从git文档库取回文件"></a>3 比较文件的差异和从git文档库取回文件</h3><h4 id="3-1-取出指定文件"><a href="#3-1-取出指定文件" class="headerlink" title="3.1 取出指定文件"></a>3.1 取出指定文件</h4><pre><code>git checkout commit 节点标识符或标签 文件名1 文件名2 #从文档库的任何一个节点取出指定文件</code></pre><font color="#A52A2A" size="5">Tips：</font><font color="#A52A2A" size="4">文件夹中的文件会被取出的文件覆盖</font><p><strong>注意：</strong></p><p>如果执行 git checkout 的文件与当前库中最新commit的文件内容不同，那么这个文件会自动记录在git索引中。稍后如果我们执行了git commit命令，那么这个取出的文件会成为新的版本被存入仓库中。为了避免这种情况的发生我们在执行git checkout之后立刻执行”git reset head”命令清除git索引。</p><h4 id="3-2-使用git-mv命令改变文件或文件夹名字"><a href="#3-2-使用git-mv命令改变文件或文件夹名字" class="headerlink" title="3.2 使用git mv命令改变文件或文件夹名字"></a>3.2 使用git mv命令改变文件或文件夹名字</h4><pre><code>git mv 原来的文件名 新文件名</code></pre><h3 id="4-获取git文档库的统计数据"><a href="#4-获取git文档库的统计数据" class="headerlink" title="4 获取git文档库的统计数据"></a>4 获取git文档库的统计数据</h3><h4 id="4-1-git-log-指令"><a href="#4-1-git-log-指令" class="headerlink" title="4.1 git log 指令"></a>4.1 git log 指令</h4><p>这个指令会按照时间顺序从最近一次的commit接单开始往前列出每一次commit的数据，包括标识符、执行人、日期以及说明。该指令后面可以接参数，比如：–author=’A’,即只列出提交人为A的提交记录。</p><pre><code>指定显示某位提交者的提交信息：git log --author=&apos;A&apos;指定显示某一段时间内的提交信息：$ git log --after=&apos;2017-10-01 00:00:00&apos; --before=&apos;2017-11-01 00:00:00&apos;after表示指定的日期之后，before表示指定的日期之前，注意使用方式！</code></pre><p><img src="https://i.imgur.com/BTccOtX.jpg" alt=""></p><p>以上指令只会显示指定日期期间的commit，如果加上”–stat”,或者”–numstat”或者”–shortstat”还可以显示每一个commit变更的情况。</p><p>比如我们执行：</p><pre><code>git log shortstat</code></pre><p><img src="https://i.imgur.com/tpcjfwr.jpg" alt=""></p><p>可以看到会显示该次提交变更的基本信息。</p><p><strong>Tips：</strong></p><p>如果git指令显示的信息炒过了屏幕大小，屏幕会自动暂停，这时候可以使用如下按键继续操作：</p><ol><li>按键 j 表示显示下一行；</li><li>空格表示显示下一页；</li><li>按键 h 表示显示操作说明；</li><li>按键 q 表示结束。</li></ol><h4 id="4-2-git-shortlog指令"><a href="#4-2-git-shortlog指令" class="headerlink" title="4.2 git shortlog指令"></a>4.2 git shortlog指令</h4><p>这个指令会按照名字的字母顺序，列出每一个人执行commit的次数和说明。</p><p><img src="https://i.imgur.com/EaE6rdB.jpg" alt=""></p><p>我们也可以按照commit的次数从高到低排列，只要加上”–commit”或者是使用缩写：”-n” 即可。如果不需要显示commit说明可以再加上”–summary”或者是使用缩写:”-s”。</p><p>git shortlog -n -s</p><p><img src="https://i.imgur.com/uFP0d8p.jpg" alt=""></p><h4 id="4-3-git-ls-files-指令"><a href="#4-3-git-ls-files-指令" class="headerlink" title="4.3 git ls-files 指令"></a>4.3 git ls-files 指令</h4><p>这个指令会列出当前git文档库中的文件列表：</p><p><img src="https://i.imgur.com/l5mshTr.jpg" alt=""></p><p>我们也可以搭配”xargs”和”wc”这两个指令来计算程序中的代码行数：</p><pre><code>git ls-files | xargs wc -l</code></pre><p><img src="https://i.imgur.com/yivp80J.jpg" alt=""></p><p>前面的数字就是该文件中的代码行数，如果你要计算行数总和可以使用如下指令：</p><pre><code>git ls-files | xargs cat | wc -l</code></pre><h3 id="5-建立分支和解决冲突"><a href="#5-建立分支和解决冲突" class="headerlink" title="5 建立分支和解决冲突"></a>5 建立分支和解决冲突</h3><h4 id="5-1-创立分支"><a href="#5-1-创立分支" class="headerlink" title="5.1 创立分支"></a>5.1 创立分支</h4><p>创立分支使用git branch 指令：</p><pre><code>git branch &lt;new branch name&gt; commit &lt;节点标识符或者是标签&gt;</code></pre><p>这个指令会根据后边参数的不同发挥不同的作用：</p><ul><li>如果最后指定了commit节点标识符或者是标签就会从该节点开始的位置长出分支，即该节点之前提交的代码新分支都有，之后的代码新分支是没有的。如果没有指定commit标签那么默认是从最新节点的位置创立分支。</li><li>“git branch” 指令后面没有任何参数的时候会列出当前文档库中正在开发的所有分支。</li></ul><p>建立分支之后可以使用”git checkout &lt;分支名&gt;” 这个指令来切换当前操作的分支。</p><h4 id="5-2-删除分支"><a href="#5-2-删除分支" class="headerlink" title="5.2 删除分支"></a>5.2 删除分支</h4><p>删除分支我们要注意的是在删除当前分支之前<strong><em>必须先切换到另外的分支</em></strong>，不然不能删除当前分支，删除分支使用如下指令：</p><pre><code>git branch -d &lt;要删除的分支&gt;使用该命令需要保证要删除的分支已经合并到别的分支过，不然会报错</code></pre><p><strong>值得注意的是：</strong></p><p><strong>我们知道如果我们新建了一个分支一般都是为了方便多人协作，开发者分别在自己的dev分支上开发然后合并到master，上面这个命令有些反人类，如果当前要删除的分支没有合并到另一个分支，使用上面的命令会报错。需要把”-d”换成”-D”。</strong></p><h4 id="5-3-修改分支名"><a href="#5-3-修改分支名" class="headerlink" title="5.3 修改分支名"></a>5.3 修改分支名</h4><p>修改分支名需要注意的是<strong>你必须的先切换到要修改的分支</strong>之后才能操作：</p><pre><code>git branch -m &lt;新的分支出名&gt;</code></pre><h4 id="5-4-合并分支"><a href="#5-4-合并分支" class="headerlink" title="5.4 合并分支"></a>5.4 合并分支</h4><p>合并分支使用如下命令：</p><pre><code>git merge 分支名</code></pre><p>该命令会把指定的分支合并到当前分支。比如当前在master分支，想把A分支的代码合并到master使用命令：</p><pre><code>git merge A</code></pre><p>即可。</p><p>如果合并之后你后悔了，想撤回可以使用”git reset”命令。我们想恢复到合并之前的状态执行如下操作：</p><pre><code>git reset --hard HEAD^</code></pre><p>“–hard” 选项表示文件夹中的文件也要一起恢复。</p><h4 id="5-5-解决冲突"><a href="#5-5-解决冲突" class="headerlink" title="5.5 解决冲突"></a>5.5 解决冲突</h4><p>我们先来想一下什么情况会发生冲突：</p><ol><li>假如有个一master分支，你在master节点的最新节点新建了一个分支branch1；</li><li>然后你在branch1分支上新增了一个文件：1.txt,修改了一个文件：test.txt；</li><li>在你准备合并branch1到master之前，你的工友小B合并了他的分支branch2到master，新增了4个文件，也修改了test.txt文件；</li><li>然而你并不知情，你也提交了你的分支到master，这时候系统会告诉你你合并不了，因为检测目前的master和你当时新建分支branch1的时候从master最新节点上得到的那一版不一样，这个时候就代表你发生冲突了，需要手动合并。</li></ol><pre><code>git checkout mastergit merge branch1</code></pre><p>然后就会提示代码冲突了。</p><p>一般冲突的部分会用:</p><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD冲突内容=======&gt;&gt;&gt;&gt;&gt;&gt;&gt;draft</code></pre><p>来表示，所以需要你手动的去合并冲突，解决完了冲突之后执行如下指令提交代码：</p><pre><code>git diff</code></pre><p>执行完成如果没有报错说明已经解决冲突。之后我们可以执行如下指令把我们的代码提交到master分支：</p><pre><code>git add .git commit -m &apos;合并branch1到master&apos;</code></pre><h3 id="6-使用Rebase指令更新分支的起始点"><a href="#6-使用Rebase指令更新分支的起始点" class="headerlink" title="6 使用Rebase指令更新分支的起始点"></a>6 使用Rebase指令更新分支的起始点</h3><p>之前我们说的合并分支的时候都在说这样的情况：</p><ol><li>有主分支master，我们在master的最新节点上创建了新分支AAA。</li><li>我们在AAA分支上做了更新，然后推送到master节点与master节点合并。</li></ol><p>那么现在我们要说的是另一种情况：</p><ol><li>有主分支master，我们在master的最新节点上创建了新分支AAA；</li><li>我们一直在AAA分支上做开发，这个过程的持续很久；</li><li>在AAA上做开发的过程中，别的程序员也在master的最新节点上创建了新的分支BBB，他开发完成很快就提交代码到master；</li><li>这个时候你在AAA分支上开发，为了保证代码的实效性，你必须的拉master的最新代码到你这里。</li></ol><p>见下图：</p><p><img src="https://i.imgur.com/oVQ5aoB.jpg" alt=""></p><p>我们执行如下命令将master合并到AAA：</p><pre><code># git checkout AAA# git merge master</code></pre><p>执行合并以后可能master会继续有更新，而我们的AAA分支也一直在开发，那么我们的节点图可能一直跟上图这样不停的交叉，到最后可能会看起来越来越复杂。当然这样并没有错，只是看起来不是那么简洁。我们可以用另一种方式让我们的节点图看起来更加简洁和直观：用rebase指令取代merge指令。</p><p>rebase指令的功能和merge一样，但是他在节点的处理上略有不同，我们用一个图来说明：</p><p><img src="https://i.imgur.com/4kIc3Y5.jpg" alt=""></p><p>这幅图我们对比上一幅可以看出：</p><p>rebase指令执行的合并会把以前从commit节点长出来的分支AAA合并到master的最新节点，然后从master的最新节点长出来。但是master和AAA节点的代码其实还是各自不同，AAA包含master的所有代码，master不包含AAA从master最新节点”长出来”之后的代码。图虽然不同，但是功能没有任何区别。</p><p>通过上面这两幅图大家是不是更加清楚这两个指定的区别。下面我们来说一下rebase指令的用法。</p><p>使用rebase很简单，就把以前使用merge的地方换成rebase即可：</p><pre><code># git checkout AAA# git rebase master</code></pre><p>与merge一样rebase也会面临发生冲突的情况，你可以使用上面提供的方法手动修改冲突然后执行 “git diff” 检测是否修改完成所有的冲突，最后提交合并。</p><p>假如你在使用rebase提交合并的时候发生冲突，这时候你决定取消合并，你可以执行如下命令：</p><pre><code># git rebase --abort</code></pre><p>执行如上命令一定是在还没有完成rebase之前，如果你提交合并成功了执行上述命令是不生效的。</p><p>接下来我们说如果执行rebase完全没有错误但是你又反悔了该如何操作。</p><p>如果是上述情况，我们可以使用”git reset”命令来恢复，但是有一个条件是:我们必须先找到执行rebase指令之前head所在的commit节点。我们知道head表示当前工作分支的最新commit节点，那我们如何找到历史的那个head节点呢？<br>git提供了一个指令：</p><pre><code># git reflog head或者是任何分支的分支名</code></pre><p>我们可以使用这个指令查询head或是任何分支的变动情况。该命令得出的结果是按照时间倒序排列。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-git配置文件&quot;&gt;&lt;a href=&quot;#1-git配置文件&quot; class=&quot;headerlink&quot; title=&quot;1 git配置文件&quot;&gt;&lt;/a&gt;1 git配置文件&lt;/h3&gt;&lt;h4 id=&quot;1-1-git权限控制&quot;&gt;&lt;a href=&quot;#1-1-git权限控制&quot; c
      
    
    </summary>
    
      <category term="git" scheme="https://blog.rickiyang.cn/categories/git/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十六）----ThreadLocal的使用</title>
    <link href="https://blog.rickiyang.cn/posts/f58afb00.html"/>
    <id>https://blog.rickiyang.cn/posts/f58afb00.html</id>
    <published>2017-04-15T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.157Z</updated>
    
    <content type="html"><![CDATA[<p>其实ThreadLocal很多接触过多线程的同学都可能会很陌生，他不像current包里面那些耳熟能详的api一样在我们面前经常出现，更多的他作为一个本地类出现在系统设计里面。我们可以说一下Spring，Spring的事务管理器通过AOP切入业务代码，在进入业务代码前，会根据对应的事务管理器提取出相应的事务对象，假如事务管理器是DataSourceTransactionManager，就会从DataSource中获取一个连接对象，通过一定的包装后将其保存在ThreadLocal中。并且Spring也将DataSource进行了包装，重写了其中的getConnection()方法，或者说该方法的返回将由Spring来控制，这样Spring就能让线程内多次获取到的Connection对象是同一个。</p><p>为什么要放在ThreadLocal里面呢？因为Spring在AOP后并不能向应用程序传递参数，应用程序的每个业务代码是事先定义好的，Spring并不会要求在业务代码的入口参数中必须编写Connection的入口参数。此时Spring选择了ThreadLocal，通过它保证连接对象始终在线程内部，任何时候都能拿到，此时Spring非常清楚什么时候回收这个连接，也就是非常清楚什么时候从ThreadLocal中删除这个元素</p><p>从名字上看我们很容易误解，ThreadLocal，本地线程。local有当地的，本地的，局部的意思，这里说的是局部线程，意思是线程的局部变量。我们知道synchronized是独占锁，同一时间只能有一个线程操作被锁住的代码大家排队等待，典型的以时间换空间的策略。那如果我们空间很足时间不够该怎么办呢，ThreadLocal就该派上用场了。ThreadLocal作为线程的局部变量，会为这个线程创建独立的变量副本，在线程的内部，他所创建的对象相当于全局对象。</p><p>说到这里，大家是不是还是没有分清楚ThreadLocal和synchronized有什么区别，下面我们来讲。</p><ul><li>ThreadLocal 不是用来解决共享对象的多线程访问问题的，上面说了ThreadLocal是线程的局部变量。一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。</li><li>ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。</li></ul><p><strong>如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题</strong>。 </p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;  </span><br><span class="line">    Session s = (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在getSession()方法中，首先判断当前线程中有没有放进去session，如果还没有，那么通过sessionFactory().openSession()来创建一个session，再将session set到线程中，实际是放到当前线程的ThreadLocalMap这个map中，这时，对于这个session的唯一引用就是当前线程中的那个ThreadLocalMap，而threadSession作为这个值的key，要取得这个session可以通过threadSession.get()来得到，里面执行的操作实际是先取得当前线程中的ThreadLocalMap，然后将threadSession作为key将对应的值取出。上面我们也讲过每个线程进来创建threadSession 的时候，这个threadSession 只属于他一个人所有，别的线程无法共享到他自己创建的ThreadLocal。这就避免了所有线程共享同一个对象的问题。并且该session创建完成之后，我们不必走到哪里都携带着session这个参数，走到哪里传递到哪里。需要使用的时候只需要从threadlocal中取出即可。这也是极其省事的。</p><p>我们可以举一个 例子来说明ThreadLocal不是用来解决对象共享访问问题的，而是为了处理在多线程环境中，某个方法处理一个业务，需要递归依赖其他方法时，而要在这些方法中共享参数的问题。例如有方法a()，在该方法中调用了方法b()，而在b方法中又调用了方法c()，即a–&gt;b—&gt;c，如果a，b，c都需要使用用户对象，那么我们常用做法就是a(User user)–&gt;b(User user)—c(User user)。但是如果使用ThreadLocal我们就可以用另外一种方式解决：</p><ol><li>在某个接口中定义一个静态的ThreadLocal 对象，例如 public static ThreadLocal  threadLocal=new ThreadLocal ();</li><li>然后让a，b，c方法所在的类假设是类A，类B，类C都实现1中的接口</li><li>在调用a时，使用A.threadLocal.set(user) 把user对象放入ThreadLocal环境</li><li>这样我们在方法a，方法b，方法c可以在不用传参数的前提下，在方法体中使用threadLocal.get()方法就可以得到user对象。</li></ol><p>上面我们说到ThreadLocal的使用，也说了ThreadLocal里面有一个ThreadLocalMap 用于存储当前线程的对象，下面我们简单的看一下源码来理解一下这个过程。先上类图：</p><p><img src="http://i.imgur.com/h6m3uaC.jpg" alt=""></p><p>ThreadLocal里面有一个内部类ThreadLocalMap，在ThreadLocal内部又装了一个Entry，他继承了WeakReference<threadlocal>，我们来看一下Entry：</threadlocal></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">  Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">       <span class="keyword">super</span>(k);</span><br><span class="line">       value = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry对象其实还是ThreadLocal类型的，这里我们看到ThreadLocal用了一个WeakReference包装是为了保证该ThreadLocal对象在没有被引用的时候能够及时的被gc掉。</p><p>下面再看一下ThreadLocal的get和set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal key, Object value)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">       ...</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在set方法中t.threadLocals只要不为空，便创建map对象，我们看到set方法中的key是ThreadLocal，即thread调用ThreadLocal.get()方法既可得到当前thread的threadLocal对象里面的ThreadLocalMap的值！是不是有点绕，是不是不知道为什么当前线程能调用ThreadLocal，我们看一下上面的getMap()方法，返回值是：t.threadLocals，这个t即当前线程，在Thread类里面有一个threadLocals对象，我们可以跟过去看一下，在这里限于篇幅，就只上相关的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">         Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面方法是ThreadLocal中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在源码中看到threadLocals并未进行赋值，他一直都是一个空对象，为什么这么做呢，我们接着看下面的get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在get方法中，如果一个线程当前并未使用ThreadLocal对象那么getMap(t)必然是空，那我们就得想了，难道在Thread类中创建一个空对象threadLocals就这么空着？哈哈，当然不是啦，我也着急了。所以就进入了下面的setInitialValue()方法啦，这里的getMap(t)当然还是空的，那进入createMap(t, value)呗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于在这里拨开云雾见月明！妈妈再也不用担心threadLocals没有人要了！上面分析的比较乱，大家就将就看，用一句话总结那就是：</p><p>在Thread类中有一个对象是threadLocals，如果在该线程运行中有ThreadLocal创建threadLocals会去找到他的！获得你在ThreadLocal中存储的值！</p><p>上面我们已经详细分析了ThreadLocal的使用和实现，那么在真实的环境中使用它有什么弊端没呢。其实使用中还真的是有很多问题的。</p><p>我们知道ThreadLocal是和当前线程绑定的，即他的生命周期是和当前线程共存，当线程结束，ThreadLocal内部的Entity对象才会被gc回收。</p><p>下面我说一个场景大家看会带来什么样的后果：如果现在是线程池对象使用了ThreadLocal来保存变量会发生什么？大家知道线程池的主要目的是为了线程复用，那么线程池中的线程基本不会结束，与jvm的生命周期是一致的。那这个时候谁知道一个携带了ThreadLocal的线程会什么时候结束呢。长久以往必然造成内存泄露。</p><p>另外我们再说一个关于忘记释放的问题。如果你在线程刚开始进来的时候就载入了ThreadLocal用来保存变量，假设你的程序设计的不是很健壮，你忘记了写remove()。这个时候事情就来了。再假设你在ThreadLocal中存放了map对象，真实的业务中Map对象也许包含了很多数据，随着时间流逝，内存中的无用对象越来越多，内存泄露是必然的。</p><p>关于ThreadLocal的内容我们就讲到这里，其实里面还有很多值得我们深究的东西，慢慢一点点的去看吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实ThreadLocal很多接触过多线程的同学都可能会很陌生，他不像current包里面那些耳熟能详的api一样在我们面前经常出现，更多的他作为一个本地类出现在系统设计里面。我们可以说一下Spring，Spring的事务管理器通过AOP切入业务代码，在进入业务代码前，会根
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十四）----(JUC集合)ArrayBlockingQueue和LinkedBlockingQueue介绍</title>
    <link href="https://blog.rickiyang.cn/posts/ed05b021.html"/>
    <id>https://blog.rickiyang.cn/posts/ed05b021.html</id>
    <published>2017-04-12T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.156Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们来了解阻塞队列（BlockingQueue），BlockingQueue接口定义了一种阻塞的FIFO queue，每一个BlockingQueue都有一个容量，当容量满时往BlockingQueue中添加数据时会造成阻塞，当容量为空时取元素操作会阻塞。首先我们来看ArrayBlockingQueue和LinkedBlockingQueue.</p><h4 id="1-ArrayBlockingQueue"><a href="#1-ArrayBlockingQueue" class="headerlink" title="1 ArrayBlockingQueue"></a>1 ArrayBlockingQueue</h4><p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。</p><p>我们看他的构造函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是非公平的，初始指定队列容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//该构造方法可以设置队列的公平性。当然如果为公平的，则对性能会产生影响<br>//访问者的公平性是使用可重入锁实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">   <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">   lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">   notEmpty = lock.newCondition();</span><br><span class="line">   notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用很简单我们直接看一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> ProducerAndConsumer(blockingQueue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    Condition pro_con = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    Condition con_con = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerAndConsumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue= blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(flag)</span><br><span class="line">                pro_con.await();</span><br><span class="line">            System.out.println(<span class="string">"正在准备放入数据。。。"</span>);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">100</span>);</span><br><span class="line">            Integer value = <span class="keyword">new</span> Random().nextInt(<span class="number">30</span>);</span><br><span class="line">            blockingQueue.put(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"   放入的数据    "</span>+value);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            con_con.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(!flag)</span><br><span class="line">                con_con.await();</span><br><span class="line">            System.out.println(<span class="string">"正在准备取数据。。。"</span>);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"   取到的数据为"</span>+blockingQueue.take());</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            pro_con.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                put();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                get();</span><br><span class="line">            &#125;</span><br><span class="line">            j=(j+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>正在准备放入数据。。。正在准备放入数据。。。正在准备放入数据。。。正在准备放入数据。。。pool-1-thread-2   放入的数据    13正在准备取数据。。。pool-1-thread-3   放入的数据    4正在准备取数据。。。pool-1-thread-3   取到的数据为13正在准备放入数据。。。pool-1-thread-1   放入的数据    11正在准备取数据。。。pool-1-thread-4   放入的数据    26正在准备取数据。。。pool-1-thread-1   取到的数据为4正在准备放入数据。。。pool-1-thread-2   取到的数据为11正在准备放入数据。。。pool-1-thread-3   放入的数据    18正在准备取数据。。。......</code></pre><h4 id="2-LinkedBlockingQueue"><a href="#2-LinkedBlockingQueue" class="headerlink" title="2 LinkedBlockingQueue"></a>2 LinkedBlockingQueue</h4><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。<br>先看一下他的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);  <span class="comment">//MAX_VALUE=2147483647</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是直接开看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义装苹果的篮子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Basket</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 篮子，能够容纳3个苹果</span></span><br><span class="line">        <span class="comment">// BlockingQueue&lt;String&gt; basket = new ArrayBlockingQueue&lt;String&gt;(3);</span></span><br><span class="line">        BlockingQueue&lt;String&gt; basket = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产苹果，放入篮子</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">// put方法放入一个苹果，若basket满了，等到basket有位置</span></span><br><span class="line">            basket.put(<span class="string">"An apple"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费苹果，从篮子中取走</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">// get方法取出一个苹果，若basket为空，等到basket有苹果为止</span></span><br><span class="line">            <span class="keyword">return</span> basket.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 　测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBasket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立一个装苹果的篮子</span></span><br><span class="line">        <span class="keyword">final</span> Basket basket = <span class="keyword">new</span> Basket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义苹果生产者</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> String instance = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">                instance = a;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="comment">// 生产苹果</span></span><br><span class="line">                        System.out.println(<span class="string">"生产者准备生产苹果："</span> + instance);</span><br><span class="line">                        basket.produce();</span><br><span class="line">                        System.out.println(<span class="string">"! 生产者生产苹果完毕："</span> + instance);</span><br><span class="line">                        <span class="comment">// 休眠300ms</span></span><br><span class="line">                        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义苹果消费者</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> String instance = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">                instance = a;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="comment">// 消费苹果</span></span><br><span class="line">                        System.out.println(<span class="string">"消费者准备消费苹果："</span> + instance);</span><br><span class="line">                        basket.consume();</span><br><span class="line">                        System.out.println(<span class="string">"! 消费者消费苹果完毕："</span> + instance);</span><br><span class="line">                        <span class="comment">// 休眠1000ms</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(<span class="string">"P1"</span>);</span><br><span class="line">        Producer producer2 = <span class="keyword">new</span> Producer(<span class="string">"P2"</span>);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(<span class="string">"C1"</span>);</span><br><span class="line">        service.submit(producer);</span><br><span class="line">        service.submit(producer2);</span><br><span class="line">        service.submit(consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 程序运行3s后，所有任务停止</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        service.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueueTest.testBasket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>生产者准备生产苹果：P1消费者准备消费苹果：C1! 生产者生产苹果完毕：P1生产者准备生产苹果：P2! 消费者消费苹果完毕：C1! 生产者生产苹果完毕：P2生产者准备生产苹果：P2! 生产者生产苹果完毕：P2生产者准备生产苹果：P1! 生产者生产苹果完毕：P1生产者准备生产苹果：P2生产者准备生产苹果：P1消费者准备消费苹果：C1! 消费者消费苹果完毕：C1! 生产者生产苹果完毕：P2生产者准备生产苹果：P2消费者准备消费苹果：C1! 消费者消费苹果完毕：C1! 生产者生产苹果完毕：P1生产者准备生产苹果：P1消费者准备消费苹果：C1! 消费者消费苹果完毕：C1! 生产者生产苹果完毕：P2Process finished with exit code 0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们来了解阻塞队列（BlockingQueue），BlockingQueue接口定义了一种阻塞的FIFO queue，每一个BlockingQueue都有一个容量，当容量满时往BlockingQueue中添加数据时会造成阻塞，当容量为空时取元素操作会阻塞。首先我们来看
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十三）----(JUC集合)ConcurrentSkipListMap介绍</title>
    <link href="https://blog.rickiyang.cn/posts/31315379.html"/>
    <id>https://blog.rickiyang.cn/posts/31315379.html</id>
    <published>2017-04-12T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.138Z</updated>
    
    <content type="html"><![CDATA[<p>Queue除了前面介绍的实现外，还有一种双向的Queue实现Deque。这种队列允许在队列头和尾部进行入队出队操作，因此在功能上比Queue显然要更复杂。</p><h4 id="1-LinkedBlockingDeque"><a href="#1-LinkedBlockingDeque" class="headerlink" title="1 LinkedBlockingDeque"></a>1 LinkedBlockingDeque</h4><p>我们来看一下该类中的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt;,  <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">387911632671998426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;    </span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123;</span><br><span class="line">            item = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个内部类Node，该类用来标记queue的节点，capacity最大为Integer.MAX_VALUE。然后使用了独占锁和条件机制来保证线程安全和进行阻塞控制。从上面的结构上我们可以看出：</p><ol><li>要想支持阻塞功能，队列的容量一定是固定的，否则无法在入队的时候挂起线程。也就是capacity是final类型的。</li><li>既然是双向链表，每一个结点就需要前后两个引用，这样才能将所有元素串联起来，支持双向遍历。也即需要prev/next两个引用。</li><li>双向链表需要头尾同时操作，所以需要first/last两个节点，当然可以参考LinkedList那样采用一个节点的双向来完成，那样实现起来就稍微麻烦点。</li><li>既然要支持阻塞功能，就需要锁和条件变量来挂起线程。这里使用一个锁两个条件变量来完成此功能。</li></ol><p>上面对LinkedBlockingDeque的结构做了说明，那么原理就很清晰了，无非是用一个独占锁来保持线程安全，然后用Condition来做阻塞操作。双向链表的操作大家都很熟悉就不做过多解释。</p><h4 id="2-ConcurrentLinkedDeque"><a href="#2-ConcurrentLinkedDeque" class="headerlink" title="2 ConcurrentLinkedDeque"></a>2 ConcurrentLinkedDeque</h4><p>ConcurrentLinkedDeque是JSR166y中新增的一个无界并发Deque实现，基于已链接节点的、任选范围的双端队列。在迭代时，队列保持弱一致性，但不会抛出ConcurrentModificationException异常。</p><p>我们看一下类的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Node&lt;Object&gt; PREV_TERMINATOR, NEXT_TERMINATOR;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">prevTerminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;E&gt;) PREV_TERMINATOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">nextTerminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;E&gt;) NEXT_TERMINATOR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到成员变量里面有头节点和尾节点，然后是节点的引用PREV_TERMINATOR, NEXT_TERMINATOR，<br>双向链表的结构都是一样的。ConcurrentLinkedDeque不是阻塞队列所以没有用到条件原语。我们在成员变量里面没有看到使用ReentrantLock,因为所有的操作都是使用原子操作，避免了使用独占锁造成性能问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Queue除了前面介绍的实现外，还有一种双向的Queue实现Deque。这种队列允许在队列头和尾部进行入队出队操作，因此在功能上比Queue显然要更复杂。&lt;/p&gt;
&lt;h4 id=&quot;1-LinkedBlockingDeque&quot;&gt;&lt;a href=&quot;#1-LinkedBlocki
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十三）----(JUC集合)ConcurrentSkipListMap介绍</title>
    <link href="https://blog.rickiyang.cn/posts/31315379.html"/>
    <id>https://blog.rickiyang.cn/posts/31315379.html</id>
    <published>2017-04-11T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.155Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够在O(log(n))时间内完成查找、插入、删除操作。</p><h4 id="1-理解SkipList"><a href="#1-理解SkipList" class="headerlink" title="1 理解SkipList"></a>1 理解SkipList</h4><p>要想弄明白ConcurrentSkipListMap,我们的先明白他的数据结构实现，先来看SkipList。</p><p>Skip List是一种随机化的数据结构，基于并联的链表，其效率可比拟于二叉查找树（对于大多数操作需要O(log n)平均时间）。基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。所有操作都以对数随机化的时间进行。SkipList可以很好解决有序链表查找特定值的困难。</p><p>Skip List定义：</p><p>一个跳表，应该具有以下特征：</p><ol><li>一个跳表应该有几个层（level）组成；</li><li>跳表的第一层包含所有的元素；</li><li>每一层都是一个有序的链表；</li><li>如果元素x出现在第i层，则所有比i小的层都包含x；</li><li>第i层的元素通过一个down指针指向下一层拥有相同值的元素；</li><li>在每一层中，-1和1两个元素都出现(分别表示INT_MIN和INT_MAX)；</li><li>Top指针指向最高层的第一个元素。</li></ol><p>构建有序链表：</p><p><img src="http://i.imgur.com/IR4pz7d.png" alt=""></p><p>一个跳表如下：</p><p><img src="http://i.imgur.com/qNokG9C.png" alt=""></p><p>Skip List构造步骤：</p><ol><li>给定一个有序的链表。</li><li>选择链表中最大和最小的元素，然后从其他元素中按照一定算法（随机）随即选出一些元素，将这些元素组成有序链表。这个新的链表称为一层，原链表称为其下一层。</li><li>为刚选出的每个元素添加一个指针域，这个指针指向下一层中值同自己相等的元素。Top指针指向该层首元素</li><li>重复2、3步，直到不再能选择出除最大最小元素以外的元素。</li></ol><p>从上图可以看到，跳表具有以下几种特性：</p><ul><li>由很多层组成，level越高的层节点越少，最后一层level用有所有的节点数据</li><li>每一层的节点数据也都是有顺序的</li><li>上面层的节点肯定会在下面层中出现</li><li>每个节点都有两个指针，分别是同一层的下一个节点指针和下一层节点的指针</li></ul><p>使用跳表查询元素的时间复杂度是O(log n)，跟红黑树一样。查询效率还是不错的，但是跳表的存储容量变大了，本来一共只有10个节点的数据，使用跳表之后变成了21个节点。</p><p>所以跳表是一种使用”空间换时间”的概念用来提高查询效率的链表，开源软件Redis、LevelDB都使用到了跳表。跳表相比B树，红黑树，AVL树时间复杂度一样，但是耗费更多存储空间，但是跳表的优势就是它相比树，实现简单，不需要考虑树的一些rebalance问题。</p><h4 id="2-ConcurrentSkipListMap探索"><a href="#2-ConcurrentSkipListMap探索" class="headerlink" title="2 ConcurrentSkipListMap探索"></a>2 ConcurrentSkipListMap探索</h4><p>ConcurrentSkipListMap包含了很多内部类，内部类的框架图如下：<br><img src="http://i.imgur.com/mOif8BQ.png" alt=""></p><p>ConcurrentSkipListMap在原始链表的基础上增加了跳表的结构，所以需要两个额外的内部类来封装链表的节点，以及跳表的节点——Node和Index。</p><p>同ConcurrentHashMap的Node节点一样，key为final，是不可变的，value和next通过volatile修饰保证内存可见性。</p><p>Index：跳表的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">       <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">       <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node：链表的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> Object value;</span><br><span class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Index封装了跳表需要的结构，首先node包装了链表的节点，down指向下一层的节点（不是Node，而是Index），right指向同层右边的节点。node和down都是final的，说明跳表的节点一旦创建，其中的值以及所处的层就不会发生变化（因为down不会变化，所以其下层的down都不会变化，那他的层显然不会变化）。Node和Index内部都提供了用于CAS原子更新的<a href="http://blog.csdn.net/a953713428/article/details/54588198" title="AtomicReferenceFieldUpdater" target="_blank" rel="noopener">AtomicReferenceFieldUpdater</a>对象，该对象前面讲Atomic原子类的时候已经讲过,原理和机制将不再介绍。</p><p>下面我们还是着重介绍ConcurrentSkipListMap的get、put和remove方法。在介绍这三个方法之前我们先看一下这三个方法都会用到的一个辅助方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Comparable&lt;? <span class="keyword">super</span> K&gt; comparable(Object key)</span><br><span class="line">            <span class="keyword">throws</span> ClassCastException &#123;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//有两种封装方法，如果在构造时指定了comparator，则使用comparator封装key</span></span><br><span class="line">    <span class="comment">// 如果没有指定comparator，则key必须是一个继承自Comparable接口的类，否则会抛出ClassCastException</span></span><br><span class="line">    <span class="comment">// 所以ConcurrentSkipListMap的key要么是继承自Comparable接口的类，如果不是的话需要显示提供comparator进行比较</span></span><br><span class="line">      <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ComparableUsingComparator&lt;K&gt;((K)key, comparator);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> (Comparable&lt;? <span class="keyword">super</span> K&gt;)key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparableUsingComparator</span>&lt;<span class="title">K</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> K actualKey;</span><br><span class="line">      <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; cmp;</span><br><span class="line">      ComparableUsingComparator(K key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp) &#123;</span><br><span class="line">          <span class="keyword">this</span>.actualKey = key;</span><br><span class="line">          <span class="keyword">this</span>.cmp = cmp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(K k2)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cmp.compare(actualKey, k2);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentSkipListMap的key必须是能够比较的，这样来确保线程安全。</p><p>我们再来看一下get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object okey)</span> </span>&#123;</span><br><span class="line">     Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(okey);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Loop needed here and elsewhere in case value field goes</span></span><br><span class="line"><span class="comment">       * null just as it is about to be returned, in which case we</span></span><br><span class="line"><span class="comment">       * lost a race with a deletion, so must retry.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; n = findNode(key);</span><br><span class="line">          <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          Object v = n.value;</span><br><span class="line">          <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">return</span> (V)v;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见在get方法中调用了doGet()来进行取值操作，首先调用了comparable（key）方法来确保该次取值的安全性，后面再一个死循环中持续进行 findNode(key)操作。</p><p>再看一下put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K kkey, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">       Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(kkey);</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 从跳表中查找最接近指定key的节点：该节点的key小于等于指定key，且处于最底层</span></span><br><span class="line">          Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">          Node&lt;K,V&gt; n = b.next;</span><br><span class="line">    <span class="comment">//新节点插入在b与n之间</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//n==null则说明b是链表的最后一个节点，则新节点直接插入到链表尾部即可</span></span><br><span class="line">              <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                  <span class="keyword">if</span> (n != b.next)  <span class="comment">// 此处增加判断，避免链表结构已被修改(针对节点b)</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  Object v = n.value;</span><br><span class="line">                  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;     <span class="comment">// n节点已经被删除</span></span><br><span class="line">                      n.helpDelete(b, f);b和f分别为n的前驱和后继节点</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">            <span class="comment">// 这里如果v==n说明n是一个删除标记，用来标记其前继节点已被删除，即b已被删除</span></span><br><span class="line">                  <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>) <span class="comment">// b is deleted</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">int</span> c = key.compareTo(n.key);</span><br><span class="line">            <span class="comment">// 如果指定key&gt;n的key，则判断下一个节点，直到n==null，或者指定key&lt;n的key</span></span><br><span class="line">                  <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      b = n;</span><br><span class="line">                      n = f;</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">            <span class="comment">// 相等，则更新value即可，更新失败，就再来一次，一直到成功为止</span></span><br><span class="line">                  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value))</span><br><span class="line">                          <span class="keyword">return</span> (V)v;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">              &#125;</span><br><span class="line">        <span class="comment">// 创建一个节点，next指向n</span></span><br><span class="line">              Node&lt;K,V&gt; z = <span class="keyword">new</span> Node&lt;K,V&gt;(kkey, value, n);</span><br><span class="line">        <span class="comment">// 将b的next指向新创建的节点，则新的链表为：b--&gt;new--&gt;n，即将新节点插入到b和n之间</span></span><br><span class="line">              <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                  <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">        <span class="comment">// 随机计算一个层级</span></span><br><span class="line">              <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">              <span class="keyword">if</span> (level &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将z插入到该层级</span></span><br><span class="line">                  insertIndex(z, level);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中已经附上了大量的注释，这里再简单的梳理下流程。首先put()方法是调用内部的doPut()方法。Comparable&lt; ? super K&amp;&gt; key = comparable(kkey);这一句将key封装成一个Comparable对象，上面已经介绍了comparable这个方法。接着进入到死循环，循环第一步是调用findPredecessor(key)方法，该方法返回一个key最接近指定key的节点(最接近指的是小于等于)，该节点是处于最底层的，下面介绍下这个方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*在跳表中查找节点的key小于指定key，且处于最底层的节点，即找到指定key的前继节点</span></span><br><span class="line"><span class="comment">*基本逻辑是从head(跳表的最高层链表的头结点)开始自右开始查找，当找到该层链表的最</span></span><br><span class="line"><span class="comment">*接近且小于指定key的节点时，往下开始查找，</span></span><br><span class="line"><span class="comment">*最终找到最底层的那个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Comparable&lt;? <span class="keyword">super</span> K&gt; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// head是跳表的最高层链表的头结点</span></span><br><span class="line">      Index&lt;K,V&gt; q = head;</span><br><span class="line">      Index&lt;K,V&gt; r = q.right;<span class="comment">// head的右边节点</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// r==null说明该层链表已经查找到头，且未找到符合条件的节点，需开始往下查找</span></span><br><span class="line">          <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Node&lt;K,V&gt; n = r.node;<span class="comment">// r的数据节点</span></span><br><span class="line">              K k = n.key;</span><br><span class="line">              <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;<span class="comment">// n的value为null，说明该节点已被删除</span></span><br><span class="line">                  <span class="comment">// 将该节点从链表移除，通过将其(n)前置节点的right指向其(n)的后置节点</span></span><br><span class="line">                  <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                      <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                  r = q.right;         <span class="comment">// reread r 移除value==null的n节点之后，继续从n的下一个节点查找</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">               <span class="comment">// 比较当前查找的节点的key与指定key，如果小于指定key，则继续查找，</span></span><br><span class="line">              <span class="comment">// 大于等于key则q即为该层链表最接近指定key的</span></span><br><span class="line">              <span class="keyword">if</span> (key.compareTo(k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  q = r;</span><br><span class="line">                  r = r.right;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 到这里有两种情况：</span></span><br><span class="line">          <span class="comment">//1)该层链表已经查找完，仍未找到符号条件的节点</span></span><br><span class="line">          <span class="comment">//2)找到一个符合条件的节点</span></span><br><span class="line">          <span class="comment">// 开始往下一层链表进行查找</span></span><br><span class="line">          Index&lt;K,V&gt; d = q.down;</span><br><span class="line">          <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123; <span class="comment">// 从下层对应位置继续查找</span></span><br><span class="line">              q = d;</span><br><span class="line">              r = d.right;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="comment">// 如果无下层链表则直接返回当前节点的node</span></span><br><span class="line">              <span class="keyword">return</span> q.node;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的查找逻辑是：从head(跳表的最高层链表的头结点)开始自右开始查找，当找到该层链表的最接近且小于指定key的节点时，往下开始查找，最终找到最底层的那个节点。具体的代码可以看注释，应该说的挺明白的了，针对Put方法，这个方法返回的节点就是将要插入的节点的前继节点，即新节点将插到该节点后面。下面是查找的示意图:</p><p> <img src="http://i.imgur.com/h99sWtC.png" alt=""></p><p>所有的修改操作都是使用CAS，只要失败就会重试，直至成功，所以就算多线程并发操作也不会出现错误，而且通过CAS避免了使用锁，性能比用锁好很多。</p><p>接下来在看一下remove：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object okey, Object value)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(okey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 从跳表中查找最接近指定key的节点：该节点的key小于等于指定key，且处于最底层</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//获取n节点的下一个节点</span></span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            Object v = n.value;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;                    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> c = key.compareTo(n.key);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;<span class="comment">//将该节点移除</span></span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);                  <span class="comment">// Retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findPredecessor(key);           <span class="comment">// Clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (V)v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：doRemove函数的处理流程如下。</p><p>　　① 根据key值找到前驱结点，查找的过程会删除一个标记为删除的结点。</p><p>　　② 从前驱结点往后查找该结点。</p><p>　　③ 在该结点后面添加一个marker结点，若添加成功，则将该结点的前驱的后继设置为该结点之前的后继。</p><p>　　④ 头结点的next域是否为空，若为空，则减少层级。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够在O(log(n))时间内完成查找、插入、删除操作。&lt;/p&gt;
&lt;h4 id=&quot;1-理解SkipList&quot;&gt;&lt;a href=&quot;#1-理解Sk
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十三）----(JUC集合)ConcurrentSkipListMap介绍</title>
    <link href="https://blog.rickiyang.cn/posts/31315379.html"/>
    <id>https://blog.rickiyang.cn/posts/31315379.html</id>
    <published>2017-04-07T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.154Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们来看一下并发的Map，ConcurrentHashMap和ConcurrentSkipListMap。ConcurrentHashMap通常只被看做并发效率更高的Map，用来替换其他线程安全的Map容器，比如Hashtable和Collections.synchronizedMap。ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够在O(log(n))时间内完成查找、插入、删除操作。</p><h4 id="1-ConcurrentHashMap简介"><a href="#1-ConcurrentHashMap简介" class="headerlink" title="1 ConcurrentHashMap简介"></a>1 ConcurrentHashMap简介</h4><p>ConcurrentHashMap是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。</p><p>为了更好的理解 ConcurrentHashMap 高并发的具体实现，让我们先探索它的结构模型。</p><p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。</p><h5 id="1-1-HashEntry类："><a href="#1-1-HashEntry类：" class="headerlink" title="1.1 HashEntry类："></a>1.1 HashEntry类：</h5><p>HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">     <span class="keyword">final</span> K key;</span><br><span class="line">     <span class="keyword">volatile</span> V value;</span><br><span class="line">     <span class="keyword">volatile</span> ConcurrentHashMap.HashEntry&lt;K, V&gt; next;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">     HashEntry(<span class="keyword">int</span> var1, K var2, V var3, ConcurrentHashMap.HashEntry&lt;K, V&gt; var4) &#123;</span><br><span class="line">         <span class="keyword">this</span>.hash = var1;</span><br><span class="line">         <span class="keyword">this</span>.key = var2;</span><br><span class="line">         <span class="keyword">this</span>.value = var3;</span><br><span class="line">         <span class="keyword">this</span>.next = var4;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(ConcurrentHashMap.HashEntry&lt;K, V&gt; var1)</span> </span>&#123;</span><br><span class="line">         UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, var1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             UNSAFE = Unsafe.getUnsafe();</span><br><span class="line">             Class var0 = ConcurrentHashMap.HashEntry.class;</span><br><span class="line">             nextOffset = UNSAFE.objectFieldOffset(var0.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception var1) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(var1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-Segment类："><a href="#1-2-Segment类：" class="headerlink" title="1.2 Segment类："></a>1.2 Segment类：</h5><p>Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。Segment 中包含HashEntry 的数组，其可以守护其包含的若干个桶（HashEntry的数组）。Segment 在某些意义上有点类似于 HashMap了，都是包含了一个数组，而数组中的元素可以是一个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>?<span class="number">64</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * table 是由 HashEntry 对象组成的数组</span></span><br><span class="line"><span class="comment">     * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class="line"><span class="comment">     * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class="line"><span class="comment">     * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class="line"><span class="comment">     * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> ConcurrentHashMap.HashEntry&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;  <span class="comment">//Segment中元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">//对table的大小造成影响的操作的数量（比如put或者remove操作）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold; <span class="comment">//阈值，Segment里面元素的数量超过这个值依旧就会对Segment进行扩容</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">//负载因子，用于确定threshold</span></span><br><span class="line"></span><br><span class="line">    Segment(<span class="keyword">float</span> var1, <span class="keyword">int</span> var2, ConcurrentHashMap.HashEntry&lt;K, V&gt;[] var3) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = var1;</span><br><span class="line">        <span class="keyword">this</span>.threshold = var2;</span><br><span class="line">        <span class="keyword">this</span>.table = var3;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 的成员变量中，包含了一个 Segment 的数组（final Segment&lt;K,V&gt;[] segments;），而 Segment 是 ConcurrentHashMap 的内部类，然后在 Segment 这个类中，包含了一个 HashEntry 的数组（transient volatile HashEntry&lt;K,V&gt;[] table;）。而 HashEntry 也是 ConcurrentHashMap 的内部类。HashEntry 中，包含了 key 和 value 以及 next 指针（类似于 HashMap 中 Entry），所以 HashEntry 可以构成一个链表。</p><p>所以通俗的讲，ConcurrentHashMap 数据结构为一个 Segment 数组，Segment 的数据结构为 HashEntry 的数组，而 HashEntry 存的是我们的键值对，可以构成链表。</p><h5 id="1-3-ConcurrentHashMap结构图"><a href="#1-3-ConcurrentHashMap结构图" class="headerlink" title="1.3 ConcurrentHashMap结构图"></a>1.3 ConcurrentHashMap结构图</h5><p><img src="http://i.imgur.com/X1ireU8.jpg" alt=""></p><p>ConcurrentHashMap引入了分割，并提供了HashTable支持的所有的功能。在ConcurrentHashMap中，支持多线程对Map做读操作，并且不需要任何的blocking。这得益于CHM将Map分割成了不同的部分，在执行更新操作时只锁住一部分。根据默认的并发级别(concurrency level)，Map被分割成16个部分，并且由不同的锁控制。这意味着，同时最多可以有16个写线程操作Map。试想一下，由只能一个线程进入变成同时可由16个写线程同时进入(读线程几乎不受限制)，性能的提升是显而易见的。但由于一些更新操作，如put(),remove(),putAll(),clear()只锁住操作的部分，所以在检索操作不能保证返回的是最新的结果。</p><p>ConcurrentHashMap默认的并发级别是16，但可以在创建CHM时通过构造函数改变。毫无疑问，并发级别代表着并发执行更新操作的数目，所以如果只有很少的线程会更新Map，那么建议设置一个低的并发级别。另外，ConcurrentHashMap还使用了ReentrantLock来对segments加锁。</p><p>经过前面的铺垫我们来正式对ConcurrentHashMap的使用进行剖析，重点关注get、put、remove这三个操作。</p><p>首先来看一下get的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> var4 = <span class="keyword">this</span>.hash(var1);</span><br><span class="line">    <span class="keyword">long</span> var5 = (<span class="keyword">long</span>)((var4 &gt;&gt;&gt; <span class="keyword">this</span>.segmentShift &amp; <span class="keyword">this</span>.segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    ConcurrentHashMap.Segment var2;</span><br><span class="line">    <span class="keyword">if</span>((var2 = (ConcurrentHashMap.Segment)UNSAFE.getObjectVolatile(<span class="keyword">this</span>.segments, var5)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentHashMap.HashEntry[] var3 = var2.table;</span><br><span class="line">        <span class="keyword">if</span>(var2.table != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ConcurrentHashMap.HashEntry var7 = (ConcurrentHashMap.HashEntry)UNSAFE.getObjectVolatile(var3, ((<span class="keyword">long</span>)(var3.length - <span class="number">1</span> &amp; var4) &lt;&lt; TSHIFT) + TBASE); var7 != <span class="keyword">null</span>; var7 = var7.next) &#123;</span><br><span class="line">                Object var8 = var7.key;</span><br><span class="line">                <span class="keyword">if</span>(var7.key == var1 || var7.hash == var4 &amp;&amp; var1.equals(var8)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> var7.value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>根据key，计算出hashCode；</p></li><li><p>根据步骤1计算出的hashCode定位segment，如果segment不为null &amp;&amp; segment.table也不为null，跳转到步骤3，否则，返回null，该key所对应的value不存在；</p></li><li><p>根据hashCode定位table中对应的hashEntry，遍历hashEntry，如果key存在，返回key对应的value；</p></li><li><p>步骤3结束仍未找到key所对应的value，返回null，该key锁对应的value不存在。</p></li></ol><p>ConcurrentHashMap的get操作高效之处在于整个get操作不需要加锁。如果不加锁，ConcurrentHashMap的get操作是如何做到线程安全的呢？原因是volatile，所有的value都定义成了volatile类型，（上面介绍HashEntry类源码中提到：volatile V value）volatile可以保证线程之间的可见性，这也是用volatile替换锁的经典应用场景。</p><p>再来看一下put操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K var1, V var2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> var4 = <span class="keyword">this</span>.hash(var1);</span><br><span class="line">        <span class="keyword">int</span> var5 = var4 &gt;&gt;&gt; <span class="keyword">this</span>.segmentShift &amp; <span class="keyword">this</span>.segmentMask;</span><br><span class="line">        ConcurrentHashMap.Segment var3;</span><br><span class="line">        <span class="keyword">if</span>((var3 = (ConcurrentHashMap.Segment)UNSAFE.getObject(<span class="keyword">this</span>.segments, (<span class="keyword">long</span>)(var5 &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            var3 = <span class="keyword">this</span>.ensureSegment(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var3.put(var1, var4, var2, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在第7行定义了一个Segment类型的 var3，然后调用了Segment的put方法存入map，我们不妨来看一下Segment的put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K var1, <span class="keyword">int</span> var2, V var3, <span class="keyword">boolean</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.获取锁，保证put操作的线程安全；</span></span><br><span class="line">  ConcurrentHashMap.HashEntry var5 = <span class="keyword">this</span>.tryLock()?<span class="keyword">null</span>:<span class="keyword">this</span>.scanAndLockForPut(var1, var2, var3);</span><br><span class="line"></span><br><span class="line">  Object var6;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      ConcurrentHashMap.HashEntry[] var7 = <span class="keyword">this</span>.table;</span><br><span class="line">      <span class="keyword">int</span> var8 = var7.length - <span class="number">1</span> &amp; var2;</span><br><span class="line">      <span class="comment">//2.定位到HashEntry数组中具体的HashEntry</span></span><br><span class="line">      ConcurrentHashMap.HashEntry var9 = ConcurrentHashMap.entryAt(var7, var8);</span><br><span class="line">      ConcurrentHashMap.HashEntry var10 = var9;</span><br><span class="line">      <span class="comment">//3.遍历HashEntry链表，假若待插入key已存在：</span></span><br><span class="line">      <span class="comment">//需要更新key所对应value（!onlyIfAbsent），更新oldValue -&gt; newValue，跳转到步骤5；</span></span><br><span class="line">      <span class="comment">//否则，直接跳转到步骤5；</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(var10 == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span>(var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  var5.setNext(var9);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  var5 = <span class="keyword">new</span> ConcurrentHashMap.HashEntry(var2, var1, var3, var9);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">int</span> var15 = <span class="keyword">this</span>.count + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span>(var15 &gt; <span class="keyword">this</span>.threshold &amp;&amp; var7.length &lt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.rehash(var5);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  ConcurrentHashMap.setEntryAt(var7, var8, var5);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              ++<span class="keyword">this</span>.modCount;</span><br><span class="line">              <span class="keyword">this</span>.count = var15;</span><br><span class="line">              var6 = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//4.遍历完HashEntry链表，key不存在，插入HashEntry节点，oldValue = null，跳转到步骤5</span></span><br><span class="line">          Object var11 = var10.key;</span><br><span class="line">          <span class="keyword">if</span>(var10.key == var1 || var10.hash == var2 &amp;&amp; var1.equals(var11)) &#123;</span><br><span class="line">              var6 = var10.value;</span><br><span class="line">              <span class="keyword">if</span>(!var4) &#123;</span><br><span class="line">                  var10.value = var3;</span><br><span class="line">                  ++<span class="keyword">this</span>.modCount;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">         var10 = var10.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//5.释放锁，返回oldValue</span></span><br><span class="line">       <span class="keyword">this</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中已经做出解析，需要知道的是Segment的HashEntry数组采用开链法来处理冲突，我们知道散列最大的局限性就是空间利用率低，例如载荷因子为0.7，那么仍有0.3的空间未被利用。使用开链法可以使载荷因子为1，每个链上都挂常数个数据，对于哈希表的开链法来说，其开的空间都是按素数个依次往后开的空间，所以put操作的效率很高。</p><p>再来看一下remove操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> var2 = <span class="keyword">this</span>.hash(var1);</span><br><span class="line">     ConcurrentHashMap.Segment var3 = <span class="keyword">this</span>.segmentForHash(var2);</span><br><span class="line">     <span class="keyword">return</span> var3 == <span class="keyword">null</span>?<span class="keyword">null</span>:var3.remove(var1, var2, (Object)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍旧是调用了Segment的remove方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object var1, <span class="keyword">int</span> var2, Object var3)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//获取锁</span></span><br><span class="line">     <span class="keyword">if</span>(!<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.scanAndLock(var1, var2);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Object var4 = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         ConcurrentHashMap.HashEntry[] var5 = <span class="keyword">this</span>.table;</span><br><span class="line">         <span class="keyword">int</span> var6 = var5.length - <span class="number">1</span> &amp; var2;</span><br><span class="line">         ConcurrentHashMap.HashEntry var7 = ConcurrentHashMap.entryAt(var5, var6);</span><br><span class="line">    </span><br><span class="line">         ConcurrentHashMap.HashEntry var10;</span><br><span class="line">         <span class="keyword">for</span>(ConcurrentHashMap.HashEntry var8 = <span class="keyword">null</span>; var7 != <span class="keyword">null</span>; var7 = var10) &#123;</span><br><span class="line">             <span class="comment">// 所有处于待删除节点之后的节点原样保留在链表中                </span></span><br><span class="line">             var10 = var7.next;</span><br><span class="line">             Object var9 = var7.key;</span><br><span class="line">             <span class="comment">//找到要删除的节点</span></span><br><span class="line">             <span class="keyword">if</span>(var7.key == var1 || var7.hash == var2 &amp;&amp; var1.equals(var9)) &#123;</span><br><span class="line">                 <span class="comment">// 所有处于待删除节点之前的节点被克隆到新链表中</span></span><br><span class="line">                 Object var11 = var7.value;</span><br><span class="line">                 <span class="keyword">if</span>(var3 != <span class="keyword">null</span> &amp;&amp; var3 != var11 &amp;&amp; !var3.equals(var11)) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">    </span><br><span class="line">                 <span class="keyword">if</span>(var8 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     ConcurrentHashMap.setEntryAt(var5, var6, var10);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     var8.setNext(var10);</span><br><span class="line">                 &#125;</span><br><span class="line">    </span><br><span class="line">                 ++<span class="keyword">this</span>.modCount;</span><br><span class="line">                 --<span class="keyword">this</span>.count;</span><br><span class="line">                  <span class="comment">// 把桶链接到新的头结点</span></span><br><span class="line">                 <span class="comment">// 新的头结点是原链表中，删除节点之前的那个节点</span></span><br><span class="line">                 var4 = var11;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">    </span><br><span class="line">             var8 = var7;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看两张图，执行删除前的原链表：</p><p><img src="http://i.imgur.com/L63CbqU.png" alt=""></p><p>删除之后的链表：</p><p><img src="http://i.imgur.com/3xwNdVt.png" alt=""></p><p>从上图可以看出，删除节点 C 之后的所有节点原样保留到新链表中；删除节点 C 之前的每个节点被克隆到新链表中，注意：它们在新链表中的链接顺序被反转了。</p><p>在执行 remove 操作时，原始链表并没有被修改，也就是说：读线程不会受同时执行 remove 操作的并发写线程的干扰。</p><p>综合上面的分析我们可以看出，写线程对某个链表的结构性修改不会影响其他的并发读线程对这个链表的遍历访问。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>ConcurrentHashMap 允许并发的读和线程安全的更新操作</li><li>在执行写操作时，ConcurrentHashMap 只锁住部分的Map</li><li>并发的更新是通过内部根据并发级别将Map分割成小部分实现的</li><li>高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争</li><li>ConcurrentHashMap 的所有操作都是线程安全</li><li>ConcurrentHashMap 返回的迭代器是弱一致性，fail-safe并且不会抛出ConcurrentModificationException异常</li><li>ConcurrentHashMap 不允许null的键值</li></ul><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们来看一下并发的Map，ConcurrentHashMap和ConcurrentSkipListMap。ConcurrentHashMap通常只被看做并发效率更高的Map，用来替换其他线程安全的Map容器，比如Hashtable和Collections.synchr
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二十一）----(JUC集合)CopyOnWriteArraySet和ConcurrentSkipListSet介绍</title>
    <link href="https://blog.rickiyang.cn/posts/5ee7a4a7.html"/>
    <id>https://blog.rickiyang.cn/posts/5ee7a4a7.html</id>
    <published>2017-04-06T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.137Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们来接着介绍JUC集合：CopyOnWriteArraySet和ConcurrentSkipListSet。从名字上来看我们知道CopyOnWriteArraySet与上一节讲到的CopyOnWriteArrayList一样是动态数组实现;ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。下面我们深入细致的分析一下他们的用法。</p><h4 id="1-CopyOnWriteArraySet简介"><a href="#1-CopyOnWriteArraySet简介" class="headerlink" title="1 CopyOnWriteArraySet简介"></a>1 CopyOnWriteArraySet简介</h4><p>它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。对其所有操作使用内部 CopyOnWriteArrayList 的 Set。因此，它共享以下相同的基本属性： </p><ol><li>它最适合于具有以下特征的应用程序：set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。  </li><li>它是线程安全的。</li><li>因为通常需要复制整个基础数组，所以可变操作（add、set 和 remove 等等）的开销很大。  迭代器不支持可变 remove操作。</li><li>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</li></ol><p>我们看一下CopyOnWriteArraySet的类体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5457747651344034263L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类有一个成员变量CopyOnWriteArrayList。CopyOnWriteArraySet其所有操作使用内部 CopyOnWriteArrayList 的 Set，所以他的所有的方法其实都是引用了CopyOnWriteArrayList的方法来完成的。有关CopyOnWriteArrayList的使用说明我们在上一节里已经介绍的很详细，有兴趣可以查看上一节里的源码介绍。</p><h4 id="2-ConcurrentSkipListSet简介"><a href="#2-ConcurrentSkipListSet简介" class="headerlink" title="2 ConcurrentSkipListSet简介"></a>2 ConcurrentSkipListSet简介</h4><p>ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。他是一个基于 ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。下面我们看一下方法体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2479143111061671589L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentNavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m = <span class="keyword">new</span> ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) ConcurrentSkipListSet继承于AbstractSet。因此，它本质上是一个集合。</p><p>(2) ConcurrentSkipListSet实现了NavigableSet接口。因此，ConcurrentSkipListSet是一个有序的集合。</p><p>(3) ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的。它包含一个ConcurrentNavigableMap对象m，而m对象实际上是ConcurrentNavigableMap的实现类ConcurrentSkipListMap的实例。ConcurrentSkipListMap中的元素是key-value键值对；而ConcurrentSkipListSet是集合，它只用到了ConcurrentSkipListMap中的key！</p><p>由源码中我们能看到ConcurrentSkipListSet内部所有操作都是在内部由ConcurrentSkipListMap完成。本节我们先不介绍ConcurrentSkipListMap，下节讲到map的时候再细说。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们来接着介绍JUC集合：CopyOnWriteArraySet和ConcurrentSkipListSet。从名字上来看我们知道CopyOnWriteArraySet与上一节讲到的CopyOnWriteArrayList一样是动态数组实现;ConcurrentSki
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十九）----(JUC集合)总体框架介绍</title>
    <link href="https://blog.rickiyang.cn/posts/c00aa264.html"/>
    <id>https://blog.rickiyang.cn/posts/c00aa264.html</id>
    <published>2017-04-04T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.142Z</updated>
    
    <content type="html"><![CDATA[<p>本节我们将继续学习JUC包中的集合类，我们知道jdk中本身自带了一套非线程安全的集合类，我们先温习一下java集合包里面的集合类，然后系统的看一下JUC包里面的集合类到底有什么不同。</p><h4 id="1-java集合类"><a href="#1-java集合类" class="headerlink" title="1 java集合类"></a>1 java集合类</h4><p>java集合类里面主要包含两大类：一类是Collection接口下的List、Set和Queue接口，一类是Map接口。</p><h5 id="1-1-List的主要实现类包括："><a href="#1-1-List的主要实现类包括：" class="headerlink" title="1.1 List的主要实现类包括："></a>1.1 List的主要实现类包括：</h5><pre><code>ArrayList：数组实现的队列，它是一个动态数组；它不是线程安全的，只适用于单线程；LinkedList：双重链表实现的队列，它也不是线程安全的，只适用于单线程；Stack：表示后进先出（LIFO）的对象堆栈，继承于Vector，他是线程安全的；Vector：可以实现可增长的对象数组，与数组一样，它包含可以使用整数索引进行访问的组件。此类是线程安全的。</code></pre><h5 id="1-2-Set的主要实现类包括："><a href="#1-2-Set的主要实现类包括：" class="headerlink" title="1.2 Set的主要实现类包括："></a>1.2 Set的主要实现类包括：</h5><pre><code>HashSet：由哈希表（实际上是一个 HashMap 实例）支持。该集合元素不可重复，它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变，并且此实现不是同步的；TreeSet：基于 TreeMap 的 NavigableSet 实现，也是一个没有重复元素的集合，不过和HashSet不同的是，TreeSet中的元素是有序的；该类的实现也不是同步的；LinkedHashSet：元素是有序的，维护着一个运行于所有条目的双重链接列表；此实现不是同步的；</code></pre><h5 id="1-3-Map的主要实现类包括："><a href="#1-3-Map的主要实现类包括：" class="headerlink" title="1.3 Map的主要实现类包括："></a>1.3 Map的主要实现类包括：</h5><pre><code>HashMap：基于哈希表的 Map 接口的实现。此实现不是同步的；TreeMap：基于红黑树（Red-Black tree）的 NavigableMap 实现，该类的&lt;k,v&gt;是有序的此实现不是同步的；HashTable：与HashMap一样都是基于哈希表的Map实现，但是此类是线程安全的；WeakHashMap：以弱键 实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。该类是非线程安全的。</code></pre><p>上面这些是传统的java集合类，他们大多数都不是线程安全的，所以在同步并发中对他们的使用率并不高，为了线程安全以及开发人员在使用集合工具的同时不必去维护线程安全，Doug Lea在JUC(java.util.concurrent)包中添加了java集合包中单线程类的对应的支持高并发的类。下面我们一起来看一下这些并发集合类。</p><h4 id="2-JUC集合类"><a href="#2-JUC集合类" class="headerlink" title="2 JUC集合类"></a>2 JUC集合类</h4><h5 id="2-1-List的主要实现类包括："><a href="#2-1-List的主要实现类包括：" class="headerlink" title="2.1 List的主要实现类包括："></a>2.1 List的主要实现类包括：</h5><p><img src="http://i.imgur.com/aOiGVFA.png" alt=""></p><p>CopyOnWriteArrayList：相当于线程安全的ArrayList，它实现了List接口，他是线程安全的。</p><h5 id="2-2-Set的主要实现类包括："><a href="#2-2-Set的主要实现类包括：" class="headerlink" title="2.2 Set的主要实现类包括："></a>2.2 Set的主要实现类包括：</h5><p><img src="http://i.imgur.com/1uyGObg.png" alt=""></p><p>CopyOnWriteArraySet：相当于线程安全的HashSet,内部使用 CopyOnWriteArrayList 。</p><p>ConcurrentSkipListSet:一个基于 ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现，内部排序是有序的。</p><h5 id="2-3-Map的主要实现类包括："><a href="#2-3-Map的主要实现类包括：" class="headerlink" title="2.3 Map的主要实现类包括："></a>2.3 Map的主要实现类包括：</h5><p><img src="http://i.imgur.com/yneZYBY.png" alt=""></p><p>ConcurrentHashMap：支持获取的完全并发和更新的所期望可调整并发的哈希表。</p><p>ConcurrentSkipListMap：可缩放的并发 ConcurrentNavigableMap 实现，内部排序是有序的Map，该类为线程安全的。</p><h5 id="2-4-Queue的主要实现类包括："><a href="#2-4-Queue的主要实现类包括：" class="headerlink" title="2.4 Queue的主要实现类包括："></a>2.4 Queue的主要实现类包括：</h5><p><img src="http://i.imgur.com/JvlUie1.png" alt=""></p><p>ArrayBlockingQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序；</p><p>LinkedBlockingQueue：一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO（先进先出）排序元素；</p><p>LinkedBlockingDeque：一个基于已链接节点的、任选范围的阻塞双端队列；</p><p>ConcurrentLinkedQueue：一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序；</p><p>ConcurrentLinkedDeque：是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。</p><p>下一节我们将一起详细的来分析JUC中的集合工具的使用和原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本节我们将继续学习JUC包中的集合类，我们知道jdk中本身自带了一套非线程安全的集合类，我们先温习一下java集合包里面的集合类，然后系统的看一下JUC包里面的集合类到底有什么不同。&lt;/p&gt;
&lt;h4 id=&quot;1-java集合类&quot;&gt;&lt;a href=&quot;#1-java集合类&quot; c
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十八）----(线程池)java线程池框架Fork-Join</title>
    <link href="https://blog.rickiyang.cn/posts/5f5c40c1.html"/>
    <id>https://blog.rickiyang.cn/posts/5f5c40c1.html</id>
    <published>2017-04-03T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.154Z</updated>
    
    <content type="html"><![CDATA[<p>这一节开始我们正式来介绍JUC集合类。我们按照List、Set、Map、Queue的顺序来进行介绍。这一节我们来看一下CopyOnWriteArrayList。</p><h4 id="1-CopyOnWriteArrayList介绍"><a href="#1-CopyOnWriteArrayList介绍" class="headerlink" title="1 CopyOnWriteArrayList介绍"></a>1 CopyOnWriteArrayList介绍</h4><p>CopyOnWriteArrayList是ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 </p><p>与ArrayList不同处就在于是否会拷贝数组和加锁。</p><p>CopyOnWriteArrayList顾名思义就是写时复制的ArrayList，其意思就是在修改容器的元素时，并不是直接在原数组上修改，而是先拷贝了一份数组，然后在拷贝的数组上进行修改，修改完后将其引用赋值给原数组的引用。这样体现了读写分离，这样无论在任何时候我们都可以对容器进行读取。</p><h4 id="2-CopyOnWriteArrayList源码分析"><a href="#2-CopyOnWriteArrayList源码分析" class="headerlink" title="2 CopyOnWriteArrayList源码分析"></a>2 CopyOnWriteArrayList源码分析</h4><p>我们看一下CopyOnWriteArrayList的类声明部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">         <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它实现了List接口，所以实现了Collection的功能，另外我们看到还有两个类成员变量lock和array，<br>在后面的源码分析中我们能看到CopyOnWriteArrayList是线程安全的使用动态数组操作机制实现的List。</p><p><strong>所谓动态数组操作机制</strong>：即通过volatile修饰的Object类型数组来进行数组的CRUD操作。在进行add,set,remove等可变操作的时候，都会先新建一个数组把更新的值赋给该数组，然后再传递给上面的array数组来保持该次操作的可见性。这也是CopyOnWriteArrayList命名的由来。这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，即在进行读操作时的效率要远远高于写或是修改操作，这种方法可能比其他替代方法更 有效。</p><p><strong>CopyOnWriteArrayList的线程安全实现</strong>：我们能看到是通过一个全局的Lock和volatile修饰的array来实现的。在进行add,remove,set等可变操作的时候通过赋值给array我们总能保证该变量的内存可见性，其他的线程每次总能读到最新的array变量；同样在每次进行add,remove,set等可变操作时候都会在操作的一开始加入独占锁，操作结束释放锁，以保证本次操作的安全性。</p><p>下面我们就上述分析来看一下他的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;  <span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Object[] elements = getArray();</span><br><span class="line">       <span class="keyword">int</span> len = elements.length;</span><br><span class="line">       <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+len);</span><br><span class="line">       Object[] newElements;</span><br><span class="line">       <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">       <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//如果是在最后一个位置增加就把该数组赋值一份然后新增一个长度</span></span><br><span class="line">           newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则新建数组，然后将"volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组"。</span></span><br><span class="line">           newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">           System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">           System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,numMoved);</span><br><span class="line">       &#125;</span><br><span class="line">       newElements[index] = element;</span><br><span class="line">       setArray(newElements); <span class="comment">//拷贝</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock = l.lock;<span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line">       checkForComodification();</span><br><span class="line">       E x = l.set(index+offset, element);</span><br><span class="line">       expectedArray = l.getArray();<span class="comment">//拷贝</span></span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; <span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Object[] elements = getArray();</span><br><span class="line">       <span class="keyword">int</span> len = elements.length;</span><br><span class="line">       E oldValue = get(elements, index);</span><br><span class="line">       <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。</span></span><br><span class="line">       <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">           setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 否则，新建数组，然后将"volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组"。</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">           System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">           System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,numMoved);</span><br><span class="line">           setArray(newElements); <span class="comment">//拷贝</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面源码部分我们可以看到CopyOnWriteArrayList在修改原数组的过程中比ArrayList多做了2件事：</p><p>1、加锁：保证我在修改数组的时候，其他人不能修改。</p><p>2、拷贝数组：无论是哪个方法，发现都需要拷贝数组。</p><p>上面的两件事就确保了CopyOnWriteArrayList在多线程的环境下可以应对自如。</p><p>我们再来看一下他的迭代器的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到迭代器里面调用了COWIterator这个类，下面来看一下他的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">     <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">         cursor = initialCursor;</span><br><span class="line">         snapshot = elements;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (! hasNext())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">         <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">         <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> cursor;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//不支持remove方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不支持set方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//不支持add方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到COWSubListIterator不支持修改元素的操作。例如，对于remove(),set(),add()等操作，COWSubListIterator都会抛出异常！</p><p>CopyOnWriteArrayList的迭代器并不是快速失败的，也就是说并不会抛出ConcurrentModificationException异常。这是因为他在修改的时候，是针对与拷贝数组而言的，对于原数组没有任何影响。我们可以看出迭代器里面没有锁机制，所以只提供读取，而不支持添加修改和删除（抛出UnsupportedOperationExcetion）。</p><h5 id="3-CopyOnWriteArrayList使用示例"><a href="#3-CopyOnWriteArrayList使用示例" class="headerlink" title="3 CopyOnWriteArrayList使用示例"></a>3 CopyOnWriteArrayList使用示例</h5><p>上面我们具体的分析了CopyOnWriteArrayList的线程安全机制和实现机制，我们再来就他的使用做一个相应的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyOnWriteArrayList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fixme: list是ArrayList对象时，程序会出错。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">/*private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> TestList(<span class="string">"aa"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        Iterator iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            value = (String)iter.next();</span><br><span class="line">            System.out.print(value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        TestList(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String val = Thread.currentThread().getName();</span><br><span class="line">            list.add(val);</span><br><span class="line">            printAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上程序，当list是ArrayList对象时，程序会出错，报出java.util.ConcurrentModificationException类型异常；当使用CopyOnWriteArrayList对象时，程序可以完成iterator遍历操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节开始我们正式来介绍JUC集合类。我们按照List、Set、Map、Queue的顺序来进行介绍。这一节我们来看一下CopyOnWriteArrayList。&lt;/p&gt;
&lt;h4 id=&quot;1-CopyOnWriteArrayList介绍&quot;&gt;&lt;a href=&quot;#1-CopyOn
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十八）----(线程池)java线程池框架Fork-Join</title>
    <link href="https://blog.rickiyang.cn/posts/5f5c40c1.html"/>
    <id>https://blog.rickiyang.cn/posts/5f5c40c1.html</id>
    <published>2017-04-03T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.136Z</updated>
    
    <content type="html"><![CDATA[<p>还记得我们在初始介绍线程池的时候提到了Executor框架的体系，到现在为止我们只有一个没有介绍，与ThreadPoolExecutor一样继承与AbstractExecutorService的ForkJoinPool.Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>我们通过表面的意思去理解ForkJoin框架：Fork即把一个大任务切割成若干部分并行执行，join即把这些被切分的任务的执行结果合并一起汇总，我们可以用下图来表示：</p><p><img src="http://i.imgur.com/CipMJZK.jpg" alt=""></p><p>Fork / Join的逻辑很简单：</p><pre><code>（1）将每个大任务分离（fork）为较小的任务; （2）在单独的线程中处理每个任务（如果必要，将它们分离成更小的任务）; （3）加入结果。</code></pre><p>Fork/Join框架的核心是由下列两个类组成的。</p><p>①ForkJoinPool：这个类实现了ExecutorService接口和工作窃取算法（Work-Stealing Algorithm）。它管理工作者线程，并提供任务的状态信息，以及任务的执行信息。</p><p>②ForkJoinTask：这个类是一个将在ForkJoinPool中执行的任务的基类。</p><p>理解一个概念的最好方法是在实践中体会他，我们先写一个小程序，在此基础上一点一点来分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        pool.submit(<span class="keyword">new</span> PrintTask(<span class="number">1</span>,<span class="number">100</span>));</span><br><span class="line">        pool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);<span class="comment">//阻塞当前线程直到 ForkJoinPool 中所有的任务都执行结束</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end - start &lt; <span class="number">50</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end; i++)&#123;</span><br><span class="line">                num += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"当前任务结果为： "</span>+num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (end + start)/<span class="number">2</span>;</span><br><span class="line">            PrintTask left = <span class="keyword">new</span> PrintTask(start,mid);</span><br><span class="line">            PrintTask right = <span class="keyword">new</span> PrintTask(mid+<span class="number">1</span>,end);</span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前任务结果为： <span class="number">3775</span></span><br><span class="line">当前任务结果为： <span class="number">1275</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们通过结果可以看到当前任务被分裂为两个子任务去执行。而执行任务的类继承了RecursiveAction这个类，那他到底在Fork-Join框架中发挥什么作用呢？我们不妨看一下：</p><p>首先我们来看一下Fork-Join框架提交任务的方法仍旧还是submit和execute：</p><pre><code>void execute(ForkJoinTask&lt;?&gt; task) //安排（异步）执行给定任务void execute(Runnable task) //在未来的某个时候执行给定的命令&lt;T&gt; ForkJoinTask&lt;T&gt; submit(Callable&lt;T&gt; task) //执行一个有返回值得任务，返回一个Future类型的实例代表任务的结果&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) //提交一个ForkJoinTask类型的任务ForkJoinTask&lt;?&gt; submit(Runnable task) //提交一个Runnable类型的任务，返回一个Future类型的实例代表任务结果 &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Runnable task, T result) //提交一个Runnable类型的任务，返回一个Future类型的实例代表任务结果 </code></pre><p>由execute和submit的参数我们可以看到Fork-join框架可以提交ForkJoinTask，Callable和Runnable类型的任务。这个ForkJoinTask我们之前没见过，先来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到ForkJoinTask实现了Future接口，一个ForkJoinTask是一个轻量级的Future。对ForkJoinTask效率源于一组限制（这只是部分静态强制执行）反映其用途作为计算任务计算纯函数或纯粹孤立的对象操作。主要的协调机制fork()，安排异步执行，而不进行join()，直到任务的结果已经计算。通常我们并不直接继承 ForkJoinTask，它包含了太多的抽象方法。针对特定的问题，我们可以选择 ForkJoinTask 的不同子类来完成任务：</p><pre><code>RecursiveAction：用于任务没有返回结果的场景。RecursiveTask：用于任务有返回结果的场景。</code></pre><p>上面的例子中我们就是继承了RecursiveAction子类用于没有返回结果的场景，下面我们再看一下RecursiveTask用于有返回结果的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRecursiveTask</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer result = <span class="number">0</span>;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> SumTask(<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result+<span class="string">"==========================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"生产完成"</span>+num+<span class="string">"个产品"</span>);</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            SumTask task1 = <span class="keyword">new</span> SumTask(<span class="number">20</span>);</span><br><span class="line">            SumTask task2 = <span class="keyword">new</span> SumTask(num - <span class="number">20</span>);</span><br><span class="line">            task1.fork();</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><pre><code>生产完成20个产品生产完成10个产品30===========================Process finished with exit code 0</code></pre><p>我们看到继承RecursiveTask类指定了返回值类型为Integer，在compute方法中的返回值类型即为Integer类型。</p><p>从以上的例子中可以看到，通过使用 Fork/Join 模式，软件开发人员能够方便地利用多核平台的计算能力。尽管还没有做到对软件开发人员完全透明，Fork/Join 模式已经极大地简化了编写并发程序的琐碎工作。对于符合 Fork/Join 模式的应用，软件开发人员不再需要处理各种并行相关事务，例如同步、通信等，以难以调试而闻名的死锁和 data race 等错误也就不会出现，提升了思考问题的层次。你可以把 Fork/Join 模式看作并行版本的 Divide and Conquer 策略，仅仅关注如何划分任务和组合中间结果，将剩下的事情丢给 Fork/Join 框架。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还记得我们在初始介绍线程池的时候提到了Executor框架的体系，到现在为止我们只有一个没有介绍，与ThreadPoolExecutor一样继承与AbstractExecutorService的ForkJoinPool.Fork/Join框架是Java7提供了的一个用于并行
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十七）----(线程池)java线程池架构和原理</title>
    <link href="https://blog.rickiyang.cn/posts/b9ed0404.html"/>
    <id>https://blog.rickiyang.cn/posts/b9ed0404.html</id>
    <published>2017-04-02T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.165Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们简单介绍了线程池的使用，但是对于其如何运行我们还不清楚，Executors为我们提供了简单的线程工厂类，但是我们知道ThreadPoolExecutor是线程池的具体实现类。我们先从他开始分析。</p><h4 id="1-ThreadPoolExecutor初探"><a href="#1-ThreadPoolExecutor初探" class="headerlink" title="1 ThreadPoolExecutor初探"></a>1 ThreadPoolExecutor初探</h4><p>ThreadPoolExecutor一共有3个构造方法，我们来看一下其中看起来比较复杂的这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来参数是挺多的，我们不妨耐心看看参数都是什么意思：</p><ol><li><p>corePoolSize：核心池的大小，默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p></li><li><p>maximumPoolSize：线程池最大线程数，它表示在线程池中最多能创建多少个线程；</p></li><li><p>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。</p></li><li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure><ol start="5"><li>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>threadFactory：是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法即可；</p></li><li><p>handler：表示当拒绝处理任务时的策略，也就是参数maximumPoolSize达到后丢弃处理的方法，java提供了4种丢弃处理的方法，当然你也可以自己根据实际情况去重写，主要是要实现接口：RejectedExecutionHandler中的方法： public void rejectedExecution(Runnabler, ThreadPoolExecutor e) java默认的是使用：AbortPolicy，他的作用是当出现这中情况的时候会抛出一个异常；有以下四种取值：    </p><p> ①ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</p><p> ②ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </p><p> ③ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p><p> ④ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p></li></ol><p>上面说了ThreadPoolExecutor的构造方法，我们继续看他的类的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码我们看出ThreadPoolExecutor继承了AbstractExecutorService类，我们知道AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上我们知道AbstractExecutorService又实现了ExecutorService接口，而ExecutorService是Executor实现类的最直接接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此我们似乎可以明白他们之间的关系：</p><ol><li>Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)；</li><li>ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；</li><li>抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；</li><li>ThreadPoolExecutor继承了类AbstractExecutorService，成为线程池的具体实现类。</li></ol><h4 id="2-线程池的实现"><a href="#2-线程池的实现" class="headerlink" title="2 线程池的实现"></a>2 线程池的实现</h4><p>上面我们从ThreadPoolExecutor的构造方法出发提到了线程池的状态，执行，初始化，排队策略等等，下面我们就从这些方面入手，看看线程池的原理。</p><h5 id="3-线程池初始化"><a href="#3-线程池初始化" class="headerlink" title="3 线程池初始化"></a>3 线程池初始化</h5><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务（execute或者submit）之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p><ul><li>prestartCoreThread()：初始化一个核心线程</li><li>prestartAllCoreThreads()：初始化所有核心线程</li></ul><p>下面是这两个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">            ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure><p>我们注意到上面两个方法都调用了addWorker方法，我们看一下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">   retry:</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">       <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">           ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">              firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">              ! workQueue.isEmpty()))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">           <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">               wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">               <span class="keyword">break</span> retry;</span><br><span class="line">           c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">           <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">               <span class="keyword">continue</span> retry;</span><br><span class="line">           <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">   Worker w = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">       w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">       <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">       <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mainLock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">               <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">               <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">               <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">               <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                   (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                   workers.add(w);</span><br><span class="line">                   <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                   <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                       largestPoolSize = s;</span><br><span class="line">                   workerAdded = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mainLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">               t.start();</span><br><span class="line">               workerStarted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">           addWorkerFailed(w);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法还是挺好理解：上面的retry是对当前线程池状态进行检查，如果当前线程池未初始化或者未分配则返回false；</p><p>往下是初始化firstTask，我们看到在56行把初始化的firstTask加入workers集合，该集合定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p>集合中包含当前所有的工作线程。<br>看完addWorker的实现，那么上面的prestartCoreThread和prestartAllCoreThreads我们就很好理解，前一个是向当前工作线程池中加入一个工作线程，后一个是循环N次。</p><h5 id="4-线程池的执行"><a href="#4-线程池的执行" class="headerlink" title="4 线程池的执行"></a>4 线程池的执行</h5><p>通常你得到线程池后，会调用其中的：submit方法或execute方法去操作；其实你会发现，submit方法最终会调用execute方法来进行操作，只是他提供了一个Future来托管返回值的处理而已，当你调用需要有返回值的信息时，你用它来处理是比较好的；这个Future会包装对Callable信息，并定义一个Sync对象（），当你发生读取返回值的操作的时候，会通过Sync对象进入锁，直到有返回值的数据通知。</p><p>我们先看一下submit方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">   <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">   RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">   execute(ftask);</span><br><span class="line">   <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在源码的第4行实际上是调用了execute()方法来处理包装的RunnableFuture。下面是execute方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个if为非空判断;</p><p>第二个if中的workerCountOf()方法拿到ctl中存储的当前线程总数，如果小于corePoolSize，那么就会走到addWorker()方法中，如果成功创建了Worker的话，那么返回true，直接return，否则重新通过cas拿一次c;</p><p>第三个if中判断当前的线程池是否处于RUNNING状态，如果是，并且workQueue.offer加入队列成功话，那么就重新拿出来一次ctl，再判断如果加入队列之后，线程池如果不是处于RUNNING的状态，并且从队列中remove成功的话，那么就会执行reject操作；判断当前线程数是否为0，如果为0的话，那么就调用addWorker(null,false)，否则如果非Running状态或者加入队列失败的话，那么就会调用addWorker(command,false)如果返回false，说明没有添加成功，就会执行reject操作。</p><h5 id="5-任务缓存队列"><a href="#5-任务缓存队列" class="headerlink" title="5 任务缓存队列"></a>5 任务缓存队列</h5><p>我们还记得ThreadPoolExecutor的构造函数中有一个参数workQueue，它用来存放等待执行的任务。<br>workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：</runnable></p><p>1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p><p>2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p><h5 id="6-线程池的关闭"><a href="#6-线程池的关闭" class="headerlink" title="6 线程池的关闭"></a>6 线程池的关闭</h5><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li><li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务<h5 id="7-线程池容量的动态调整"><a href="#7-线程池容量的动态调整" class="headerlink" title="7 线程池容量的动态调整"></a>7 线程池容量的动态调整</h5>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()</li></ul><p>setCorePoolSize：设置核心池大小</p><p>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</p><p>当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p><p>下面我们看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> produceTaskSleepTime = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> produceTaskMaxNumber = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造一个线程池</span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= produceTaskMaxNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String task = <span class="string">"task-- "</span> + i;</span><br><span class="line">                System.out.println(<span class="string">"创建任务并提交到线程池中："</span> + task);</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> ThreadPoolTask(task));</span><br><span class="line">                System.out.println(<span class="string">"线程池中线程数目："</span>+threadPool.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">                       threadPool.getQueue().size()+<span class="string">"，已执行完毕的任务数目："</span>+threadPool.getCompletedTaskCount());</span><br><span class="line"></span><br><span class="line">                Thread.sleep(produceTaskSleepTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object attachData;</span><br><span class="line"></span><br><span class="line">    ThreadPoolTask(Object tasks) &#123;</span><br><span class="line">        <span class="keyword">this</span>.attachData = tasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"开始执行任务："</span> + attachData);</span><br><span class="line"></span><br><span class="line">        attachData = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attachData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line"></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">1</span></span><br><span class="line">开始执行任务：task-- <span class="number">1</span></span><br><span class="line">线程池中线程数目：<span class="number">1</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行完毕的任务数目：<span class="number">0</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">2</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行完毕的任务数目：<span class="number">1</span></span><br><span class="line">开始执行任务：task-- <span class="number">2</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">3</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">2</span></span><br><span class="line">开始执行任务：task-- <span class="number">3</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">4</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">3</span></span><br><span class="line">开始执行任务：task-- <span class="number">4</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">5</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">4</span></span><br><span class="line">开始执行任务：task-- <span class="number">5</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">6</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">5</span></span><br><span class="line">开始执行任务：task-- <span class="number">6</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">7</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">6</span></span><br><span class="line">开始执行任务：task-- <span class="number">7</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">8</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行完毕的任务数目：<span class="number">7</span></span><br><span class="line">开始执行任务：task-- <span class="number">8</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">9</span></span><br><span class="line">开始执行任务：task-- <span class="number">9</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行完毕的任务数目：<span class="number">8</span></span><br><span class="line">创建任务并提交到线程池中：task-- <span class="number">10</span></span><br><span class="line">开始执行任务：task-- <span class="number">10</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行完毕的任务数目：<span class="number">9</span></span><br></pre></td></tr></table></figure><p>由结果我们可以看到当线程池中线程的数目大于2时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们简单介绍了线程池的使用，但是对于其如何运行我们还不清楚，Executors为我们提供了简单的线程工厂类，但是我们知道ThreadPoolExecutor是线程池的具体实现类。我们先从他开始分析。&lt;/p&gt;
&lt;h4 id=&quot;1-ThreadPoolExecutor初探&quot;
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十六）----(线程池)java线程池的使用</title>
    <link href="https://blog.rickiyang.cn/posts/e7e539b9.html"/>
    <id>https://blog.rickiyang.cn/posts/e7e539b9.html</id>
    <published>2017-03-28T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.161Z</updated>
    
    <content type="html"><![CDATA[<p>上节我们简单介绍了线程池，这次我们就来使用一下。Executors提供四种线程池，分别是：newCachedThreadPool，newFixedThreadPool ，newScheduledThreadPool ，newSingleThreadExecutor 。下面我们分别来使用下。</p><h4 id="1-newSingleThreadExecutor"><a href="#1-newSingleThreadExecutor" class="headerlink" title="1 newSingleThreadExecutor"></a>1 newSingleThreadExecutor</h4><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>我们来看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newSingleThreadExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService ex = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                    System.out.println(Thread.currentThread().getName());                           </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1</code></pre><p>由输出结果可以看出始终只有一个线程在工作。</p><h4 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2 newFixedThreadPool"></a>2 newFixedThreadPool</h4><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><p>我们来看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newFixedThreadPoolTest</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService ex = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-1pool-1-thread-2pool-1-thread-2pool-1-thread-5pool-1-thread-3pool-1-thread-3pool-1-thread-3pool-1-thread-3pool-1-thread-3pool-1-thread-4</code></pre><p>我们启动了10个线程，但是池中只有5个线程工作，所以结果中最多只有5个线程。</p><h4 id="3-newCachedThreadPool"><a href="#3-newCachedThreadPool" class="headerlink" title="3 newCachedThreadPool"></a>3 newCachedThreadPool</h4><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，<br>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p><p>我们来看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newCachedThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService ex = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1</code></pre><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。但是如果执行第二个任务时第一个任务没有完成则又是另一番景象，我们把上面的例子稍稍改一下就有所不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newCachedThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService ex = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-1pool-1-thread-3pool-1-thread-2pool-1-thread-5pool-1-thread-4pool-1-thread-6pool-1-thread-7pool-1-thread-8pool-1-thread-9pool-1-thread-10</code></pre><p>第一个任务在执行的时候等待了6秒，所以此时第二个任务执行的时候则是新建一个线程来执行。</p><h4 id="4-newScheduledThreadPool"><a href="#4-newScheduledThreadPool" class="headerlink" title="4 newScheduledThreadPool"></a>4 newScheduledThreadPool</h4><p>创建一个大小无限的线程池。此线程池支持定时以及<strong>周期性执</strong>行任务的需求。        </p><p>在上一篇类类的关系图中我们可以看到该方法直接实现了ScheduledExecutorService接口，而该接口相当于提供了”延时”和”周期执行”功能的ExecutorService，再来看一下该方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值是ScheduledExecutorService类型的，与其他3个方法不同，需要注意。我们来看一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newScheduledThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService ex = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.schedule(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//定时执行的线程池</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="number">2</span>, TimeUnit.SECONDS); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre><code>pool-1-thread-2pool-1-thread-4pool-1-thread-1pool-1-thread-5pool-1-thread-3pool-1-thread-2pool-1-thread-3pool-1-thread-5pool-1-thread-1pool-1-thread-4</code></pre><p>启动后会延迟2s之后才开始执行。</p><p>我们再来看一个周期性执行的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newScheduledThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService ex = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ex.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//延迟3s后每2s周期性执行一次，不停</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="number">3</span>,<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>pool-1-thread-3pool-1-thread-4pool-1-thread-2pool-1-thread-5pool-1-thread-1...</code></pre><p>newScheduledThreadPool中有很多另外3个类中没有的方法，我们来看一下：</p><ol><li><p>shedule(Runnable command, long delay, TimeUnit unit): 延迟一定时间后执行Runnable任务；</p></li><li><p>schedule(Callable callable, long delay, TimeUnit unit): 延迟一定时间后执行Callable任务；</p></li><li><p>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit):  延迟一定时间后，以间隔period时间的频率周期性地执行任务；</p></li><li><p>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit):  与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，也就是这一些任务系列的触发时间都是可预知的。</p></li></ol><p>由上我们看到ScheduledExecutorService在执行定时任务方面还是挺强大的。线程池的使用我们就到这里，其实用了这么多我们只是在调用别人写好的方法，但是对于线程池是如何实现的我们还是未知的，下一节我们就深入的去分析线程池的实现，看看到底有什么高深莫测。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上节我们简单介绍了线程池，这次我们就来使用一下。Executors提供四种线程池，分别是：newCachedThreadPool，newFixedThreadPool ，newScheduledThreadPool ，newSingleThreadExecutor 。下面我
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>（十五）----(线程池)java线程池简介</title>
    <link href="https://blog.rickiyang.cn/posts/d72ca9c5.html"/>
    <id>https://blog.rickiyang.cn/posts/d72ca9c5.html</id>
    <published>2017-03-27T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.160Z</updated>
    
    <content type="html"><![CDATA[<p>好的软件设计不建议手动创建和销毁线程。线程的创建和销毁是非常耗 CPU 和内存的，因为这需要 JVM 和操作系统的参与。64位 JVM 默认线程栈是大小1 MB。这就是为什么说在请求频繁时为每个小的请求创建线程是一种资源的浪费。线程池可以根据创建时选择的策略自动处理线程的生命周期。重点在于：在资源（如内存、CPU）充足的情况下，线程池没有明显的优势，否则没有线程池将导致服务器崩溃。有很多的理由可以解释为什么没有更多的资源。例如，在拒绝服务（denial-of-service）攻击时会引起的许多线程并行执行，从而导致线程饥饿（thread starvation）。除此之外，手动执行线程时，可能会因为异常导致线程死亡，程序员必须记得处理这种异常情况。这时我们需要一个管理线程的工具—-线程池应运而生。</p><p>在 Java 5 之后，并发编程引入了一堆新的启动、调度和管理线程的API。Executor 框架便是 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用 Executor 在构造器中。</p><h4 id="1-Executor简介"><a href="#1-Executor简介" class="headerlink" title="1 Executor简介"></a>1 Executor简介</h4><p>我们先看一下Execotor框架的体系：</p><p><img src="http://i.imgur.com/CIzy36s.png" alt=""></p><p>Executor: 所有线程池的接口,只有一个方法。</p><pre><code>void execute(Runnable command);</code></pre><p><strong>ExecutorService</strong>: 增加Executor的行为，是Executor实现类的最直接接口。</p><p><strong>AbstractExecutorService</strong>：AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。</p><p><strong>ScheduledExecutorService</strong>：ScheduledExecutorService是一个接口，它继承于ExecutorService。它相当于提供了”延时”和”周期执行”功能的ExecutorService。ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。</p><p><strong>ForkJoinPool</strong> ：ForkJoinPool 是 Java SE 7 新功能“分叉/结合框架”的核心类，专用于需要将一个任务不断分解成子任务（分叉），再不断进行汇总得到最终结果（结合）的计算过程。比起传统的线程池类ThreadPoolExecutor，ForkJoinPool 实现了工作窃取算法，使得空闲线程能够主动分担从别的线程分解出来的子任务，从而让所有的线程都尽可能处于饱满的工作状态，提高执行效率。</p><p><strong>ScheduledThreadPoolExecutor</strong>：ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了”延时”和”周期执行”功能的ScheduledExecutorService。ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。</p><p><strong>Executors</strong>：Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。</p><p><strong>ThreadPoolExecutor</strong>：线程池的具体实现类,一般用的各种线程池都是基于这个类实现的。</p><p>构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><p>corePoolSize - 池中所保存的线程数，包括空闲线程。</p><p>maximumPoolSize - 池中允许的最大线程数。</p><p>keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</p><p>unit - keepAliveTime 参数的时间单位。</p><p>workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。 </p><p>该方法作用为：用给定的初始参数和默认的线程工厂及被拒绝的执行处理程序创建新的 ThreadPoolExecutor。但是使用 Executors 工厂方法比使用此通用构造方法方便得多。（所以一般不用这个方法）</p><p><strong>由该方法我们可以看出一般线程池的工作方式为：</strong></p><p>①线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p><p>②当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><p>⒈如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p><p>⒉如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p><p>⒊如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p><p>⒋如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</p><p>⒌当一个线程完成任务时，它会从队列中取下一个任务来执行。</p><p>⒍当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><h4 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2 线程池"></a>2 线程池</h4><h5 id="2-1-线程池的作用："><a href="#2-1-线程池的作用：" class="headerlink" title="2.1 线程池的作用："></a>2.1 线程池的作用：</h5><p>线程池作用就是限制系统中执行线程的数量。</p><p> 根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。</p><h5 id="2-2-为什么要用线程池"><a href="#2-2-为什么要用线程池" class="headerlink" title="2.2 为什么要用线程池:"></a>2.2 为什么要用线程池:</h5><p>1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p><p>2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。<br><strong>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService</strong>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p><p>1.<strong>newSingleThreadExecutor</strong></p><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>2.<strong>newFixedThreadPool</strong></p><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><p>3.<strong>newCachedThreadPool</strong></p><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，<br>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p><p>4.<strong>newScheduledThreadPool</strong><br>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><p>下节我们分别介绍这些工厂类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好的软件设计不建议手动创建和销毁线程。线程的创建和销毁是非常耗 CPU 和内存的，因为这需要 JVM 和操作系统的参与。64位 JVM 默认线程栈是大小1 MB。这就是为什么说在请求频繁时为每个小的请求创建线程是一种资源的浪费。线程池可以根据创建时选择的策略自动处理线程的生
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十三）----(JUC原子类)引用类型介绍（CAS和ABA的介绍）</title>
    <link href="https://blog.rickiyang.cn/posts/579efe75.html"/>
    <id>https://blog.rickiyang.cn/posts/579efe75.html</id>
    <published>2017-03-25T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.166Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们将探讨引用类型原子类：AtomicReference, AtomicStampedRerence, AtomicMarkableReference。AtomicReference的使用非常简单，根据API我们就可以知道如何用，但是后两个从名字上看起来感觉是很难的样子，其实只是他的样子长得有点吓人，并且确实发挥了很大的作用（解决了ABA问题）。所以并没有那么可怕，就让我们一起来克服困难吧。</p><h4 id="1-AtomicReference简介"><a href="#1-AtomicReference简介" class="headerlink" title="1 AtomicReference简介"></a>1 AtomicReference简介</h4><p>AtomicReference的使用非常简单，首先我们来看一下他的方法：</p><pre><code>构造函数：AtomicReference()               //使用 null 初始值创建新的 AtomicReference。 AtomicReference(V initialValue) //使用给定的初始值创建新的 AtomicReference。 方法：boolean compareAndSet(V expect, V update) //如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 V get()                        //获取当前值。 V getAndSet(V newValue)        //以原子方式设置为给定值，并返回旧值。 void lazySet(V newValue)       //最终设置为给定值。 void set(V newValue)           //设置为给定值。 String toString()              //返回当前值的字符串表示形式。 boolean weakCompareAndSet(V expect, V update) // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 </code></pre><p>下面我们看一个例子来了解下使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference atomic1 = <span class="keyword">new</span> AtomicReference();</span><br><span class="line">        atomic1.set(<span class="string">"aaa"</span>);</span><br><span class="line">        atomic1.set(<span class="keyword">new</span> StringBuffer(<span class="string">"str"</span>));</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"name"</span>,<span class="string">"xiaoming"</span>);</span><br><span class="line">        atomic1.set(map);</span><br><span class="line">        System.out.println(atomic1.get());</span><br><span class="line"></span><br><span class="line">        String[] s = &#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>&#125;;</span><br><span class="line">        AtomicReference atomic2 = <span class="keyword">new</span> AtomicReference(s);</span><br><span class="line">        System.out.println(atomic2.get());</span><br><span class="line">        atomic2.set(atomic1);</span><br><span class="line">        System.out.println(atomic2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>{name=xiaoming}[Ljava.lang.String;@766e119d{name=xiaoming}Process finished with exit code 0</code></pre><p>由上面程序我们可以看到：AtomicReference可以set任何类型的值并且都是以原子的形式操作的。</p><h4 id="2-CAS和ABA"><a href="#2-CAS和ABA" class="headerlink" title="2 CAS和ABA"></a>2 CAS和ABA</h4><p>在介绍AtomicStampedRerence, AtomicMarkableReference之前我们的先谈一谈CAS和ABA的问题，因为这两个类的设计就是为了避免CAS操作中的ABA问题而设计的.</p><h5 id="2-1-CAS-原子操作的基石"><a href="#2-1-CAS-原子操作的基石" class="headerlink" title="2.1 CAS 原子操作的基石"></a>2.1 CAS 原子操作的基石</h5><p>我们知道之前我们学过的Synchronized是一种独占锁。一个线程获得该锁，那么其余的线程只能等待该线程释放锁才能获得。这其实是一种悲观锁的形式。那么乐观锁是如何实现的呢？乐观锁是每次都不加锁，假设完成某项任务没有冲突。如果因为冲突失败那就重试，直到成功为止。</p><p>今天我们要说的CAS就是<strong>乐观锁的实现机制</strong>。可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><p>CAS:Compare and Swap，这个操作用C语言来描述就是下面这个样子（代码来自Wikipedia的Compare And Swap词条）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval)</span><br><span class="line">     *reg = newval;</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思就是说，看一看内存*reg里的值是不是oldval，如果是的话，则对其赋值newval。</p><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><p>在使用上，通常会记录下某块内存中的旧值，通过对旧值进行一系列的操作后得到新值，然后通过CAS操作将新值与旧值进行交换。如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行 使内存中的数据变为新值。如果内存中的值在这期间内被修改过，则一般来说旧值会与内存中的数据不同，这时CAS操作将会失败，新值将不会被写入内存。</p><h5 id="2-2-原子操作"><a href="#2-2-原子操作" class="headerlink" title="2.2 原子操作"></a>2.2 原子操作</h5><p>虽然我们是在用java语言去执行原子操作，但是最终还是对应到处理器上去执行。那么在处理器上是如何执行原子操作的呢？</p><p>32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><p><strong>第一个机制是通过总线锁保证原子性。</strong>。如果多个处理器同时对共享变量进行读改写（i++就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致，举个例子：如果i=1,我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。</p><p>原因是有可能多个处理器同时从各自的缓存中读取变量i，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p><p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。</p><p><strong>第二个机制是通过缓存锁定保证原子性</strong>。在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p><p>上面说了cpu的原子操作是如何实现的，那么在java中一定也有相应的方法去驱动处理器来实现原子操作。JUC包中的原子类都是基于CAS来实现的，我们不妨以AtomicInteger为例来跟踪一下，看看到底是如何实现原子操作的。</p><p>首先我们能看到在AtomicInteger中的value值是这样定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>我们再来看他的get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回value值，说明在无锁的情况下，通过volatile来做控制，保证值是可见的。</p><p>下面我们接着看一下i++在原子类中是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, newValue))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到，首先把volatile修饰的内存中的原始值赋值给当前变量，为了下面compareAndSet方法拿内存中的值和新值比较进行CAS操作。所以关键就在于这个compareAndSet（）方法，我们接着进入这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到compareAndSet方法中返回的是unsafe类的方法，我们知道java不能直接访问操作系统底层，而是通过本地方法来访问。<strong>Unsafe类提供了硬件级别的原子操作</strong>，这就与硬件相挂钩了。由此我们从java到处理器的通道就打通了。</p><p>具体的compareAndSwapInt()方法的实现属于JDK底层的实现，我们在此不多做说明，有兴趣的可以查阅相关资料，看java的底层c语言源码。大致的过程我们可以说明如下：CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Java并发包(java.util.concurrent)中大量使用了CAS操作,<strong>涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作</strong>。</p><h5 id="2-3-ABA问题"><a href="#2-3-ABA问题" class="headerlink" title="2.3 ABA问题"></a>2.3 ABA问题</h5><p>上面我们结合着处理器对原子操作的处理机制一起讲了java对原子操作的处理方式，那么难道这种方式就一定是完美的吗。下面我们举出一种情况大家分析看看：</p><ol><li>进程P1在共享变量中读到值为A</li><li>P1被抢占了，进程P2执行</li><li>P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。</li><li>P1回来看到共享变量里的值没有被改变，于是继续执行。</li></ol><p>你觉得这会出现什么问题呢？我们知道java底层代码都是用c语言实现的，虽然java中没有指针，但不代表java底层代码中没有使用。虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，<strong>因为CAS判断的是指针的地址</strong>（c语言的特性）。如果这个地址被重用了呢，问题就很大了。</p><p>现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B:</p><p><img src="http://i.imgur.com/WHz1hpa.png" alt=""></p><p>在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A，此时堆栈结构如下图，而对象B此时已经出栈：</p><p><img src="http://i.imgur.com/JHnfHNT.png" alt=""></p><p>在CAS中c语言的堆栈实现过程大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">push(node):</span><br><span class="line"> curr := head</span><br><span class="line">  old := curr</span><br><span class="line">  node-&gt;next = curr</span><br><span class="line">  <span class="keyword">while</span> (old != (curr = CAS(&amp;head, curr, node))) &#123;</span><br><span class="line">      old = curr</span><br><span class="line">      node-&gt;next = curr</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">pop():</span><br><span class="line">   curr := head</span><br><span class="line">   old := curr</span><br><span class="line">   next = curr-&gt;next</span><br><span class="line">   <span class="keyword">while</span> (old != (curr = CAS(&amp;head, curr, next))) &#123;</span><br><span class="line">       old = curr</span><br><span class="line">       next = curr-&gt;next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure><p>假如，在pop函数中，next = curr-&gt;next 和 while之间，线程被切换走，此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，<strong>但实际上B.next为null，即while此时还没有执行呢</strong>，所以此时的情况变为：</p><p><img src="http://i.imgur.com/ANevGLg.png" alt=""></p><p>其中堆栈中只有B元素的引用地址，C和D组成的链表不再存在于堆栈中，平白无故就把C、D丢掉了。</p><p>如果这个例子你没有看懂的话，我可以再举出一个生活中的例子：</p><p><em>你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。</em></p><p>以上就是ABA问题。</p><h4 id="3-解决ABA问题之道"><a href="#3-解决ABA问题之道" class="headerlink" title="3 解决ABA问题之道"></a>3 解决ABA问题之道</h4><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。<strong>ABA问题的解决思路就是使用版本号</strong>。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 为了避免CAS过程中的ABA问题，并发包提供了两个类，AtomicStampedReference和AtomicMarkableReference。前者相当于一个[引用,integer]的二元组，后者相当于一个[引用,boolean]的二元组。<br>AtomicStampedReference可用来作为带版本号的原子引用，而AtomicMarkableReference可用于表示已删除的节点。</p><p>这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。  </p><p>我们先来看一下AtomicStampedReference的方法，AtomicStampedReference 维护带有整数“标志”的对象引用，可以用原子方式对其进行更新：</p><pre><code>构造方法：AtomicStampedReference(V initialRef, int initialStamp) //创建具有给定初始值的新 AtomicStampedReference方法： boolean attemptStamp(V expectedReference, int newStamp) //如果当前引用 == 预期引用，则以原子方式将该标志的值设置为给定的更新值。 boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) //如果当前引用 == 预期引用，并且当前标志等于预期标志，                                                                                则以原子方式将该引用和该标志的值设置为给定的更新值。 V get(int[] stampHolder)   //返回该引用和该标志的当前值。 V getReference()           //返回该引用的当前值。 int getStamp()             // 返回该标志的当前值。 void set(V newReference, int newStamp) // 无条件地同时设置该引用和标志的值。 boolean weakCompareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) //如果当前引用 == 预期引用，并且当前标志等于预期标志，则以原子方式将该引用和该标志的值设置为给定的更新值。</code></pre><p>看来看一下AtomicMarkableReference的方法：</p><p>构造方法：<br>    AtomicMarkableReference(V initialRef, boolean initialMark) //创建具有给定初始值的新 AtomicMarkableReference。</p><p>方法：<br>    boolean attemptMark(V expectedReference, boolean newMark) //如果当前引用 == 预期引用，则以原子方式将该标记的值设置为给定的更新值。<br>    boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) //如果当前引用 == 预期引用，并且当前标记等于预期标记，那么以原子方式将引用和标记的值设置为给定的更新值。<br>    V get(boolean[] markHolder) // 返回该引用和该标记的当前值。<br>    V getReference() //返回该引用的当前值。<br>    boolean isMarked() //返回该标记的当前值。<br>    void set(V newReference, boolean newMark) //无条件地同时设置该引用和标记的值。<br>    boolean weakCompareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) //如果当前引用 == 预期引用，并且当前标记等于预期标记，那么以原子方式将引用和标记的值设置为给定的更新值。 </p><p>AtomicMarkableReference类描述的一个(Object,Boolean)的对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。</p><p>AtomicStampedReference类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比AtomicMarkableReference类的(Object,Boolean)，AtomicStampedReference维护的是一种类似(Object,int)的数据结构，其实就是对对象（引用）的一个并发计数。但是与AtomicInteger不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。</p><p>下面我们就AtomicStampedReference 的使用举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInt = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">        atomicInt.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">        atomicInt.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"new value = "</span> + atomicInt.get());</span><br><span class="line">        <span class="keyword">boolean</span> result1 = atomicInt.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">        System.out.println(result1); <span class="comment">// result:true</span></span><br><span class="line"></span><br><span class="line">        AtomicInteger v1 = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">        AtomicInteger v2 = <span class="keyword">new</span> AtomicInteger(<span class="number">101</span>);</span><br><span class="line">        AtomicStampedReference&lt;AtomicInteger&gt; stampedRef = <span class="keyword">new</span> AtomicStampedReference&lt;AtomicInteger&gt;(v1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> stamp = stampedRef.getStamp();</span><br><span class="line">        stampedRef.compareAndSet(v1, v2, stampedRef.getStamp(),</span><br><span class="line">                stampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(stampedRef.getStamp());</span><br><span class="line">        stampedRef.compareAndSet(v2, v1, stampedRef.getStamp(),</span><br><span class="line">                stampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"new value = "</span> + stampedRef.getReference());</span><br><span class="line">        <span class="keyword">boolean</span> result2 = stampedRef.compareAndSet(v1, v2, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">        System.out.println(result2); <span class="comment">// result:false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre><code>new value = 100true1new value = 100falseProcess finished with exit code 0</code></pre><p>上面的输出结果可以看到AtomicInteger 执行cas操作成功，AtomicStampedReference执行cas操作失败。我们可以看到在24行compareAndSet(v1, v2, stamp, stamp + 1)中第三个参数期待的标志位值为1，但是经过上面两次的值变更，stampedRef.getStamp()已经是2了，所以此刻期待值与内存中的标志位值不符，操作失败。</p><p>AtomicMarkableReference的使用方法也是类似，在此就不另做介绍，大家可以多多使用才会知道这些类所带来的好处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们将探讨引用类型原子类：AtomicReference, AtomicStampedRerence, AtomicMarkableReference。AtomicReference的使用非常简单，根据API我们就可以知道如何用，但是后两个从名字上看起来感觉是很难的样
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十四）----(JUC原子类)对象的属性修改类型介绍</title>
    <link href="https://blog.rickiyang.cn/posts/58721c94.html"/>
    <id>https://blog.rickiyang.cn/posts/58721c94.html</id>
    <published>2017-03-25T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.141Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们介绍原子类的最后一个类型—-对象的属性修改类型: AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicReferenceFieldUpdater。有了这几个方法，普通的变量也能享受原子操作了。</p><h4 id="1-开胃菜"><a href="#1-开胃菜" class="headerlink" title="1 开胃菜"></a>1 开胃菜</h4><p>由API我们知道AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater通过反射原子更新对象的字段,既然他们的作用是更新字段我们知道有些类型的字段是不可被更新的，所以被更新的字段是有一定的要求：</p><p style="color:red"><br>1. 必须是volatile类型（volatile是线程可见变量，保存在Jvm的主内存中，而不是线程的工作内存里面），<br><br>2. 字段的描述类型（修饰符public/protected/default/private）是调用者与操作对象字段的关系一致，<br><br>3. 只能是实例变量，不能是类变量，也就是说不能加static关键字，<br><br>4. 只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在，<br><br>5. 对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</p><h4 id="2-使用它"><a href="#2-使用它" class="headerlink" title="2 使用它"></a>2 使用它</h4><p>上面我们说了这几个类的作用是让普通类型的字段也能享受到原子操作，假如原本有一个变量是int型，并且很多地方都应用了这个变量，但是在某个场景下，想让int型变成AtomicInteger，但是如果直接改类型，就要改其他地方的应用。AtomicIntegerFieldUpdater就是为了解决这样的问题产生的。</p><p>AtomicIntegerFieldUpdater，AtomicLongFieldUpdater分别是对int和long类型的字段操作，AtomicReferenceFieldUpdater是对引用型的对象操作，并且在API中他们的操作方法与普通的AtomicInteger差不多，所以方法我就不再罗列，我们就直接使用吧。</p><p>我们来看AtomicIntegerFieldUpdater的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* allscore 如果和 score 的结果相同则说明线程是安全的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AA&gt; vv = AtomicIntegerFieldUpdater.newUpdater(AA.class, <span class="string">"score"</span>); <span class="comment">//newUpdater方法为AA类中的score 对象创造一个更新器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger allscore = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AA stu = <span class="keyword">new</span> AA();</span><br><span class="line">        Thread[] t = <span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i] = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Math.random()&gt;<span class="number">0.4</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        vv.incrementAndGet(stu);</span><br><span class="line">                        allscore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"score="</span>+stu.getScore());</span><br><span class="line">        System.out.println(<span class="string">"allscore="</span>+allscore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>score=6032allscore=6032</code></pre><p>AtomicIntegerFieldUpdater包装过的int类型的score与 AtomicInteger 的allscore输出的值是一样的，足以见他们所起到的作用是一样。</p><p>我们说了AtomicIntegerFieldUpdater,那么AtomicLongFieldUpdater与它的用法大同小异，就不再说明。我们说这几个类是基于反射的实用工具，那么到底是怎么个反射法呢，我们不妨看看源码体验一下，上面用到了AtomicIntegerFieldUpdater.newUpdater()方法来指定类中的字段，我们不妨看看这个newUpdater是怎么执行的：</p><p>newUpdater（）方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass, String fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;(tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在newUpdater方法上有一个注解：@CallerSensitive，关于这个注解我们可以探究一天的，暂时先埋一个伏笔哈，我们直接跟进去AtomicIntegerFieldUpdaterImpl方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AtomicIntegerFieldUpdaterImpl(Class&lt;T&gt; tclass, String fieldName, Class&lt;?&gt; caller) &#123;</span><br><span class="line">    Field field = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> modifiers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        field = tclass.getDeclaredField(fieldName);</span><br><span class="line">        modifiers = field.getModifiers();</span><br><span class="line">        sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">            caller, tclass, <span class="keyword">null</span>, modifiers);</span><br><span class="line">        sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class fieldt = field.getType();</span><br><span class="line">    <span class="keyword">if</span> (fieldt != <span class="keyword">int</span>.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be integer type"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be volatile type"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                   caller != tclass) ? caller : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.tclass = tclass;</span><br><span class="line">    offset = unsafe.objectFieldOffset(field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能看到该类里面都是我们常见到的反射的机制，除了sun.reflect.misc.ReflectUtil这个包里面的我们没用到以外。</p><p>我们再看一下AtomicReferenceFieldUpdater的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         TestAA testAA = <span class="keyword">new</span> TestAA(<span class="string">"xiaoming"</span>,<span class="string">"nv"</span>,<span class="number">12</span>);</span><br><span class="line">         AtomicReferenceFieldUpdater Updater = AtomicReferenceFieldUpdater.newUpdater(TestAA.class,String.class,<span class="string">"name"</span>)；</span><br><span class="line">         Updater.compareAndSet(testAA,testAA.name,<span class="string">"liming"</span>);</span><br><span class="line">         System.out.println(testAA.getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAA</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="keyword">volatile</span> String sex;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestAA</span><span class="params">(String name, String sex, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>limingProcess finished with exit code 0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们介绍原子类的最后一个类型—-对象的属性修改类型: AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicReferenceFieldUpdater。有了这几个方法，普通的变量也能享受原子操作了。&lt;/p&gt;
&lt;h4
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十二）----(JUC原子类)数组类型介绍</title>
    <link href="https://blog.rickiyang.cn/posts/f9388b3f.html"/>
    <id>https://blog.rickiyang.cn/posts/f9388b3f.html</id>
    <published>2017-03-25T04:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.140Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们介绍过三个基本类型的原子类，这次我们来看一下数组类型： AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray。其中前两个的使用方式差不多，AtomicReferenceArray因为他的参数为引用数组，所以跟前两个的使用方式有所不同。</p><h4 id="1-AtomicLongArray介绍"><a href="#1-AtomicLongArray介绍" class="headerlink" title="1 AtomicLongArray介绍"></a>1 AtomicLongArray介绍</h4><p>对于AtomicLongArray, AtomicIntegerArray我们还是只介绍一个，另一个使用方式大同小异。</p><p>我们先来看看AtomicLongArray的构造函数和方法：</p><pre><code>构造函数：    AtomicLongArray(int length) //创建给定长度的新 AtomicLongArray。     AtomicLongArray(long[] array) //创建与给定数组具有相同长度的新 AtomicLongArray，并从给定数组复制其所有元素。     方法：     long addAndGet(int i, long delta) //以原子方式将给定值添加到索引 i 的元素。      boolean compareAndSet(int i, long expect, long update) //如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。      long decrementAndGet(int i)       //以原子方式将索引 i 的元素减1。      long get(int i)                   //获取位置 i 的当前值。      long getAndAdd(int i, long delta) //以原子方式将给定值与索引 i 的元素相加。      long getAndDecrement(int i)       //以原子方式将索引 i 的元素减 1。      long getAndIncrement(int i)       //以原子方式将索引 i 的元素加 1。      long getAndSet(int i, long newValue) //以原子方式将位置 i 的元素设置为给定值，并返回旧值。      long incrementAndGet(int i)       // 以原子方式将索引 i 的元素加1。      void lazySet(int i, long newValue)// 最终将位置 i 的元素设置为给定值。      int length()                      //返回该数组的长度。      void set(int i, long newValue)    //将位置 i 的元素设置为给定值。      String toString()                 //返回数组当前值的字符串表示形式。 </code></pre><h4 id="2-使用方式："><a href="#2-使用方式：" class="headerlink" title="2 使用方式："></a>2 使用方式：</h4><p>我们可以发现AtomicLongArray的使用方式和上一篇介绍的基本类型的原子类差不多，无非是换成了数组类型，另外方法里面的etAndAdd与ncrementAndGet我们要注意使用方式。</p><h4 id="3-AtomicReferenceArray介绍"><a href="#3-AtomicReferenceArray介绍" class="headerlink" title="3 AtomicReferenceArray介绍"></a>3 AtomicReferenceArray介绍</h4><p>我们来看一下他的方法：<br>    构造方法：</p><pre><code>AtomicReferenceArray(E[] array) //创建与给定数组具有相同长度的新 AtomicReferenceArray，并从给定数组复制其所有元素。 AtomicReferenceArray(int length) // 创建给定长度的新 AtomicReferenceArray。 方法:boolean compareAndSet(int i, E expect, E update) //如果当前值 == 预期值，则以原子方式将位置 i 的元素设置为给定的更新值。  E get(int i)                    //获取位置 i 的当前值。  E getAndSet(int i, E newValue)  // 以原子方式将位置 i 的元素设置为给定值，并返回旧值。  void lazySet(int i, E newValue) //最终将位置 i 的元素设置为给定值。  int length()                    //返回该数组的长度。  void set(int i, E newValue)     // 将位置 i 的元素设置为给定值。  String toString()               //返回数组当前值的字符串表示形式。  boolean weakCompareAndSet(int i, E expect, E update) // 如果当前值 == 预期值，则以原子方式将位置 i 的元素设置为给定的更新值。 </code></pre><p>由上我们可以看到AtomicReferenceArray与前两个的方法相比少了很多。</p><p>下面我们通过一个小例子来看一下他的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Long[] l = <span class="keyword">new</span> Long[<span class="number">4</span>];</span><br><span class="line">        String[] s = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        Integer[] in = <span class="keyword">new</span> Integer[<span class="number">4</span>];</span><br><span class="line">        AtomicReferenceArray atomicReferenceArray = <span class="keyword">new</span> AtomicReferenceArray(l);</span><br><span class="line">        System.out.println(atomicReferenceArray.length());</span><br><span class="line">        System.out.println(atomicReferenceArray.get(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        AtomicReferenceArray atomic = <span class="keyword">new</span> AtomicReferenceArray(<span class="number">4</span>);</span><br><span class="line">        atomic.set(<span class="number">0</span>,<span class="number">432141</span>);</span><br><span class="line">        atomic.set(<span class="number">2</span>,<span class="string">"fsafefeq"</span>);</span><br><span class="line">        atomic.set(<span class="number">3</span>,i);</span><br><span class="line">        System.out.println(atomic.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre><code>exclude patterns:4null[432141, null, fsafefeq, [I@357b2b99]Process finished with exit code 0</code></pre><p>说明：<br>    1.当我们使用AtomicReferenceArray(E[] array)这个构造方法传入一个数组对象时，该数组对象必须是引用类型，int[]不可以，但是Integer[]的可以。<br>    2.当我们使用AtomicReferenceArray(int length)这个构造函数的时候，只要为他指定了数组大小之后，你为数组的每一位设置什么值是没有要求的，类似于Map的形式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们介绍过三个基本类型的原子类，这次我们来看一下数组类型： AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray。其中前两个的使用方式差不多，AtomicReferenceArray因为他的参数为引用数组，
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十一）----(JUC原子类)基本类型介绍</title>
    <link href="https://blog.rickiyang.cn/posts/8ca24763.html"/>
    <id>https://blog.rickiyang.cn/posts/8ca24763.html</id>
    <published>2017-03-24T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.140Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们说到了基本原子类的简单介绍，这一节我们先来看一下基本类型: AtomicInteger, AtomicLong, AtomicBoolean。AtomicInteger和AtomicLong的使用方法差不多，AtomicBoolean因为比较简单所以方法比前两个都少，那我们这节主要挑AtomicLong来说，会使用一个，其余的大同小异。</p><h4 id="1-原子操作与一般操作异同"><a href="#1-原子操作与一般操作异同" class="headerlink" title="1 原子操作与一般操作异同"></a>1 原子操作与一般操作异同</h4><p>我们在说原子操作之前为了有个对比为什么需要这些原子类而不是普通的基本数据类型就能满足我们的使用要求，那就不得不提原子操作不同的地方。</p><p>当你在操作一个普通变量时，你在Java实现的每个操作，在程序编译时会被转换成几个机器能读懂的指令。例如，当你分配一个值给变量，在Java你只使用了一个指令，但是当你编译这个程序时，这个指令就被转换成多个JVM 语言指令。这样子的话当你在操作多个线程且共享一个变量时，就会导致数据不一致的错误。</p><p>为了避免这样的问题，Java引入了原子变量。当一个线程正在操作一个原子变量时，即使其他线程也想要操作这个变量，类的实现中含有一个检查那步骤操作是否完成的机制。 基本上，操作获取变量的值，改变本地变量值，然后尝试以新值代替旧值。如果旧值还是一样，那么就改变它。如果不一样，方法再次开始操作。这个操作称为 Compare and Set（简称CAS，比较并交换的意思）。</p><p>原子变量不使用任何锁或者其他同步机制来保护它们的值的访问。他们的全部操作都是基于CAS操作。它保证几个线程可以同时操作一个原子对象也不会出现数据不一致的错误，并且它的性能比使用受同步机制保护的正常变量要好。</p><h4 id="2-AtomicLong简介"><a href="#2-AtomicLong简介" class="headerlink" title="2 AtomicLong简介"></a>2 AtomicLong简介</h4><p>由字面意义我们可以知道AtomicLong可以用原子方式更新的 long 值，下面我们看一下他的构造方法和一般方法：</p><pre><code>构造方法：    AtomicLong()                  //创建具有初始值 0 的新 AtomicLong。     AtomicLong(long initialValue) //创建具有给定初始值的新 AtomicLong。     方法：     long addAndGet(long delta)   //以原子方式将给定值添加到当前值。      boolean compareAndSet(long expect, long update) //如果当前值 == 预期值，则以原子方式将该值                                                   设置为给定的更新值。      long decrementAndGet()       //以原子方式将当前值减 1。      double doubleValue()         //以 double 形式返回指定的数值。      float floatValue()           //以 float 形式返回指定的数值。      long get()                   //获取当前值。      long getAndAdd(long delta)   //以原子方式将给定值添加到当前值。      long getAndDecrement()       //以原子方式将当前值减 1。      long getAndIncrement()       //以原子方式将当前值加 1。      long getAndSet(long newValue)// 以原子方式设置为给定值，并返回旧值。      long incrementAndGet()       //以原子方式将当前值加 1。      int intValue()               // 以 int 形式返回指定的数值。      void lazySet(long newValue)  //最后设置为给定值。      long longValue()             // 以 long 形式返回指定的数值。      void set(long newValue)      //设置为给定值。      String toString()            // 返回当前值的字符串表示形式。      boolean weakCompareAndSet(long expect, long update) //如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 </code></pre><h4 id="3-使用AtomicLong"><a href="#3-使用AtomicLong" class="headerlink" title="3 使用AtomicLong"></a>3 使用AtomicLong</h4><h5 id="3-1-创建AtomicLong"><a href="#3-1-创建AtomicLong" class="headerlink" title="3.1 创建AtomicLong"></a>3.1 创建AtomicLong</h5><p>创建AtomicLong的过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（）;</span><br></pre></td></tr></table></figure><p>此示例创建一个初始值为0的AtomicLong 。</p><p>如果你想创建一个带有初始值的AtomicLong ，你可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（<span class="number">123</span>）;</span><br></pre></td></tr></table></figure><p>此示例将值123作为参数传递给AtomicLong装订器，该装置将AtomicLong实例的初始值设置为123 。</p><h5 id="3-2-获取AtomicLong值"><a href="#3-2-获取AtomicLong值" class="headerlink" title="3.2 获取AtomicLong值"></a>3.2 获取AtomicLong值</h5><p>您可以通过get()方法get() AtomicLong实例的值。 这里是一个AtomicLong.get()示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（<span class="number">123</span>）;</span><br><span class="line"><span class="keyword">long</span> theValue = atomicLong.get（）;</span><br></pre></td></tr></table></figure><p>设置AtomicLong值</p><p>您可以通过set()方法set() AtomicLong实例的值。 这里是一个AtomicLong.set()示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（<span class="number">123</span>）;</span><br><span class="line">  </span><br><span class="line">atomicLong.set（<span class="number">234</span>）;</span><br></pre></td></tr></table></figure><p>此示例创建一个初始值为123的AtomicLong示例，然后在下一行中将其值设置为234 。</p><h5 id="3-3-比较并设置AtomicLong值"><a href="#3-3-比较并设置AtomicLong值" class="headerlink" title="3.3 比较并设置AtomicLong值"></a>3.3 比较并设置AtomicLong值</h5><p>AtomicLong类也有一个原子compareAndSet()方法。 此方法将AtomicLong实例的当前值与AtomicLong进行比较，如果这两个值相等， AtomicLong实例设置新值。 这里是一个AtomicLong.compareAndSet()示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（<span class="number">123</span>）;</span><br><span class="line"><span class="keyword">long</span> expectedValue = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">long</span> newValue = <span class="number">234</span>;</span><br><span class="line">atomicLong.compareAndSet（expectedValue，newValue）;</span><br></pre></td></tr></table></figure><p>此示例首先创建一个初始值为123的AtomicLong实例。 然后，它将AtomicLong的值与期望值123进行比较，如果它们相等，则AtomicLong的新值变为234 ;</p><h5 id="3-4-添加到AtomicLong值"><a href="#3-4-添加到AtomicLong值" class="headerlink" title="3.4 添加到AtomicLong值"></a>3.4 <strong>添加到AtomicLong值</strong></h5><p>AtomicLong类包含几个方法，您可以使用这些方法向AtomicLong添加值并返回其值。<strong>这里我们要重点关注一下，因为这几个方法会如果我们使用不当会造成歧义</strong>。 这些方法是：</p><pre><code>addAndGet()getAndAdd()getAndIncrement()incrementAndGet()</code></pre><ul><li>第一种方法addAndGet()向AtomicLong添加一个数字，并在添加后返回其值。 </li><li>第二种方法getAndAdd()还向AtomicLong添加一个数字，但返回AtomicLong在添加值之前的值。 </li></ul><p>您应该使用这两种方法中的哪一种取决于您的用例。 这里有两个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong（）;</span><br><span class="line">System.out.println（atomicLong.getAndAdd（<span class="number">10</span>））;</span><br><span class="line">System.out.println（atomicLong.addAndGet（<span class="number">10</span>））;</span><br></pre></td></tr></table></figure><p>此示例将打印出值0和20 。 首先，示例在添加10之前获取AtomicLong的值。 它的值在加法之前为0.然后示例将10添加到AtomicLong ，并获取添加后的值。 该值现在为20。</p><p><strong>您也可以通过这两种方法向AtomicLong添加负数。 结果实际上是一个减法。</strong></p><p>方法getAndIncrement()和incrementAndGet()工作原理像getAndAdd()和addAndGet()但只是添加1到AtomicLong的值。</p><h5 id="3-5-从AtomicLong值中减去"><a href="#3-5-从AtomicLong值中减去" class="headerlink" title="3.5 从AtomicLong值中减去"></a>3.5 从AtomicLong值中减去</h5><p>AtomicLong类还包含一些用于从AtomicLong值中以AtomicLong值的方法。 这些方法是：</p><pre><code>decrementAndGet()getAndDecrement()</code></pre><p>decrementAndGet()从AtomicLong值中减去1，并在AtomicLong后返回其值。 getAndDecrement()也从AtomicLong值中减去1，但返回AtomicLong在AtomicLong之前的值。</p><p>由上我们大致知道了AtomicLong的用法，AtomicBoolean，AtomicInteger也与它的用法差不多，我们看一下API他们各自的方法就知道该如何使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们说到了基本原子类的简单介绍，这一节我们先来看一下基本类型: AtomicInteger, AtomicLong, AtomicBoolean。AtomicInteger和AtomicLong的使用方法差不多，AtomicBoolean因为比较简单所以方法比前两个都
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（十）----JUC原子类介绍</title>
    <link href="https://blog.rickiyang.cn/posts/db147845.html"/>
    <id>https://blog.rickiyang.cn/posts/db147845.html</id>
    <published>2017-03-23T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.139Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来看一下JUC包中的原子类，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程），原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分。将整个操作视作一个整体是原子性的核心特征。</p><p><img src="http://i.imgur.com/1cgiAcM.png" alt=""></p><p>在atomic包中的这些原子类我们可以大致给他分类为：</p><ol><li>基本类型: AtomicInteger, AtomicLong, AtomicBoolean ; </li><li>数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ;</li><li>引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ;</li><li>对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。</li></ol><p>下一节我们详细的分析这些原子类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来看一下JUC包中的原子类，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程），原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（九）----(JUC)CyclicBarrier</title>
    <link href="https://blog.rickiyang.cn/posts/f5e73779.html"/>
    <id>https://blog.rickiyang.cn/posts/f5e73779.html</id>
    <published>2017-03-21T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.143Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们介绍了CountDownlatch，我们知道CountDownlatch是“在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待”，即CountDownLatch的作用是允许1或N个线程等待其他线程完成执行，而我们今天要介绍的CyclicBarrier则是允许N个线程相互等待。</p><h4 id="1-CyclicBarrier简介"><a href="#1-CyclicBarrier简介" class="headerlink" title="1 CyclicBarrier简介"></a>1 CyclicBarrier简介</h4><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。   在JDK中对CyclicBarrier是这样说的“允许一组线程全部等待彼此到达公共屏障点的同步辅助。 循环障碍在涉及必须偶尔彼此等待的固定大小的线程程序中是有用的。屏障称为循环 ，因为它可以在等待线程释放后重新使用”。CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</p><p>我们先来看一下他的构造方法和使用方式：</p><pre><code>构造函数：    CyclicBarrier(int parties) //其参数表示屏障拦截的线程数量，每个线程调用await方法告                                 诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。    CyclicBarrier (int parties, Runnable barrierAction) //创建一个新的CyclicBarrier ，                                当给定数量的参与者（线程）等待它时，它将跳闸，当障碍跳闸时，它                                将执行 给定的障碍动作(Runnable参数提供)，由最后一个线程进入障碍。    方法：    int await()   //在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。                  方法之前将一直等待,或者超出了指定的等待时间。    int getNumberWaiting()  //返回当前在屏障处等待的参与者数目。    int getParties()        //返回要求启动此 barrier 的参与者数目。    boolean isBroken()      //查询此屏障是否处于损坏状态。    void reset()            //将屏障重置为其初始状态。</code></pre><p>下面我们来看一个小程序了解一下CyclicBarrier的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在等待..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在等待..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"人够了，出发吧 当前有 "</span>+c.getParties()+<span class="string">" 个人参与比赛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><pre><code>Thread-0正在等待...main正在等待...人够了，出发吧 当前有 2 个人参与比赛Process finished with exit code 0</code></pre><p>在上面程序中如果我们把”static CyclicBarrier c = new CyclicBarrier(2);”中的参数2修改为3的话改程序中的线程Thread-0和main则会一直等待下去，因为CyclicBarrier是让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，而这最后一个线程迟迟不来，所以屏障也不会被打开。</p><p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。我们来看一下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>,<span class="keyword">new</span> PrioExecut());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在等待..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在等待..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"人够了，出发吧 当前有 "</span>+c.getParties()+<span class="string">" 个人参与比赛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioExecut</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我会先跑5秒，不管你信不信！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><pre><code>我会先跑5秒，不管你信不信！Thread-0正在等待...main正在等待...人够了，出发吧 当前有 2 个人参与比赛Process finished with exit code 0</code></pre><p>我们可以看到构造方法中的参数：new PrioExecut()中的线程会优先执行。</p><h4 id="2-CyclicBarrier的应用场景"><a href="#2-CyclicBarrier的应用场景" class="headerlink" title="2 CyclicBarrier的应用场景"></a>2 CyclicBarrier的应用场景</h4><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。比如在支付业务中，我们可以按照事先划分好的片区的形式来统计日收支流水，然后根据片区的计算结果，使用Runnable barrierAction来进行汇总这是一个很好的实现。</p><h4 id="3-CyclicBarrier和CountDownLatch的区别"><a href="#3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="3 CyclicBarrier和CountDownLatch的区别"></a>3 CyclicBarrier和CountDownLatch的区别</h4><p>在javadoc里面的描述是这样的：</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><blockquote><p>CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.</p></blockquote><ul><li><p>根据我的理解：对于CountDownLatch来说，重点是那个“一个线程”, 它在等待其余线程执行完毕他才能执行，而另外那N的线程在把“某个事情”做完之后可以继续等待，可以终止。比如上文说的跑步的例子，只有5位跑步者同时准备好了，裁判才能下令开始跑步；CyclicBarrier强调的是n个线程，大家相互等待，只要有一个没完成，所有人都得等着。</p></li><li><p>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇我们介绍了CountDownlatch，我们知道CountDownlatch是“在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待”，即CountDownLatch的作用是允许1或N个线程等待其他线程完成执行，而我们今天要介绍的CyclicBarri
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（七）----（JUC）ReadWriteLock</title>
    <link href="https://blog.rickiyang.cn/posts/de2aa32e.html"/>
    <id>https://blog.rickiyang.cn/posts/de2aa32e.html</id>
    <published>2017-03-19T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.162Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经分析过JUC包里面的Lock锁，ReentrantLock锁和semaphore信号量机制。Lock锁实现了比synchronized更灵活的锁机制，Reentrantlock是Lock的实现类，是一种可重入锁，都是每次只有一次线程对资源进行处理；semaphore实现了多个线程同时对一个资源的访问；今天我们要讲的ReadWriteLock锁将实现另外一种很重要的功能：读写分离锁。</p><p>假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写，也就是说：<strong>读-读能共存，读-写不能共存，写-写不能共存</strong>。这就需要一个读/写锁来解决这个问题。</p><h4 id="1-ReadWriteLock简介"><a href="#1-ReadWriteLock简介" class="headerlink" title="1 ReadWriteLock简介"></a>1 ReadWriteLock简介</h4><p>我们在JUC包可以看到ReadWriteLock是一个接口，他有一个实现类：ReentrantReadWriteLock，先让我们对读写访问资源的条件做个概述：</p><pre><code>- 读取： 没有线程正在做写操作，且没有线程在请求写操作。- 写入： 没有线程正在做读写操作。</code></pre><p>如果某个线程想要读取资源，只要没有线程正在对该资源进行写操作且没有线程请求对该资源的写操作即可。同样当有线程想要写资源，但是此刻有线程正在读取资源，那么此刻写资源的操作是不能继续下去的。<br>我们来看一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> ExecutorService exService = Executors.newFixedThreadPool(threadCount);</span><br><span class="line">            <span class="keyword">final</span> ScoreBoard scoreBoard = <span class="keyword">new</span> ScoreBoard();</span><br><span class="line">            exService.execute(<span class="keyword">new</span> ScoreUpdateThread(scoreBoard));</span><br><span class="line">            exService.execute(<span class="keyword">new</span> ScoreHealthThread(scoreBoard));</span><br><span class="line">            exService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreBoard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> scoreUpdated = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    String health = <span class="string">"不可用"</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rrwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMatchHealth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rrwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (scoreUpdated) &#123;</span><br><span class="line">            rrwl.readLock().unlock();</span><br><span class="line">            rrwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (scoreUpdated) &#123;</span><br><span class="line">                    score = fetchScore();</span><br><span class="line">                    scoreUpdated = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rrwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rrwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (score % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                health = <span class="string">"Bad Score"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                health = <span class="string">"Good Score"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rrwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> health;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rrwl.writeLock().lock();</span><br><span class="line">            scoreUpdated = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rrwl.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fetchScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calendar calender = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">return</span> calender.get(Calendar.MILLISECOND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreHealthThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ScoreBoard scoreBoard;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScoreHealthThread</span><span class="params">(ScoreBoard scoreTable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scoreBoard = scoreTable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Match Health: "</span>+ scoreBoard.getMatchHealth());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreUpdateThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ScoreBoard scoreBoard;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScoreUpdateThread</span><span class="params">(ScoreBoard scoreTable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scoreBoard = scoreTable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Score Updated."</span>);</span><br><span class="line">            scoreBoard.updateScore();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><pre><code>Score Updated.Match Health: Good ScoreScore Updated.Match Health: Good ScoreScore Updated.Match Health: Good ScoreScore Updated.Match Health: Good ScoreScore Updated.Match Health: Good Score</code></pre><p>基本用法见上例，读写分离锁很好的控制了多个线程对同一个资源的访问。</p><h4 id="2-ReentrantReadWriteLock"><a href="#2-ReentrantReadWriteLock" class="headerlink" title="2 ReentrantReadWriteLock"></a>2 ReentrantReadWriteLock</h4><p>由名字我们可以看到读写锁也有可重入的实现类。ReentrantReadWriteLock具有关联的读取和写入锁定，可以重新获取锁定。它可表现为公平和不公平的模式两者。 默认行为是不公平的。 非公平锁的性能更好，虽然有可能读写器或写入器锁可以被推迟许多次，并且持续地尝试锁定。 在公平锁定的情况下，锁定请求按照最长等待的单个写入器锁或读取锁定组请求的顺序来完成，无论谁具有最长等待时间将获得对共享资源的锁定。 在重入ReentrantReadWriteLock可以写入<strong>锁定降级读锁</strong>。 这意味着如果线程已经获得写锁定，它可以将其锁从写降级到读锁。 顺序将是首先获得写锁定，执行写操作，然后获取读锁，然后解锁写锁，并且在读操作后最终解锁读锁。 </p><p>ReentrantReadWriteLock 也是基于 AbstractQueuedSynchronizer 实现的，它具有下面这些属性：</p><ul><li>获取顺序</li></ul><p>此类不会将读取者优先或写入者优先强加给锁访问的排序。但是，它确实支持可选的公平 策略。</p><p>1.非公平模式（默认）</p><p>当非公平地（默认）构造时，未指定进入读写锁的顺序，受到 reentrancy 约束的限制。连续竞争的非公平锁可能无限期地推迟一个或多个 reader 或 writer 线程，但吞吐量通常要高于公平锁。</p><p>2.公平模式</p><p>当公平地构造线程时，线程利用一个近似到达顺序的策略来争夺进入。当释放当前保持的锁时，可以为等待时间最长的单个 writer 线程分配写入锁，如果有一组等待时间大于所有正在等待的 writer 线程 的 reader 线程，将为该组分配写入锁。</p><p>如果保持写入锁，或者有一个等待的 writer 线程，则试图获得公平读取锁（非重入地）的线程将会阻塞。直到当前最旧的等待 writer 线程已获得并释放了写入锁之后，该线程才会获得读取锁。当然，如果等待 writer 放弃其等待，而保留一个或更多 reader 线程为队列中带有写入锁自由的时间最长的 waiter，则将为那些 reader 分配读取锁。</p><p>试图获得公平写入锁的（非重入地）的线程将会阻塞，除非读取锁和写入锁都自由（这意味着没有等待线程）。（注意，非阻塞 ReentrantReadWriteLock.ReadLock.tryLock() 和 ReentrantReadWriteLock.WriteLock.tryLock() 方法不会遵守此公平设置，并将获得锁（如果可能），不考虑等待线程）。</p><ul><li>重入</li></ul><p>此锁允许 reader 和 writer 按照 ReentrantLock 的样式重新获取读取锁或写入锁。在写入线程保持的所有写入锁都已经释放后，才允许重入 reader 使用它们。</p><p>此外，writer 可以获取读取锁，但反过来则不成立。在其他应用程序中，当在调用或回调那些在读取锁状态下执行读取操作的方法期间保持写入锁时，重入很有用。如果 reader 试图获取写入锁，那么将永远不会获得成功。</p><ul><li>锁降级</li></ul><p>重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</p><ul><li>锁获取的中断</li></ul><p>读取锁和写入锁都支持锁获取期间的中断。</p><ul><li>Condition 支持</li></ul><p>写入锁提供了一个 Condition 实现，对于写入锁来说，该实现的行为与 ReentrantLock.newCondition() 提供的 Condition 实现对 ReentrantLock 所做的行为相同。当然，此 Condition 只能用于写入锁。读取锁不支持 Condition，readLock().newCondition() 会抛出 UnsupportedOperationException。</p><ul><li>监测</li></ul><p>此类支持一些确定是保持锁还是争用锁的方法。这些方法设计用于监视系统状态，而不是同步控制。</p><p>此类行为的序列化方式与内置锁的相同：反序列化的锁处于解除锁状态，无论序列化该锁时其状态如何。</p><p>下面的代码展示了如何利用重入来执行升级缓存后的锁降级（为简单起见，省略了异常处理）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         rwl.readLock().lock();</span><br><span class="line">         <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 在获得写锁之前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="comment">// Recheck state because another thread might have acquired</span></span><br><span class="line">            <span class="comment">//   write lock and changed state before we did.</span></span><br><span class="line">            <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">              data = ...</span><br><span class="line">              cacheValid = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过在释放写锁之前获得读锁来降级</span></span><br><span class="line">            rwl.readLock().lock();</span><br><span class="line">            rwl.writeLock().unlock(); <span class="comment">// 解锁写锁，但是任然持有读锁</span></span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">        use(data);</span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-与互斥锁对比"><a href="#3-与互斥锁对比" class="headerlink" title="3 与互斥锁对比"></a>3 与互斥锁对比</h4><p>互斥锁一次只允许一个线程访问共享数据，哪怕进行的是只读操作；读写锁允许对共享数据进行更高级别的并发访问：对于写操作，一次只有一个线程（write线程）可以修改共享数据，对于读操作，允许任意数量的线程同时进行读取。</p><p>与互斥锁相比，使用读写锁能否提升性能则取决于读写操作期间读取数据相对于修改数据的频率，以及数据的争用——即在同一时间试图对该数据执行读取或写入操作的线程数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们已经分析过JUC包里面的Lock锁，ReentrantLock锁和semaphore信号量机制。Lock锁实现了比synchronized更灵活的锁机制，Reentrantlock是Lock的实现类，是一种可重入锁，都是每次只有一次线程对资源进行处理；semapho
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（七）----（JUC）ReadWriteLock</title>
    <link href="https://blog.rickiyang.cn/posts/de2aa32e.html"/>
    <id>https://blog.rickiyang.cn/posts/de2aa32e.html</id>
    <published>2017-03-19T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.142Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch 是一个非常实用的多线程控制工具类。” Count Down “ 在英文中意为倒计数， Latch 为门问的意思。如果翻译成为倒计数门阀， 我想大家都会觉得不知所云吧! 因此，这里简单地称之为倒计数器。在这里， 门问的含义是:把门锁起来，不让里面的线程跑出来。因此，这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束， 再开始执行。</p><p>CountDown Latch 的构造函数接收一个整数作为参数，即当前这个计数器的计数个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure><p>CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。一个CountDownLatch初始化为给定的计数 。 调用await方法阻塞，直到当前计数为零，在调用countDown()方法之后，所有等待的线程被释放，任何后续调用await立即返回。 这是一次性的现象 - 计数不能重置。 如果需要重置计数，考虑使用CyclicBarrier ，CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</p><p>主要方法：</p><pre><code>// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。void await()// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。boolean await(long timeout, TimeUnit unit)// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。void countDown()// 返回当前计数。long getCount()</code></pre><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNER_NUMBER = <span class="number">5</span>; <span class="comment">// 运动员个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于判断发令之前运动员是否已经完全进入准备状态，需要等待5个运动员，所以参数为5</span></span><br><span class="line">        CountDownLatch readyLatch = <span class="keyword">new</span> CountDownLatch(RUNNER_NUMBER);</span><br><span class="line">        <span class="comment">// 用于判断裁判是否已经发令，只需要等待一个裁判，所以参数为1</span></span><br><span class="line">        CountDownLatch startLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RUNNER_NUMBER; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner((i + <span class="number">1</span>) + <span class="string">"号运动员"</span>, readyLatch, startLatch));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readyLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        startLatch.countDown();</span><br><span class="line">        System.out.println(<span class="string">"裁判：所有运动员准备完毕，开始..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch readyLatch;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch startLatch;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Runner</span><span class="params">(String name, CountDownLatch readyLatch, CountDownLatch startLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.readyLatch = readyLatch;</span><br><span class="line">            <span class="keyword">this</span>.startLatch = startLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readyTime = RANDOM.nextInt(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(name + <span class="string">"：我需要"</span> + readyTime + <span class="string">"秒时间准备."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(readyTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">"：我已经准备完毕."</span>);</span><br><span class="line">            readyLatch.countDown();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startLatch.await();  <span class="comment">// 等待裁判发开始命令</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">"：开跑..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><pre><code>1号运动员：我需要547秒时间准备.2号运动员：我需要281秒时间准备.4号运动员：我需要563秒时间准备.5号运动员：我需要916秒时间准备.3号运动员：我需要461秒时间准备.2号运动员：我已经准备完毕.3号运动员：我已经准备完毕.1号运动员：我已经准备完毕.4号运动员：我已经准备完毕.5号运动员：我已经准备完毕.裁判：所有运动员准备完毕，开始...3号运动员：开跑...2号运动员：开跑...1号运动员：开跑...4号运动员：开跑...5号运动员：开跑...Process finished with exit code 0</code></pre><p>注意：计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CountDownLatch 是一个非常实用的多线程控制工具类。” Count Down “ 在英文中意为倒计数， Latch 为门问的意思。如果翻译成为倒计数门阀， 我想大家都会觉得不知所云吧! 因此，这里简单地称之为倒计数器。在这里， 门问的含义是:把门锁起来，不让里面
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（六）----（JUC）Semaphore</title>
    <link href="https://blog.rickiyang.cn/posts/7afb7337.html"/>
    <id>https://blog.rickiyang.cn/posts/7afb7337.html</id>
    <published>2017-03-19T03:12:00.000Z</published>
    <updated>2018-12-04T09:28:26.141Z</updated>
    
    <content type="html"><![CDATA[<p>Semaphore,从字面意义上我们知道他是信号量的意思。在java中，一个计数信号量维护了一个许可集。Semaphore 只对可用许可的号码进行计数，并采取相应的行动。拿到信号量的线程可以进入代码，否则就等待。通过acquire()和release()获取和释放访问许可。</p><p>信号量Semaphore是一个控制访问多个共享资源的计数器，它本质上是一个“共享锁”。</p><p>Java并发提供了两种加锁模式：共享锁和独占锁。前面介绍的ReentrantLock就是独占锁。对于独占锁而言，它每次只能有一个线程持有，而共享锁则不同，它允许多个线程并行持有锁，并发访问共享资源。</p><p>独占锁它所采用的是一种悲观的加锁策略，  对于写而言为了避免冲突独占是必须的，但是对于读就没有必要了，因为它不会影响数据的一致性。如果某个只读线程获取独占锁，则其他读线程都只能等待了，这种情况下就限制了不必要的并发性，降低了吞吐量。而共享锁则不同，它放宽了加锁的条件，采用了乐观锁机制，它是允许多个读线程同时访问同一个共享资源的。</p><p>举一个生活中的例子，有一条单行道路口有一红绿灯在正常的绿灯时间内如果骑车速度都很平均只能过去20辆车，这就意味着排在前面的20辆肯定能过去红绿灯，后面的就只能等下一个绿灯了。但是如果这个时候有车不想过去这个路口它驶向了边上别的路，那么后面的车就有机会。下面我们来看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> A(<span class="string">"car"</span>+(j++),semaphore),<span class="string">"Thread"</span>+(j++));</span><br><span class="line">            <span class="comment">//new Thread(new A("car"+(j++),semaphore),"Thread"+(j++)).start();</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"最后还有"</span>+semaphore.availablePermits()+<span class="string">"个许可可用"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"最后还有"</span>+semaphore.availablePermits()+<span class="string">"个许可可用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    String carName;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String carName, Semaphore semaphore)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carName = carName;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this car is get the way"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(semaphore.availablePermits() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                getWay();</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"请等待========"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Semaphore,从字面意义上我们知道他是信号量的意思。在java中，一个计数信号量维护了一个许可集。Semaphore 只对可用许可的号码进行计数，并采取相应的行动。拿到信号量的线程可以进入代码，否则就等待。通过acquire()和release()获取和释放访问许可。
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（五）----（JUC）ReentrantLock</title>
    <link href="https://blog.rickiyang.cn/posts/d68e6b33.html"/>
    <id>https://blog.rickiyang.cn/posts/d68e6b33.html</id>
    <published>2017-03-18T17:02:00.000Z</published>
    <updated>2018-12-05T06:13:34.099Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们了解了Lock接口的一些简单的说明，知道Lock锁的常用形式，那么这节我们正式开始进入JUC锁（java.util.concurrent包下的锁，简称JUC锁）。下面我们来看一下Lock最常用的实现类ReentrantLock。</p><h4 id="1-ReentrantLock简介"><a href="#1-ReentrantLock简介" class="headerlink" title="1 ReentrantLock简介"></a>1 ReentrantLock简介</h4><p>由单词意思我们可以知道这是可重入的意思。那么可重入对于锁而言到底意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了 synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的 synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续） synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个 synchronized 块时，才释放锁。</p><h5 id="1-1-公平锁与非公平锁"><a href="#1-1-公平锁与非公平锁" class="headerlink" title="1.1 公平锁与非公平锁"></a>1.1 公平锁与非公平锁</h5><p>我们查看ReentrantLock的源码可以看到无参构造函数是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync()方法为一个非公平锁的实现方法，另外Reentrantlock还有一个有参的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它允许您选择想要一个 公平（fair）锁，还是一个 不公平（unfair）锁。公平锁使线程按照请求锁的顺序依次获得锁；而不公平锁则允许直接获取锁，在这种情况下，线程有时可以比先请求锁的其他线程先得到锁。</p><p>为什么我们不让所有的锁都公平呢？毕竟，公平是好事，不公平是不好的，不是吗？（当孩子们想要一个决定时，总会叫嚷“这不公平”。我们认为公平非常重要，孩子们也知道。）在现实中，公平保证了锁是非常健壮的锁，有很大的性能成本。要确保公平所需要的记帐（bookkeeping）和同步，就意味着被争夺的公平锁要比不公平锁的吞吐率更低。作为默认设置，应当把公平设置为 false ，除非公平对您的算法至关重要，需要严格按照线程排队的顺序对其进行服务。</p><p>下面我们先来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReentrantLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        set();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestReentrantLock ss = <span class="keyword">new</span> TestReentrantLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(ss).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ss).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ss).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>101012121111Process finished with exit code 0</code></pre><p>由结果我们可以看出同一个线程进入了同一个ReentrantLock锁两次。</p><h4 id="2-condition条件变量"><a href="#2-condition条件变量" class="headerlink" title="2 condition条件变量"></a>2 condition条件变量</h4><p>我们知道根类 Object 包含某些特殊的方法，用来在线程的 wait() 、 notify() 和 notifyAll() 之间进行通信。那么为了在对象上 wait 或 notify ，您必须持有该对象的锁。就像 Lock 是同步的概括一样， Lock 框架包含了对 wait 和 notify 的概括，这个概括叫作 条件（Condition）。 Condition 的方法与 wait 、 notify 和 notifyAll 方法类似，分别命名为 await 、 signal 和signalAll ，因为它们不能覆盖 Object 上的对应方法。</p><p>首先我们来计算一道题：<br>我们要打印1到9这9个数字，由A线程先打印1，2，3，然后由B线程打印4,5,6，然后再由A线程打印7，8，9. 这道题有很多种解法，我们先用Object的wait，notify方法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printAndIncrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">"prints "</span> + val);</span><br><span class="line">        val++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print 1,2,3 7,8,9</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (val &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                printAndIncrease();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print 1,2,3 then notify printerB</span></span><br><span class="line">            <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"PrinterA printed 1,2,3; notify PrinterB"</span>);</span><br><span class="line">                WaitNotifyDemo.<span class="keyword">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (val &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"wait in printerA"</span>);</span><br><span class="line">                        WaitNotifyDemo.<span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"wait end printerA"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (val &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                printAndIncrease();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"PrinterA exits"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print 4,5,6 after printA print 1,2,3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out</span><br><span class="line">                                .println(<span class="string">"printerB wait for printerA printed 1,2,3"</span>);</span><br><span class="line">                        WaitNotifyDemo.<span class="keyword">this</span>.wait();</span><br><span class="line">                        System.out</span><br><span class="line">                                .println(<span class="string">"printerB waited for printerA printed 1,2,3"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (val &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">                printAndIncrease();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"notify in printerB"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">                WaitNotifyDemo.<span class="keyword">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"notify end printerB"</span>);</span><br><span class="line">            System.out.println(<span class="string">"PrinterB exits."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotifyDemo demo = <span class="keyword">new</span> WaitNotifyDemo();</span><br><span class="line">        demo.doPrint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PrinterA pa = <span class="keyword">new</span> PrinterA();</span><br><span class="line">        PrinterB pb = <span class="keyword">new</span> PrinterB();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(pa);</span><br><span class="line">        a.setName(<span class="string">"printerA"</span>);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(pb);</span><br><span class="line">        b.setName(<span class="string">"printerB"</span>);</span><br><span class="line">        <span class="comment">// 必须让b线程先执行，否则b线程有可能得不到锁，执行不了wait，而a线程一直持有锁，会先notify了</span></span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><pre><code>printerB wait for printerA printed 1,2,3printerA prints 1printerA prints 2printerA prints 3PrinterA printed 1,2,3; notify PrinterBwait in printerAprinterB waited for printerA printed 1,2,3printerB prints 4printerB prints 5printerB prints 6notify in printerBnotify end printerBwait end printerAprinterA prints 7printerA prints 8printerA prints 9PrinterA exitsPrinterB exits.Process finished with exit code 0</code></pre><p>我们来分析一下上面的程序：</p><ol><li><p>首先在main方法中我们看到是先启动了B线程，因为B线程持有wait()对象，而A线程则持有notify(),如果先启动A有可能会造成死锁的状态。<br>B线程启动以后进入run()方法：</p><p> while (val &lt; 3) {</p><pre><code>synchronized (WaitNotifyDemo.this) {    try {        System.out.println(&quot;printerB wait for printerA printed 1,2,3&quot;);        WaitNotifyDemo.this.wait();        System.out.println(&quot;printerB waited for printerA printed 1,2,3&quot;);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre><p> }<br> while (val &lt;= 6) {</p><pre><code>printAndIncrease();</code></pre><p> }</p></li></ol><p>这里有一个while循环，如果val的值小于3，那么在WaitNotifyDemo的实例的同步块中调用WaitNotifyDemo.this.wait()方法，这里要注意无论是wait，还是notify，notifyAll方法都需要在其实例对象的同步块中执行，这样当前线程才能获得同步实例的同步控制权，如果不在同步块中执行wait或者notify方法会出java.lang.IllegalMonitorStateException异常。另外还要注意在wait方法两边的同步块会在wait执行完毕之后释放对象锁。</p><p>这样PrinterB就进入了等待状态，我们再看下PrinterA的run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (val &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">    printAndIncrease();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print 1,2,3 then notify printerB</span></span><br><span class="line"><span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"PrinterA printed 1,2,3; notify PrinterB"</span>);</span><br><span class="line">    WaitNotifyDemo.<span class="keyword">this</span>.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (val &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"wait in printerA"</span>);</span><br><span class="line">            WaitNotifyDemo.<span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"wait end printerA"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先打印了1、2、3，然后在同步块中调用了WaitNotifyDemo实例的notify方法，这样PrinterB就得到了继续执行的通知，然后PrinterA进入等待状态，等待PrinterB通知。</p><p>我们再看下PrinterB run方法剩下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (val &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">    printAndIncrease();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"notify in printerB"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (WaitNotifyDemo.<span class="keyword">this</span>) &#123;</span><br><span class="line">    WaitNotifyDemo.<span class="keyword">this</span>.notify();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"notify end printerB"</span>);</span><br><span class="line">System.out.println(<span class="string">"PrinterB exits."</span>);</span><br></pre></td></tr></table></figure><p>PrinterB首先打印了4、5、6，然后在同步块中调用了notify方法，通知PrinterA开始执行。</p><p>PrinterA得到通知后，停止等待，打印剩下的7、8、9三个数字，如下是PrinterA run方法中剩下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (val &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">    printAndIncrease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个程序就分析完了，下面我们再来使用Condition来做这道题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberWrapper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化可重入锁</span></span><br><span class="line">        <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个条件当屏幕上输出到3</span></span><br><span class="line">        <span class="keyword">final</span> Condition reachThreeCondition = lock.newCondition();</span><br><span class="line">        <span class="comment">//第二个条件当屏幕上输出到6</span></span><br><span class="line">        <span class="keyword">final</span> Condition reachSixCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//NumberWrapper只是为了封装一个数字，一边可以将数字对象共享，并可以设置为final</span></span><br><span class="line">        <span class="comment">//注意这里不要用Integer, Integer 是不可变对象</span></span><br><span class="line">        <span class="keyword">final</span> NumberWrapper num = <span class="keyword">new</span> NumberWrapper();</span><br><span class="line">        <span class="comment">//初始化A线程</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//需要先获得锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA start write"</span>);</span><br><span class="line">                    <span class="comment">//A线程先输出前3个数</span></span><br><span class="line">                    <span class="keyword">while</span> (num.value &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        System.out.println(num.value);</span><br><span class="line">                        num.value++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//输出到3时要signal，告诉B线程可以开始了</span></span><br><span class="line">                    reachThreeCondition.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待输出6的条件</span></span><br><span class="line">                    reachSixCondition.await();</span><br><span class="line">                    System.out.println(<span class="string">"threadA start write"</span>);</span><br><span class="line">                    <span class="comment">//输出剩余数字</span></span><br><span class="line">                    <span class="keyword">while</span> (num.value &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                        System.out.println(num.value);</span><br><span class="line">                        num.value++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (num.value &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="comment">//等待3输出完毕的信号</span></span><br><span class="line">                        reachThreeCondition.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="comment">//已经收到信号，开始输出4，5，6</span></span><br><span class="line">                    System.out.println(<span class="string">"threadB start write"</span>);</span><br><span class="line">                    <span class="keyword">while</span> (num.value &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">                        System.out.println(num.value);</span><br><span class="line">                        num.value++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4，5，6输出完毕，告诉A线程6输出完了</span></span><br><span class="line">                    reachSixCondition.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动两个线程</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本思路就是首先要A线程先写1，2，3，这时候B线程应该等待reachThredCondition信号，而当A线程写完3之后就通过signal告诉B线程“我写到3了，该你了”，这时候A线程要等嗲reachSixCondition信号，同时B线程得到通知，开始写4，5，6，写完4，5，6之后B线程通知A线程reachSixCondition条件成立了，这时候A线程就开始写剩下的7，8，9了。</p><p>我们可以看到上例中我们创建了两个Condition,在不同的情况下可以使用不同的Condition，与wait和notify相比提供了更细致的控制。</p><h4 id="3-线程阻塞原语–LockSupport"><a href="#3-线程阻塞原语–LockSupport" class="headerlink" title="3 线程阻塞原语–LockSupport"></a>3 线程阻塞原语–LockSupport</h4><p>我们一再提线程、锁等概念，但锁是如果实现的呢？又是如何知道当前阻塞线程的又是哪个对象呢？LockSupport是JDK中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞原语。</p><p>java锁和同步器框架的核心 <span>AQS:</span> <span>AbstractQueuedSynchronizer，就是通过调用 <span>LockSupport</span> .park()和 <span>LockSupport</span> .unpark()实现线程的阻塞和唤醒 </span><span>的。</span> <span><span>LockSupport</span> 很类似于二元信号量(只有1个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继 </span><span>续</span> <span>执行；如果许可已经被占用，当前线</span> <span>程阻塞，等待获取许可。<br>LockSupport是针对特定线程来进行阻塞和解除阻塞操作的；而Object的wait()/notify()/notifyAll()是用来操作特定对象的等待集合的。<br>LockSupport的两个主要方法是park()和Unpark()，我们来看一下他们的实现：</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   setBlocker(t, blocker);</span><br><span class="line">   unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">   setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">       unsafe.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码我们可见在park方法内部首先获得当前线程然后阻塞当前线程，unpark方法传入一个可配置的线程来为该线程解锁。以“线程”作为方法的参数， 语义更清晰，使用起来也更方便。而wait/notify的实现使得“线程”的阻塞/唤醒对线程本身来说是被动的，要准确的控制哪个线程、什么时候阻塞/唤醒很困难， 要不随机唤醒一个线程（notify）要不唤醒所有的（notifyAll）。</p><p>下面我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setName(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">                System.out.println(<span class="string">"in"</span> + getName());</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把”LockSupport.unpark(t1);”这一句注掉的话我们会发现程序陷入死锁。而且我们看到再main方法中unpark是在t1和t2启动之后才执行，但是为什么t1启动之后，t2也启动了呢？注意，<strong>unpark函数可以先于park调用。比如线程B调用unpark函数，给线程A发了一个“许可”，那么当线程A调用park时，它发现已经有“许可”了，那么它会马上再继续运行。</strong>unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。</p><p>除了有定时阻塞的功能外,还支持中断影响,但是和其他接收中断函数不一样,他不会抛出<br>InterruptedException异常,他只会默默的返回,但是我们可以从Thread.Interrupted()等方法获得中断标记.<br>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setName(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">                System.out.println(<span class="string">"in "</span> + getName());</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                    System.out.println(getName() + <span class="string">" 被中断了!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName() + <span class="string">" 执行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>in t1t1 被中断了!t1 执行结束in t2t2 执行结束Process finished with exit code 0</code></pre><p>由run方法中的终端异常捕获我们可以看到线程在中断时并没有抛出异常而是正常执行下去了。<br>关于LockSupport其实要介绍的东西还是很多，因为这个类实现了底层的一些方法，各种的锁实现都是这个基础上发展而来的。以后会专门用一个篇章来学习jdk内部的阻塞机制。说前面我们讲到Object的wait和notify，讲到Condition条件，讲到jdk中不对外部暴露的LockSupport阻塞原语，那么在JUC包中还有另外一个阻塞机制—信号量机制（Semaphore），下一节我们一起探讨一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们了解了Lock接口的一些简单的说明，知道Lock锁的常用形式，那么这节我们正式开始进入JUC锁（java.util.concurrent包下的锁，简称JUC锁）。下面我们来看一下Lock最常用的实现类ReentrantLock。&lt;/p&gt;
&lt;h4 id=&quot;1-Ree
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（四）----（JUC）Lock锁初探</title>
    <link href="https://blog.rickiyang.cn/posts/f4331185.html"/>
    <id>https://blog.rickiyang.cn/posts/f4331185.html</id>
    <published>2017-03-17T17:02:00.000Z</published>
    <updated>2018-12-05T06:13:34.113Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来回忆一下上一节讲过的synchronized关键字，该关键字用于给代码段或方法加锁，使得某一时刻它修饰的方法或代码段只能被一个线程访问。那么试想，当我们遇到这样的情况：当synchronized修饰的方法或代码段因为某种原因（IO异常或是sleep方法）被阻塞了，但是锁有没有被释放，那么其他线程除了等待以外什么事都做不了。当我们遇到这种情况该怎么办呢？我们今天讲到的Lock锁将有机会为此行使他的职责。</p><h4 id="1-为什么需要Lock"><a href="#1-为什么需要Lock" class="headerlink" title="1 为什么需要Lock"></a>1 为什么需要Lock</h4><p>synchronized 是Java 语言层面的，是内置的关键字；Lock 则是JDK 5 的J.U.C(java/util/currrent)包中出现的一个类，在使用时，synchronized 同步的代码块可以由JVM自动释放；Lock 需要程序员在finally块中手工释放；synchronized是比较古老的实现机制，设计较早，有一些功能上的限制：</p><pre><code>——它无法中断一个正在等候获得锁的线程——也无法通过投票得到锁，如果不想等下去，也就没法得到锁。——同步还要求锁的释放只能在与获得锁所在的堆栈帧相同的堆栈帧中进行</code></pre><p>而且对多线程环境中，使用synchronized后，线程要么获得锁，执行相应的代码，要么无法获得锁处于等待状态，对于锁的处理不灵活。而Lock提供了多种基于锁的处理机制，比如：</p><ol><li>void lock()，获取一个锁，如果锁当前被其他线程获得，当前的线程将被休眠。       </li><li>boolean tryLock()，尝试获取一个锁，如果当前锁被其他线程持有，则返回false，不会使当前线程休眠。     </li><li>boolean    tryLock(long timeout,TimeUnit  unit)，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false。</li><li>void lockInterruptibly()，如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断。</li></ol><p>可见lock比synchronized提供了更细的粒度、更灵活的控制。</p><h4 id="2-初探Lock"><a href="#2-初探Lock" class="headerlink" title="2 初探Lock"></a>2 初探Lock</h4><p>在jdk1.5之后，并发包中新增了Lock接口(以及相关实现类)用来实现锁功能，其实真正的实现Lock接口的类就三个，ReentrantLock和ReentrantReadWriteLock的两个内部类（ReadLock和WriteLock实现了Lock的接口），下面我们来看一下Lock的类图：</p><p><img src="http://i.imgur.com/FpFZGXS.png" alt=""></p><p>ReentrantLock：一个可重入的互斥锁，为lock接口的主要实现。</p><p>ReentrantReadWriteLock：</p><p>ReadWriteLock、ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。</p><p>Semaphore：一个计数信号量。</p><p>Condition:锁的关联条件，目的是允许线程获取锁并且查看等待的某一个条件是否满足。</p><p>CyclicBarrier：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点。</p><p>①首先我们来看一下Lock的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"> </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常使用Lock的用法最多就是这样，ReentrantLock是Lock的实现类们也是最常使用的。如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并在finally块释放锁，以保证锁一定被被释放，防止死锁的发生。</p><p>②我们也可以这样使用Lock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则直接做其他事情    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取）则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p>这一节我们简单了解一下Lock接口，由于Lock锁的内容实在是太多，包括互斥锁，公平锁，非公平锁，共享锁以及相关的条件机制，信号量机制等等，我会一点点的把他们都啃下来，下面才是我们的重头戏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们来回忆一下上一节讲过的synchronized关键字，该关键字用于给代码段或方法加锁，使得某一时刻它修饰的方法或代码段只能被一个线程访问。那么试想，当我们遇到这样的情况：当synchronized修饰的方法或代码段因为某种原因（IO异常或是sleep方法）被阻塞了，
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(五)NIO学习总结以及NIO新特性介绍</title>
    <link href="https://blog.rickiyang.cn/posts/da918f82.html"/>
    <id>https://blog.rickiyang.cn/posts/da918f82.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.380Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道是NIO是在2002年引入到J2SE 1.4里的，很多Java开发者比如我还是不知道怎么充分利用NIO，更少的人知道在Java SE 7里引入了更新的输入/输出 API（NIO.2）。但是对于普通的开发者来说基本的I/O操作就够用了，而NIO则是在处理I/O性能优化方面带来显著性效果。更快的速度则意味着NIO和NIO.2的API暴露了更多低层次的系统操作的入口，这对于开发者而言则意味着更复杂的操作和精巧的程序设计。从前面的几节的讲解来看NIO的操作无不繁琐。要完全掌握还是有点难度的。前面我们讲解了Buffer，Channel，Selector,都是从大的面上去探讨NIO的主要组件。这一节我们则从NIO的特性方面去探讨更细节的一些问题。</p><h4 id="1-NIO的新特性"><a href="#1-NIO的新特性" class="headerlink" title="1.NIO的新特性"></a>1.NIO的新特性</h4><p>总的来说java 中的IO 和NIO的区别主要有3点：</p><ol><li>IO是面向流的，NIO是面向缓冲的；</li><li>IO是阻塞的，NIO是非阻塞的；</li><li>IO是单线程的，NIO 是通过选择器来模拟多线程的；</li></ol><p>NIO在基础的IO流上发展处新的特点，分别是：内存映射技术，字符及编码，非阻塞I/O和文件锁定。下面我们分别就这些技术做一些说明。</p><h4 id="2-内存映射"><a href="#2-内存映射" class="headerlink" title="2. 内存映射"></a>2. 内存映射</h4><p>这个功能主要是为了提高大文件的读写速度而设计的。内存映射文件(memory-mappedfile)能让你创建和修改那些大到无法读入内存的文件。有了内存映射文件，你就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问了。将文件的一段区域映射到内存中，比传统的文件处理速度要快很多。内存映射文件它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。</p><p>NIO中内存映射主要用到以下两个类：</p><ol><li>java.nio.MappedByteBuffer</li><li>java.nio.channels.FileChannel</li></ol><p>下面我们通过一个例子来看一下内存映射读取文件和普通的IO流读取一个150M大文件的速度对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c://1.pdf"</span>,<span class="string">"rw"</span>);</span><br><span class="line">            FileChannel channel = file.getChannel();</span><br><span class="line">            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,channel.size());</span><br><span class="line">            ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> len = file.length();</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//读取内存映射文件</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;file.length();i+=<span class="number">1024</span>*<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (len - i &gt; <span class="number">1024</span>) &#123;</span><br><span class="line">                    buffer.get(b);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    buffer.get(<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)(len - i)]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"使用内存映射方式读取文件总耗时： "</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//普通IO流方式</span></span><br><span class="line">            <span class="keyword">long</span> startTime1 = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span>(channel.read(buffer1) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                buffer1.flip();</span><br><span class="line">                buffer1.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> endTime1 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"使用普通IO流方式读取文件总耗时： "</span>+(endTime1 - startTime1));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果为：</p><p><img src="http://i.imgur.com/biLgFkf.png" alt=""></p><p>效果对比还是挺明显的。我们看到在上面程序中调用FileChannel类的map方法进行内存映射，第一个参数设置映射模式,现在支持3种模式：</p><ol><li><p>FileChannel.MapMode.READ_ONLY：只读缓冲区，在缓冲区中如果发生写操作则会产生ReadOnlyBufferException；</p></li><li><p>FileChannel.MapMode.READ_WRITE：读写缓冲区，任何时刻如果通过内存映射的方式修改了文件则立刻会对磁盘上的文件执行相应的修改操作。别的进程如果也共享了同一个映射，则也会同步看到变化。而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；</p></li><li><p>FileChannel.MapMode.PRIVATE ：这个比较狠，可写缓冲区，但任何修改是缓冲区私有的，不会回到文件中。所以尽情的修改吧，结局跟突然停电是一样的。</p></li></ol><p>我们注意到FileChannel类中有map方法来建立内存映射，按理说是否应用的有相应的unmap方法来卸载映射内存呢。但是竟然没有找到该方法。一旦建立映射保持有效，直到MappedByteBuffer对象被垃圾收集。 此外，映射缓冲区不会绑定到创建它们的通道。 关闭相关的FileChannel不会破坏映射; 只有缓冲对象本身的处理打破了映射。</p><p>内存映射文件的优点：</p><ol><li>用户进程将文件数据视为内存，因此不需要发出read()或write()系统调用。</li><li>当用户进程触摸映射的内存空间时，将自动生成页面错误，以从磁盘引入文件数据。 如果用户修改映射的内存空间，受影响的页面将自动标记为脏，并随后刷新到磁盘以更新文件。</li><li>操作系统的虚拟内存子系统将执行页面的智能缓存，根据系统负载自动管理内存。</li><li>数据始终是页面对齐的，不需要缓冲区复制。</li><li>可以映射非常大的文件，而不消耗大量内存来复制数据。</li></ol><p>下面我们再写一个复制文件的例子来看一下对于一个120M的文件通过这种方式到底能有多快速度的提升：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemMapReadWrite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">readFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(fileName, <span class="string">"rw"</span>);</span><br><span class="line">            len = (<span class="keyword">int</span>) file.length();</span><br><span class="line">            FileChannel channel = file.getChannel();</span><br><span class="line">            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> buffer.get(<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> readFileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writeFileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String readFileName, String writeFileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(writeFileName, <span class="string">"rw"</span>);</span><br><span class="line">            FileChannel channel = file.getChannel();</span><br><span class="line">            ByteBuffer buffer = readFile(readFileName);</span><br><span class="line"></span><br><span class="line">            MappedByteBuffer bytebuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, len);</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                bytebuffer.put(i, buffer.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            bytebuffer.flip();</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"写文件耗时： "</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String readFileName = <span class="string">"c://1.pdf"</span>;</span><br><span class="line">        String writeFileName = <span class="string">"c://2.pdf"</span>;</span><br><span class="line"></span><br><span class="line">        writeFile(readFileName, writeFileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="http://i.imgur.com/bMsFKdn.png" alt=""></p><p>这个速度还是相当惊人的！</p><h4 id="2-字符及编码"><a href="#2-字符及编码" class="headerlink" title="2. 字符及编码"></a>2. 字符及编码</h4><p>说到字符和编码，我们的先说一个概念，<strong>字符编码方案</strong>：</p><p><em>编码方案定义了如何把字符编码的序列表达为字节序列。字符编码的数值不需要与编码字节相同，也不需要是一对一或一对多个的关系。原则上，把字符集编码和解码近似视为对象的序列化和反序列化。</em></p><p>通常字符数据编码是用于网络传输或文件存储。编码方案不是字符集，它是映射；但是因为它们之间的紧密联系，大部分编码都与一个独立的字符集相关联。例如，UTF-8，仅用来编码Unicode字符集。尽管如此，用一个编码方案处理多个字符集还是可能发生的。例如，EUC可以对几个亚洲语言的字符进行编码。</p><p>目前字符编码方案有US-ASCII,UTF-8,GB2312, BIG5,GBK,GB18030,UTF-16BE, UTF-16LE, UTF-16,UNICODE。其中Unicode试图把全世界所有语言的字符集统一到全面的映射之中。虽然战友一定的市场份额，但是目前其余的字符方案仍然广被采用。<strong>大部分的操作系统在I/O与文件存储方面仍是以字节为导向的，所以无论使用何种编码，Unicode或其他编码，在字节序列和字符集编码之间仍需要进行转化。</strong></p><p>由java.nio.charset包组成的类满足了这个需求。这不是Java平台第一次处理字符集编码，但是它是最系统、最全面、以及最灵活的解决方式。<br>下面我们通过一个小例子来看一下通过不同的Charset实现如何把字符翻译成字节序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharsetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = input.next();</span><br><span class="line">        String[] charsetNames = &#123;<span class="string">"US-ASCII"</span>, <span class="string">"ISO-8859-1"</span>, <span class="string">"UTF-8"</span>, <span class="string">"UTF-16BE"</span>,</span><br><span class="line">                <span class="string">"UTF-16LE"</span>, <span class="string">"UTF-16"</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charsetNames.length; i++) &#123;</span><br><span class="line">            doEncode(Charset.forName(charsetNames[i]), str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doEncode</span><span class="params">(Charset cs, String input)</span> </span>&#123;</span><br><span class="line">        ByteBuffer bb = cs.encode(input);</span><br><span class="line">        System.out.println(<span class="string">"Charset: "</span> + cs.name());</span><br><span class="line">        System.out.println(<span class="string">" Input: "</span> + input);</span><br><span class="line">        System.out.println(<span class="string">"Encoded: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; bb.hasRemaining(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> b = bb.get();</span><br><span class="line">            <span class="keyword">int</span> ival = ((<span class="keyword">int</span>) b) &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>) ival;</span><br><span class="line">            <span class="comment">// Keep tabular alignment pretty</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">10</span>) System.out.print(<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// 打印索引序列</span></span><br><span class="line">            System.out.print(<span class="string">" "</span> + i + <span class="string">": "</span>);</span><br><span class="line">            <span class="comment">// Better formatted output is coming someday...</span></span><br><span class="line">            <span class="keyword">if</span> (ival &lt; <span class="number">16</span>)</span><br><span class="line">                System.out.print(<span class="string">"0"</span>);</span><br><span class="line">            <span class="comment">// 输出该字节位值的16进制形式</span></span><br><span class="line">            System.out.print(Integer.toHexString(ival));</span><br><span class="line">            <span class="comment">// 打印出刚才我们输入的字符，如果是空格或者标准字符集中没有包含</span></span><br><span class="line">            <span class="comment">//该字符输出空格，否则输出该字符</span></span><br><span class="line">            <span class="keyword">if</span> (Character.isWhitespace(c) || Character.isISOControl(c)) &#123;</span><br><span class="line">                System.out.println(<span class="string">""</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">" ("</span> + c + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>abcCharset: US-ASCII Input: abcEncoded:   0: 61 (a)  1: 62 (b)  2: 63 (c)Charset: ISO-8859-1 Input: abcEncoded:   0: 61 (a)  1: 62 (b)  2: 63 (c)Charset: UTF-8 Input: abcEncoded:   0: 61 (a)  1: 62 (b)  2: 63 (c)Charset: UTF-16BE Input: abcEncoded:   0: 00  1: 61 (a)  2: 00  3: 62 (b)  4: 00  5: 63 (c)Charset: UTF-16LE Input: abcEncoded:   0: 61 (a)  1: 00  2: 62 (b)  3: 00  4: 63 (c)  5: 00Charset: UTF-16 Input: abcEncoded:   0: fe (þ)  1: ff (ÿ)  2: 00  3: 61 (a)  4: 00  5: 62 (b)  6: 00  7: 63 (c)Process finished with exit code 0</code></pre><h5 id="2-1-字符集编码器和解码器"><a href="#2-1-字符集编码器和解码器" class="headerlink" title="2.1 字符集编码器和解码器"></a>2.1 字符集编码器和解码器</h5><p>字符的编码和解码是使用很频繁的，试想如果使用UTF-8字符集进行编码，但是却是用UTF-16字符集进行解码，那么这条信息对于用户来说其实是无用的。因为没人能看得懂。在NIO中提供了两个类CharsetEncoder和CharsetDecoder来实现编码转换方案。</p><p>CharsetEncoder类是一个状态编码引擎。实际上，编码器有状态意味着它们不是线程安全的：CharsetEncoder对象不应该在线程中共享。CharsetEncoder对象是一个状态转换引擎：字符进去，字节出来。一些编码器的调用可能需要完成转换。编码器存储在调用之间转换的状态。</p><p>字符集解码器是编码器的逆转。通过特殊的编码方案把字节编码转化成16-位Unicode字符的序列。与CharsetEncoder类似的, CharsetDecoder也是状态转换引擎。</p><h4 id="3-非阻塞IO"><a href="#3-非阻塞IO" class="headerlink" title="3. 非阻塞IO"></a>3. 非阻塞IO</h4><p>一般来说 I/O 模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞 四种IO模型。</p><p>同步阻塞 IO ：   </p><p>在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。 JAVA传统的 IO 模型属于此种方式！    </p><p>同步非阻塞 IO:</p><p>在此种方式下，用户进程发起一个 IO 操作以后可以返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 JAVA 的 NIO 就属于同步非阻塞 IO 。    </p><p>异步阻塞 IO ：   </p><p>此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！   </p><p>异步非阻塞 IO:   </p><p>在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为 真正的 IO读取或者写入操作已经由 内核完成了。目前 Java 中还没有支持此种 IO 模型。</p><p>上面我们说到nio是使用了同步非阻塞模型。我们知道典型的非阻塞IO模型一般如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    data = socket.read();</span><br><span class="line">    <span class="keyword">if</span>(data!= error)&#123;</span><br><span class="line">        处理数据</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。所以这就不得不说到下面这个概念–多路复用IO模型。</p><p>多路复用IO模型</p><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p><p>NIO 的非阻塞 I/O 机制是围绕 选择器和 通道构建的。 Channel 类表示服务器和客户机之间的一种通信机制。Selector 类是 Channel 的多路复用器。 Selector 类将传入客户机请求多路分用并将它们分派到各自的请求处理程序。NIO 设计背后的基石是反应器(Reactor)设计模式。</p><p>关于Reactor模式在此就不多做介绍，网上很多。Reactor负责IO事件的响应，一旦有事件发生，便广播发送给相应的handler去处理。而NIO的设计则是完全按照Reactor模式来设计的。Selector发现某个channel有数据时，会通过SelectorKey来告知，然后实现事件和handler的绑定。</p><p>在Reactor模式中，包含如下角色：</p><ul><li>Reactor 将I/O事件发派给对应的Handler</li><li>Acceptor 处理客户端连接请求</li><li>Handlers 执行非阻塞读/写</li></ul><p>我们简单写一个利用了Reactor模式的NIO服务端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(selector.selectNow() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取注册的channel</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//遍历所有的key</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">//如果通道上有事件发生</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//获取该通道</span></span><br><span class="line">                    ServerSocketChannel acceptServerSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel socketChannel = acceptServerSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    LOGGER.info(<span class="string">"Accept request from &#123;&#125;"</span>, socketChannel.getRemoteAddress());</span><br><span class="line">                    <span class="comment">//同时将SelectionKey标记为可读，以便读取。</span></span><br><span class="line">                    SelectionKey readKey = socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">//利用SelectionKey的attache功能绑定Acceptor 如果有事情，触发Acceptor</span></span><br><span class="line">                    <span class="comment">//Processor对象为自定义处理请求的类</span></span><br><span class="line">                    readKey.attach(<span class="keyword">new</span> Processor());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    Processor processor = (Processor) key.attachment();</span><br><span class="line">                    processor.process(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Processor类中设置一个线程池来处理请求，</span></span><br><span class="line"><span class="comment"> * 这样就可以充分利用多线程的优势</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Processor.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ByteBuffer buffer = <span class="keyword">null</span>;</span><br><span class="line">                SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                        selectionKey.cancel();</span><br><span class="line">                        LOGGER.info(<span class="string">"&#123;&#125;\t Read ended"</span>, socketChannel);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                LOGGER.info(<span class="string">"&#123;&#125;\t Read message &#123;&#125;"</span>, socketChannel, <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式带来的好处也是不言而喻的。利用多路复用机制避免了线程的阻塞，提高了连接的数量。一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。虽然多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p><p>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</p><h4 id="4-文件锁定"><a href="#4-文件锁定" class="headerlink" title="4. 文件锁定"></a>4. 文件锁定</h4><p>NIO中的文件通道（FileChannel）在读写数据的时候主 要使用了阻塞模式，它不能支持非阻塞模式的读写，而且FileChannel的对象是不能够直接实例化的， 他的实例只能通过getChannel()从一个打开的文件对象上边读取（RandomAccessFile、 FileInputStream、FileOutputStream），并且通过调用getChannel()方法返回一个 Channel对象去连接同一个文件，也就是针对同一个文件进行读写操作。</p><p>文件锁的出现解决了很多Java应用程序和非Java程序之间共享文件数据的问题，在以前的JDK版本中，没有文件锁机制使得Java应用程序和其他非Java进程程序之间不能够针对同一个文件共享 数据，有可能造成很多问题，JDK1.4里面有了FileChannel，它的锁机制使得文件能够针对很多非 Java应用程序以及其他Java应用程序可见。但是Java里面 的文件锁机制主要是基于共 享锁模型，在不支持共享锁模型的操作系统上，文件锁本身也起不了作用，JDK1.4使用文件通道读写方式可以向一些文件 发送锁请求，<br>FileChannel的 锁模型主要针对的是每一个文件，并不是每一个线程和每一个读写通道，也就是以文件为中心进行共享以及独占，也就是文件锁本身并不适合于同一个JVM的不同 线程之间。</p><p>我们简要看一下相关API：</p><pre><code>// 如果请求的锁定范围是有效的，阻塞直至获取锁 public final FileLock lock()  // 尝试获取锁非阻塞，立刻返回结果   public final FileLock tryLock()  // 第一个参数：要锁定区域的起始位置  // 第二个参数：要锁定区域的尺寸,  // 第三个参数：true为共享锁，false为独占锁   public abstract FileLock lock (long position, long size, boolean shared)   public abstract FileLock tryLock (long position, long size, boolean shared) </code></pre><p>锁定区域的范围不一定要限制在文件的size值以内，锁可以扩展从而超出文件尾。因此，我们可以提前把待写入数据的区域锁定，我们也可以锁定一个不包含任何文件内容的区域，比如文件最后一个字节以外的区域。如果之后文件增长到达那块区域，那么你的文件锁就可以保护该区域的文件内容了。相反地，如果你锁定了文件的某一块区域，然后文件增长超出了那块区域，那么新增加 的文件内容将不会受到您的文件锁的保护。</p><p>我们写一个简单实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c://1.txt"</span>, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        <span class="comment">// 写入4个字节</span></span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(<span class="string">"abcd"</span>.getBytes()));</span><br><span class="line">        <span class="comment">// 将前2个字节区域锁定（共享锁）</span></span><br><span class="line">        FileLock lock1 = fileChannel.lock(<span class="number">0</span>, <span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 当前锁持有锁的类型（共享锁/独占锁）</span></span><br><span class="line">        lock1.isShared();</span><br><span class="line">        <span class="comment">// IOException 不能修改只读的共享区域</span></span><br><span class="line">        <span class="comment">// fileChannel.write(ByteBuffer.wrap("a".getBytes()));</span></span><br><span class="line">        <span class="comment">// 可以修改共享锁之外的区域，从第三个字节开始写入</span></span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(<span class="string">"ef"</span>.getBytes()), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// OverlappingFileLockException 重叠的文件锁异常</span></span><br><span class="line">        <span class="comment">// FileLock lock2 = fileChannel.lock(0, 3, true);</span></span><br><span class="line">        <span class="comment">// FileLock lock3 = fileChannel.lock(0, 3, false);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到创建锁的通道</span></span><br><span class="line">        lock1.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁的起始位置</span></span><br><span class="line">        <span class="keyword">long</span> position = lock1.position();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁的范围</span></span><br><span class="line">        <span class="keyword">long</span> size = lock1.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断锁是否与指定文件区域有重叠</span></span><br><span class="line">        lock1.overlaps(position, size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记得用try/catch/finally&#123;release()&#125;方法释放锁</span></span><br><span class="line">        lock1.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们总结了NIO的4个新特性，对于IO来说都是很重要的功能以及性能的升级。下面我们写一个完整的NIO Socket客户端和服务端，总结一下NIO 的用法，每一行都加了注释：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识数字/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缓冲区大小/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> BLOCK = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">//接受数据缓冲区/</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer sendbuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="comment">//发送数据缓冲区/</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer receivebuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">7788</span>;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server(port);</span><br><span class="line">        server.listen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 打开服务器套接字通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 服务器配置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 检索与此通道关联的服务器套接字</span></span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        <span class="comment">// 进行服务的绑定</span></span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        <span class="comment">// 通过open()方法找到Selector</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">// 注册到selector，等待连接</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">"Server Start----7788:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 选择一组键，并且相应的通道已经打开</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 返回此选择器的已选择键集。</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handleKey(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleKey</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 接受请求</span></span><br><span class="line">        ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">        SocketChannel client = <span class="keyword">null</span>;</span><br><span class="line">        String receiveText;</span><br><span class="line">        String sendText;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 测试此键的通道是否已准备好接受新的套接字连接。</span></span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">// 接受到此通道套接字的连接。</span></span><br><span class="line">            <span class="comment">// 此方法返回的套接字通道（如果有）将处于阻塞模式。</span></span><br><span class="line">            client = server.accept();</span><br><span class="line">            <span class="comment">// 配置为非阻塞</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到selector，等待连接</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            client = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//将缓冲区清空以备下次读取</span></span><br><span class="line">            receivebuffer.clear();</span><br><span class="line">            <span class="comment">//读取服务器发送来的数据到缓冲区中</span></span><br><span class="line">            count = client.read(receivebuffer);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                receiveText = <span class="keyword">new</span> String(receivebuffer.array(), <span class="number">0</span>, count);</span><br><span class="line">                System.out.println(<span class="string">"服务器端接受客户端数据--:"</span> + receiveText);</span><br><span class="line">                client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">            <span class="comment">//将缓冲区清空以备下次写入</span></span><br><span class="line">            sendbuffer.clear();</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            client = (SocketChannel) selectionKey.channel();</span><br><span class="line">            sendText = <span class="string">"message from server--"</span> + flag++;</span><br><span class="line">            <span class="comment">//向缓冲区中输入数据</span></span><br><span class="line">            sendbuffer.put(sendText.getBytes());</span><br><span class="line">            <span class="comment">//将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位</span></span><br><span class="line">            sendbuffer.flip();</span><br><span class="line">            <span class="comment">//输出到通道</span></span><br><span class="line">            client.write(sendbuffer);</span><br><span class="line">            System.out.println(<span class="string">"服务器端向客户端发送数据--："</span> + sendText);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标识数字/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缓冲区大小/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> BLOCK = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">//接受数据缓冲区/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer sendbuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="comment">//发送数据缓冲区/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer receivebuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="comment">//服务器端地址/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> InetSocketAddress SERVER_ADDRESS = <span class="keyword">new</span> InetSocketAddress(</span><br><span class="line">            <span class="string">"localhost"</span>, <span class="number">7788</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 打开socket通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置为非阻塞方式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 打开选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 注册连接服务端socket动作</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="comment">// 连接</span></span><br><span class="line">        socketChannel.connect(SERVER_ADDRESS);</span><br><span class="line">        <span class="comment">// 分配缓冲区大小内存</span></span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator;</span><br><span class="line">        SelectionKey selectionKey;</span><br><span class="line">        SocketChannel client;</span><br><span class="line">        String receiveText;</span><br><span class="line">        String sendText;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//选择一组键，其相应的通道已为 I/O 操作准备就绪。</span></span><br><span class="line">            <span class="comment">//此方法执行处于阻塞模式的选择操作。</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//返回此选择器的已选择键集。</span></span><br><span class="line">            selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//System.out.println(selectionKeys.size());</span></span><br><span class="line">            iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                selectionKey = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"client connect"</span>);</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">// 判断此通道上是否正在进行连接操作。</span></span><br><span class="line">                    <span class="comment">// 完成套接字通道的连接过程。</span></span><br><span class="line">                    <span class="keyword">if</span> (client.isConnectionPending()) &#123;</span><br><span class="line">                        client.finishConnect();</span><br><span class="line">                        System.out.println(<span class="string">"完成连接!"</span>);</span><br><span class="line">                        sendbuffer.clear();</span><br><span class="line">                        sendbuffer.put(<span class="string">"Hello,Server"</span>.getBytes());</span><br><span class="line">                        sendbuffer.flip();</span><br><span class="line">                        client.write(sendbuffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//将缓冲区清空以备下次读取</span></span><br><span class="line">                    receivebuffer.clear();</span><br><span class="line">                    <span class="comment">//读取服务器发送来的数据到缓冲区中</span></span><br><span class="line">                    count = client.read(receivebuffer);</span><br><span class="line">                    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        receiveText = <span class="keyword">new</span> String(receivebuffer.array(), <span class="number">0</span>, count);</span><br><span class="line">                        System.out.println(<span class="string">"客户端接受服务器端数据--:"</span> + receiveText);</span><br><span class="line">                        client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">                    sendbuffer.clear();</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    sendText = <span class="string">"message from client--"</span> + (flag++);</span><br><span class="line">                    sendbuffer.put(sendText.getBytes());</span><br><span class="line">                    <span class="comment">//将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位</span></span><br><span class="line">                    sendbuffer.flip();</span><br><span class="line">                    client.write(sendbuffer);</span><br><span class="line">                    System.out.println(<span class="string">"客户端向服务器端发送数据--："</span> + sendText);</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            selectionKeys.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道是NIO是在2002年引入到J2SE 1.4里的，很多Java开发者比如我还是不知道怎么充分利用NIO，更少的人知道在Java SE 7里引入了更新的输入/输出 API（NIO.2）。但是对于普通的开发者来说基本的I/O操作就够用了，而NIO则是在处理I/O性能优化
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(一)简介</title>
    <link href="https://blog.rickiyang.cn/posts/ec039d95.html"/>
    <id>https://blog.rickiyang.cn/posts/ec039d95.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.143Z</updated>
    
    <content type="html"><![CDATA[<h4 id="I-O简介"><a href="#I-O简介" class="headerlink" title="I/O简介"></a><strong>I/O简介</strong></h4><p>在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。</p><p>Java NIO即Java Non-blocking IO(Java非阻塞I/O)，因为是在Jdk1.4之后增加的一套新的操作I/O工具包，所以一般会被叫做Java New IO。NIO是为提供I/O吞吐量而专门设计，其卓越的性能甚至可以与C媲美。NIO是通过Reactor模式的事件驱动机制来达到Non blocking的，那么什么是Reactor模式呢？Reactor翻译成中文是“反应器”，就是我们将事件注册到Reactor中，当有相应的事件发生时，Reactor便会告知我们有哪些事件发生了，我们再根据具体的事件去做相应的处理。</p><p>NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式–块I/O。块 I/O 的效率可以比流 I/O 高许多。NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p><p>面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p><p>一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><h4 id="NIO介绍"><a href="#NIO介绍" class="headerlink" title="NIO介绍"></a><strong>NIO介绍</strong></h4><p>NIO有三个核心模块：Selector(选择器)、Channel(通道)、Buffer(缓冲区)，另外java.nio.charsets包下新增的字符集类也是nio一个重要的模块，但个人觉得不算是NIO的核心，只是一个供NIO核心类使用的工具类。</p><h4 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a><strong>通道和缓冲区</strong></h4><h5 id="什么是通道"><a href="#什么是通道" class="headerlink" title="什么是通道"></a><strong>什么是通道</strong></h5><p>通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p><p>Channel是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。<br>正如前面提到的，所有数据都通过 Buffer 对象来处理。你永远不会将字节直接写入通道中，相反，你是将数据写入包含一个或者多个字节的缓冲区。同样，你不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p><p>下面是JAVA NIO中的一些主要Channel的实现：</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p><h4 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区"></a><strong>什么是缓冲区</strong></h4><p>Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，将数据直接写入或者将数据直接读到 Stream 对象中。在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>Buffer与chennel的关系如下：</p><p><img src="http://i.imgur.com/q3fA02A.png" alt=""></p><p>最常用的缓冲区类型是 ByteBuffer。一个 ByteBuffer 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。ByteBuffer 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>每一个 Buffer 类都是 Buffer 接口的一个实例。 除了 ByteBuffer，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I/O 操作都使用 ByteBuffer，所以它具有所有共享的缓冲区操作以及一些特有的操作。</p><h5 id="什么是Selector"><a href="#什么是Selector" class="headerlink" title="什么是Selector"></a><strong>什么是Selector</strong></h5><p>在并发型服务器程序中使用NIO，实际上是通过网络事件驱动模型实现的。我们应用Select 机制，不用为每一个客户端连接新启线程处理，而是将其注册到特定的Selector 对象上，这就可以在单线程中利用Selector 对象管理大量并发的网络连接，更好的利用了系统资源；采用非阻塞I/O的通信方式，不要求阻塞等待I/O 操作完成即可返回，从而减少了管理I/O 连接导致的系统开销，大幅度提高了系统性能。</p><p>当有读或写等任何注册的事件发生时，可以从Selector 中获得相应的SelectionKey ， 从SelectionKey 中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。由于在非阻塞网络I/O 中采用了事件触发机制，处理程序可以得到系统的主动通知，从而可以实现底层网络I/O无阻塞、流畅地读写，而不像在原来的阻塞模式下处理程序需要不断循环等待。使用NIO，可以编写出性能更好、更易扩展的并发型服务器程序。</p><p>这是在一个单线程中使用一个Selector处理4个Channel的图示：</p><p><img src="http://i.imgur.com/iWvaX0f.png" alt=""></p><p>要使用Selector，得先向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子比如有新连接进来或是数据接收等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;I-O简介&quot;&gt;&lt;a href=&quot;#I-O简介&quot; class=&quot;headerlink&quot; title=&quot;I/O简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;I/O简介&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（三）----线程的同步</title>
    <link href="https://blog.rickiyang.cn/posts/71e4d230.html"/>
    <id>https://blog.rickiyang.cn/posts/71e4d230.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.158Z</updated>
    
    <content type="html"><![CDATA[<p>在现实开发中，我们或多或少的都经历过这样的情景：某一个变量被多个用户并发式的访问并修改，如何保证该变量在并发过程中对每一个用户的正确性呢？今天我们来聊聊线程同步的概念。</p><p>一般来说，程序并行化是为了获得更高的执行效率，但前提是，高效率不能以牺牲正确性为代价。如果程序并行化后， 连基本的执行结果的正确性都无法保证， 那么并行程序本身也就没有任何意义了。因此， 线程安全就是并行程序的根本和根基。解决这些问题从<strong>临界区</strong>的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。</p><p>java为我们提供了同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。临界区有如下的规则：</p><blockquote><ol><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</li><li>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li></ol></blockquote><p>java语言为解决同步问题帮我们提供了两种机制来实现：</p><pre><code>1. synchronized关键字；2.     Lock锁及其实现；</code></pre><h4 id="synchronized的作用"><a href="#synchronized的作用" class="headerlink" title="synchronized的作用"></a>synchronized的作用</h4><p>关键字synchronized 的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次， 只能有一个线程进入同步块，从而保证线程间的安全性。</p><p>关键宇synchronized 可以有多种用法。这里做一个简单的整理。</p><pre><code>· 指定加锁对象: 对给定对象加锁，进入同步代码前要获得给定对象的锁。· 直接作用于实例方法: 相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。. 直接作用于静态方法: 相当于对当前类加锁， 进入同步代码前要获得当前类的锁。</code></pre><p>1.给指定对象加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync() ;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i =O;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span>(<span class="keyword">int</span> j=O; j&lt;lOOOOOOO; j++)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (instance) &#123;   <span class="comment">//对象锁</span></span><br><span class="line">                i++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> <span class="title">InterruptedException</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Thread t1=new Thread(instance)</span></span>;</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public static void main(String[] args) throws InterruptedException (</span></span><br><span class="line"><span class="comment">        Thread t1=new Thread(new AccountingSync());</span></span><br><span class="line"><span class="comment">        Thread t2=new Thread(new AccountingSync());</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        t2.start();</span></span><br><span class="line"><span class="comment">        t1.join();</span></span><br><span class="line"><span class="comment">        t2.join();</span></span><br><span class="line"><span class="comment">        System.out.println(i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道我为什么要给出两个main方法让大家参考吗？上述锁对象是锁定AccountingSync实例对象。第一个main方法中t1 和 t2 两个线程同时指向了instance实例，所以第7行的锁对象synchronized (instance)在线程t1 和 线程 t2 获得锁的时候是获取同一个对象的，这个时候的锁是同一把锁。但是在第二个main方法中我们可以看到线程t1 和 线程 t2分别对应的是两个不同的AccountingSync对象，这时候锁对象获得的是不同的AccountingSync实例，安全性是没有保证的，大家可以动手尝试一下。</p><p>2.直接作用于实例方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tester2 a1 = <span class="keyword">new</span> Tester2();</span><br><span class="line">        Th t1 = <span class="keyword">new</span> Th(a1);</span><br><span class="line">        t1.start();</span><br><span class="line">        Th t2 = <span class="keyword">new</span> Th(a1);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(name +<span class="string">","</span>+i+<span class="keyword">new</span> Date().toLocaleString() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Th</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    Tester2 test;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Th</span><span class="params">(Tester2 test1)</span></span>&#123;</span><br><span class="line">        test = test1;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.say(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对Tester2类中的方法使用synchronized很好理解，同一时刻如果t1正在调用say()方法，在他没有执行完毕并退出方法之前其余的线程是无法获得该方法的。只能排队等待知道t1执行完毕。</p><p>3.作用于静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">                Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Sale(<span class="number">5</span>));</span><br><span class="line">                Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producted(<span class="number">5</span>));</span><br><span class="line">                t1.start();</span><br><span class="line">                t2.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Shop</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">40</span>;</span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            a -= b;</span><br><span class="line">            System.out.println(<span class="string">"售出  "</span>+b+<span class="string">"  张大饼，"</span>+<span class="string">"还剩  "</span>+a+<span class="string">" 张大饼"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">factory</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">            a += c;</span><br><span class="line">            System.out.println(<span class="string">"仓库还有  "</span>+a+<span class="string">"  张大饼"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sale</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Sale</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                Thread.interrupted();</span><br><span class="line">            &#125;</span><br><span class="line">            Shop.shopping(b);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                Shop.factory(b-<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producted</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producted</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Shop.factory(b);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                Shop.shopping(b-<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">静态方法前加<span class="keyword">synchronized</span>这个锁等价于锁住了当前类的<span class="class"><span class="keyword">class</span>对象，因为静态方法或者是静态关键字在本质上是一个类对象，而不是成员对象，在内存中位于方法区被所有的实例共享。即等同于<span class="title">synchronized</span>(<span class="title">Shop</span>.<span class="title">class</span>)。我们需要注意的是锁住了类并不代表锁住了类所在的对象，类本身也是一种对象。它与类的实例是完全不同的两个对象，在加锁时不是相互依赖的，即对类加锁并不与上面例子中的加锁互斥，锁住了子类或子类的对象与锁住父类或父类的对象是不相关的。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">synchronized</span>的使用其实主要是前面两种，对象锁和方法锁，静态方法锁我们并不常用到。其余的操作方式都是在这两种的基础上演变而来，比如大家经常说的“块级锁”：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">```<span class="title">java</span></span></span><br><span class="line"><span class="class"><span class="title">synchronized</span>(<span class="title">object</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//代码内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁住的其实并不是代码块，而是object这个对象，所以如果在其他的代码中<br>也发生synchronized(object)时就会发生互斥。我们为什么要研究这些呢，因为如果我们不知道我们锁住的是什么，就不清楚锁住了多大范围的内容，自然就不知道是否锁住了想要得到互斥的效果，同时也不知道如何去优化锁的使用。</p><p>因此java中的synchronized就真正能做到临界区的效果，在临界区内多个线程的操作绝对是串行的，这一点java绝对可以保证。同时synchronized造成的开销也是很大的，我们如果无法掌握好他的粒度控制，就会导致频繁的锁征用，进入悲观锁状态。</p><p>####volatile—-轻量级的synchronized<br>既然我们说到了synchronized那就不得不提到volatile，在java中synchronized是控制并发的，我们知道在我们对一个变量执行赋值操作的时候比如：i++，在执行完毕之后i的结果其实是写到缓存中的它并没有及时的写入到内存，后续在某些情况下（比如cpu缓存不够）再将cpu缓存写入内存，假设A线程正在执行i++操作，而此时B线程也来执行。B在执行i++之前是不会自己跑到缓存中去取变量的值的，它只会去内存中读取i，很显然i的值是没有被更新的，为了防止这种情况出现，volatile应运而生。</p><p>Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWithoutVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bChanged;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (bChanged == !bChanged) &#123;  </span><br><span class="line">                        System.out.println(<span class="string">"!="</span>);  </span><br><span class="line">                        System.exit(<span class="number">0</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        Thread.sleep(<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    bChanged = !bChanged;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中我们如果多次运行会出现两种结果，一种是正常打印：”!=”,还有一种就是程序会陷入死循环。但是我们如果给bChanged前面加上volatile的话则每次都会打印出”!=”,请读者朋友们下去可以尝试。<br>在此处没有加volatile之前之所以会出现有时可以出现正确结果有时则卡死的原因就在于两个线程同时在运行的过程中双方都在操作bChanged变量，但是该变量的值对于同时在使用它的另一个线程来说并不总是可见的，运气好的时候线程修改完值之后就写入主存，运气不好的时候线程只在缓存中更新了值并未写入主存。但是在加了volatile修饰之后效果则不同，因为volatile可以保证变量的可见性。<br>说到可见性，我们来看一幅图：<br><img src="http://img.blog.csdn.net/20161222222356667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>每一个线程都有相应的工作内存，工作内存中有一份主内存变量的副本，线程对变量的操作都在工作内存中进行（避免再次访问主内存，提高性能），不同线程不能访问彼此的工作内存，而通过将操作后的值刷新到主内存来进行彼此的交互，这就会带来一个变量值对其他线程的可见性问题。当一个任务在工作内存中变量值进行改变，其他任务对此是不可见的，导致每一个线程都有一份不同的变量副本。而volatile恰恰可以解决这个可见性的问题，当变量被volatile修饰，如private volatile int stateFlag = 0; 它将直接通过主内存中被读取或者写入，线程从主内存中加载的值将是最新的。</strong></p><p>但是volatile的使用有着严格的限制，当对变量的操作依赖于以前值（如i++）,或者其值被其他字段的值约束，这个时候volatile是无法实现线程安全的。被volatile修饰的变量必须独立于程序的其他状态。因为volatile只是保证了变量的可见性，并不能保证操作的原子性，所谓原子性，即有“不可分”的意思，如对基本数据类型(java中排除long和double)的赋值操作a=6,如返回操作return a，这些操作都不会被线程调度器中断，同一时刻只有一个线程对它进行操作。<br>看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//这里延迟1毫秒，使得结果明显</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></span><br><span class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> + Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的例子我们可以发现每次运行的结果都不一样，预期结果应该是1000，尽管counter被volatile修饰，保证了可见性，但是counter++并不是一个原子性操作，它被拆分为读取和写入两部分操作，我们需要用synchronized修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicstaticsynchronizedvoid <span class="title">incNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时每次运行结果都是1000，实现了线程安全。synchronized是一种独占锁，它对一段操作或内存进行加锁，当线程要操作被synchronized修饰的内存或操作时，必须首先获得锁才能进行后续操作；但是在同一时刻只能有一个线程获得相同的一把锁，所以它只允许一个线程进行操作。synchronized同样能够将变量最新值刷新到主内存，当一个变量只被synchronized方法操作时,是没有必要用volatile修饰的，所以我们接着把变量声明修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br></pre></td></tr></table></figure><p>多次运行结果依旧是1000。</p><p><strong>说明</strong>：<br>上例中如果你按照上面这样改完之后其实结果并是不1000，我多次运行的结果都是先打印出”运行结果:Counter.count=0”,然后线程卡死。究其原因，我猜可能是第一个线程等待一秒再执行count++，然后后面的线程在这个等待过程中等不及的原因。java线程的运行具有不确定性，不能保证线程会按部就班的顺序执行，所以会出现什么样的后果很难预测。<br>正确结果代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></span><br><span class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> + Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，由于volatile只能保证变量对多个线程的可见性，但不能保证原子性，它的同步机制是比较脆弱的，它在使用过程中有着诸多限制，对使用者也有更高的要求，相对而言，synchronized锁机制是比较安全的同步机制，有时候出于提高性能的考虑，可以利用volatile对synchronized进行代替和优化，但前提是你必须充分理解其使用场景和涵义。</p><p>下一节我们接着分析Lock锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在现实开发中，我们或多或少的都经历过这样的情景：某一个变量被多个用户并发式的访问并修改，如何保证该变量在并发过程中对每一个用户的正确性呢？今天我们来聊聊线程同步的概念。&lt;/p&gt;
&lt;p&gt;一般来说，程序并行化是为了获得更高的执行效率，但前提是，高效率不能以牺牲正确性为代价。如果
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（三）----线程的同步</title>
    <link href="https://blog.rickiyang.cn/posts/71e4d230.html"/>
    <id>https://blog.rickiyang.cn/posts/71e4d230.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-05T06:13:34.116Z</updated>
    
    <content type="html"><![CDATA[<p>在现实开发中，我们或多或少的都经历过这样的情景：某一个变量被多个用户并发式的访问并修改，如何保证该变量在并发过程中对每一个用户的正确性呢？今天我们来聊聊线程同步的概念。</p><p>一般来说，程序并行化是为了获得更高的执行效率，但前提是，高效率不能以牺牲正确性为代价。如果程序并行化后， 连基本的执行结果的正确性都无法保证， 那么并行程序本身也就没有任何意义了。因此， 线程安全就是并行程序的根本和根基。解决这些问题从<strong>临界区</strong>的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。</p><p>java为我们提供了同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界 区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。临界区有如下的规则：</p><blockquote><ol><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</li><li>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li></ol></blockquote><p>java语言为解决同步问题帮我们提供了两种机制来实现：</p><pre><code>1. synchronized关键字；2. Lock锁及其实现；</code></pre><h4 id="1-synchronized的作用"><a href="#1-synchronized的作用" class="headerlink" title="1 synchronized的作用"></a>1 synchronized的作用</h4><p>关键字synchronized 的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次， 只能有一个线程进入同步块，从而保证线程间的安全性。</p><p>关键宇synchronized 可以有多种用法。这里做一个简单的整理。</p><pre><code>· 指定加锁对象: 对给定对象加锁，进入同步代码前要获得给定对象的锁。· 直接作用于实例方法: 相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。. 直接作用于静态方法: 相当于对当前类加锁， 进入同步代码前要获得当前类的锁。</code></pre><p>1.给指定对象加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync() ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i =O;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span>(<span class="keyword">int</span> j=O; j&lt;lOOOOOOO; j++)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (instance) &#123;   <span class="comment">//对象锁</span></span><br><span class="line">            i++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> <span class="title">InterruptedException</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Thread t1=new Thread(instance)</span></span>;</span><br><span class="line">    Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static void main(String[] args) throws InterruptedException (</span></span><br><span class="line"><span class="comment">    Thread t1=new Thread(new AccountingSync());</span></span><br><span class="line"><span class="comment">    Thread t2=new Thread(new AccountingSync());</span></span><br><span class="line"><span class="comment">    t1.start();</span></span><br><span class="line"><span class="comment">    t2.start();</span></span><br><span class="line"><span class="comment">    t1.join();</span></span><br><span class="line"><span class="comment">    t2.join();</span></span><br><span class="line"><span class="comment">    System.out.println(i);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>知道我为什么要给出两个main方法让大家参考吗？上述锁对象是锁定AccountingSync实例对象。第一个main方法中t1 和 t2 两个线程同时指向了instance实例，所以第7行的锁对象synchronized (instance)在线程t1 和 线程 t2 获得锁的时候是获取同一个对象的，这个时候的锁是同一把锁。但是在第二个main方法中我们可以看到线程t1 和 线程 t2分别对应的是两个不同的AccountingSync对象，这时候锁对象获得的是不同的AccountingSync实例，安全性是没有保证的，大家可以动手尝试一下。</p><p>2.直接作用于实例方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tester2 a1 = <span class="keyword">new</span> Tester2();</span><br><span class="line">        Th t1 = <span class="keyword">new</span> Th(a1);</span><br><span class="line">        t1.start();</span><br><span class="line">        Th t2 = <span class="keyword">new</span> Th(a1);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(name +<span class="string">","</span>+i+<span class="keyword">new</span> Date().toLocaleString() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Th</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    Tester2 test;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Th</span><span class="params">(Tester2 test1)</span></span>&#123;</span><br><span class="line">        test = test1;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.say(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对Tester2类中的方法使用synchronized很好理解，同一时刻如果t1正在调用say()方法，在他没有执行完毕并退出方法之前其余的线程是无法获得该方法的。只能排队等待知道t1执行完毕。</p><p>3.作用于静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Sale(<span class="number">5</span>));</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producted(<span class="number">5</span>));</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shop</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">40</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a -= b;</span><br><span class="line">        System.out.println(<span class="string">"售出  "</span>+b+<span class="string">"  张大饼，"</span>+<span class="string">"还剩  "</span>+a+<span class="string">" 张大饼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">factory</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        a += c;</span><br><span class="line">        System.out.println(<span class="string">"仓库还有  "</span>+a+<span class="string">"  张大饼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sale</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sale</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125;</span><br><span class="line">        Shop.shopping(b);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            Shop.factory(b-<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producted</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producted</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Shop.factory(b);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            Shop.shopping(b-<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法前加synchronized这个锁等价于锁住了当前类的class对象，因为静态方法或者是静态关键字在本质上是一个类对象，而不是成员对象，在内存中位于方法区被所有的实例共享。即等同于synchronized(Shop.class)。我们需要注意的是锁住了类并不代表锁住了类所在的对象，类本身也是一种对象。它与类的实例是完全不同的两个对象，在加锁时不是相互依赖的，即对类加锁并不与上面例子中的加锁互斥，锁住了子类或子类的对象与锁住父类或父类的对象是不相关的。</p><p>synchronized的使用其实主要是前面两种，对象锁和方法锁，静态方法锁我们并不常用到。其余的操作方式都是在这两种的基础上演变而来，比如大家经常说的“块级锁”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">    <span class="comment">//代码内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁住的其实并不是代码块，而是object这个对象，所以如果在其他的代码中<br>也发生synchronized(object)时就会发生互斥。我们为什么要研究这些呢，因为如果我们不知道我们锁住的是什么，就不清楚锁住了多大范围的内容，自然就不知道是否锁住了想要得到互斥的效果，同时也不知道如何去优化锁的使用。</p><p>因此java中的synchronized就真正能做到临界区的效果，在临界区内多个线程的操作绝对是串行的，这一点java绝对可以保证。同时synchronized造成的开销也是很大的，我们如果无法掌握好他的粒度控制，就会导致频繁的锁征用，进入悲观锁状态。</p><h4 id="2-volatile—-轻量级的synchronized"><a href="#2-volatile—-轻量级的synchronized" class="headerlink" title="2 volatile—-轻量级的synchronized"></a>2 volatile—-轻量级的synchronized</h4><p>既然我们说到了synchronized那就不得不提到volatile，在java中synchronized是控制并发的，我们知道在我们对一个变量执行赋值操作的时候比如：i++，在执行完毕之后i的结果其实是写到缓存中的它并没有及时的写入到内存，后续在某些情况下（比如cpu缓存不够）再将cpu缓存写入内存，假设A线程正在执行i++操作，而此时B线程也来执行。B在执行i++之前是不会自己跑到缓存中去取变量的值的，它只会去内存中读取i，很显然i的值是没有被更新的，为了防止这种情况出现，volatile应运而生。</p><p>Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWithoutVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bChanged;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (bChanged == !bChanged) &#123;  </span><br><span class="line">                        System.out.println(<span class="string">"!="</span>);  </span><br><span class="line">                        System.exit(<span class="number">0</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        Thread.sleep(<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    bChanged = !bChanged;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中我们如果多次运行会出现两种结果，一种是正常打印：”!=”,还有一种就是程序会陷入死循环。但是我们如果给bChanged前面加上volatile的话则每次都会打印出”!=”,请读者朋友们下去可以尝试。<br>在此处没有加volatile之前之所以会出现有时可以出现正确结果有时则卡死的原因就在于两个线程同时在运行的过程中双方都在操作bChanged变量，但是该变量的值对于同时在使用它的另一个线程来说并不总是可见的，运气好的时候线程修改完值之后就写入主存，运气不好的时候线程只在缓存中更新了值并未写入主存。但是在加了volatile修饰之后效果则不同，因为volatile可以保证变量的可见性。<br>说到可见性，我们来看一幅图：</p><p><img src="http://img.blog.csdn.net/20161222222356667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>每一个线程都有相应的工作内存，工作内存中有一份主内存变量的副本，线程对变量的操作都在工作内存中进行（避免再次访问主内存，提高性能），不同线程不能访问彼此的工作内存，而通过将操作后的值刷新到主内存来进行彼此的交互，这就会带来一个变量值对其他线程的可见性问题。当一个任务在工作内存中变量值进行改变，其他任务对此是不可见的，导致每一个线程都有一份不同的变量副本。而volatile恰恰可以解决这个可见性的问题，当变量被volatile修饰，如private volatile int stateFlag = 0; 它将直接通过主内存中被读取或者写入，线程从主内存中加载的值将是最新的。</strong></p><p>但是volatile的使用有着严格的限制，当对变量的操作依赖于以前值（如i++）,或者其值被其他字段的值约束，这个时候volatile是无法实现线程安全的。被volatile修饰的变量必须独立于程序的其他状态。因为volatile只是保证了变量的可见性，并不能保证操作的原子性，所谓原子性，即有“不可分”的意思，如对基本数据类型(java中排除long和double)的赋值操作a=6,如返回操作return a，这些操作都不会被线程调度器中断，同一时刻只有一个线程对它进行操作。<br>看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//这里延迟1毫秒，使得结果明显</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></span><br><span class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> + Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的例子我们可以发现每次运行的结果都不一样，预期结果应该是1000，尽管counter被volatile修饰，保证了可见性，但是counter++并不是一个原子性操作，它被拆分为读取和写入两部分操作，我们需要用synchronized修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicstaticsynchronizedvoid <span class="title">incNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时每次运行结果都是1000，实现了线程安全。synchronized是一种独占锁，它对一段操作或内存进行加锁，当线程要操作被synchronized修饰的内存或操作时，必须首先获得锁才能进行后续操作；但是在同一时刻只能有一个线程获得相同的一把锁，所以它只允许一个线程进行操作。synchronized同样能够将变量最新值刷新到主内存，当一个变量只被synchronized方法操作时,是没有必要用volatile修饰的，所以我们接着把变量声明修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br></pre></td></tr></table></figure><p>多次运行结果依旧是1000。</p><p><strong>说明</strong>：<br>上例中如果你按照上面这样改完之后其实结果并是不1000，我多次运行的结果都是先打印出”运行结果:Counter.count=0”,然后线程卡死。究其原因，我猜可能是第一个线程等待一秒再执行count++，然后后面的线程在这个等待过程中等不及的原因。java线程的运行具有不确定性，不能保证线程会按部就班的顺序执行，所以会出现什么样的后果很难预测。<br>正确结果代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Counter.inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></span><br><span class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> + Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，由于volatile只能保证变量对多个线程的可见性，但不能保证原子性，它的同步机制是比较脆弱的，它在使用过程中有着诸多限制，对使用者也有更高的要求，相对而言，synchronized锁机制是比较安全的同步机制，有时候出于提高性能的考虑，可以利用volatile对synchronized进行代替和优化，但前提是你必须充分理解其使用场景和涵义。</p><p>下一节我们接着分析Lock锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在现实开发中，我们或多或少的都经历过这样的情景：某一个变量被多个用户并发式的访问并修改，如何保证该变量在并发过程中对每一个用户的正确性呢？今天我们来聊聊线程同步的概念。&lt;/p&gt;
&lt;p&gt;一般来说，程序并行化是为了获得更高的执行效率，但前提是，高效率不能以牺牲正确性为代价。如果
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(二)Buffer</title>
    <link href="https://blog.rickiyang.cn/posts/e8d11d6a.html"/>
    <id>https://blog.rickiyang.cn/posts/e8d11d6a.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.144Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要与 NIO Channel 进行交互时, 我们就需要使用到 NIO Buffer, 即数据从 Buffer读取到 Channel 中, 并且从 Channel 中写入到 Buffer 中。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p><h4 id="缓冲区基础"><a href="#缓冲区基础" class="headerlink" title="缓冲区基础"></a><strong>缓冲区基础</strong></h4><p>Buffer 类型有:</p><p><img src="http://i.imgur.com/co6hMaY.png" alt=""></p><p>缓冲区是包在一个对象内的基础数据的数组，Buffer类相比一般简单数组而言其优点是将数据的内容和相关信息放在一个对象里面，这个对象提供了处理缓冲区数据的丰富的API。</p><p>所有缓冲区都有4个属性：capacity、limit、position、mark，并遵循：capacity&gt;=limit&gt;=position&gt;=mark&gt;=0，下面是对这4个属性的解释：</p><ul><li>Capacity:&nbsp;&nbsp;&nbsp;&nbsp; 容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</li><li>Limit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上界，缓冲区中当前数据量</li><li>Position: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位置，下一个要被读或写的元素的索引</li><li>Mark:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记，调用mark()来设置mark=position，再调用reset()可以让position恢复到标记的位置即position=mark</li></ul><p>我们通过一个简单的操作流程来说明buffer的使用，下图是新创建的容量为10的缓冲区逻辑视图：</p><p><img src="http://i.imgur.com/HNu79ue.png" alt=""></p><p>然后进行5次调用put：<br>buffer.put((byte)’A’).put((byte)’B’).put((byte)’C’).put((byte)’D’).put((byte)’E’)</p><p>5次调用put之后的缓冲区为：<br><img src="http://i.imgur.com/PtNCleq.png" alt=""></p><p>现在缓冲区满了，我们必须将其清空。我们想把这个缓冲区传递给一个通道，以使内容能被全部写出，但现在执行get()无疑会取出未定义的数据。我们必须将 posistion设为0，然后通道就会从正确的位置开始读了，但读到哪算读完了呢？这正是limit引入的原因，它指明缓冲区有效内容的未端。这个操作 在缓冲区中叫做翻转：buffer.flip()。</p><p><img src="http://i.imgur.com/ExlR0LW.png" alt=""></p><h4 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a><strong>Buffer的基本用法</strong></h4><p>使用Buffer读写数据一般遵循以下四个步骤：</p><ol><li>写入数据到Buffer</li><li>调用flip()方法</li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法</li></ol><p>当向buffer写入数据时，buffer会记录下写了多少数据。</p><p>一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p><p>下面我们看一段程序来看一下Buffer的基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">     RandomAccessFile aFile = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//文件流</span></span><br><span class="line">        aFile = <span class="keyword">new</span> RandomAccessFile(fileName, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">//将文件输入到管道</span></span><br><span class="line">         FileChannel inChannel = aFile.getChannel();</span><br><span class="line">        <span class="comment">//为buffer分配1024个字节大小的空间</span></span><br><span class="line">         ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//将buffer中的内容读取到管道中</span></span><br><span class="line">         <span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line">         <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">             <span class="comment">//反转buffer，将写模式改为读模式</span></span><br><span class="line">              buf.flip();</span><br><span class="line">             <span class="keyword">while</span> (buf.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">//获取buffer中的数据</span></span><br><span class="line">                System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">//将上次分配的1024字节的内容清空，为下次接收做准备</span></span><br><span class="line">             buf.clear();</span><br><span class="line">            <span class="comment">//管道重新读取buffer中的内容</span></span><br><span class="line">             bytesRead = inChannel.read(buf);</span><br><span class="line">         &#125;</span><br><span class="line">         aFile.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="字节缓冲区"><a href="#字节缓冲区" class="headerlink" title="字节缓冲区"></a><strong>字节缓冲区</strong></h4><p>我们将进一步观察字节缓冲区。所有的基本数据类型都有相应的缓冲区类（布尔型除外），但字节缓冲区有自己的独特之处。字节是操作系统及其I/O设备使用的基本数据类型。当在JVM和操作系统间传递数据时，将其他的数据类型拆分成构成它们的字节是十分必要的。如我们在后面的章节中将要看到的那样，系统层次的I/O面向字节的性质可以在整个缓冲区的设计以及它们互相配合的服务中感受到。</p><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a><strong>直接缓冲区</strong></h4><p>我们知道操作系统是在内存中进行I/O操作，这些内存区域，就操作系统方面而言，是相连的字节序列。于是，毫无疑问，只有字节缓冲区有资格参与I/O操作。即操作系统会直接存取进程，那么我们现在在JVM中进行操作，java中的内存空间是由JVM直接进行管理，但是在JVM中，字节数组可能不会在内存中连续存储，或者无用存储单元收集可能随时对其进行移动，这就不能保证I/O操作的目标是连续的。</p><p>出于这一原因，引入了直接缓冲区的概念。直接缓冲区被用于与通道和固有I/O例程交互。它们通过使用固有代码来告知操作系统直接释放或填充内存区域，对用于通道直接或原始存取的内存区域中的字节元素的存储尽了最大的努力。</p><p>直接字节缓冲区通常是I/O操作最好的选择。在设计方面，它们支持JVM可用的最高效I/O机制。非直接字节缓冲区可以被传递给通道，但是这样可能导致性能损耗。通常非直接缓冲不可能成为一个本地I/O操作的目标。如果您向一个通道中传递一个非直接ByteBuffer对象用于写入，通道可能会在每次调用中隐含地进行下面的操作： </p><ol><li>创建一个临时的直接ByteBuffer对象。</li><li>将非直接缓冲区的内容复制到临时缓冲中。</li><li>使用临时缓冲区执行低层次I/O操作。</li><li>临时缓冲区对象离开作用域，并最终成为被回收的无用数据。</li></ol><h4 id="视图缓冲区"><a href="#视图缓冲区" class="headerlink" title="视图缓冲区"></a><strong>视图缓冲区</strong></h4><p>就像我们已经讨论的那样，I/O基本上可以归结成组字节数据的四处传递。在进行大数据量的I/O操作时，很又可能你会使用各种ByteBuffer类去读取文件内容，接收来自网络连接的数据，等等。一旦数据到达了你的ByteBuffer，您就需要查看它以决定怎么做或者在将它发送出去之前对它进行一些操作。ByteBuffer类提供了丰富的API来创建视图缓冲区。</p><p>视图缓冲区通过已存在的缓冲区对象实例的工厂方法来创建。这种视图对象维护它自己的属性，容量，位置，上界和标记，但是和原来的缓冲区共享数据元素。但是ByteBuffer类允许创建视图来将byte型缓冲区字节数据映射为其它的原始数据类型。例如，asLongBuffer()函数创建一个将八个字节型数据当成一个long型数据来存取的视图缓冲区。</p><p>但是使用视图缓冲区的话，一旦ByteBuffer对于视图的维护对象产生非常规行的使用，那么对于工厂方法创建的缓冲区而言，asLongBuffer()函数就不在使用这个视窗，那么这个8字节的数据当成一个long类型的数据类型来存取的数据视图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们需要与 NIO Channel 进行交互时, 我们就需要使用到 NIO Buffer, 即数据从 Buffer读取到 Channel 中, 并且从 Channel 中写入到 Buffer 中。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq入门(二)</title>
    <link href="https://blog.rickiyang.cn/posts/a042465a.html"/>
    <id>https://blog.rickiyang.cn/posts/a042465a.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.145Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们了解了JMS规范并且知道了JMS规范的良好实现者-activemq。今天我们就去了解一下activemq的使用。另外我们应该抱着目的去学习，别忘了我们为什么要使用消息中间件：解耦系统之间的联系，同步或异步的消息传输，尤其是异步的消息传输，分布式环境下，可靠、高效的消息传输，可以保证消息的重发性和顺序性。即解决业务系统比较多或者是分布式环境下的系统之间安全有效通信的问题，带着这样的目的我们来学习消息中间件就有了方向。</p><h4 id="1-为什么用activemq"><a href="#1-为什么用activemq" class="headerlink" title="1. 为什么用activemq"></a><strong>1. 为什么用activemq</strong></h4><p>在设计分布式应用程序时，应用程序间的耦合（或称集成）方式很重要。耦合意味着两个或者多个应用程序或系统的相互依赖关系。一种简单的方式是在所有的应用程序中从架构上设计他们与其他应用程序间的交叉实现。这样必然导致，一个应用程序的改变，直接导致另一个应用程序的改变。</p><p>ActiveMQ采用松耦合方式，应用程序将消息发送给ActiveMQ而并不关心什么时间以何种方式消息投递给接收者。同样的，消息接收者也不会关心消息来源于哪里和消息是怎样投递给ActiveMQ的。对于多语言编写的复杂应用环境中，允许客户端使用不同的编程语言甚至不同的消息包装协议。ActiveMQ作为消息的中间件，允许复杂的多语言应用程序以一种一步的方式集成和交互。所以说，ActiveMQ是一种好的，提供松散耦合的，能够为多语言交叉应用提供集成的中间件。</p><h4 id="2-什么时候用activemq"><a href="#2-什么时候用activemq" class="headerlink" title="2. 什么时候用activemq"></a><strong>2. 什么时候用activemq</strong></h4><p>ActiveMQ的设计目标是提供标准的，面向消息的，能够跨越多语言和多系统的应用集成消息通信中间件。大多数情况下ActiveMQ被用于做系统之间的数据交换。</p><p>只要是两个应用程序间需要通信的情况，都可以考虑使用JMS，不论这种通信是在本地的（就是通信的两个应用程序在同一台主机上），还是分布在不同机器上。尽管是在同一个主机上的两个应用程序需要通信也可以使用ActiveMQ。ActiveMQ可以确保消息投递成功并采用异步方式通信。</p><h4 id="3-activemq特性"><a href="#3-activemq特性" class="headerlink" title="3. activemq特性"></a><strong>3. activemq特性</strong></h4><p>支持JMS规范：ActiveMQ完全实现了JMS1.1规范。</p><p>连接方式的多样化：ActiveMQ提供了广泛的连接模式，包括HTTP/S、JGroups、JXTA、muticast、SSL、TCP、UDP、XMPP等。提供了如此多的连接模式表明了ActiveMQ具有较高的灵活性。</p><p>与其他的Java容器紧密集成：ActiveMQ提供了和其它流行的Java容器的结合，包括Apache Geronimo、Apache Tomcat、JBoss、Jetty等。</p><p>客户端API：ActiveMQ提供了多种客户端可访问的API，包括Java、C/C++，.NET，Perl、PHP、Python、Ruby等。当然，ActiveMQ中介必须运行在Java虚拟机中，但是使用它的客户端可以使用其他的语言来实现。</p><p>中介集群：多个ActiveMQ中介可以一起协同工作，来完成某项复杂的工作，这被称为网络型中介（network of brokers），这种类型的中介将会支持多种拓扑类型。</p><h4 id="4-使用activemq"><a href="#4-使用activemq" class="headerlink" title="4. 使用activemq"></a><strong>4. 使用activemq</strong></h4><p>首先我们去apache上下载activemq，<a href="http://activemq.apache.org/" target="_blank" rel="noopener">点此下载</a>。</p><p>接下来我是使用maven来管理jar的，如果你不用maven的话就去刚下载的activemq包中找到jar包导入即可。maven引入jar：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.14.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后我们进入刚下载的activemq，我进入的路径如下：apache-activemq-5.14.5-bin\apache-activemq-5.14.5\bin\win64\activemq.bat<br>,我用的是64位的系统，如果你是32位的同理进入相应文件夹下点击activemq.bat启动activemq客户端，启动完成之后，直接访问ActiveMQ管理页面<a href="http://localhost:8161/admin/" target="_blank" rel="noopener">http://localhost:8161/admin/</a> 默认用户名密码admin/admin。</p><p>客户端界面如下：</p><p><img src="http://i.imgur.com/C7gRpOs.jpg" alt=""></p><p>接下来该我们写代码的时候了，首先我们还是先写一个P2P(点对点)模式的客户端。代码如下：</p><p>Sender.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Connection;</span><br><span class="line"><span class="keyword">import</span> javax.jms.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.DeliveryMode;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageProducer;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ConnectionFactory是连接工厂，JMS用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Connection JMS客户端到JMS provider的连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Session 一个发送或者接收消息的线程</span></span><br><span class="line">        Session session;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Destination 消息发送目的地，消息发送给谁接收</span></span><br><span class="line">        Destination destination;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MessageProducer 消息发送者</span></span><br><span class="line">        MessageProducer messageProducer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造ConnectionFactory 实例对象，此处采用ActiveMQ的实现jar</span></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">            connection.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个Queue，名称为FirstQueue</span></span><br><span class="line">            destination = session.createQueue(<span class="string">"FirstQueue"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到消息生产者【发送者】</span></span><br><span class="line">            messageProducer = session.createProducer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置不持久化，根据实际情况而定</span></span><br><span class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个消息对象</span></span><br><span class="line">            TextMessage message = session.createTextMessage();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把我们的消息写入msg对象中</span></span><br><span class="line">            BufferedReader b=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Enter Msg, end to terminate:"</span>);</span><br><span class="line">                String s=b.readLine();</span><br><span class="line">                <span class="keyword">if</span> (s.equals(<span class="string">"end"</span>))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                message.setText(s);</span><br><span class="line">                <span class="comment">//发送消息</span></span><br><span class="line">                messageProducer.send(message);</span><br><span class="line">                System.out.println(<span class="string">"Message successfully sent."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != connection)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Receiver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Connection;</span><br><span class="line"><span class="keyword">import</span> javax.jms.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageConsumer;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//connectionFactory 连接工厂，JMS用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//connection JMS客户端到JMS provider 的连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//session一个发送或者接收的线程</span></span><br><span class="line">        Session session;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//destination 消息目的地，发送给谁接收</span></span><br><span class="line">        Destination destination;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费者消息接收者</span></span><br><span class="line">        MessageConsumer consumer;</span><br><span class="line"></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">            connection.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">            destination = session.createQueue(<span class="string">"FirstQueue"</span>);</span><br><span class="line">            consumer = session.createConsumer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//设置接收者收消息的时间，为了方便测试，这里暂定设置为100s</span></span><br><span class="line">                TextMessage message = (TextMessage)consumer.receive(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != message)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息==="</span>+message.getText());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != connection)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码已经注释过了，就不多做解释，接着我们先运行Sender,需要你在控制台输入你要发送的消息，当你输入”end”的时候才会结束输入，否则你每一次输入按回车都是发送一条消息。然后去看一下activemq的控制台，点击一下菜单栏上的Queues：</p><p><img src="http://i.imgur.com/XqBRQr4.jpg" alt=""></p><p>因为我刚发送了两条消息在这里会显示，消息会由activemq这个中间人统一管理，当接受者需要接受消息的时候，他会来请求activemq，从这里获取消息而不是发送端一直等着接收端。</p><p>下面你可以运行一下Receiver，这时候就把刚才这两条消息消费了。消息队列此刻就是空的。之所以强调这一点是为了和接下来的 发布/订阅 模式做一个比较，限于篇幅我就不截图了，大家可以尝试。</p><p>下面我们接着写一个Pub/Sub模式的例子，并没有多大的变化，在创建消息队列的时候改为topic模式：</p><p>TopicSender.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/4/25.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ConnectionFactory是连接工厂，JMS用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Connection JMS客户端到JMS provider的连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Session 一个发送或者接收消息的线程</span></span><br><span class="line">        Session session;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Destination 消息发送目的地，消息发送给谁接收</span></span><br><span class="line">        Topic destination;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MessageProducer 消息发送者</span></span><br><span class="line">        MessageProducer messageProducer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造ConnectionFactory 实例对象，此处采用ActiveMQ的实现jar</span></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">            connection.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个Queue，SecondQueue 此处使用的是Topic模式</span></span><br><span class="line">            destination = session.createTopic(<span class="string">"SecondQueue"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到消息生产者【发送者】</span></span><br><span class="line">            messageProducer = session.createProducer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置不持久化，根据实际情况而定</span></span><br><span class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个消息对象</span></span><br><span class="line">            TextMessage message = session.createTextMessage();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把我们的消息写入msg对象中</span></span><br><span class="line">            BufferedReader b=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            message.setText(<span class="string">"你好"</span>);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            messageProducer.send(message);</span><br><span class="line">            System.out.println(<span class="string">"Message successfully sent."</span>);</span><br><span class="line"></span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != connection)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理接受方也是如此：</p><p>TopicReciever.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReciever</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//connectionFactory 连接工厂，JMS用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//connection JMS客户端到JMS provider 的连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//session一个发送或者接收的线程</span></span><br><span class="line">        <span class="keyword">final</span> Session session;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//destination 消息目的地，发送给谁接收 这里注意改成Topic类型的</span></span><br><span class="line">        Topic destination;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费者消息接收者</span></span><br><span class="line">        <span class="keyword">final</span> MessageConsumer consumer;</span><br><span class="line"></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">            connection.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//此处使用的是Topic模式</span></span><br><span class="line">            destination = session.createTopic(<span class="string">"SecondQueue"</span>);</span><br><span class="line">            consumer = session.createConsumer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//设置接收者收消息的时间</span></span><br><span class="line">                TextMessage message = (TextMessage)consumer.receive(<span class="number">10000</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != message)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息==="</span>+message.getText());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以把Reciever同样的代码再复制一份Reciever1，然后我们先把两个接收端启动，再启动发送端，这时候我们发现消息被接受到了；但是如果我们先启动发送端再启动接收端，这时候虽然消息是被发送出去了，但是接收端并未收到，这是为什么呢？这就是我前面在讲P2P模式的时候留下的一个对比点：</p><p>P2P模式是1V1的，我发送只对当前声明的这个标识，接受者也只接受该标识所对应的消息。一旦接受者获取该消息，该标识对应的消息即从消息队列中移除；</p><p>Pub/Sub模式是1 V N 的，1个发送端发出的消息，可以有多个接收端去消费，但是有一个前提：想消费这条消息的接收端必须先注册，即先启动接收端去activemq的客户端注册，发送端就根据注册的情况主动把消息推送到订阅过该消息的消费者。</p><p><img src="http://img.blog.csdn.net/20170426234611917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>我们看到消息队列里面有一条消息，然后有两位消费者来订阅这一条消息，上面我们看到两个消费者分别取队列取一次消息，然后activemq会创建两个临时生产者去他们服务把消息给他们。</p><p>好拉，这一节的入门知识就讲到这里，既然是入门我们就不必太深刻，不然适得其反啊！哈哈。下面开始我们就详细的探讨activemq的一些特性以及消息中间件在集群环境中的应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们了解了JMS规范并且知道了JMS规范的良好实现者-activemq。今天我们就去了解一下activemq的使用。另外我们应该抱着目的去学习，别忘了我们为什么要使用消息中间件：解耦系统之间的联系，同步或异步的消息传输，尤其是异步的消息传输，分布式环境下，可靠、高效的
      
    
    </summary>
    
      <category term="activeMQ" scheme="https://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq消息机制和持久化介绍(三)</title>
    <link href="https://blog.rickiyang.cn/posts/28fe9931.html"/>
    <id>https://blog.rickiyang.cn/posts/28fe9931.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.146Z</updated>
    
    <content type="html"><![CDATA[<p>前面一节简单学习了activemq的使用，我们知道activemq的使用方式非常简单有如下几个步骤：</p><ol><li>创建连接工厂</li><li>创建连接 </li><li>创建会话</li><li>创建目的地</li><li>创建生产者或消费者</li><li>生产或消费消息</li><li>关闭生产或消费者、关闭会话、关闭连接</li></ol><p>前面我们的实例代码中已经按照这个步骤完成了P2P和Pub/Sub模式的消息发送和接收。那么这一节我们就针对他的消息传播机制和持久化方式做一个简单的学习。在会用的同时我们也需要理解一些基本的概念，这样才不至于在出错后无从下手。</p><h4 id="1-activemq服务器工作模型"><a href="#1-activemq服务器工作模型" class="headerlink" title="1.activemq服务器工作模型"></a><strong>1.activemq服务器工作模型</strong></h4><p>我们先看一下消息发送的时序图：</p><p><img src="http://img.blog.csdn.net/20170502232257791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>ConnectionFactory 对象创建一个连接工厂，消息的发送和接受服务均由此进行；</p><p>ConnectionFactory 创建一个活动Connection作为当前使用的连接；</p><p>Session 是一个用于生成和使用消息的单线程上下文，它用于创建发送的生产者和接收消息的消费者，并为所发送的消息定义发送顺序。会话通过大量确认选项或通过事务来支持可靠传送。</p><p>户端使用 MessageProducer 向指定的物理目标发送消息，生产者可指定一个默认传送模式（持久性消息与非持久性消息）、优先级和有效期值，以控制生产者向物理目标发送的所有消息；</p><p>消费者可以支持同步或异步消息接收。异步使用可通过向消费者注册 MessageListener 来实现。当会话线程调用 MessageListener 对象的 onMessage 方法时，客户端将使用消息。</p><h4 id="2-ActiveMQ消息传送模型"><a href="#2-ActiveMQ消息传送模型" class="headerlink" title="2.ActiveMQ消息传送模型"></a><strong>2.ActiveMQ消息传送模型</strong></h4><p> ActiveMQ 支持两种消息传送模型：PTP（即点对点模型）和Pub/Sub（即发布 /订阅模型）,前面我们已经讲过，在此就不赘述。</p><h4 id="3-消息选择器"><a href="#3-消息选择器" class="headerlink" title="3.消息选择器"></a><strong>3.消息选择器</strong></h4><p>ActiveMQ提供了一种机制，使用它，消息服务可根据消息选择器中的标准来执行消息过滤。生产者可在消息中放入应用程序特有的属性，而消费者可使用基于这些属性的选择标准来表明对消息是否感兴趣。</p><p>消息选择器是根据 header 和 properties 允许客户端选择性的制定需要接收的消息，消息选择器是无法利用 消息主体(Body)进行过滤的。无论你的消息主题是什么类型， 文本、或者对象、或者键值对。下面我们讲一下消息选择器的语法以及使用规范：</p><p>可接收的类型包括：byte,int,double,boolean,String;</p><h5 id="属性标识符定义："><a href="#属性标识符定义：" class="headerlink" title="属性标识符定义："></a>属性标识符定义：</h5><pre><code>变量名与java定义一样； 要么在heads中定义 要么在 properties中定义，如果在sender中是在heads中定义而receiver中却从properties中寻找的话，找不到的情况下他是不会自动去heads中寻找的，而是会返回null；根据不同类型的变量选择不同的方法：message.setIntProperty(&quot;test&quot;,14);那么在接收端可以对该变量进行拦截：session.createConsumer(destination,&quot;test &gt; 14&quot;)；属性标志符是区分大小写的；</code></pre><h5 id="拦截器中的部分表示方式："><a href="#拦截器中的部分表示方式：" class="headerlink" title="拦截器中的部分表示方式："></a>拦截器中的部分表示方式：</h5><pre><code>可以是条件表达式可以是算术表达式可以是比较运算和逻辑运算组成的表达式</code></pre><p>支持 () 左右括号；</p><p>支持逻辑运算的优先顺序表达式 例如: NOT , AND , OR；</p><p>比较运算符有: = , &gt; , &gt;= , &lt; , &lt;= , &lt;&gt; (not equal)；</p><p>eg：</p><pre><code>标识符是null&quot;prop_name IS NULL&quot;标识符非空 not null&quot;prop_name IS NOT NULL&quot;&quot;age BETWEEN 15 AND 19&quot; is equivalent to &quot;age &gt;= 15 AND age &lt;= 19&quot;&quot;Country NOT IN (&apos; UK&apos;, &apos;US&apos;, &apos;France&apos;) &quot;</code></pre><p>代码很简单，只需要在Sender端做如下改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextMessage message = session.createTextMessage();</span><br><span class="line">message.setIntProperty(<span class="string">"test"</span>,<span class="number">14</span>);</span><br><span class="line">message.setText(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><p>Receiver端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer = session.createConsumer(destination,<span class="string">"test &gt; 14"</span>);</span><br></pre></td></tr></table></figure><p>对发送端的特定字符做一个判断符合条件即被拦截</p><h4 id="4-消息确认机制"><a href="#4-消息确认机制" class="headerlink" title="4.消息确认机制"></a><strong>4.消息确认机制</strong></h4><p>jms消息只有在被确认之后才认为成功消费了这条消息。消息的成功消费通常包括三个步骤：</p><p>（1）client接收消息 </p><p>（2）client处理消息 </p><p>（3）消息被确认（也就是client给一个确认消息）</p><p>在事务性会话中当一个事务被提交的时候，确认自动发生，和应答模式没关系，这个值可以随便写。（这里多提一句异步消息接收中不能使用事务性会话）。</p><p>在非事务性会话中消息何时被确认取决于创建的session中设置的消息应答模式（acknowledge model）该参数有三个值：</p><ol><li>Session.AUTO_ACKNOWLEDGE：当client端成功的从receive方法或从onMessage(Message message) 方法返回的时候，会话自动确认client收到消息。</li><li>Session.CLIENT_ACKNOWLEDGE: 客户单通过调用acknowledge方法来确认客户端收到消息。但需要注意在这种应答模式下，确认是在会话层上进行的，确认一个被消费的消息将自动确认所有已消费的其他消息。比如一个消费者已经消费了10条消息，然后确认了第5条消息被消费，则这10条都被确认消费了。、</li></ol><p>acknowledge（）通知方法是在Message对象上，同步接收，调用acknowledge（）方法进行确认如下所示：</p><p>consumer = session.createConsumer(queue);<br>Message message = consumer.receive();<br>message.acknowledge(); </p><p>异步接受，调用acknowledge（）方法进行确认：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String value = textMessage.getText();</span><br><span class="line">            System.out.println(<span class="string">"value: "</span> + value);</span><br><span class="line">            message.acknowledge(); <span class="comment">//消息消费确认通知</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.Session.DUPS_ACKNOWLEDGE：不是必须签收，消息可能会重复发送。在第二次重新传送消息的时候，消息头的JmsDelivered会被置为true标示当前消息已经传送过一次，客户端需要进行消息的重复处理控制。 </p><h4 id="5-持久化消息"><a href="#5-持久化消息" class="headerlink" title="5. 持久化消息"></a><strong>5. 持久化消息</strong></h4><p>JMS 支持以下两种消息提交模式：</p><h5 id="5-1-ERSISTENT-持久消息"><a href="#5-1-ERSISTENT-持久消息" class="headerlink" title="5.1 ERSISTENT 持久消息"></a>5.1 ERSISTENT 持久消息</h5><p>是activemq默认的传送方式，此方式下的消息在配合activemq.xml中配置的消息存储方式，会被存储在特定的地方，直到有消费者将消息消费或者消息过期进入DLQ队列，消息生命周期才会结束。此模式下可以保证消息只会被成功传送一次和成功使用一次，消息具有可靠性。在消息传递到目标消费者，在消费者没有成功应答前，消息不会丢失。所以很自然的，需要一个地方来持久性存储。如果消息消费者在进行消费过程发生失败，则消息会被再次投递。</p><p>DeliveryMode.PERSISTENT  指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失。 消息持久化在硬盘中，ActiveMQ持久化有三种方式：AMQ、KahaDB、JDBC。</p><p>AMQ</p><p>AMQ是一种文件存储形式，它具有写入速度快和容易恢复的特点。消息存储在一个个文件中，文件的默认大小为32M，如果一条消息的大小超过了32M，那么这个值必须设置大一点。当一个存储文件中的消息已经全部被消费，那么这个文件将被标识为可删除，在下一个清除阶段，这个文件被删除。AMQ适用于ActiveMQ5.3之前的版本。</p><p>KahaDB</p><p>KahaDB是基于文件的本地数据库储存形式，虽然没有AMQ的速度快，但是它具有强扩展性，恢复的时间比AMQ短，从5.4版本之后KahaDB做为默认的持久化方式。</p><p>JDBC</p><p>可以将消息存储到数据库中，例如：Mysql、SQL Server、Oracle、DB2。</p><p>具体使用方式大家下去查一下，限于篇幅在此就不做太详细的介绍。</p><h5 id="5-2-NON-PERSISTENT-非持久消息"><a href="#5-2-NON-PERSISTENT-非持久消息" class="headerlink" title="5.2 NON_PERSISTENT 非持久消息"></a><strong>5.2 NON_PERSISTENT 非持久消息</strong></h5><p>非持久的消息适用于不重要的，可以接受消息丢失的哪一类消息，这种消息只会被投递一次，消息不会在持久性存储中存储，也不会保证消息丢失后的重新投递。</p><p>DeliveryMode.NON_PERSISTENT  不要求JMS provider持久保存消息，消息存放在内存中，读写速度快，在JMS服务停止后消息会消失，没有持久化到硬盘。</p><h4 id="6-ActiveMQ消息过期设置"><a href="#6-ActiveMQ消息过期设置" class="headerlink" title="6. ActiveMQ消息过期设置"></a><strong>6. ActiveMQ消息过期设置</strong></h4><p>允许消息过期 。默认情况下，消息永不会过期。如果消息在特定周期内失去意义，那么可以设置过期时间。<br>有两种方法设置消息的过期时间，时间单位为毫秒： </p><ol><li>使用 setTimeToLive 方法为所有的消息设置过期时间； </li><li>使用 send 方法为每一条消息设置过期时间。</li></ol><p>消息过期时间，send 方法中的 timeToLive 值加上发送时刻的 GMT 时间值。如果 timeToLive 值等于零，则 JMSExpiration 被设为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除。</p><p>这一节对activemq的消息机制和持久化我们就简单介绍到这里，后面我们结合具体的工程来把它应用到生产中，再来讲解如何持久化如何高效的应用于生产环境。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面一节简单学习了activemq的使用，我们知道activemq的使用方式非常简单有如下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建连接工厂&lt;/li&gt;
&lt;li&gt;创建连接 &lt;/li&gt;
&lt;li&gt;创建会话&lt;/li&gt;
&lt;li&gt;创建目的地&lt;/li&gt;
&lt;li&gt;创建生产者或消费者&lt;/li
      
    
    </summary>
    
      <category term="activeMQ" scheme="https://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(一)-为什么选择Netty</title>
    <link href="https://blog.rickiyang.cn/posts/704e9e4d.html"/>
    <id>https://blog.rickiyang.cn/posts/704e9e4d.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.148Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们简单学习了NIO。我们知道java的I/O模型一共有四种，分别是：传统的BIO，伪异步I/O，NIO和AIO。为了澄清概念和分清区别，我们还是先简单的介绍一下他们的概念，然后再去比较优劣。以及探讨我们为什么使用netty。</p><h4 id="1-概念澄清"><a href="#1-概念澄清" class="headerlink" title="1.概念澄清"></a><strong>1.概念澄清</strong></h4><h5 id="1-1-BIO"><a href="#1-1-BIO" class="headerlink" title="1.1 BIO"></a>1.1 BIO</h5><p>BIO，即Blocking I/O。网络编程的基本模型是Client/Server 模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息(绑定的Ip 地址和监听端口) ，客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建在成功，双方就可以通过网络套接字( Socket ) 进行通信。在基于传统同步阻塞模型开发中， ServerSocket 负责绑定IP 地址，启动监听端口:Socket 负责发起连接操作。连接成功之后，双方通过输入和输出流进行<strong>同步阻塞式通信</strong>。</p><p>BIO通信模型图：</p><p><img src="http://i.imgur.com/y9lBJlB.png" alt=""></p><p>解释一下上图：</p><p>采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端， 统程销毁。这就是典型的一请求一回答通信模型。</p><p>对于这种IO模型我们知道：用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。即在读写数据过程中会发生阻塞现象。</p><h5 id="1-2-伪异步IO"><a href="#1-2-伪异步IO" class="headerlink" title="1.2 伪异步IO"></a>1.2 <strong>伪异步IO</strong></h5><p>为了解决同步阻塞 I/O 面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M: 线程池最大线程数N 的比例关系，其中M 可以远远大于N。通过线程地可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p><p>伪异步IO通信模型图：</p><p><img src="http://i.imgur.com/FrAFXdo.png" alt="">     </p><p>采用线程池和任务队列可以实现伪异步I/O通信框架。当有新的客户端接入时，将客户端的Socket 封装成一个Task (该任务实现java.lang.<br>Runnable 接口）投递到后端的线程池中进行处理， JDK 的线程将维护一个消息队列和N个活跃线程， 对消息队列中的任务进行处理。由于统程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的， 无论多少个客户端并发访问， 都不会导致资源的耗尽和省机。</p><p>伪异步I/O 通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。但是由于它底层的通信依然采用同步阻塞模型，因此无法从根本上解决问题。伪异步I/O 实际上仅仅是对之前I/O 线程模型的一个简单优化，它无法从根本上解决同步I/O 导致的通信线程阻塞问题。下面我们就简单分析下通信对方返回应答时间过长会引起的级联故障。</p><ol><li>服务端处理缓慢，返回应答消息耗费60s，平时只需要10ms;</li><li>采用伪异步I/O 的线程在读取故障服务节点的响应，由于读/取输入流是阻塞的，它将会被同步阻塞60s;</li><li>假如所有的可用线程都被故障服务器阻塞，那后续的所有的I/O消息都将在队列中排队;</li><li>由于线程地采用阻塞队列实现，当队列积满之后，后续入队列的操作将被阻塞;</li><li>由于前端只有一个Accptor 线程接收客户端接入，它被阻塞在线程池的同步阻塞队列之后，新的客户端请求消息将被拒绝，客户端会发生大量的连接超时;</li><li>由于几于所有的连接都超时，调用者会认为系统已经崩溃，无法接收新的请求消息。</li></ol><p>如何破解这个难题?下面我们再看一下NIO。</p><h5 id="1-3-NIO"><a href="#1-3-NIO" class="headerlink" title="1.3 NIO"></a>1.3 <strong>NIO</strong></h5><p>NIO,很多人叫他New I/O，由于之前老的I/O 类库是阻塞I/O ，New I/O 类库的目标就是要让Java 支持非阻塞I/O，所以，更多的人喜欢称之为非阻塞I/O(Non-block I/O)。</p><p>与Socket类和ServerSocket 类相对应， NIO也提供了SocketChannel 和ServerSocketChannel两种不同的套接字通道实现。这两种新增的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单，但是性能和可靠性都不好，非阻塞模式则正好相反。开发人员可以根据自己的需要来选择合适的模式。一般来说，低负载、低并发的应用程序可以选择同步阻塞I/O以降低编程复杂度:对于高负载、高并发的网络应用，需要使用NIO 的非阻塞模式进行开发。</p><p>前面我们已经对NIO进行了介绍，我们知道NIO中引入了缓冲区Buffer，通道Channel和多路复用器Selector的概念。一个多路复用器Selector 可以同时轮询多个Channel，而Channel又是全双工的，同时支持读写操作，使用NIO 编程的优点总结如下：</p><ol><li><p>客户端发起的连接操作是异步的，可以通过在多路复用器注册OP_CONNECT 等待后续结果，不需要像之前的客户端那样被同步阻塞。</p></li><li><p>SocketChannel 的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样I/O 通信线程就可以处理其他的链路，不需要同步等待这个链路可用。</p></li><li><p>线程模型的优化:由于JDK 的Selector 在Linux 等主流操作系统上通过epoll 实现，它没有连接句柄数的限制(只受限于操作系统的最大句柄数或者对单个进程的句柄限制)，这意味着一个Selector 线程可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线性下降。因此，它非常适合做高性能、高负载的网络服务器。</p></li></ol><h5 id="1-4-AIO"><a href="#1-4-AIO" class="headerlink" title="1.4 AIO"></a>1.4 <strong>AIO</strong></h5><p>NIO 2.0 引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。异步通道提供以下两种方式获取获取操作结果：</p><pre><code>▷通过java.util.concurrent.Future 类来表示异步操作的结果;▷在执行异步操作的时候传入一个java.nio.channels;</code></pre><p>NIO 2.0 的异步套接字通道是真正的异步非阻塞I/O ，对应于UNIX 网络编程中的事件<br>驱动I/O (AIO) 。它不需要通过多路复用器( Selector) 对注册的通道进行轮询操作即可实<br>现异步读写，从而简化了NIO 的编程模型。</p><p>前面对不同的I/O模型进行了简单介绍，不同的I/O 模型由于线程模型、API 等差别很大，所以用法的差异也非常大。我们用一个表格来做一个统一说明：</p><p><img src="http://i.imgur.com/wwVG3tz.png" alt=""></p><h4 id="2-为什么用Netty"><a href="#2-为什么用Netty" class="headerlink" title="2. 为什么用Netty"></a>2. 为什么用Netty</h4><p>开发出高质量的NIO 程序并不是一件简单的事情，除去NIO 固有的复杂性和Bug不谈，作为一个NIO 服务端,需要能够处理网络的闪断、客户端的重复接入、客户端的安全认证、消息的编解码、半包读写等情况， 如果你没有足够的NIO 编程经验积累， 一个NIO 框架的稳定往往需要半年甚至更长的时间。更为糟糕的是， 一旦在生产环境中发生问题， 往往会导致跨节点的服务调用中断， 严重的可能<br>会导致整个集群环境都不可用， 需要重启服务器，这种非正常停机会带来巨大的损失。</p><p>从可维护性角度看，由于NIO 采用了异步非阻塞编程模型，而且是一个I/O 线程处理多条链路，它的调试和跟踪非常麻烦， 特别是生产环境中的问题，我们无法进行有效的调试和跟踪， 往往只能靠一些日志来帮助分析，定位难度很大。</p><p>对于java原生的IO我们之所以不选择使用是因为：</p><ol><li><p>NIO的类库和API繁杂使用麻烦，你需要熟练掌握Selectol,ServerSocketChannel,<br>SocketChannel,ByteBuffer 等。</p></li><li><p>需妥具备其他的额外技能做制垫，例如熟悉Java 多线程编程。这是因为NIO编程涉及到Reactor 模式，你必须对多钱程和网络编程非常如悉，才能编写出高质量的NIO程序。</p></li><li><p>可靠性能力补齐， 工作量和难度都非常大。例如客户端面临断连重连、网络间断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题， NI0 编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。</p></li><li><p>JDK NIO的BUG，比如epoll bug，这个BUG会在linux上导致cpu 100%，使得nio server/client不可用，这个BUG直到jdk 6u4才解决，但是直到JDK1.7中仍然有这个问题，该问题并未被完全解决，只是发生的频率降低了而已。</p></li></ol><p>基于上述原因大多数场景下都不建议直接使原生NIO，除非你精通NIO编程或者是有特殊的需要，否则作为服务器编程的NIO可能会带来巨大的生产隐患。</p><p>关于Netty：</p><p>Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty的NIO框架构建。</p><p>与Netty同样功能的NIO框架还有Mina，Netty的主导作者与Mina的主导作者是同一人，在设计理念上与Mina基本上是一致的。Mina出身于开源界的大牛Apache组织，Netty出身于商业开源大亨Jboss。<br>这几年Netty社区相对比较活跃，所以我们就先选择Netty作为入手网络编程的首选，有时间再学习一下Mina。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们简单学习了NIO。我们知道java的I/O模型一共有四种，分别是：传统的BIO，伪异步I/O，NIO和AIO。为了澄清概念和分清区别，我们还是先简单的介绍一下他们的概念，然后再去比较优劣。以及探讨我们为什么使用netty。&lt;/p&gt;
&lt;h4 id=&quot;1-概念澄清&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(二）-Helloworld Netty</title>
    <link href="https://blog.rickiyang.cn/posts/7ab746e7.html"/>
    <id>https://blog.rickiyang.cn/posts/7ab746e7.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.149Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们来讲解Netty，使用Netty之前我们先了解一下Netty能做什么，无为而学，岂不是白费力气！</p><h4 id="1-使用Netty能够做什么"><a href="#1-使用Netty能够做什么" class="headerlink" title="1.使用Netty能够做什么"></a><strong>1.使用Netty能够做什么</strong></h4><ol><li>开发异步、非阻塞的TCP网络应用程序；</li><li>开发异步、非阻塞的UDP网络应用程序；</li><li>开发异步文件传输应用程序；</li><li>开发异步HTTP服务端和客户端应用程序；</li><li>提供对多种编解码框架的集成，包括谷歌的Protobuf、Jboss marshalling、Java序列化、压缩编解码、XML解码、字符串编解码等，这些编解码框架可以被用户直接使用；</li><li>提供形式多样的编解码基础类库，可以非常方便的实现私有协议栈编解码框架的二次定制和开发；</li><li>基于职责链模式的Pipeline-Handler机制，用户可以非常方便的对网络事件进行拦截和定制；</li><li>所有的IO操作都是异步的，用户可以通过Future-Listener机制主动Get结果或者由IO线程操作完成之后主动Notify结果，用户的业务线程不需要同步等待；</li><li>IP黑白名单控制；</li><li>打印消息码流；</li><li>流量控制和整形；</li><li>性能统计；</li><li>基于链路空闲事件检测的心跳检测</li></ol><h4 id="2-Netty常用类讲解"><a href="#2-Netty常用类讲解" class="headerlink" title="2. Netty常用类讲解"></a><strong>2. Netty常用类讲解</strong></h4><p>在这里我们就一些我们常用到的类做大致的讲解，然后再写入门程序的时候大致知道每一行都讲了什么。</p><p><strong>EventLoop,EventLoopGroup</strong></p><p>EventLoop目的是为Channel处理IO操作，一个EventLoop可以为多个Channel服务,EventLoopGroup会包含多个EventLoop。</p><p><strong>BootStrap,ServerBootstrap</strong></p><p>一个Netty应用通常由一个Bootstrap开始，它主要作用是配置整个Netty程序，串联起各个组件。</p><p><strong>ChannelInitializer</strong></p><p>当一个链接建立时，我们需要知道怎么来接收或者发送数据，当然，我们有各种各样的Handler实现来处理它，那么ChannelInitializer便是用来配置这些Handler，它会提供一个ChannelPipeline，并把Handler加入到ChannelPipeline。</p><p><strong>Handler</strong></p><p>为了支持各种协议和处理数据的方式，便诞生了Handler组件。Handler主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p><p><strong>ChannelInboundHandler</strong></p><p>一个最常用的Handler。这个Handler的作用就是处理接收到数据时的事件，也就是说，我们的业务逻辑一般就是写在这个Handler里面的，ChannelInboundHandler就是用来处理我们的核心业务逻辑。</p><p><strong>Future</strong></p><p>在Netty中所有的IO操作都是异步的，因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之，所有的操作都会返回一个ChannelFuture。</p><h4 id="3-第一个Helloworld"><a href="#3-第一个Helloworld" class="headerlink" title="3. 第一个Helloworld"></a><strong>3. 第一个Helloworld</strong></h4><p>上面我们已经对常用类进行说明，下面我们就使用这些类来构建我们的第一个入门程序，本示例我使用的是maven来构建工程，如果你使用的是普通的项目则跳过第一步。</p><p>首先引入maven jar包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.1.5.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>下面我们来写客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = bootstrap.connect(address,port).sync().channel();</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                String msg = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span>(msg == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;             </span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelInitializer用来配置处理数据的handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个地方的 必须和服务端对应上。否则无法正常解码和编码</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 解码和编码 我将会在下一节为大家详细的讲解。暂时不做详细的描述</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * /        </span></span><br><span class="line"><span class="comment">        pipeline.addLast("decoder", new StringDecoder());</span></span><br><span class="line"><span class="comment">        pipeline.addLast("encoder", new StringEncoder());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 我们自己的handler</span></span><br><span class="line"><span class="comment">        pipeline.addLast("handler", new HelloWorldClientHandler());</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>写一个我们自己的handler，用自己的方式来处理数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server say : "</span>+msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is active"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端我们写完了，下面开始写服务器端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWordServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWordServer server = <span class="keyword">new</span> HelloWordServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端的ChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();      </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWordServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端的handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">"===&gt;server: "</span>+msg.toString());</span><br><span class="line">        ctx.write(<span class="string">"received your msg"</span>);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面服务器端和客户端的代码都已经写完，下面我们先启动服务端，然后启动客户端，程序中我是在客户端让手动输入，输入结束之后回车，服务器端即可接受数据。</p><p>客户端：<br><img src="http://i.imgur.com/OMBsop1.png" alt=""></p><p>服务端：<br><img src="http://i.imgur.com/h9vfXoV.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们来讲解Netty，使用Netty之前我们先了解一下Netty能做什么，无为而学，岂不是白费力气！&lt;/p&gt;
&lt;h4 id=&quot;1-使用Netty能够做什么&quot;&gt;&lt;a href=&quot;#1-使用Netty能够做什么&quot; class=&quot;headerlink&quot; title=&quot;1.使
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(三）-Netty重要接口讲解</title>
    <link href="https://blog.rickiyang.cn/posts/d48afec7.html"/>
    <id>https://blog.rickiyang.cn/posts/d48afec7.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.151Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们写了一个HelloWorld，对于Netty的运行有了一定的了解，知道Netty是如何启动客户端和服务器端。这一节我们简要的讲解一下几个重要的接口，初步探讨Netty的运行机制，当然刚学Netty就深入原理肯定是很枯燥的，所以我们就点到为止。</p><h4 id="1-ChannelPipeLine和ChannelHandler"><a href="#1-ChannelPipeLine和ChannelHandler" class="headerlink" title="1 ChannelPipeLine和ChannelHandler"></a>1 <strong>ChannelPipeLine和ChannelHandler</strong></h4><p>在上一篇中我们在ChannelInitializer类的initChannel方法中使用了ChannelPipeline，然后在ChannelPipeline中使用了handler来处理业务逻辑。</p><p>ChannelPipeline是ChannelHandler的容器，它负责ChannelHandler的管理和事件拦截与调度。Netty的ChannelPipeline和ChannelHandler机制类似于Servlet 和Filter 过滤器，这类拦截器实际上是职责链模式的一种变形，主要是为了方便事件的拦截和用户业务逻辑的定制。</p><p>Netty的channel运用机制和Filter过滤器机制一样，它将Channel 的数据管道抽象为ChannelPipeline. 消息在ChannelPipeline中流动和传递。ChannelPipeline 持有I/O事件拦截器ChannelHandler 的链表，由ChannelHandler 对I/0 事件进行拦截和处理，可以方便地通过新增和删除ChannelHandler 来实现小同的业务逻辑定制，不需要对已有的ChannelHandler进行修改，能够实现对修改封闭和对扩展的支持。</p><p>通过一张图我们来看一下他们之间的关系：</p><p><img src="http://i.imgur.com/I6jciGg.png" alt=""></p><p>一个Channel中包含一个ChannelPipeline，用来处理Channel中的事件，一个ChannelPipeline中可以包含很多个handler，第二节的示例代码中我们也看到了，使用各种handler来处理通信信息。</p><p>同时我们也注意到在hadler中继承了ChannelInboundHandlerAdapter类并实现了他的一些方法，比如：channelRead，channelActive，channelInactive等等，我们看到这些方法中都有一个参数：ChannelHandlerContext ctx。这个ChannelHandlerContext就是handler的上下文对象，有了这个ChannelHandlerContext你就获得了一切，你可以获得通道，获得事件的控制权。</p><p>事实上，用户不需要自己创建pipeline，因为使用ServerBootstrap 或者Bootstrap 启动<br>服务端或者客户端时， Netty 会为每个Channel 连接创建一个独立的pipeline。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">pipeline.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">8192</span>,Delimiters.lineDelimiter()));</span><br><span class="line">pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的逻辑</span></span><br><span class="line">pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWorldClientHandler());</span><br></pre></td></tr></table></figure><p>ChannelPipeline 是线程安全的， 这意味着N个业务线程可以并发地操作ChannelPipeline<br>而不存在多线程并发问题。但是，ChannelHandler却不是线程安全的，这意味着尽管<br>ChannelPipeline 是线程去全的， 但是仍然需要自己保证ChannelHandler的线程安全。</p><p>Netty 中的事件分为inbound 事件和outbound 事件。inbound 事件通常由I/O线程触发，例如TCP 链路建立事件、链路关闭事件、读事件、异常通知事件等。Outbound 事件通常是I/O 用户主动发起的网络I/O 操作，例如用户发起的连接操作、绑定操作、消息发送等操作。</p><p>我们常用的inbound事件有：</p><ul><li>ChannelHandlerContext fireChannelRegistered()   //channel注册事件</li><li>ChannelHandlerContext fireChannelActive()  //channel激活事件</li><li>ChannelHandlerContext fireExceptionCaught(Throwable var1) //channel异常处理事件</li><li>ChannelHandlerContext fireUserEventTriggered(Object var1) //用户自定义事件</li><li>ChannelHandlerContext fireChannelRead(Object var1) //读事件</li></ul><p>pipeline 中以fireXXX命名的方法都是从I/O 线程流向用户业务Handler的inbound 事件，它们的实现因功能而异，但是处理步骤类似：</p><ol><li><p>调用HeadHandler对应的fireXXX 方法</p></li><li><p>执行事件相关的逻辑操作</p></li></ol><p>常用的outbound事件有：</p><ul><li>ChannelFuture bind(SocketAddress var1, ChannelPromise var2) //绑定地址</li><li>ChannelFuture connect(SocketAddress var1, ChannelPromise var2) //连接服务器</li><li>ChannelFuture write(Object var1) //发送事件</li><li>ChannelHandlerContext flush() //刷新事件</li></ul><p>上面我们说到事件，netty的事件机制是由前至后的，一般来说，都是一个channel的ChannnelActive方法中调用fireChannelActive来触发调用下一个handler中的ChannelActive方法，即你在ChannelPipeline中添加handler的时候，要在第一个handler的channelActive方法中调用fireChannelActive，以此来触发下一个事件。我们再来写一个案例说明一下：</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HWClient</span><span class="params">(<span class="keyword">int</span> port, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().writeAndFlush(<span class="string">"Hello Netty Server ,I am a common client"</span>);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HWClient client = <span class="keyword">new</span> HWClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端ClientChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端的handler</span></span><br><span class="line">        <span class="comment">//先调用handler在ChannnelActive方法中调用fireChannelActive会激活handler1</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HWClientHandler());</span><br><span class="line">        pipeline.addLast(<span class="string">"handler1"</span>, <span class="keyword">new</span> BaseClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server say : "</span>+msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Handler1"</span>);</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的第二个handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Handler2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HWServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HWServer server = <span class="keyword">new</span> HWServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端ServerChannelInitializer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HWServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">"===&gt;server: "</span>+msg.toString());</span><br><span class="line">        ctx.write(<span class="string">"received your msg"</span>);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动服务端和客户端，会发现客户端的两个handler都通过了。</p><p><img src="http://i.imgur.com/NLijyim.png" alt=""></p><p>先调用HWClientHandler，打印出：HWClientHandler channelActive；继而调用了BaseClientHandler ，打印出：BaseClient1Handler channelActive.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们写了一个HelloWorld，对于Netty的运行有了一定的了解，知道Netty是如何启动客户端和服务器端。这一节我们简要的讲解一下几个重要的接口，初步探讨Netty的运行机制，当然刚学Netty就深入原理肯定是很枯燥的，所以我们就点到为止。&lt;/p&gt;
&lt;h4 id
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(五)-DelimiterBasedFrameDecoder</title>
    <link href="https://blog.rickiyang.cn/posts/87e472dc.html"/>
    <id>https://blog.rickiyang.cn/posts/87e472dc.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.149Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们说了LineBasedframeDecoder来解决粘包拆包的问题，TCP以流的方式进行数据传输，上层应用协议为了对消息进行区分，一般采用如下4种方式：</p><ol><li>消息长度固定，累计读取到消息长度总和为定长Len的报文之后即认为是读取到了一个完整的消息。计数器归位，重新读取。</li><li>将回车换行符作为消息结束符。</li><li>将特殊的分隔符作为消息分隔符，回车换行符是他的一种。</li><li>通过在消息头定义长度字段来标识消息总长度。</li></ol><p>LineBasedframeDecoder属于第二种，今天我们要说的DelimiterBasedFrameDecoder和FixedLengthFrameDecoder属于第三种和第一种。DelimiterBasedFrameDecoder用来解决以特殊符号作为消息结束符的粘包问题，FixedLengthFrameDecoder用来解决定长消息的粘包问题。下面首先来用DelimiterBasedFrameDecoder来写一个例子，我们看一下效果然后接着分析用法。</p><h4 id="1-DelimiterBasedFrameDecoder使用"><a href="#1-DelimiterBasedFrameDecoder使用" class="headerlink" title="1. DelimiterBasedFrameDecoder使用"></a><strong>1. DelimiterBasedFrameDecoder使用</strong></h4><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWordServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWordServer server = <span class="keyword">new</span> HelloWordServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端ServerChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">"\t"</span>.getBytes());</span><br><span class="line">        pipeline.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">2048</span>,delimiter));    </span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> ServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String body = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"server receive order : "</span> + body + <span class="string">";the counter is: "</span> + ++counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端ClientChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个地方的 必须和服务端对应上。否则无法正常解码和编码</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span>       </span><br><span class="line">        ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">"\t"</span>.getBytes());</span><br><span class="line">        pipeline.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">2048</span>,delimiter)); </span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端的逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] req;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         req = (<span class="string">"Unless required by applicable law or agreed to in writing, software\t"</span> +</span><br><span class="line">                <span class="string">"  distributed under the License is distributed on an \"AS IS\" BASIS,\t"</span> +</span><br><span class="line">                <span class="string">"  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\t"</span> +</span><br><span class="line">                <span class="string">"  See the License for the specific language governing permissions and\t"</span> +</span><br><span class="line">                <span class="string">"  limitations under the License.This connector uses the BIO implementation that requires the JSSE\t"</span> +</span><br><span class="line">                <span class="string">"  style configuration. When using the APR/native implementation, the\t"</span> +</span><br><span class="line">                <span class="string">"  penSSL style configuration is required as described in the APR/native\t"</span> +</span><br><span class="line">                <span class="string">"  documentation.An Engine represents the entry point (within Catalina) that processes\t"</span> +</span><br><span class="line">                <span class="string">"  every request.  The Engine implementation for Tomcat stand alone\t"</span> +</span><br><span class="line">                <span class="string">"  analyzes the HTTP headers included with the request, and passes them\t"</span> +</span><br><span class="line">                <span class="string">"  on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software\t"</span> +</span><br><span class="line">                <span class="string">"# distributed under the License is distributed on an \"AS IS\" BASIS,\t"</span> +</span><br><span class="line">                <span class="string">"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\t"</span> +</span><br><span class="line">                <span class="string">"# See the License for the specific language governing permissions and\t"</span> +</span><br><span class="line">                <span class="string">"# limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log\t"</span> +</span><br><span class="line">                <span class="string">"# each component that extends LifecycleBase changing state:\t"</span> +</span><br><span class="line">                <span class="string">"#org.apache.catalina.util.LifecycleBase.level = FINE\t"</span></span><br><span class="line">                ).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf message;</span><br><span class="line"></span><br><span class="line">        message = Unpooled.buffer(req.length);</span><br><span class="line">        message.writeBytes(req);</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String buf = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"Now is : "</span> + buf + <span class="string">" ; the counter is : "</span>+ (++counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><pre><code>server receive order : Unless required by applicable law or agreed to in writing, software;the counter is: 1server receive order :   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,;the counter is: 2server receive order :   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.;the counter is: 3server receive order :   See the License for the specific language governing permissions and;the counter is: 4server receive order :   limitations under the License.This connector uses the BIO implementation that requires the JSSE;the counter is: 5server receive order :   style configuration. When using the APR/native implementation, the;the counter is: 6server receive order :   penSSL style configuration is required as described in the APR/native;the counter is: 7server receive order :   documentation.An Engine represents the entry point (within Catalina) that processes;the counter is: 8server receive order :   every request.  The Engine implementation for Tomcat stand alone;the counter is: 9server receive order :   analyzes the HTTP headers included with the request, and passes them;the counter is: 10server receive order :   on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software;the counter is: 11server receive order : # distributed under the License is distributed on an &quot;AS IS&quot; BASIS,;the counter is: 12server receive order : # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.;the counter is: 13server receive order : # See the License for the specific language governing permissions and;the counter is: 14server receive order : # limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log;the counter is: 15server receive order : # each component that extends LifecycleBase changing state:;the counter is: 16server receive order : #org.apache.catalina.util.LifecycleBase.level = FINE;the counter is: 17</code></pre><p>启动服务端和客户端，我们能看到服务端接收客户端发过来的消息一共分17次接收。那么为什么是17次呢？而且我们并没有使用在上一篇中解决拆包和粘包问题的LineBasedFrameDecoder，并且这次我们的消息每一行的末尾也换成了”\t”。下面就来讲解一下DelimiterBasedFrameDecoder的使用。</p><p>DelimiterBasedFrameDecoder是将特殊的字符作为消息的分隔符，本例中用到的是”\t”。而LineBasedFrameDecoder是默认将换行符”\n”作为消息分隔符。首先我们注意到在ServerChannelInitializer中我们在添加解码器时跟以前有点不一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">"\t"</span>.getBytes());</span><br><span class="line">pipeline.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">2048</span>, delimiter));</span><br></pre></td></tr></table></figure><p>这里我们添加DelimiterBasedFrameDecoder解码器并且手动指定消息分隔符为：”\t”。我们可以看一下DelimiterBasedFrameDecoder的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelimiterBasedFrameDecoder</span><span class="params">(<span class="keyword">int</span> maxFrameLength, <span class="keyword">boolean</span> stripDelimiter, ByteBuf delimiter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(maxFrameLength, stripDelimiter, <span class="keyword">true</span>, delimiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>maxFrameLength：解码的帧的最大长度</p><p>stripDelimiter：解码时是否去掉分隔符</p><p>failFast：为true，当frame长度超过maxFrameLength时立即报TooLongFrameException异常，为false，读取完整个帧再报异常</p><p>delimiter：分隔符</p><p>这个时候大家应该明白了为什么服务端分17次收到消息。我们在消息的每一行都加了一个”\t”,自然解码器在度消息时遇到”\t”就会认为这是一条消息的结束。用这种方式我们可以把”\t”换成任何我们自定义的字符对象。换成”\n”也是可以的。</p><h4 id="2-FixedLengthFrameDecoder使用"><a href="#2-FixedLengthFrameDecoder使用" class="headerlink" title="2. FixedLengthFrameDecoder使用"></a><strong>2. FixedLengthFrameDecoder使用</strong></h4><p>FixedLengthFrameDecoder是固定长度解码器，它能够按照指定的长度对消息进行自动解码。使用它也没有什么特别费力的事情，在ServerChannelInitializer类中添加：</p><p>pipeline.addLast(new FixedLengthFrameDecoder(23));//参数为一次接受的数据长度</p><p>即可，同时也别忘了把刚才使用的DelimiterBasedFrameDecoder注释掉啊，不然达不到效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节我们说了LineBasedframeDecoder来解决粘包拆包的问题，TCP以流的方式进行数据传输，上层应用协议为了对消息进行区分，一般采用如下4种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息长度固定，累计读取到消息长度总和为定长Len的报文之后即认为是读取到了一个完整的
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(四)-TCP粘包和拆包</title>
    <link href="https://blog.rickiyang.cn/posts/278c909d.html"/>
    <id>https://blog.rickiyang.cn/posts/278c909d.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.150Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道TCP是基于字节流的传输协议。那么数据在通信层传播其实就像河水一样并没有明显的分界线，而数据具体表示什么意思什么地方有句号什么地方有分号这个对于TCP底层来说并不清楚。应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段，之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。所以对于这个数据拆分成大包小包的问题就是我们今天要讲的粘包和拆包的问题。</p><h4 id="1-TCP粘包拆包问题说明"><a href="#1-TCP粘包拆包问题说明" class="headerlink" title="1 TCP粘包拆包问题说明"></a>1 TCP粘包拆包问题说明</h4><p>粘包和拆包这两个概念估计大家还不清楚，通过下面这张图我们来分析一下：</p><p><img src="http://i.imgur.com/QcZkTTz.jpg" alt=""></p><p>假设客户端分别发送两个数据包D1,D2个服务端，但是发送过程中数据是何种形式进行传播这个并不清楚，分别有下列4种情况：</p><ol><li>服务端一次接受到了D1和D2两个数据包，两个包粘在一起，称为粘包；</li><li>服务端分两次读取到数据包D1和D2，没有发生粘包和拆包；</li><li>服务端分两次读到了数据包，第一次读到了D1和D2的部分内容，第二次读到了D2的剩下部分，这个称为拆包；</li><li>服务器分三次读到了数据部分，第一次读到了D1包，第二次读到了D2包的部分内容，第三次读到了D2包的剩下内容。</li></ol><h4 id="2-TCP粘包产生原因"><a href="#2-TCP粘包产生原因" class="headerlink" title="2. TCP粘包产生原因"></a>2. TCP粘包产生原因</h4><p>我们知道在TCP协议中，应用数据分割成TCP认为最适合发送的数据块，这部分是通过“MSS”（最大数据包长度）选项来控制的，通常这种机制也被称为一种协商机制，MSS规定了TCP传往另一端的最大数据块的长度。这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以往往MSS为1460。通讯双方会根据双方提供的MSS值得最小值确定为这次连接的最大MSS值。</p><p>tcp为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。</p><p>发生粘包拆包的原因主要有以下这些：</p><ol><li><p>应用程序写入数据的字节大小大于套接字发送缓冲区的大小将发生拆包；</p></li><li><p>进行MSS大小的TCP分段。MSS是TCP报文段中的数据字段的最大长度，当TCP报文长度-TCP头部长度&gt;mss的时候将发生拆包；</p></li><li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上,将发生粘包；</p></li><li><p>数据包大于MTU的时候将会进行切片。MTU即(Maxitum Transmission Unit) 最大传输单元,由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64bytes最大不能超过1518bytes,刨去以太网帧的帧头14Bytes和帧尾CRC校验部分4Bytes,那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。这个就是网络层协议非常关心的地方，因为网络层协议比如IP协议会根据这个值来决定是否把上层传下来的数据进行分片。</p></li></ol><h4 id="3-如何解决TCP粘包拆包"><a href="#3-如何解决TCP粘包拆包" class="headerlink" title="3. 如何解决TCP粘包拆包"></a>3. 如何解决TCP粘包拆包</h4><p>我们知道tcp是无界的数据流，且协议本身无法避免粘包，拆包的发生，那我们只能在应用层数据协议上，加以控制。通常在制定传输数据时，可以使用如下方法：</p><ol><li><p>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息；</p></li><li><p>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容；</p></li><li><p>设置消息边界，服务端从网络流中按消息边界分离出消息内容。比如在消息末尾加上换行符用以区分消息结束。</p></li></ol><p>当然应用层还有更多复杂的方式可以解决这个问题，这个就属于网络层的问题了，我们还是用java提供的方式来解决这个问题。我们先看一个例子看看粘包是如何发生的。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWordServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWordServer server = <span class="keyword">new</span> HelloWordServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWordServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String body = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"server receive order : "</span> + body + <span class="string">";the counter is: "</span> + ++counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();         </span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">    </span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端的逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWorldClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] req;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        req = (<span class="string">"Unless required by applicable law or agreed to in writing, software\n"</span> +</span><br><span class="line">                <span class="string">"  distributed under the License is distributed on an \"AS IS\" BASIS,\n"</span> +</span><br><span class="line">                <span class="string">"  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"</span> +</span><br><span class="line">                <span class="string">"  See the License for the specific language governing permissions and\n"</span> +</span><br><span class="line">                <span class="string">"  limitations under the License.This connector uses the BIO implementation that requires the JSSE\n"</span> +</span><br><span class="line">                <span class="string">"  style configuration. When using the APR/native implementation, the\n"</span> +</span><br><span class="line">                <span class="string">"  penSSL style configuration is required as described in the APR/native\n"</span> +</span><br><span class="line">                <span class="string">"  documentation.An Engine represents the entry point (within Catalina) that processes\n"</span> +</span><br><span class="line">                <span class="string">"  every request.  The Engine implementation for Tomcat stand alone\n"</span> +</span><br><span class="line">                <span class="string">"  analyzes the HTTP headers included with the request, and passes them\n"</span> +</span><br><span class="line">                <span class="string">"  on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software\n"</span> +</span><br><span class="line">                <span class="string">"# distributed under the License is distributed on an \"AS IS\" BASIS,\n"</span> +</span><br><span class="line">                <span class="string">"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"</span> +</span><br><span class="line">                <span class="string">"# See the License for the specific language governing permissions and\n"</span> +</span><br><span class="line">                <span class="string">"# limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log\n"</span> +</span><br><span class="line">                <span class="string">"# each component that extends LifecycleBase changing state:\n"</span> +</span><br><span class="line">                <span class="string">"#org.apache.catalina.util.LifecycleBase.level = FINE"</span></span><br><span class="line">                ).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf message;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上面的所有字符串作为一个消息体发送出去</span></span><br><span class="line">        message = Unpooled.buffer(req.length);</span><br><span class="line">        message.writeBytes(req);</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String buf = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"Now is : "</span> + buf + <span class="string">" ; the counter is : "</span>+ (++counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行客户端和服务端我们能看到：</p><p><img src="http://img.blog.csdn.net/20170327234130148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>我们看到这个长长的字符串被截成了2段发送，这就是发生了拆包的现象。同样粘包我们也很容易去模拟，我们把BaseClientHandler中的channelActive方法里面的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message = Unpooled.buffer(req.length);</span><br><span class="line">message.writeBytes(req);</span><br><span class="line">ctx.writeAndFlush(message);</span><br></pre></td></tr></table></figure><p>这几行代码是把我们上面的一长串字符转成的byte数组写进流里发送出去，那么我们可以在这里把上面发送消息的这几行循环几遍这样发送的内容增多了就有可能在拆包的时候把上一条消息的一部分分配到下一条消息里面了，修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    message = Unpooled.buffer(req.length);</span><br><span class="line">    message.writeBytes(req);</span><br><span class="line">    ctx.writeAndFlush(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改完之后我们再运行一下，输出太长不好截图，我们在输出结果中能看到循环3次之后的消息服务端收到的就不是之前的完整的一条了，而是被拆分了4次发送。</p><p>对于上面出现的粘包和拆包的问题，Netty已有考虑，并且有实施的方案：LineBasedFrameDecoder。<br>我们重新改写一下ServerChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">2048</span>));       </span><br><span class="line">        <span class="comment">// 字符串解码 和 编码</span></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> BaseServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增：pipeline.addLast(new LineBasedFrameDecoder(2048))。同时，我们还得对上面发送的消息进行改造BaseClientHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] req;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    req = (<span class="string">"Unless required by applicable dfslaw or agreed to in writing, software"</span> +</span><br><span class="line">                <span class="string">"  distributed under the License is distributed on an \"AS IS\" BASIS,"</span> +</span><br><span class="line">                <span class="string">"  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."</span> +</span><br><span class="line">                <span class="string">"  See the License for the specific language governing permissions and"</span> +</span><br><span class="line">                <span class="string">"  limitations under the License.This connector uses the BIO implementation that requires the JSSE"</span> +</span><br><span class="line">                <span class="string">"  style configuration. When using the APR/native implementation, the"</span> +</span><br><span class="line">                <span class="string">"  penSSL style configuration is required as described in the APR/native"</span> +</span><br><span class="line">                <span class="string">"  documentation.An Engine represents the entry point (within Catalina) that processes"</span> +</span><br><span class="line">                <span class="string">"  every request.  The Engine implementation for Tomcat stand alone"</span> +</span><br><span class="line">                <span class="string">"  analyzes the HTTP headers included with the request, and passes them"</span> +</span><br><span class="line">                <span class="string">"  on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software"</span> +</span><br><span class="line">                <span class="string">"# distributed under the License is distributed on an \"AS IS\" BASIS,"</span> +</span><br><span class="line">                <span class="string">"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."</span> +</span><br><span class="line">                <span class="string">"# See the License for the specific language governing permissions and"</span> +</span><br><span class="line">                <span class="string">"# limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log"</span> +</span><br><span class="line">                <span class="string">"# each component that extends LifecycleBase changing state:"</span> +</span><br><span class="line">                <span class="string">"#org.apache.catalina.util.LifecycleBase.level = FINE\n"</span></span><br><span class="line">                ).getBytes();  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf message;</span><br><span class="line"></span><br><span class="line">        message = Unpooled.buffer(req.length);</span><br><span class="line">        message.writeBytes(req);</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String buf = (String)msg;</span><br><span class="line">        System.out.println(<span class="string">"Now is : "</span> + buf + <span class="string">" ; the counter is : "</span>+ (++counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉所有的”\n”,只保留字符串末尾的这一个。原因稍后再说。channelActive方法中我们不必再用循环多次发送消息了，只发送一次就好(第一个例子中发送一次的时候是发生了拆包的)，然后我们再次运行，大家会看到这么长一串字符只发送了一串就发送完毕。程序输出我就不截图了。下面来解释一下LineBasedFrameDecoder。</p><p>LineBasedFrameDecoder的工作原理是它依次遍历ByteBuf 中的可读字节，判断看是否有”\n” 或者” \r\n”，如果有，就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。它是以换行符为结束标志的解码器。支持携带结束符或者不携带结束符两种解码方式，同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读到的异常码流。这个对于我们确定消息最大长度的应用场景还是很有帮助。</p><p>对于上面的判断看是否有”\n” 或者” \r\n”以此作为结束的标志我们可能回想，要是没有”\n” 或者” \r\n”那还有什么别的方式可以判断消息是否结束呢。别担心，Netty对于此已经有考虑，还有别的解码器可以帮助我们解决问题，下节我们继续学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们都知道TCP是基于字节流的传输协议。那么数据在通信层传播其实就像河水一样并没有明显的分界线，而数据具体表示什么意思什么地方有句号什么地方有分号这个对于TCP底层来说并不清楚。应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(六)-LengthFieldBasedFrameDecoder解码器</title>
    <link href="https://blog.rickiyang.cn/posts/2b5f20ba.html"/>
    <id>https://blog.rickiyang.cn/posts/2b5f20ba.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.151Z</updated>
    
    <content type="html"><![CDATA[<p>在TCP协议中我们知道当我们在接收消息时候，我们如何判断我们一次读取到的包就是整包消息呢，特别是对于使用了长连接和使用了非阻塞I/O的程序。上节我们也说了上层应用协议为了对消息进行区分一般采用4种方式。前面三种我们都说了，第四种是：通过在消息头定义长度字段来标识消息总长度。这个我们还没讲。当然Netty也提供了相应的解码器：LengthFieldBasedFrameDecoder。</p><p>大多数的协议（私有或者公有），协议头中会携带长度字段，用于标识消息体或者整包消息的长度，例如SMPP、HTTP协议等。由于基于长度解码需求 的通用性，Netty提供了LengthFieldBasedFrameDecoder，自动屏蔽TCP底层的拆包和粘 包问题，只需要传入正确的参数，即可轻松解决“读半包“问题。</p><p>我们先来看一下他的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LengthFieldBasedFrameDecoder</span><span class="params">(ByteOrder byteOrder, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> maxFrameLength, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> lengthFieldOffset, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> lengthFieldLength, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> lengthAdjustment, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> initialBytesToStrip, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">boolean</span> failFast)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>byteOrder：表示字节流表示的数据是大端还是小端，用于长度域的读取；</p></li><li><p>maxFrameLength：表示的是包的最大长度，超出包的最大长度netty将会做一些特殊处理；</p></li><li><p>lengthFieldOffset：指的是长度域的偏移量，表示跳过指定长度个字节之后的才是长度域；</p></li><li><p>lengthFieldLength：记录该帧数据长度的字段本身的长度；</p></li><li><p>lengthAdjustment：该字段加长度字段等于数据帧的长度，包体长度调整的大小，长度域的数值表示的长度加上这个修正值表示的就是带header的包；</p></li><li><p>initialBytesToStrip：从数据帧中跳过的字节数，表示获取完一个完整的数据包之后，忽略前面的指定的位数个字节，应用解码器拿到的就是不带长度域的数据包；</p></li><li><p>failFast：如果为true，则表示读取到长度域，TA的值的超过maxFrameLength，就抛出一个 TooLongFrameException，而为false表示只有当真正读取完长度域的值表示的字节之后，才会抛出 TooLongFrameException，默认情况下设置为true，建议不要修改，否则可能会造成内存溢出。</p></li></ul><p>LengthFieldBasedFrameDecoder定义了一个长度的字段来表示消息的长度，因此能够处理可变长度的消息。将消息分为消息头和消息体，消息头固定位置增加一个表示长度的字段，通过长度字段来获取整包的信息。LengthFieldBasedFrameDecoder继承了ByteToMessageDecoder，即转换字节这样的工作是由ByteToMessageDecoder来完成，而LengthFieldBasedFrameDecoder只用安心完成他的解码工作就好。Netty在解耦和方面确实做的不错。</p><p>既然我们知道了LengthFieldBasedFrameDecoder处理的是带有消息头和消息体的消息类型，那么我们完全可以来定义一个我们自己的消息，我们来写一个消息类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息体</span></span><br><span class="line">    <span class="keyword">private</span> String msgBody;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">byte</span> type, <span class="keyword">int</span> length, String msgBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.msgBody = msgBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">byte</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsgBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msgBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgBody</span><span class="params">(String msgBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgBody = msgBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来写服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FRAME_LENGTH = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_LENGTH = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_OFFSET = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_ADJUSTMENT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_BYTES_TO_STRIP = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap sbs = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                    .group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> NewServerChannelInitializer(MAX_FRAME_LENGTH,LENGTH_FIELD_LENGTH,LENGTH_FIELD_OFFSET,LENGTH_ADJUSTMENT,INITIAL_BYTES_TO_STRIP))</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = sbs.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Server start listen at "</span> + port );</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NewServer server = <span class="keyword">new</span> NewServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到服务端我们在上面定义了5个参数，这5个参数是为了传入LengthFieldBasedFrameDecoder里面用的，因为我们的LengthFieldBasedFrameDecoder写在了NewServerChannelInitializer类里面，所以这几个参数采用可配置的方式也更符合可扩展性，我们分别说一下这几个参数定值的含义：</p><ul><li>MAX_FRAME_LENGTH = 1024 * 1024 ：这个没什么说的，消息体的最大长度；</li><li>LENGTH_FIELD_LENGTH = 4        ：指的就是我们的Message类中的length的长度，int占4位</li><li>LENGTH_FIELD_OFFSET = 1        ：偏移多少位之后才是我们的消息体，因为我们消息头只有type一个参数，byte类型占1位，所以是1；</li><li>LENGTH_ADJUSTMENT = 0          ：该字段加长度字段等于数据帧的长度，一般数据帧长度都是这样定义(即我们在设置Message中的length属性)，加入你的消息体是20位，再加上</li><li>LENGTH_FIELD_LENGTH就是24位，所以在此处为了正确的解析出消息体，需要偏移4位才能解析出消息体的正确位置，我们在发送的消息里面设置的就是消息体本身的长度，所以无需偏移。</li><li>INITIAL_BYTES_TO_STRIP = 0       ：这里我们也不需要跳过数据帧中的字节数，因为我们的消息体和长度是分别发送的，详情见下面EnCoder代码。</li></ul><p>然后我们写ChannelInitializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> MAX_FRAME_LENGTH;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_LENGTH;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_FIELD_OFFSET;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_ADJUSTMENT;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_BYTES_TO_STRIP;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewServerChannelInitializer</span><span class="params">(<span class="keyword">int</span> MAX_FRAME_LENGTH, <span class="keyword">int</span> LENGTH_FIELD_LENGTH, <span class="keyword">int</span> LENGTH_FIELD_OFFSET, <span class="keyword">int</span> LENGTH_ADJUSTMENT, <span class="keyword">int</span> INITIAL_BYTES_TO_STRIP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.MAX_FRAME_LENGTH = MAX_FRAME_LENGTH;</span><br><span class="line">        <span class="keyword">this</span>.LENGTH_FIELD_LENGTH = LENGTH_FIELD_LENGTH;</span><br><span class="line">        <span class="keyword">this</span>.LENGTH_FIELD_OFFSET = LENGTH_FIELD_OFFSET;</span><br><span class="line">        <span class="keyword">this</span>.LENGTH_ADJUSTMENT = LENGTH_ADJUSTMENT;</span><br><span class="line">        <span class="keyword">this</span>.INITIAL_BYTES_TO_STRIP = INITIAL_BYTES_TO_STRIP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> NewDecoder(MAX_FRAME_LENGTH,LENGTH_FIELD_LENGTH,LENGTH_FIELD_OFFSET,LENGTH_ADJUSTMENT,INITIAL_BYTES_TO_STRIP,<span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> NewServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到了我们自己写的Decoder，接下来定义一个Decoder，继承LengthFieldBasedFrameDecoder，以方便我们做一些改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewDecoder</span> <span class="keyword">extends</span> <span class="title">LengthFieldBasedFrameDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们在Message类中定义了type和length，这都放在消息头部</span></span><br><span class="line"><span class="comment">     * type占1个字节，length占4个字节所以头部总长度是5个字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEADER_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">private</span> String msgBody;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxFrameLength   网络字节序，默认为大端字节序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldOffset 消息中长度字段偏移的字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldLength 数据帧的最大长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthAdjustment 该字段加长度字段等于数据帧的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBytesToStrip 从数据帧中跳过的字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> failFast 如果为true，则表示读取到长度域，TA的值的超过maxFrameLength，就抛出一个 TooLongFrameException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewDecoder</span><span class="params">(<span class="keyword">int</span> maxFrameLength, <span class="keyword">int</span> lengthFieldOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> lengthFieldLength, <span class="keyword">int</span> lengthAdjustment, <span class="keyword">int</span> initialBytesToStrip,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> failFast)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength,</span><br><span class="line">                lengthAdjustment, initialBytesToStrip, failFast);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &lt; HEADER_SIZE)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"错误的消息"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过源码我们能看到在读的过程中</span></span><br><span class="line"><span class="comment">         * 每读一次读过的字节即被抛弃</span></span><br><span class="line"><span class="comment">         * 即指针会往前跳</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        type = in.readByte();</span><br><span class="line"></span><br><span class="line">        length = in.readByte();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &lt; length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"消息不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = in.readBytes(length);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(b);</span><br><span class="line"></span><br><span class="line">        msgBody = <span class="keyword">new</span> String(b,<span class="string">"UTF-8"</span>);</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(type,length,msgBody);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的NewDecoder中有一个HEADER_SIZE-消息头。上面也解释过了，我们在Message中定义的type和length分别占一个字节和4个字节（别问我为啥是4个哈）。所以我们的消息头就是5个字节啦。</p><p>接下来就是服务端的handler了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Message) &#123;</span><br><span class="line">            Message msg = (Message)o;</span><br><span class="line">            System.out.println(<span class="string">"Client-&gt;Server:"</span>+channelHandlerContext.channel().remoteAddress()+<span class="string">" send "</span>+msg.getMsgBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler中我们用来接收已经被NewDecoder解码过后的客户端发送过来的消息。</p><p>下面是客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> NewClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NewClient client = <span class="keyword">new</span> NewClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewClientChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> NewEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> NewClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端中我们又定义了一个编码器NewEncoder，继承了MessageToByteEncoder，该类用于将文本信息转换为流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(message == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"未获得消息内容"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        String msgBody = message.getMsgBody();</span><br><span class="line">        <span class="keyword">byte</span>[] b = msgBody.getBytes(Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">        byteBuf.writeByte(message.getType());</span><br><span class="line">        byteBuf.writeByte(b.length);</span><br><span class="line">        byteBuf.writeBytes(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是我们的客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String m = <span class="string">"你好啊,Netty。昂昂"</span>;</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message((<span class="keyword">byte</span>)<span class="number">0xCA</span>, m.length(), m);</span><br><span class="line">        ctx.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在handler中我们发送了一个Message对象。然后会由NewEncoder编码发送出去，服务端对消息解码获得消息头和消息体。分别启动服务端和客户端，打印结果为：</p><p><img src="http://i.imgur.com/uYXV45n.png" alt=""></p><p>我们的消息就发送出去了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在TCP协议中我们知道当我们在接收消息时候，我们如何判断我们一次读取到的包就是整包消息呢，特别是对于使用了长连接和使用了非阻塞I/O的程序。上节我们也说了上层应用协议为了对消息进行区分一般采用4种方式。前面三种我们都说了，第四种是：通过在消息头定义长度字段来标识消息总长度。
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(七)-Netty编解码技术以及ProtoBuf和Thrift的介绍</title>
    <link href="https://blog.rickiyang.cn/posts/f693139f.html"/>
    <id>https://blog.rickiyang.cn/posts/f693139f.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.152Z</updated>
    
    <content type="html"><![CDATA[<p>在前几节我们学习过处理粘包和拆包的问题，用到了Netty提供的几个解码器对不同情况的问题进行处理。功能很是强大。我们有没有去想这么强大的功能是如何实现的呢？背后又用到了什么技术？这一节我们就来处理这个问题。了解一下编码解码到底是如何处理的。</p><p>通常说的编码(Encoder)也就是发生在发送消息的时候需要将消息编译成字节对象，在Netty中即编译成ByteBuf对象。在java中我们将这种编译称之为序列化(Serializable),即将对象序列化为字节数组，然后用于传输或是持久化啊之类的。那么自然解码（Decoder）就是一个反序列化的过程，使用相应的编码格式对接收到的对做一个解码，以正确解析该对象。</p><h4 id="1-java序列化的弱点"><a href="#1-java序列化的弱点" class="headerlink" title="1. java序列化的弱点"></a><strong>1. java序列化的弱点</strong></h4><p>谈到序列化我们自然想到java提供的Serializable接口，在java中我们如果需要序列化只需要继承该接口就可以通过输入输出流进行序列化和反序列化。但是在提供很用户简单的调用的同时他也存在很多问题：</p><ul><li><p>无法跨语言。当我们进行跨应用之间的服务调用的时候如果另外一个应用使用c语言来开发，这个时候我们发送过去的序列化对象，别人是无法进行反序列化的因为其内部实现对于别人来说完全就是黑盒。</p></li><li><p>序列化之后的码流太大。这个我们可以做一个实验还是上一节中的Message类，我们分别用java的序列化和使用二进制编码来做一个对比，下面我写了一个测试类：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerializable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">"哈哈,我是一条消息"</span>;</span><br><span class="line">    Message msg = <span class="keyword">new</span> Message((<span class="keyword">byte</span>)<span class="number">0xAD</span>,<span class="number">35</span>,str);</span><br><span class="line">    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        os.writeObject(msg);</span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="keyword">byte</span>[] b = out.toByteArray();</span><br><span class="line">        System.out.println(<span class="string">"jdk序列化后的长度： "</span>+b.length);</span><br><span class="line">        os.close();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bt = msg.getMsgBody().getBytes();</span><br><span class="line">        buffer.put(msg.getType());</span><br><span class="line">        buffer.putInt(msg.getLength());</span><br><span class="line">        buffer.put(bt);</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">        buffer.get(result);</span><br><span class="line">        System.out.println(<span class="string">"使用二进制序列化的长度："</span>+result.length);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="http://i.imgur.com/tdJO9ED.png" alt=""></p><p>我们可以看到差距是挺大的，目前的主流编解码框架序列化之后的码流也都比java序列化要小太多。</p><ul><li>序列化效率差，这个我们也可以做一个对比，还是上面写的测试代码我们循环跑100000次对比一下时间：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerializable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">"哈哈,我是一条消息"</span>;</span><br><span class="line">    Message msg = <span class="keyword">new</span> Message((<span class="keyword">byte</span>)<span class="number">0xAD</span>,<span class="number">35</span>,str);</span><br><span class="line">    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)&#123;</span><br><span class="line">            ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">            os.writeObject(msg);</span><br><span class="line">            os.flush();</span><br><span class="line">            <span class="keyword">byte</span>[] b = out.toByteArray();</span><br><span class="line">            <span class="comment">/*System.out.println("jdk序列化后的长度： "+b.length);*/</span></span><br><span class="line">            os.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"jdk序列化100000次耗时："</span> +(endTime - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)&#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bt = msg.getMsgBody().getBytes();</span><br><span class="line">            buffer.put(msg.getType());</span><br><span class="line">            buffer.putInt(msg.getLength());</span><br><span class="line">            buffer.put(bt);</span><br><span class="line">            buffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">            buffer.get(result);</span><br><span class="line">            <span class="comment">/*System.out.println("使用二进制序列化的长度："+result.length);*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"使用二进制序列化100000次耗时："</span> +(endTime1 - startTime1));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="http://i.imgur.com/DE0Lovg.png" alt=""></p><p>结果为毫秒数，这个差距也是不小的。</p><p>结合以上我们看到：目前的序列化过程中使用java本身的肯定是不行，使用二进制编码的话又的我们自己去手写，所以为了让我们少搬砖前辈们早已经写好了工具让我们调用，目前社区比较活跃的有google的Protobuf和Apache的Thrift。</p><h4 id="2-Protobuf序列化的使用"><a href="#2-Protobuf序列化的使用" class="headerlink" title="2. Protobuf序列化的使用"></a><strong>2. Protobuf序列化的使用</strong></h4><p>我们先来使用Protobuf进行序列化，他和XML，json一样都有自己的语法，xml的后缀是.xml，json文件的后缀是.json，自然Protobuf文件的后缀就是.proto（哈哈，当然不是全称）。</p><p>下面我们使用Protobuf来封装一段消息，通过一个案例简单介绍一下它的使用。</p><p>首先我们用Protobuf的语法格式来写一段需要序列化的对象，命名格式为：Msg.proto</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">option java_package = <span class="string">"cn.edu.hust.netty.demo10"</span>;</span><br><span class="line">option java_outer_classname = <span class="string">"MessageProto"</span>;</span><br><span class="line"></span><br><span class="line">message RequestMsg&#123;</span><br><span class="line">    required bytes msgType = <span class="number">1</span>;</span><br><span class="line">    required string receiveOne = <span class="number">2</span>;</span><br><span class="line">    required string msg = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ResponseMsg&#123;</span><br><span class="line">    required bytes msgType = <span class="number">1</span>;</span><br><span class="line">    required string receiveOne = <span class="number">2</span>;</span><br><span class="line">    required string msg = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Message.proto中的语法格式，详情大家google一下相关的说明，网上很多介绍，再次简单就上面的语法说明一下：</p><ul><li>option java_package：表示生成的.java文件的包名</li><li>option java_outer_classname：生成的java文件的文件名</li><li>message ： 为他的基本类型，如同java中的class一样</li></ul><p>字段修饰符：</p><ul><li>required：一个格式良好的消息一定要含有1个这种字段。表示该值是必须要设置的；</li><li>optional：消息格式中该字段可以有0个或1个值（不超过1个）。</li><li>repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。表示该值可以重复，相当于java中的List。</li></ul><p>字符类型稍微有些不同：double,float,int32,int64,bool(boolean)<br>,string,bytes。稍微有些不同，String，boolean，int有差别。</p><p>另外我们看到上面3个字段分别赋值了，这个值是什么意思呢？消息定义中，每个字段都有唯一的一个<strong>数字标识符</strong>。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。</p><p>关于Protobuf 的语法我们就简单的介绍这么多，更多细节大家自己去查阅文档吧。下面我们开始使用Protobuf 来进行序列化。</p><p>首先我们的在工程中引入protobuf的jar包，目前官方版本最高3.2，我们用3.0的吧：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Protobuf的文件已经定义好了，下就需要把它编译成java代码，这里我们的借助到google为我们提供的脚本工具protoc，<a href="http://download.csdn.net/download/fuwen1989/9630598" target="_blank" rel="noopener">链接在这里，点击下载</a>这里提供的是protoc-3.0.2。要注意protoc的版本需要和Protobuf的版本对应上，不然不同的版本之间会有一些差异解析可能会有问题。现在知道我们为啥非得选用protobuf3.0.2版本吧，因为我没有找到别的版本的protoc。。。</p><p>下载好了我们解压缩然后把刚才写好的Msg.proto文件复制进去。</p><p><img src="http://i.imgur.com/FBV3PSK.png" alt=""></p><p>接着我们进cmd输入如下命令：</p><p><img src="http://i.imgur.com/U9Mzyst.png" alt=""></p><p>主要是第三句命令。如果你输入没有报错的话你的proto文件夹应该会生成一个子文件夹：</p><p><img src="http://i.imgur.com/WvNjIkK.png" alt=""></p><p>进去该文件夹你会看到已经生成了MessageProto.java文件，恭喜你，这时候你已经完成了protobuf序列化文件的生成。<strong>然后你把该文件拷贝至工程目录下</strong>。接下来我们用生成的文件去发消息吧。还是老套路服务端和客户端。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoBufServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProtoBufServer server = <span class="keyword">new</span> ProtoBufServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufDecoder(MessageProto.RequestMsg.getDefaultInstance()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtoBufServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageProto.ResponseMsg.Builder builder = MessageProto.ResponseMsg.newBuilder();</span><br><span class="line">        builder.setMsgType(ByteString.copyFromUtf8(<span class="string">"CBSP"</span>));</span><br><span class="line">        builder.setReceiveOne(<span class="string">"小红"</span>);</span><br><span class="line">        builder.setMsg(<span class="string">"你好，你有啥事"</span>);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageProto.RequestMsg m = (MessageProto.RequestMsg)msg;</span><br><span class="line">        System.out.println(<span class="string">"Client say: "</span>+m.getReceiveOne()+<span class="string">","</span>+m.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoBufClient</span><span class="params">(<span class="keyword">int</span> port, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProtoBufClient client = <span class="keyword">new</span> ProtoBufClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtoBufClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageProto.ResponseMsg m = (MessageProto.ResponseMsg)msg;</span><br><span class="line">        System.out.println(<span class="string">"Server say: "</span>+m.getReceiveOne()+<span class="string">","</span>+m.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageProto.RequestMsg.Builder builder = MessageProto.RequestMsg.newBuilder();</span><br><span class="line">        builder.setMsgType(ByteString.copyFromUtf8(<span class="string">"CBSP"</span>));</span><br><span class="line">        builder.setReceiveOne(<span class="string">"小明"</span>);</span><br><span class="line">        builder.setMsg(<span class="string">"你好，我找你有事"</span>);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务端和客户端，输出如下：</p><p><img src="http://i.imgur.com/bgl32QI.png" alt=""></p><p>最简单的protoBuf应用案例我们就写完了，真实的使用场景大同小异，随机应变即可。</p><h4 id="3-thrift序列化的使用"><a href="#3-thrift序列化的使用" class="headerlink" title="3. thrift序列化的使用"></a><strong>3. thrift序列化的使用</strong></h4><p>哈哈，我本来是打算讲thrift的安装和使用的，但是现在却讲不了，因为这玩意儿的安装是个问题。由于我没有linux环境，thrift如果在linux环境下安装使用是挺简单的，但是在windows环境下挺麻烦。thrift在windows下，还使用C++，搭环境是最难的。 libthrift依赖boost libthriftnb依赖boost，libevent 等于你得安装boost，libevent 除此之外，还需要openssl 装openssl，又需要perl，nasm 期间，还会涉及版本兼容问题，总而言之，比较折磨，而这还仅是安装编译。</p><p>所以暂时我就跳过这一部分，等我安装linux环境之后再来讲解吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前几节我们学习过处理粘包和拆包的问题，用到了Netty提供的几个解码器对不同情况的问题进行处理。功能很是强大。我们有没有去想这么强大的功能是如何实现的呢？背后又用到了什么技术？这一节我们就来处理这个问题。了解一下编码解码到底是如何处理的。&lt;/p&gt;
&lt;p&gt;通常说的编码(En
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(八)-Netty的心跳机制</title>
    <link href="https://blog.rickiyang.cn/posts/9afa0af8.html"/>
    <id>https://blog.rickiyang.cn/posts/9afa0af8.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.153Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道在TCP长连接或者WebSocket长连接中一般我们都会使用心跳机制–即发送特殊的数据包来通告对方自己的业务还没有办完，不要关闭链接。那么心跳机制可以用来做什么呢？我们知道网络的传输是不可靠的，当我们发起一个链接请求的过程之中会发生什么事情谁都无法预料，或者断电，服务器重启，断网线之类。如果有这种情况的发生对方也无法判断你是否还在线。所以这时候我们引入心跳机制，在长链接中双方没有数据交互的时候互相发送数据(可能是空包，也可能是特殊数据)，对方收到该数据之后也回复相应的数据用以确保双方都在线，这样就可以确保当前链接是有效的。</p><h4 id="1-如何实现心跳机制"><a href="#1-如何实现心跳机制" class="headerlink" title="1. 如何实现心跳机制"></a><strong>1. 如何实现心跳机制</strong></h4><p>一般实现心跳机制由两种方式：</p><ul><li>TCP协议自带的心跳机制来实现；</li><li>在应用层来实现。</li></ul><p>但是TCP协议自带的心跳机制系统默认是设置的是2小时的心跳频率。它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。另外该心跳机制是与TCP协议绑定的，那如果我们要是使用UDP协议岂不是用不了？所以一般我们都不用。</p><p>而一般我们自己实现呢大致的策略是这样的：</p><ol><li>Client启动一个定时器，不断发送心跳；</li><li>Server收到心跳后，做出回应；</li><li>Server启动一个定时器，判断Client是否存在，这里做判断有两种方法：时间差和简单标识。</li></ol><p>时间差：</p><ol><li>收到一个心跳包之后记录当前时间；</li><li>判断定时器到达时间，计算多久没收到心跳时间=当前时间-上次收到心跳时间。如果改时间大于设定值则认为超时。</li></ol><p>简单标识：</p><ol><li>收到心跳后设置连接标识为true;</li><li>判断定时器到达时间，如果未收到心跳则设置连接标识为false;</li></ol><p>今天我们来看一下Netty的心跳机制的实现，在Netty中提供了IdleStateHandler类来进行心跳的处理，它可以对一个 Channel 的 读/写设置定时器, 当 Channel 在一定事件间隔内没有数据交互时(即处于 idle 状态), 就会触发指定的事件。</p><p>该类可以对三种类型的超时做心跳机制检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">int</span> readerIdleTimeSeconds, <span class="keyword">int</span> writerIdleTimeSeconds, <span class="keyword">int</span> allIdleTimeSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">long</span>)readerIdleTimeSeconds, (<span class="keyword">long</span>)writerIdleTimeSeconds, (<span class="keyword">long</span>)allIdleTimeSeconds, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readerIdleTimeSeconds：设置读超时时间；</li><li>writerIdleTimeSeconds：设置写超时时间；</li><li>allIdleTimeSeconds：同时为读或写设置超时时间；</li></ul><p>下面我们还是通过一个例子来讲解IdleStateHandler的使用。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartBeatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> HeartBeatServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeartBeatServer server = <span class="keyword">new</span> HeartBeatServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>,<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HeartBeatServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里IdleStateHandler也是handler的一种，所以加入addLast。我们分别设置4个参数：读超时时间为3s，写超时和读写超时为0，然后加入时间控制单元。</p><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loss_connect_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">"Server :"</span> + msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="comment">//服务端对应着读事件，当为READER_IDLE时触发</span></span><br><span class="line">                IdleStateEvent event = (IdleStateEvent)evt;</span><br><span class="line">            <span class="keyword">if</span>(event.state() == IdleState.READER_IDLE)&#123;</span><br><span class="line">                loss_connect_time++;</span><br><span class="line">                System.out.println(<span class="string">"接收消息超时"</span>);</span><br><span class="line">                <span class="keyword">if</span>(loss_connect_time &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"关闭不活动的链接"</span>);</span><br><span class="line">                    ctx.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.userEventTriggered(ctx,evt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在handler中调用了userEventTriggered方法，IdleStateEvent的state()方法一个有三个值：<br>READER_IDLE，WRITER_IDLE，ALL_IDLE。正好对应读事件写事件和读写事件。</p><p>再来写一下客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatsClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartBeatsClient</span><span class="params">(<span class="keyword">int</span> port, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> HeartBeatsClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeartBeatsClient client = <span class="keyword">new</span> HeartBeatsClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatsClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HeartBeatClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们设置了IdleStateHandler的写超时为3秒，客户端执行的动作为写消息到服务端，服务端执行读动作。</p><p>客户端handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf HEARTBEAT_SEQUENCE = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="string">"Heartbeat"</span>,</span><br><span class="line">            CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRY_TIMES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"激活时间是："</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"链接已经激活"</span>);</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"停止时间是："</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"关闭链接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前轮询时间："</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                <span class="keyword">if</span>(currentTime &lt;= TRY_TIMES)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"currentTime:"</span>+currentTime);</span><br><span class="line">                    currentTime++;</span><br><span class="line">                    ctx.channel().writeAndFlush(HEARTBEAT_SEQUENCE.duplicate());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String message = (String) msg;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="keyword">if</span> (message.equals(<span class="string">"Heartbeat"</span>)) &#123;</span><br><span class="line">            ctx.write(<span class="string">"has read message from server"</span>);</span><br><span class="line">            ctx.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务端和客户端我们看到输出为：</p><p><img src="http://i.imgur.com/Gkhgtwh.png" alt=""></p><p>我们再来屡一下思路：</p><ol><li>首先客户端激活channel，因为客户端中并没有发送消息所以会触发客户端的IdleStateHandler，它设置的写超时时间为3s；</li><li>然后触发客户端的事件机制进入userEventTriggered方法，在触发器中计数并向客户端发送消息；</li><li>服务端接收消息；</li><li>客户端触发器继续轮询发送消息，直到计数器满不再向服务端发送消息；</li><li>服务端在IdleStateHandler设置的读消息超时时间5s内未收到消息，触发了服务端中handler的userEventTriggered方法，于是关闭客户端的链接。</li></ol><p>大体我们的简单心跳机制就是这样的思路，通过事件触发机制以及计数器的方式来实现，上面我们的案例中最后客户端没有发送消息的时候我们是强制断开了客户端的链接，那么既然可以关闭，我们是不是也可是重新链接客户端呢？因为万一客户端本身并不想关闭而是由于别的原因导致他无法与服务端通信。下面我们来说一下重连机制。</p><p>当我们的服务端在未读到客户端消息超时而关闭客户端的时候我们一般在客户端的finally块中方的是关闭客户端的代码，这时我们可以做一下修改的，finally是一定会被执行新的，所以我们可以在finally块中重新调用一下启动客户端的代码，这样就又重新启动了客户端了，上客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本Client为测试netty重连机制</span></span><br><span class="line"><span class="comment"> * Server端代码都一样，所以不做修改</span></span><br><span class="line"><span class="comment"> * 只用在client端中做一下判断即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatsClient2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line">    ChannelFuture future;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartBeatsClient2</span><span class="params">(<span class="keyword">int</span> port, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> HeartBeatsClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//group.shutdownGracefully();</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.channel() != <span class="keyword">null</span> &amp;&amp; future.channel().isOpen()) &#123;</span><br><span class="line">                    future.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"准备重连"</span>);</span><br><span class="line">            start();</span><br><span class="line">            System.out.println(<span class="string">"重连成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeartBeatsClient2 client = <span class="keyword">new</span> HeartBeatsClient2(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余部分的代码与上面的实例并无异同，只需改造客户端即可，我们再运行服务端和客户端会看到客户端虽然被关闭了，但是立马又被重启：</p><p><img src="http://i.imgur.com/Q7eee7J.png" alt=""></p><p>当然生产级别的代码应该不是这样实现的吧，哈哈，下一节我们再好好探讨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道在TCP长连接或者WebSocket长连接中一般我们都会使用心跳机制–即发送特殊的数据包来通告对方自己的业务还没有办完，不要关闭链接。那么心跳机制可以用来做什么呢？我们知道网络的传输是不可靠的，当我们发起一个链接请求的过程之中会发生什么事情谁都无法预料，或者断电，服
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(三)Channel</title>
    <link href="https://blog.rickiyang.cn/posts/12968bae.html"/>
    <id>https://blog.rickiyang.cn/posts/12968bae.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.162Z</updated>
    
    <content type="html"><![CDATA[<p>通道（Channel）是java.nio的第二个主要创新。它们既不是一个扩展也不是一项增强，而是全新、极好的Java I/O示例，提供与I/O服务的直接连接。Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。</p><h4 id="channel介绍"><a href="#channel介绍" class="headerlink" title="channel介绍"></a><strong>channel介绍</strong></h4><p>通道是访问I/O服务的导管。I/O可以分为广义的两大类别：File I/O和Stream I/O。那么相应地有两种类型的通道也就不足为怪了，它们是文件（file）通道和套接字（socket）通道。我们看到在api里有一个FileChannel类和三个socket通道类：SocketChannel、ServerSocketChannel和DatagramChannel。</p><p>通道可以以多种方式创建。Socket通道有可以直接创建新socket通道的工厂方法。但是一个FileChannel对象却只能通过在一个打开的RandomAccessFile、FileInputStream或FileOutputStream对象上调用getChannel( )方法来获取。你不能直接创建一个FileChannel对象。</p><p>我们先来看一下FileChannel的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件输出字节流</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>);</span><br><span class="line"><span class="comment">//得到文件通道</span></span><br><span class="line">FileChannel fc = fos.getChannel();</span><br><span class="line"><span class="comment">//往通道写入ByteBuffer</span></span><br><span class="line">fc.write(ByteBuffer.wrap(<span class="string">"Some text "</span>.getBytes()));</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">fos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机访问文件</span></span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">//得到文件通道</span></span><br><span class="line">fc = raf.getChannel();</span><br><span class="line"><span class="comment">//设置通道的文件位置 为末尾</span></span><br><span class="line">fc.position(fc.size()); </span><br><span class="line"><span class="comment">//往通道写入ByteBuffer</span></span><br><span class="line">fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">raf.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件输入流</span></span><br><span class="line">FileInputStream fs = <span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>);</span><br><span class="line"><span class="comment">//得到文件通道</span></span><br><span class="line">fc = fs.getChannel();</span><br><span class="line"><span class="comment">//分配ByteBuffer空间大小</span></span><br><span class="line">ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line"><span class="comment">//从通道中读取ByteBuffer</span></span><br><span class="line">fc.read(buff);</span><br><span class="line"><span class="comment">//调用此方法为一系列通道写入或相对获取 操作做好准备</span></span><br><span class="line">buff.flip();</span><br><span class="line"><span class="comment">//从ByteBuffer从依次读取字节并打印</span></span><br><span class="line"><span class="keyword">while</span> (buff.hasRemaining())&#123;</span><br><span class="line">   System.out.print((<span class="keyword">char</span>) buff.get());</span><br><span class="line">&#125;</span><br><span class="line">fs.close();</span><br></pre></td></tr></table></figure><p>再来看一下SocketChannel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open( );</span><br><span class="line">sc.connect (<span class="keyword">new</span> InetSocketAddress (<span class="string">"somehost"</span>, someport)); </span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open( ); </span><br><span class="line">ssc.socket( ).bind (<span class="keyword">new</span> InetSocketAddress (somelocalport)); </span><br><span class="line">DatagramChannel dc = DatagramChannel.open( );</span><br></pre></td></tr></table></figure><p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    <span class="comment">//wait, or do something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端的使用经常会考虑到非阻塞socket通道，因为它们使同时管理很多socket通道变得更容易。但是，在客户端使用一个或几个非阻塞模式的socket通道也是有益处的，例如，借助非阻塞socket通道，GUI程序可以专注于用户请求并且同时维护与一个或多个服务器的会话。在很多程序上，非阻塞模式都是有用的。</p><p>调用finishConnect( )方法来完成连接过程，该方法任何时候都可以安全地进行调用。假如在一个非阻塞模式的SocketChannel对象上调用finishConnect( )方法，将可能出现下列情形之一：</p><ul><li>connect( )方法尚未被调用。那么将产生NoConnectionPendingException异常。</li><li>连接建立过程正在进行，尚未完成。那么什么都不会发生，finishConnect( )方法会立即返回false值。</li><li>在非阻塞模式下调用connect( )方法之后，SocketChannel又被切换回了阻塞模式。那么如果有必要的话，调用线程会阻塞直到连接建立完成，finishConnect( )方法接着就会返回true值。在初次调用connect( )或最后一次调用finishConnect( )之后，连接建立过程已经完成。那么SocketChannel对象的内部状态将被更新到已连接状态，finishConnect( )方法会返回true值，然后SocketChannel对象就可以被用来传输数据了。</li><li>连接已经建立。那么什么都不会发生，finishConnect( )方法会返回true值。</li></ul><p>Socket通道是线程安全的。并发访问时无需特别措施来保护发起访问的多个线程，不过任何时候都只有一个读操作和一个写操作在进行中。请记住，sockets是面向流的而非包导向的。它们可以保证发送的字节会按照顺序到达但无法承诺维持字节分组。某个发送器可能给一个socket写入了20个字节而接收器调用read( )方法时却只收到了其中的3个字节。剩下的17个字节还是传输中。由于这个原因，让多个不配合的线程共享某个流socket的同一侧绝非一个好的设计选择。</p><p>最后再看一下DatagramChannel：</p><p>最后一个socket通道是DatagramChannel。正如SocketChannel对应Socket，ServerSocketChannel对应ServerSocket，每一个DatagramChannel对象也有一个关联的DatagramSocket对象。不过原命名模式在此并未适用：“DatagramSocketChannel”显得有点笨拙，因此采用了简洁的“DatagramChannel”名称。</p><p>正如SocketChannel模拟连接导向的流协议（如TCP/IP），DatagramChannel则模拟包导向的无连接协议（如UDP/IP）：</p><p>创建DatagramChannel的模式和创建其他socket通道是一样的：调用静态的open( )方法来创建一个新实例。新DatagramChannel会有一个可以通过调用socket( )方法获取的对等DatagramSocket对象。DatagramChannel对象既可以充当服务器（监听者）也可以充当客户端（发送者）。如果你希望新创建的通道负责监听，那么通道必须首先被绑定到一个端口或地址/端口组合上。绑定DatagramChannel同绑定一个常规的DatagramSocket没什么区别，都是委托对等socket对象上的API实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open( );</span><br><span class="line">DatagramSocket socket = channel.socket( ); </span><br><span class="line">socket.bind (<span class="keyword">new</span> InetSocketAddress (portNumber));</span><br></pre></td></tr></table></figure><p>DatagramChannel是无连接的。每个数据报（datagram）都是一个自包含的实体，拥有它自己的目的地址及不依赖其他数据报的数据净荷。与面向流的的socket不同，DatagramChannel可以发送单独的数据报给不同的目的地址。同样，DatagramChannel对象也可以接收来自任意地址的数据包。每个到达的数据报都含有关于它来自何处的信息（源地址）。</p><p>一个未绑定的DatagramChannel仍能接收数据包。当一个底层socket被创建时，一个动态生成的端口号就会分配给它。绑定行为要求通道关联的端口被设置为一个特定的值（此过程可能涉及安全检查或其他验证）。不论通道是否绑定，所有发送的包都含有DatagramChannel的源地址（带端口号）。未绑定的DatagramChannel可以接收发送给它的端口的包，通常是来回应该通道之前发出的一个包。已绑定的通道接收发送给它们所绑定的熟知端口（wellknown port）的包。数据的实际发送或接收是通过send( )和receive( )方法来实现的。</p><p><strong>注意：*</strong>假如您提供的ByteBuffer没有足够的剩余空间来存放您正在接收的数据包，没有被填充的字节都会被悄悄地丢弃。*</p><h4 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a><strong>Scatter/Gather</strong></h4><p>通道提供了一种被称为Scatter/Gather的重要新功能（有时也被称为矢量I/O）。它是指在多个缓冲区上实现一个简单的I/O操作。对于一个write操作而言，数据是从几个缓冲区按顺序抽取（称为gather）并沿着通道发送的。缓冲区本身并不需要具备这种gather的能力（通常它们也没有此能力）。该gather过程的效果就好比全部缓冲区的内容被连结起来，并在发送数据前存放到一个大的缓冲区中。对于read操作而言，从通道读取的数据会按顺序被散布（称为scatter）到多个缓冲区，将每个缓冲区填满直至通道中的数据或者缓冲区的最大空间被消耗完。</p><p>scatter / gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p><p>Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述：</p><p><img src="http://i.imgur.com/3Oj21dk.png" alt=""></p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocateDirect (<span class="number">10</span>); </span><br><span class="line">ByteBuffer body = ByteBuffer.allocateDirect (<span class="number">80</span>); </span><br><span class="line">ByteBuffer [] buffers = &#123; header, body &#125;; </span><br><span class="line"><span class="keyword">int</span> bytesRead = channel.read (buffers);</span><br></pre></td></tr></table></figure><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述：</p><p><img src="http://i.imgur.com/g6xjbxP.png" alt=""></p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocateDirect (<span class="number">10</span>); </span><br><span class="line">ByteBuffer body = ByteBuffer.allocateDirect (<span class="number">80</span>); </span><br><span class="line">ByteBuffer [] buffers = &#123; header, body &#125;; </span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p>使用得当的话，Scatter/Gather会是一个极其强大的工具。它允许你委托操作系统来完成辛苦活：将读取到的数据分开存放到多个存储桶（bucket）或者将不同的数据区块合并成一个整体。这是一个巨大的成就，因为操作系统已经被高度优化来完成此类工作了。它节省了您来回移动数据的工作，也就避免了缓冲区拷贝和减少了您需要编写、调试的代码数量。既然您基本上通过提供数据容器引用来组合数据，那么按照不同的组合构建多个缓冲区阵列引用，各种数据区块就可以以不同的方式来组合了。下面的例子好地诠释了这一点： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatheringTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEMOGRAPHIC = <span class="string">"output.txt"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reps = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            reps = Integer.parseInt(argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(DEMOGRAPHIC);</span><br><span class="line">        GatheringByteChannel gatherChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer[] bs = utterBS(reps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gatherChannel.write(bs) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 不做操作，让通道把数据输出到文件写完</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Mindshare paradigms synergized to "</span> + DEMOGRAPHIC);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String [] col1 = &#123; <span class="string">"Aggregate"</span>, <span class="string">"Enable"</span>, <span class="string">"Leverage"</span>,</span><br><span class="line">                                      <span class="string">"Facilitate"</span>, <span class="string">"Synergize"</span>, <span class="string">"Repurpose"</span>,</span><br><span class="line">                                      <span class="string">"Strategize"</span>, <span class="string">"Reinvent"</span>, <span class="string">"Harness"</span></span><br><span class="line">                                    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String [] col2 = &#123; <span class="string">"cross-platform"</span>, <span class="string">"best-of-breed"</span>, <span class="string">"frictionless"</span>,</span><br><span class="line">                                      <span class="string">"ubiquitous"</span>, <span class="string">"extensible"</span>, <span class="string">"compelling"</span>,</span><br><span class="line">                                      <span class="string">"mission-critical"</span>, <span class="string">"collaborative"</span>, <span class="string">"integrated"</span></span><br><span class="line">                                    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String [] col3 = &#123; <span class="string">"methodologies"</span>, <span class="string">"infomediaries"</span>, <span class="string">"platforms"</span>, <span class="string">"schemas"</span>, <span class="string">"mindshare"</span>, <span class="string">"paradigms"</span>, <span class="string">"functionalities"</span>, <span class="string">"web services"</span>, <span class="string">"infrastructures"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String newline = System.getProperty (<span class="string">"line.separator"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer [] utterBS (<span class="keyword">int</span> howMany) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; howMany; i++) &#123;</span><br><span class="line">            list.add(pickRandom(col1, <span class="string">" "</span>));</span><br><span class="line">            list.add(pickRandom(col2, <span class="string">" "</span>));</span><br><span class="line">            list.add(pickRandom(col3, newline));</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuffer[] bufs = <span class="keyword">new</span> ByteBuffer[list.size()];</span><br><span class="line">        list.toArray(bufs);</span><br><span class="line">        <span class="keyword">return</span> (bufs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random( );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strings</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> suffix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">pickRandom</span> <span class="params">(String [] strings, String suffix)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String string = strings [rand.nextInt (strings.length)];</span><br><span class="line">        <span class="keyword">int</span> total = string.length() + suffix.length( );</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate (total);</span><br><span class="line">        buf.put (string.getBytes (<span class="string">"US-ASCII"</span>));</span><br><span class="line">        buf.put (suffix.getBytes (<span class="string">"US-ASCII"</span>));</span><br><span class="line">        buf.flip( );</span><br><span class="line">        <span class="keyword">return</span> (buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>Reinvent integrated web servicesAggregate best-of-breed platformsHarness frictionless platformsRepurpose extensible paradigmsFacilitate ubiquitous methodologiesRepurpose integrated methodologiesFacilitate mission-critical paradigmsSynergize compelling methodologiesReinvent compelling functionalitiesFacilitate extensible platforms</code></pre><p>虽然这种输出没有什么意义，但是gather确是很容易的让我们把它输出出来。</p><h4 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a><strong>Pipe</strong></h4><p>java.nio.channels包中含有一个名为Pipe（管道）的类。广义上讲，管道就是一个用来在两个实体之间单向传输数据的导管。<br><strong><em>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取</em></strong>。Pipe类创建一对提供环回机制的Channel对象。这两个通道的远端是连接起来的，以便任何写在SinkChannel对象上的数据都能出现在SourceChannel对象上。</p><p>下面我们来创建一条Pipe，并向Pipe中写数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Pipe.open()方法打开管道</span></span><br><span class="line">Pipe pipe = Pipe.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//要向管道写数据，需要访问sink通道</span></span><br><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过调用SinkChannel的write()方法，将数据写入SinkChannel</span></span><br><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看如何从管道中读取数据：</p><p>读取管道的数据，需要访问source通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure><p>调用source通道的read()方法来读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = sourceChannel.read(buf);</span><br></pre></td></tr></table></figure><p>read()方法返回的int值会告诉我们多少字节被读进了缓冲区。</p><p>到此我们就把通道的简单用法讲完了，要想会用还是得多去练习，多模拟使用，这样才知道什么时候用以及怎么用，下节我们来讲选择器-Selectors。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通道（Channel）是java.nio的第二个主要创新。它们既不是一个扩展也不是一项增强，而是全新、极好的Java I/O示例，提供与I/O服务的直接连接。Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。&lt;/p&gt;
&lt;h4 
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq实战整合Spring之Topic模式(五)</title>
    <link href="https://blog.rickiyang.cn/posts/1d6950fa.html"/>
    <id>https://blog.rickiyang.cn/posts/1d6950fa.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.147Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们看一下Topic模式下的消息发布是如何处理的。</p><p>applicationContext-ActiveMQ.xml配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:amq=<span class="string">"http://activemq.apache.org/schema/core"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> /&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                           brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                           userName=<span class="string">"admin"</span></span><br><span class="line">                           password=<span class="string">"admin"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS连接工厂 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"connectionFactory"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"amqConnectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"sessionCacheSize"</span> value=<span class="string">"100"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义消息队列（topic） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"demoTopicDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span><br><span class="line">        &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS模板（topic），Spring提供的JMS工具类，它发送、接收消息。 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"jmsTemplate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"defaultDestination"</span> ref=<span class="string">"demoTopicDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;        </span><br><span class="line">        &lt;property name=<span class="string">"pubSubDomain"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置消息队列监听者（topic） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"topicMessageListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener"</span> /&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"topicMessageListener1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener1"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 显示注入消息监听容器（topic），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueListenerContainer"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoTopicDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"topicMessageListener"</span> /&gt;       </span><br><span class="line">        &lt;!--消息接收超时 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"queueListenerContainerB"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoTopicDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"topicMessageListener1"</span> /&gt;</span><br><span class="line">        &lt;!--消息接收超时 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>这里与queue模式不一样的地方在于订阅者有一个或是多个，有几个订阅者就需要配置监听器。</p><p>applicationContext.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!-- 查找最新的schemaLocation 访问 http:<span class="comment">//www.springframework.org/schema/ --&gt;</span></span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop/spring-aop-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定Sping组件扫描的基本包路径 --&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> &gt;</span><br><span class="line">        &lt;!-- 这里只扫描Controller，不可重复加载Service --&gt;</span><br><span class="line">        &lt;context:include-filter type=<span class="string">"annotation"</span> expression=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span><br><span class="line">    &lt;/context:component-scan&gt;</span><br><span class="line">    &lt;!-- 启用MVC注解 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- JSP视图解析器--&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">        &lt;!--  定义其解析视图的order顺序为<span class="number">1</span> --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"order"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>web.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span><br><span class="line"><span class="string">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span><br><span class="line">         version=<span class="string">"3.0"</span>&gt;</span><br><span class="line">&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:applicationContext-ActiveMQ.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">springMVC</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line">            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 处理编码格式 --&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">UTF</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">forceEncoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">true</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">characterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其余部分与queue模式代码一样，只是需要多配置一个监听器，目录结构如下：</p><p><img src="http://img.blog.csdn.net/20170512000602743?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>ProducerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination,<span class="keyword">final</span> String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProducerServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ProducerService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, <span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 向队列"</span>+destination.toString()+<span class="string">"发送消息---------&gt;"</span>+msg);</span><br><span class="line">        jmsTemplate.send(destination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        String destination = jmsTemplate.getDefaultDestinationName();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 向队列"</span>+destination+<span class="string">"发送消息--------&gt;"</span>+msg);</span><br><span class="line">        jmsTemplate.send(<span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TextMessage <span class="title">receive</span><span class="params">(Destination destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ConsumerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextMessage <span class="title">receive</span><span class="params">(Destination destination)</span></span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) jmsTemplate.receive(destination);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"从队列"</span> + destination.toString() + <span class="string">"收到了消息：\t"</span></span><br><span class="line">                    + textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueueMessageListener.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage tm = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"topicMessageListener监听到了文本消息：\t"</span></span><br><span class="line">                    + tm.getText());</span><br><span class="line">            <span class="comment">//do something ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueueMessageListener1.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueMessageListener1</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage tm = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"topicMessageListener1监听到了文本消息：\t"</span></span><br><span class="line">                    + tm.getText());</span><br><span class="line">            <span class="comment">//do something ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ConsumerService;</span><br><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ProducerService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MessageController.class);</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"demoQueueDestination"</span>)</span><br><span class="line">    <span class="keyword">private</span> Destination destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列消息生产者</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ProducerService producer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列消息消费者</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ConsumerService consumer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/SendMessage"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------开始发送消息"</span>);</span><br><span class="line">        producer.sendMessage(msg);</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------发送完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value= <span class="string">"/ReceiveMessage"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------开始接受消息"</span>);</span><br><span class="line">        TextMessage tm = consumer.receive(destination);</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------接受完毕"</span>);</span><br><span class="line">        <span class="keyword">return</span> tm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动工程，在地址栏中输入：<a href="http://localhost:8080/SendMessage?msg=nihao，" target="_blank" rel="noopener">http://localhost:8080/SendMessage?msg=nihao，</a><br>代码很简单我就没有写前台页面啦，msg部分你可以随便写。回车之后我们去看一下控制台两个订阅者都接收到消息。</p><p><img src="http://img.blog.csdn.net/20170512000659974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们看一下Topic模式下的消息发布是如何处理的。&lt;/p&gt;
&lt;p&gt;applicationContext-ActiveMQ.xml配置：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="activeMQ" scheme="https://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq实战之整合Spring(四)</title>
    <link href="https://blog.rickiyang.cn/posts/64e3c39e.html"/>
    <id>https://blog.rickiyang.cn/posts/64e3c39e.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.163Z</updated>
    
    <content type="html"><![CDATA[<p>前面的理论准备已经很充分，这一节我们来实战：将activemq整合到Spring框架才行中，因为Spring已经集成了JMS，这也为我们配置activermq带来了方便。</p><h4 id="1-Spring对jms的支持"><a href="#1-Spring对jms的支持" class="headerlink" title="1. Spring对jms的支持"></a>1. Spring对jms的支持</h4><p>因为Spring已经将JMS集成到框架里面了，对jms做了自己的封装，我们使用起来更加方便，在Spring中使用jms比较麻烦的就是配置，在Spring中配置JMS大体需要8个部分：</p><ol><li>ConnectionFactory： 和jms服务器的连接, 可以是外部的jms server, 也可以使用embedded ActiveMQ Broker；</li><li>Destination： 有topic和queue两种方式；</li><li>JmsTemplate： spring提供的jms模板；</li><li>MessageConverter： 消息转换器；</li><li>MessageProducer： 消息生产者；</li><li>MessageConsumer： 消息消费者；</li><li>MessageListener： 消息监听器；</li><li>MessageListenerContainer： 消息监听容器。</li></ol><p>下面我把完整的配置文件按照上面的步骤拆开分别讲解：</p><p><strong>1.1首先我们配置ConnectionFactory：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                   brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                   userName=<span class="string">"admin"</span></span><br><span class="line">                   password=<span class="string">"admin"</span> /&gt;</span><br></pre></td></tr></table></figure><p>brokerURL是指要连接的activeMQ server的地址，该配置即使用activemq独立的消息存储环境，即使服务器重启消息也不会丢失。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置JMS连接工厂 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"connectionFactory"</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span><br><span class="line">    &lt;constructor-arg ref=<span class="string">"amqConnectionFactory"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"sessionCacheSize"</span> value=<span class="string">"100"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>我们从Spring给我们提供的connectionFactory中获取Connection，并且把该connectionFactory注册到上面定义的activemq server中。</p><p><strong>1.2 Destination：</strong></p><p>由前面我们知道Destination有两种形式：P2P和Pub/Sub。那么在配置中表示就是：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 定义消息队列（Queue） --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"demoQueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span><br><span class="line">    &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 定义消息队列（topic） --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"demoQueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span><br><span class="line">    &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>1.3 JmsTemplate：</strong></p><p>将connectionFactory和defaultDestination注入JmsTemplate中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"jmsTemplate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"defaultDestination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">    &lt;!-- <span class="keyword">true</span>是topic，<span class="keyword">false</span>是queue，默认是<span class="keyword">false</span>，此处显示写出<span class="keyword">false</span> --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"pubSubDomain"</span> value=<span class="string">"false"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在Java相关处理文件中添加(这里用的是@Inject注解，当然也可以用@Autowired)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line"><span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">TextMessage textMessage = (TextMessage) jmsTemplate.receive(destination);</span><br></pre></td></tr></table></figure><p><strong>1.4 MessageConverter</strong></p><p>MessageConverter实现的是org.springframework.jms.support.converter.MessageConverter接口, 提供消息的转换功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"defaultMessageConverter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.DefaultMessageConverter"</span> /&gt;</span><br></pre></td></tr></table></figure><p><strong>1.5 MessageProducer和MessageConsumer</strong></p><p>此处灵活使用，可以以服务的形式提供也可以以工具类的形式提供，详情见下面的示例代码。</p><p><strong>1.6 MessageListener</strong></p><p>消息的消费者应有的有对应的Listener。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置消息队列监听者（Queue） --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"queueMessageListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener"</span> /&gt; =</span><br></pre></td></tr></table></figure><p><strong>1.7 MessageListenerContainer</strong></p><p>MessageListenerContainer即Listener的容器，用来对Listener坐一些配置，每一个listener都对应着一个Container：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 显示注入消息监听容器（Queue），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"queueListenerContainer"</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"queueMessageListener"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>Spring为我们听过了两种类型的MessageListenerContainer：SimpleMessageListenerContainer和DefaultMessageListenerContainer。</p><ul><li>SimpleMessageListenerContainer会在一开始的时候就创建一个会话Session和消费者Consumer，并且会适用标准的JMS的MessageConsumer.setMessageListener()方法注册监听器让JMS提供调用监听器的回调函数。它不会动态的适应运行时需要和参与外部的事务管理。兼容性方面，它非常接近于独立的JMS规范，但一般不兼容J2EE的JMS限制。大多数情况下，我们还是使用DefaultMessageListenerContainer。</li><li>DefaultMessageListenerContainer，与SimpleMessageListenerContainer相比，它会动态的适应运行时的需求，并且能够参与外部的事务管理。</li></ul><p>上面就是mq的配置文件部分，如果从上到下的配置部分都清楚地话使用起来肯定没有问题，我们再做一个简要的总结：</p><ol><li>可以有一个或者多个消息生产者向同一个destination发送消息；</li><li>queue类型的只能有一个消息消费者；</li><li>topic类型的可以有多个消息消费者；</li><li>每个消费者对应一个MessageListener和一个MessageListenerContainer。</li></ol><p>下面我们看一下整合的全部代码：</p><p>首先上pom.xml看一下依赖的jar包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;q&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;q&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;name&gt;q Maven Webapp&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http:<span class="comment">//maven.apache.org&lt;/url&gt;</span></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;springframework&gt;4.3.0.RELEASE&lt;/springframework&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- spring --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;springframework&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- xbean 如&lt;amq:connectionFactory /&gt; --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.16&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- activemq --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.7.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.12.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;q&lt;/finalName&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;source&gt;1.6&lt;/source&gt;</span><br><span class="line">          &lt;target&gt;1.6&lt;/target&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>然后是我们的Spring配置文件applicationContext.xml:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!-- 查找最新的schemaLocation 访问 http:<span class="comment">//www.springframework.org/schema/ --&gt;</span></span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop/spring-aop-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定Sping组件扫描的基本包路径 --&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> &gt;</span><br><span class="line">        &lt;!-- 这里只扫描Controller，不可重复加载Service --&gt;</span><br><span class="line">        &lt;context:include-filter type=<span class="string">"annotation"</span> expression=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span><br><span class="line">    &lt;/context:component-scan&gt;</span><br><span class="line">    &lt;!-- 启用MVC注解 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- JSP视图解析器--&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">        &lt;!--  定义其解析视图的order顺序为<span class="number">1</span> --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"order"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>activemq的配置文件applicationContext-ActiveMQ.xml：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:amq=<span class="string">"http://activemq.apache.org/schema/core"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> /&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                           brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                           userName=<span class="string">"admin"</span></span><br><span class="line">                           password=<span class="string">"admin"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS连接工厂 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"connectionFactory"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"amqConnectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"sessionCacheSize"</span> value=<span class="string">"100"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义消息队列（Queue） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"demoQueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span><br><span class="line">        &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"jmsTemplate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"defaultDestination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">        &lt;!-- <span class="keyword">true</span>是topic，<span class="keyword">false</span>是queue，默认是<span class="keyword">false</span>，此处显示写出<span class="keyword">false</span> --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"pubSubDomain"</span> value=<span class="string">"false"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置消息队列监听者（Queue） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueMessageListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 显示注入消息监听容器（Queue），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueListenerContainer"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"queueMessageListener"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>配置的介绍在上面我已经讲过了，不明白的地方翻到上面去看看。</p><p>web.xml文件的配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span><br><span class="line"><span class="string">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span><br><span class="line">         version=<span class="string">"3.0"</span>&gt;</span><br><span class="line">&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:applicationContext-ActiveMQ.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">springMVC</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line">            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 处理编码格式 --&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">UTF</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">forceEncoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">true</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">characterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们的工程目录结构如下：</p><p><img src="http://img.blog.csdn.net/20170505081848348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>上service的代码：</p><p>ProducerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination,<span class="keyword">final</span> String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProducerServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ProducerService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, <span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 向队列"</span>+destination.toString()+<span class="string">"发送消息---------&gt;"</span>+msg);</span><br><span class="line">        jmsTemplate.send(destination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        String destination = jmsTemplate.getDefaultDestinationName();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 向队列"</span>+destination+<span class="string">"发送消息--------&gt;"</span>+msg);</span><br><span class="line">        jmsTemplate.send(<span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TextMessage <span class="title">receive</span><span class="params">(Destination destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ConsumerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jmsTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextMessage <span class="title">receive</span><span class="params">(Destination destination)</span></span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) jmsTemplate.receive(destination);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"从队列"</span> + destination.toString() + <span class="string">"收到了消息：\t"</span></span><br><span class="line">                    + textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueueMessageListener.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage tm = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"QueueMessageListener监听到了文本消息：\t"</span></span><br><span class="line">                    + tm.getText());</span><br><span class="line">            <span class="comment">//do something ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ConsumerService;</span><br><span class="line"><span class="keyword">import</span> cn.edu.hust.activemq.service.ProducerService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/5/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MessageController.class);</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"demoQueueDestination"</span>)</span><br><span class="line">    <span class="keyword">private</span> Destination destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列消息生产者</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ProducerService producer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列消息消费者</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ConsumerService consumer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/SendMessage"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------开始发送消息"</span>);</span><br><span class="line">        producer.sendMessage(msg);</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------发送完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value= <span class="string">"/ReceiveMessage"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------开始接受消息"</span>);</span><br><span class="line">        TextMessage tm = consumer.receive(destination);</span><br><span class="line">        logger.info(Thread.currentThread().getName()+<span class="string">"------------接受完毕"</span>);</span><br><span class="line">        <span class="keyword">return</span> tm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是上面这些，我们先启动acticemq server，然后下启动工程，在地址栏中输入：<a href="http://localhost:8080/SendMessage?msg=nihao，" target="_blank" rel="noopener">http://localhost:8080/SendMessage?msg=nihao，</a><br>代码很简单我就没有写前台页面啦，msg部分你可以随便写。回车之后我们去看一下控制台消息就发送出去了。</p><p><img src="http://img.blog.csdn.net/20170505081958553?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面的理论准备已经很充分，这一节我们来实战：将activemq整合到Spring框架才行中，因为Spring已经集成了JMS，这也为我们配置activermq带来了方便。&lt;/p&gt;
&lt;h4 id=&quot;1-Spring对jms的支持&quot;&gt;&lt;a href=&quot;#1-Spring对jms
      
    
    </summary>
    
      <category term="activeMQ" scheme="https://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-NIO(四)Selector</title>
    <link href="https://blog.rickiyang.cn/posts/e87423e8.html"/>
    <id>https://blog.rickiyang.cn/posts/e87423e8.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.144Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们将探索选择器(selectors)。选择器提供选择执行已经就绪的任务的能力，这使得多元 I/O 成为可能。就像在第一章中描述的那样，就绪选择和多元执行使得单线程能够有效率地同时管理多个 I/O 通道(channels)。C/C++代码的工具箱中，许多年前就已经有 select()和 poll()这两个POSIX（可移植性操作系统接口）系统调用可供使用了。许过操作系统也提供相似的功能，但对Java 程序员来说，就绪选择功能直到 JDK 1.4 才成为可行的方案。</p><p>下面我们来使用选择器：</p><p>通过 Selector.open()方法, 我们可以创建一个选择器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>将 Channel 注册到选择器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p><b style="color:red"><strong><em>注意, 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的, 即channel.configureBlocking(false);因为 Channel 必须要是非阻塞的, 因此 FileChannel 不能够使用选择器, 因为 FileChannel 都是阻塞的.</em></strong></b></p><p>注意到, 在使用 Channel.register()方法时, 第二个参数指定了我们对 Channel 的什么类型的事件感兴趣, 这些事件有:</p><ol><li>Connect, 即连接事件(TCP 连接), 对应于SelectionKey.OP_CONNECT</li><li>Accept, 即确认事件, 对应于SelectionKey.OP_ACCEPT</li><li>Read, 即读事件, 对应于SelectionKey.OP_READ, 表示 buffer 可读.</li><li>Write, 即写事件, 对应于SelectionKey.OP_WRITE, 表示 buffer 可写.</li></ol><p>一个 Channel发出一个事件也可以称为 对于某个事件, Channel 准备好了. 因此一个 Channel 成功连接到了另一个服务器也可以被称为 connect ready.<br>我们可以使用或运算|来组合多个事件, 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p><em>注意, 一个 Channel 仅仅可以被注册到一个 Selector 一次, 如果将 Channel 注册到 Selector 多次, 那么其实就是相当于更新 SelectionKey 的 interest set. 例如:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure><p><em>上面的 channel 注册到同一个 Selector 两次了, 那么第二次的注册其实就是相当于更新这个 Channel 的 interest set 为 SelectionKey.OP_READ | SelectionKey.OP_WRITE.</em></p><p>但是Java NIO的selector允许一个单一线程监听多个channel输入。我们可以注册多个channel到selector上，然后然后用一个线程来挑出一个处于可读或者可写状态的channel。selector机制使得单线程管理多个channel变得容易。</p><p>下面我们写一个完整的例子，看一下Selector的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//注册通道</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">//查看selector中的key是否准备好</span></span><br><span class="line">    <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">    <span class="comment">//小于0超时，等于0没准备好，大于0已经准备完毕</span></span><br><span class="line">    <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//获取选择器中的key</span></span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">    <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="comment">//遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件</span></span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 连接已经被ServerSocketChannel所接受</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">            <span class="comment">// 连接已经被远程终止.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 通道已经准备好读数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 通道已经准备好写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择器的使用还有很多的细节，我们应该多查看api文档了解各个方法的用法。下一节我们做一个综合练习，总结一下NIO的使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节我们将探索选择器(selectors)。选择器提供选择执行已经就绪的任务的能力，这使得多元 I/O 成为可能。就像在第一章中描述的那样，就绪选择和多元执行使得单线程能够有效率地同时管理多个 I/O 通道(channels)。C/C++代码的工具箱中，许多年前就已经有 
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis Generator最完整配置详解</title>
    <link href="https://blog.rickiyang.cn/posts/a9e1e2fd.html"/>
    <id>https://blog.rickiyang.cn/posts/a9e1e2fd.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.164Z</updated>
    
    <content type="html"><![CDATA[<p>转自：【<a href="http://www.jianshu.com/p/e09d2370b796】" target="_blank" rel="noopener">http://www.jianshu.com/p/e09d2370b796】</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;  </span><br><span class="line">&lt;!DOCTYPE generatorConfiguration  </span><br><span class="line">  PUBLIC <span class="string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span>  </span><br><span class="line"><span class="string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;  </span><br><span class="line">&lt;!-- 配置生成器 --&gt;  </span><br><span class="line">&lt;generatorConfiguration&gt;  </span><br><span class="line">&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项  </span><br><span class="line">    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties          </span><br><span class="line">    url：配置资源加载地质，使用URL的方式，比如file:<span class="comment">///C:/myfolder/generatorConfig.properties.  </span></span><br><span class="line">    注意，两个属性只能选址一个;  </span><br><span class="line">  </span><br><span class="line">    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用  </span><br><span class="line">&lt;properties resource=<span class="string">""</span> url=<span class="string">""</span> /&gt;  </span><br><span class="line"> --&gt;  </span><br><span class="line">  </span><br><span class="line"> &lt;!-- 在MBG工作的时候，需要额外加载的依赖包  </span><br><span class="line">     location属性指明加载jar/zip包的全路径  </span><br><span class="line">&lt;classPathEntry location=<span class="string">"/Program Files/IBM/SQLLIB/java/db2java.zip"</span> /&gt;  </span><br><span class="line">  --&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!--   </span><br><span class="line">    context:生成一组对象的环境   </span><br><span class="line">    id:必选，上下文id，用于在生成错误时提示  </span><br><span class="line">    defaultModelType:指定生成对象的样式  </span><br><span class="line">        <span class="number">1</span>，conditional：类似hierarchical；  </span><br><span class="line">        <span class="number">2</span>，flat：所有内容（主键，blob）等全部生成在一个对象中；  </span><br><span class="line">        <span class="number">3</span>，hierarchical：主键生成一个XXKey对象(key <span class="class"><span class="keyword">class</span>)，<span class="title">Blob</span>等单独生成一个对象，其他简单属性在一个对象中(<span class="title">record</span> <span class="title">class</span>)  </span></span><br><span class="line">    targetRuntime:  </span><br><span class="line">        <span class="number">1</span>，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；  </span><br><span class="line">        <span class="number">2</span>，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；  </span><br><span class="line">    introspectedColumnImpl：类全限定名，用于扩展MBG  </span><br><span class="line">--&gt;  </span><br><span class="line">&lt;context id=<span class="string">"mysql"</span> defaultModelType=<span class="string">"hierarchical"</span> targetRuntime=<span class="string">"MyBatis3Simple"</span> &gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 自动识别数据库关键字，默认<span class="keyword">false</span>，如果设置为<span class="keyword">true</span>，根据SqlReservedWords中定义的关键字列表；  </span><br><span class="line">        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"autoDelimitKeywords"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">    &lt;!-- 生成的Java文件的编码 --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"javaFileEncoding"</span> value=<span class="string">"UTF-8"</span>/&gt;  </span><br><span class="line">    &lt;!-- 格式化java代码 --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"javaFormatter"</span> value=<span class="string">"org.mybatis.generator.api.dom.DefaultJavaFormatter"</span>/&gt;  </span><br><span class="line">    &lt;!-- 格式化XML代码 --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"xmlFormatter"</span> value=<span class="string">"org.mybatis.generator.api.dom.DefaultXmlFormatter"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"beginningDelimiter"</span> value=<span class="string">"`"</span>/&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"endingDelimiter"</span> value=<span class="string">"`"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 必须要有的，使用这个配置链接数据库  </span><br><span class="line">        <span class="meta">@TODO</span>:是否可以扩展  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;jdbcConnection driverClass=<span class="string">"com.mysql.jdbc.Driver"</span> connectionURL=<span class="string">"jdbc:mysql:///pss"</span> userId=<span class="string">"root"</span> password=<span class="string">"admin"</span>&gt;  </span><br><span class="line">        &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;  </span><br><span class="line">    &lt;/jdbcConnection&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- java类型处理器   </span><br><span class="line">        用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；  </span><br><span class="line">        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；   </span><br><span class="line">    --&gt;  </span><br><span class="line">    &lt;javaTypeResolver type=<span class="string">"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl"</span>&gt;  </span><br><span class="line">        &lt;!--   </span><br><span class="line">            <span class="keyword">true</span>：使用BigDecimal对应DECIMAL和 NUMERIC数据类型  </span><br><span class="line">            <span class="keyword">false</span>：默认,  </span><br><span class="line">                scale&gt;<span class="number">0</span>;length&gt;<span class="number">18</span>：使用BigDecimal;  </span><br><span class="line">                scale=<span class="number">0</span>;length[<span class="number">10</span>,<span class="number">18</span>]：使用Long；  </span><br><span class="line">                scale=<span class="number">0</span>;length[<span class="number">5</span>,<span class="number">9</span>]：使用Integer；  </span><br><span class="line">                scale=<span class="number">0</span>;length&lt;<span class="number">5</span>：使用Short；  </span><br><span class="line">         --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"forceBigDecimals"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">    &lt;/javaTypeResolver&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- java模型创建器，是必须要的元素  </span><br><span class="line">        负责：<span class="number">1</span>，key类（见context的defaultModelType）；<span class="number">2</span>，java类；<span class="number">3</span>，查询类  </span><br><span class="line">        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；  </span><br><span class="line">        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;javaModelGenerator targetPackage=<span class="string">"com._520it.mybatis.domain"</span> targetProject=<span class="string">"src/main/java"</span>&gt;  </span><br><span class="line">        &lt;!--  <span class="keyword">for</span> MyBatis3/MyBatis3Simple  </span><br><span class="line">            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；  </span><br><span class="line">         --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"constructorBased"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层<span class="keyword">package</span>，最终生成的类放在这个<span class="keyword">package</span>下，默认为<span class="keyword">false</span> --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"enableSubPackages"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- <span class="keyword">for</span> MyBatis3 / MyBatis3Simple  </span><br><span class="line">            是否创建一个不可变的类，如果为<span class="keyword">true</span>，  </span><br><span class="line">            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类  </span><br><span class="line">         --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"immutable"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 设置一个根对象，  </span><br><span class="line">            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项  </span><br><span class="line">            注意：如果在key <span class="class"><span class="keyword">class</span>或者<span class="title">record</span> <span class="title">class</span>中有<span class="title">root</span> <span class="title">class</span>相同的属性，<span class="title">MBG</span>就不会重新生成这些属性了，包括：  </span></span><br><span class="line"><span class="class">                1，属性名相同，类型相同，有相同的<span class="title">getter</span>/<span class="title">setter</span>方法；  </span></span><br><span class="line"><span class="class">         --&gt;  </span></span><br><span class="line"><span class="class">        &lt;<span class="title">property</span> <span class="title">name</span></span>=<span class="string">"rootClass"</span> value=<span class="string">"com._520it.mybatis.domain.BaseDomain"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"trimStrings"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">    &lt;/javaModelGenerator&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 生成SQL map的XML文件生成器，  </span><br><span class="line">        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），  </span><br><span class="line">            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置  </span><br><span class="line">        targetPackage/targetProject:同javaModelGenerator  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;sqlMapGenerator targetPackage=<span class="string">"com._520it.mybatis.mapper"</span> targetProject=<span class="string">"src/main/resources"</span>&gt;  </span><br><span class="line">        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层<span class="keyword">package</span>，最终生成的类放在这个<span class="keyword">package</span>下，默认为<span class="keyword">false</span> --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"enableSubPackages"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">    &lt;/sqlMapGenerator&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口   </span><br><span class="line">        targetPackage/targetProject:同javaModelGenerator  </span><br><span class="line">        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：  </span><br><span class="line">            <span class="number">1</span>，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；  </span><br><span class="line">            <span class="number">2</span>，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；  </span><br><span class="line">            <span class="number">3</span>，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；  </span><br><span class="line">        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER  </span><br><span class="line">    --&gt;  </span><br><span class="line">    &lt;javaClientGenerator targetPackage=<span class="string">"com._520it.mybatis.mapper"</span> type=<span class="string">"ANNOTATEDMAPPER"</span> targetProject=<span class="string">"src/main/java"</span>&gt;  </span><br><span class="line">        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层<span class="keyword">package</span>，最终生成的类放在这个<span class="keyword">package</span>下，默认为<span class="keyword">false</span> --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"enableSubPackages"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查  </span><br><span class="line">        &lt;property name=<span class="string">"rootInterface"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">    &lt;/javaClientGenerator&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素  </span><br><span class="line">        选择的table会生成一下文件：  </span><br><span class="line">        <span class="number">1</span>，SQL map文件  </span><br><span class="line">        <span class="number">2</span>，生成一个主键类；  </span><br><span class="line">        <span class="number">3</span>，除了BLOB和主键的其他字段的类；  </span><br><span class="line">        <span class="number">4</span>，包含BLOB的类；  </span><br><span class="line">        <span class="number">5</span>，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；  </span><br><span class="line">        <span class="number">6</span>，Mapper接口（可选）  </span><br><span class="line">  </span><br><span class="line">        tableName（必要）：要生成对象的表名；  </span><br><span class="line">        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会  </span><br><span class="line">            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：  </span><br><span class="line">            <span class="number">1</span>，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；  </span><br><span class="line">            <span class="number">2</span>，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；  </span><br><span class="line">            <span class="number">3</span>，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；  </span><br><span class="line">            <span class="number">4</span>，否则，使用指定的大小写格式查询；  </span><br><span class="line">        另外的，如果在创建表的时候，使用的<span class="string">""</span>把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；  </span><br><span class="line">        这个时候，请设置delimitIdentifiers=<span class="string">"true"</span>即可保留大小写格式；  </span><br><span class="line">  </span><br><span class="line">        可选：  </span><br><span class="line">        <span class="number">1</span>，schema：数据库的schema；  </span><br><span class="line">        <span class="number">2</span>，catalog：数据库的catalog；  </span><br><span class="line">        <span class="number">3</span>，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName  </span><br><span class="line">        <span class="number">4</span>，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；  </span><br><span class="line">        <span class="number">5</span>，enableInsert（默认<span class="keyword">true</span>）：指定是否生成insert语句；  </span><br><span class="line">        <span class="number">6</span>，enableSelectByPrimaryKey（默认<span class="keyword">true</span>）：指定是否生成按照主键查询对象的语句（就是getById或get）；  </span><br><span class="line">        <span class="number">7</span>，enableSelectByExample（默认<span class="keyword">true</span>）：MyBatis3Simple为<span class="keyword">false</span>，指定是否生成动态查询语句；  </span><br><span class="line">        <span class="number">8</span>，enableUpdateByPrimaryKey（默认<span class="keyword">true</span>）：指定是否生成按照主键修改对象的语句（即update)；  </span><br><span class="line">        <span class="number">9</span>，enableDeleteByPrimaryKey（默认<span class="keyword">true</span>）：指定是否生成按照主键删除对象的语句（即delete）；  </span><br><span class="line">        <span class="number">10</span>，enableDeleteByExample（默认<span class="keyword">true</span>）：MyBatis3Simple为<span class="keyword">false</span>，指定是否生成动态删除语句；  </span><br><span class="line">        <span class="number">11</span>，enableCountByExample（默认<span class="keyword">true</span>）：MyBatis3Simple为<span class="keyword">false</span>，指定是否生成动态查询总条数语句（用于分页的总条数查询）；  </span><br><span class="line">        <span class="number">12</span>，enableUpdateByExample（默认<span class="keyword">true</span>）：MyBatis3Simple为<span class="keyword">false</span>，指定是否生成动态修改语句（只修改对象中不为空的属性）；  </span><br><span class="line">        <span class="number">13</span>，modelType：参考context元素的defaultModelType，相当于覆盖；  </span><br><span class="line">        <span class="number">14</span>，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）  </span><br><span class="line">        <span class="number">15</span>，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为<span class="keyword">false</span>，delimitIdentifiers参考context的属性  </span><br><span class="line">  </span><br><span class="line">        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；  </span><br><span class="line">     --&gt;  </span><br><span class="line">    &lt;table tableName=<span class="string">"userinfo"</span> &gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"constructorBased"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 默认为<span class="keyword">false</span>，如果设置为<span class="keyword">true</span>，在生成的SQL中，table名字不会加上catalog或schema； --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"ignoreQualifiersAtRuntime"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"immutable"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 指定是否只生成domain类，如果设置为<span class="keyword">true</span>，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"modelOnly"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 参考 javaModelGenerator 的 rootClass 属性   </span><br><span class="line">        &lt;property name=<span class="string">"rootClass"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 参考javaClientGenerator 的  rootInterface 属性  </span><br><span class="line">        &lt;property name=<span class="string">"rootInterface"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">        --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog   </span><br><span class="line">        &lt;property name=<span class="string">"runtimeCatalog"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">        --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema   </span><br><span class="line">        &lt;property name=<span class="string">"runtimeSchema"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">        --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename   </span><br><span class="line">        &lt;property name=<span class="string">"runtimeTableName"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">        --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 注意，该属性只针对MyBatis3Simple有用；  </span><br><span class="line">            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；  </span><br><span class="line">         --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"selectAllOrderByClause"</span> value=<span class="string">"age desc,username asc"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- 如果设置为<span class="keyword">true</span>，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"useActualColumnNames"</span> value=<span class="string">"false"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        &lt;!-- generatedKey用于生成生成主键的方法，  </span><br><span class="line">            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选  </span><br><span class="line">            column:主键的列名；  </span><br><span class="line">            sqlStatement：要生成的selectKey语句，有以下可选项：  </span><br><span class="line">                Cloudscape:相当于selectKey的SQL为： <span class="function">VALUES <span class="title">IDENTITY_VAL_LOCAL</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                DB2       :相当于selectKey的SQL为： VALUES <span class="title">IDENTITY_VAL_LOCAL</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                DB2_MF    :相当于selectKey的SQL为：SELECT <span class="title">IDENTITY_VAL_LOCAL</span><span class="params">()</span> FROM SYSIBM.SYSDUMMY1  </span></span><br><span class="line"><span class="function">                Derby      :相当于selectKey的SQL为：VALUES <span class="title">IDENTITY_VAL_LOCAL</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                HSQLDB      :相当于selectKey的SQL为：CALL <span class="title">IDENTITY</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                Informix  :相当于selectKey的SQL为：select <span class="title">dbinfo</span><span class="params">(<span class="string">'sqlca.sqlerrd1'</span>)</span> from systables where tabid</span>=<span class="number">1</span>  </span><br><span class="line">                MySql      :相当于selectKey的SQL为：<span class="function">SELECT <span class="title">LAST_INSERT_ID</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                SqlServer :相当于selectKey的SQL为：SELECT <span class="title">SCOPE_IDENTITY</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY  </span></span><br><span class="line"><span class="function">                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys</span>=<span class="string">"true"</span>和keyProperty属性  </span><br><span class="line">        &lt;generatedKey column=<span class="string">""</span> sqlStatement=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;!--   </span><br><span class="line">            该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，  </span><br><span class="line">            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；  </span><br><span class="line">            那么就可以设置searchString为<span class="string">"^CUST_"</span>，并使用空白替换，那么生成的Customer对象中的属性名称就不是  </span><br><span class="line">            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；  </span><br><span class="line">  </span><br><span class="line">            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，  </span><br><span class="line">            如果使用了columnOverride元素，该属性无效；  </span><br><span class="line">  </span><br><span class="line">        &lt;columnRenamingRule searchString=<span class="string">""</span> replaceString=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">         &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；  </span><br><span class="line">             column:要重新设置的列名；  </span><br><span class="line">             注意，一个table元素中可以有多个columnOverride元素哈~  </span><br><span class="line">          --&gt;  </span><br><span class="line"></span><br><span class="line">        &lt;!--生成的实体类字段与表中字段名不同，property属性制定实体类字段名称--&gt;</span><br><span class="line">          &lt;columnOverride column=<span class="string">"para_index"</span> property=<span class="string">"index"</span>&gt;</span><br><span class="line">            &lt;/columnOverride&gt;</span><br><span class="line">            </span><br><span class="line">         &lt;columnOverride column=<span class="string">"username"</span>&gt;  </span><br><span class="line">             &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;  </span><br><span class="line">             &lt;property name=<span class="string">"property"</span> value=<span class="string">"userName"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">             &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名  </span><br><span class="line">             &lt;property name=<span class="string">"javaType"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">              --&gt;  </span><br><span class="line">  </span><br><span class="line">             &lt;!-- jdbcType用于指定该列的JDBC类型   </span><br><span class="line">             &lt;property name=<span class="string">"jdbcType"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">              --&gt;  </span><br><span class="line">  </span><br><span class="line">             &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名  </span><br><span class="line">                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler  </span><br><span class="line">                 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述  </span><br><span class="line">             &lt;property name=<span class="string">"jdbcType"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">             --&gt;  </span><br><span class="line">  </span><br><span class="line">             &lt;!-- 参考table元素的delimitAllColumns配置，默认为<span class="keyword">false</span>  </span><br><span class="line">             &lt;property name=<span class="string">"delimitedColumnName"</span> value=<span class="string">""</span>/&gt;  </span><br><span class="line">              --&gt;  </span><br><span class="line">         &lt;/columnOverride&gt;  </span><br><span class="line">  </span><br><span class="line">         &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现   </span><br><span class="line">             column:指定要忽略的列的名字；  </span><br><span class="line">             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为<span class="keyword">false</span>  </span><br><span class="line">  </span><br><span class="line">             注意，一个table元素中可以有多个ignoreColumn元素  </span><br><span class="line">         &lt;ignoreColumn column=<span class="string">"deptId"</span> delimitedColumnName=<span class="string">""</span>/&gt;  </span><br><span class="line">         --&gt;  </span><br><span class="line">    &lt;/table&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/context&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：【&lt;a href=&quot;http://www.jianshu.com/p/e09d2370b796】&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jianshu.com/p/e09d2370b796】&lt;/a&gt;&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://blog.rickiyang.cn/categories/Mybatis/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件和JMS介绍(一)</title>
    <link href="https://blog.rickiyang.cn/posts/c0d0b105.html"/>
    <id>https://blog.rickiyang.cn/posts/c0d0b105.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.378Z</updated>
    
    <content type="html"><![CDATA[<p>在一个公司创立初期，他可能只有几个应用，系统之间的关联也不是那么大，A系统调用B系统就直接调用B提供的API接口；后来这个公司做大了，他一步步发展有了几十个系统，这时候A系统要调用B系统的接口，但是B系统前几天刚改了一下接口A并不知情。所以A发现调不通于是给B系统管理员打电话，小王啊，改了接口咋不告诉我呢。我还以为我们系统出错了呢。弄得小王一顿尴尬，我这自己改个东西还的通知这个通知那个的。</p><p>####<strong> 1  中间件介绍</strong><br>我们看到上面的故事中的小王他真的是很累啊。自己修改一个接口还的给所有调用接口的系统管理员打电话告知API发生变化。说到这个问题啊，还是的说我们系统之间的耦合。对于一个小公司来说是无所谓，但是对于一个大公司这种情况简直是致命的。于是最近几年这些越来越大的互联网公司在这种挑战下提出了中间件这个概念：中间件在操作系统软件，网络和数据库之上，应用软件之下，总的作用是为处于自己上层的软件提供灵活的开发环境。因而中间件是指一类软件，是基于分布式处理的软件，最突出的特点是其网络通信功能。也可认为中间件是位于平台和应用之间的通用服务，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，可以有符合接口和协议的多种实现。</p><p><img src="http://i.imgur.com/Y6vUXNA.png" alt=""></p><p>#####<strong> 1.1 中间件分类</strong><br>中间件可以分为六类：</p><p>1) 终端仿真/屏幕转换</p><p>2) 数据访问中间件（UDA）</p><p>3) 远程过程调用中间件（RPC）</p><p>4) 消息中间件（MOM）</p><p>5) 交易中间件（TPM）</p><p>6) 对象中间件</p><p>然而在实际应用中，一般将中间件分为两大类：</p><p>一类是底层中间件，用于支撑单个应用系统或解决一类问题，包括交易中间件、应用服务器、消息中间件、数据访问中间件等；</p><p>另一类是高层中间件，更多的用于系统整合，包括企业应用集成中间件、工作流中间件、门户中间件等，他们通常会与多个应用系统打交道，在系统中层次较高，并大多基于前一类的底层中间件运行。</p><p><strong>终端仿真/屏幕转换</strong></p><p>此类中间件用于实现客户机图形用户接口与已有的字符接口方式的服务器应用程序之间的互操作，应用与早期的大型机系统，现在已很少使用。</p><p><strong>数据访问中间件</strong></p><p>此类中间件是为了建立数据应用资源互操作的模式，对异构环境下的数据库或文件系统实现联接。</p><p><strong>远程过程调用中间件</strong></p><p>此类中间件可以使开发人员在需要时调用位于远端服务器上的过程，屏蔽了在调用过程中的通信细节。一个应用程序使用RPC来远程执行一个位于不同地址空间里的过程，在效果上看和执行本地调用相同。</p><p><strong>交易中间件</strong></p><p>此类中间件是专门针对联机交易系统而设计的。联机交易系统需要处理大量并发进程，处理并发涉及到操作系统，文件系统，编程语言，数据通信，数据库系统，系统管理，应用软件等。而交易中间件根据分布式交易处理的标准及参考模型，对资源管理，交易管理和应用进行了实现，从而使得基于交易中间件开发应用程序更为简单。交易中间件基本上只适用于联机交易系统，是一种较为专用的中间件。</p><p><strong>消息中间件</strong></p><p>此类中间件是指利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p><p>消息中间件可以即支持同步方式，又支持异步方式。异步中间件比同步中间件具有更强的容错性，在系统故障时可以保证消息的正常传输。异步中间件技术又分为两类：广播方式和发布/订阅方式。由于发布/订阅方式可以指定哪种类型的用户可以接受哪种类型的消息，更加有针对性，事实上已成为异步中间件的非正式标准。目前主流的消息中间件产品有IBM的MQSeries，BEA的MessageQ和Sun的JMS等[1]。</p><p><strong>对象中间件</strong></p><p>传统的对象技术通过封装、继承及多态提供了良好的代码重用功能。但这些对象只存在与一个程序中，外界并不知道它们的存在，也无法访问它们。对象中间件提供了一个标准的构建框架，能使不同厂家的软件通过不同的地址空间，网络和操作系统实现交互访问。对象中间件的目标是为软件用户及开发者提供一种应用级的即插即用的互操作性。目前主流的对象中间件有OMG的CORBA，Microsoft 的COM以及IBM的SOM，Sun的RMI等。</p><p><strong>中间件的特点</strong></p><p>一般来讲，中间件具有以下一些特点：满足大量应用的需求，运行于多种硬件和操作系统平台，支持分布式计算，支持标准接口和协议。开发人员通过调用中间件提供的大量API，实现异构环境的通信，从而屏蔽异构系统中复杂的操作系统和网络协议。</p><p>由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。分布式应用软件借助中间件可以在不同的技术之间共享资源。</p><p>总的来说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少了程序设计的复杂性，将注意力集中与自己的业务上，不必再为程序在不同软件系统上的移植而重复工作，从而大大减少了技术上的负担。</p><h4 id="2-消息中间件"><a href="#2-消息中间件" class="headerlink" title=" 2  消息中间件"></a><strong> 2  消息中间件</strong></h4><p>面向消息的中间件（MOM），提供了以松散耦合的灵活方式集成应用程序的一种机制。它们提供了基于存储和转发的应用程序之间的异步数据发送，即应用程序彼此不直接通信，而是与作为中介的MOM通信。MOM提供了有保证的消息发送（至少是在尽可能地做到这一点），应用程序开发人员无需了解远程过程调用（RPC）和网络/通信协议的细节。</p><p>消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被用程序读走。通过消息队列，应用程序可独立地执行–它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。设计分布式应用的方法主要有：远程过程调用(RPC)–分布式计算环境(DCE)的基础标准成分之一；对象事务监控(OTM)–基于CORBA的面向对象工业标准与事务处理(TP)监控技术的组合；消息队列(MessageQueue)–构造分布式应用的松耦合方法。</p><p>MOM将消息路由给应用程B，这样消息就可以存在于完全不同的计算机上，MOM负责处理网络通信。如果网络连接不可用，MOM会存储消息，直到连接变得可用时，再将消息转发给应用程序B。</p><p>灵活性的另一方面体现在，当应用程序A发送其消息时，应用程序B甚至可以不处于执行状态。MOM将保留这个消息，直到应用程序B开始执行并试着检索消息为止。这还防止了应用程序A因为等待应用程序B检索消息而出现阻塞。这种异步通信要求应用程序的设计与现在大多数应用程序不同，不过，对于时间无关或并行处理，它可能是一个极其有用的方法。</p><h5 id="2-1-消息中间件的传递模式"><a href="#2-1-消息中间件的传递模式" class="headerlink" title=" 2.1 消息中间件的传递模式"></a><strong> 2.1 消息中间件的传递模式</strong></h5><p>消息中间件一般有两种传递模式：点对点模式(P2P)和发布-订阅模式(Pub/Sub)。</p><p><strong>点对点模式</strong></p><p>Point-to-Point(P2P)我们很容易理解，即生产者和消费者之间的消息往来。<br><img src="http://i.imgur.com/rVHHyTG.jpg" alt=""></p><p>每个消息都被发送到特定的消息队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p><p>P2P的特点：</p><ol><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)；</li><li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列；</li><li>接收者在成功接收消息之后需向队列应答成功。</li></ol><p><strong>发布-订阅模式(Pub/Sub)</strong></p><p>我们可以联想到卖报纸的过程：印刷厂把当天的报纸印好然后送到邮递员手里，邮递员风雨兼程的把报纸送到每一位订阅者手里。由此我们可以看到发布-订阅模式的一些特点：</p><ol><li>每个消息可以有多个消费者；</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态；</li></ol><p><img src="http://i.imgur.com/RBm4pWV.jpg" alt=""></p><p>由上介绍我们可以看出这两种模式各有千秋，如果你需要点对点的发送消息那么使用P2P更专注，如果你是群发消息，显然pub/sub模式更适合。</p><h4 id="3-基于多种协议的消息传递机制"><a href="#3-基于多种协议的消息传递机制" class="headerlink" title=" 3 基于多种协议的消息传递机制"></a><strong> 3 基于多种协议的消息传递机制</strong></h4><p>目前市场上对于网络消息传递的协议版本很多，不同的协议有不同的规范，我们在使用时要比对实现不同协议的产品。下面我们看一下目前主流的消息传递协议：</p><h5 id="3-1-AMQP协议"><a href="#3-1-AMQP协议" class="headerlink" title=" 3.1 AMQP协议"></a><strong> 3.1 AMQP协议</strong></h5><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP协议是一种二进制协议，提供客户端应用与消息中间件之间异步、安全、高效地交互。</p><p>AMQP是一个应用层的异步消息传递协议，为面向消息的中间件而设计。其目的是通过协议使应用模块之间或应用程序与中间件等进行充分解耦。而在设计初期，AMQP的原始用途只是为金融界提供一个可以彼此协作的消息协议。现在已经有相当一部分遵循AMQP的服务器和客户端供使用。其中RabbitMQ是AMQP的一款开源标准实现。</p><p>支持所有消息中间件的功能：消息交换、文件传输、流传输、远程进程调用等。</p><p>AMQP的服务器(Broker)主要由交换器、消息、队列组成。Broker的主要功能是消息的路由和缓存。对于需要保障可靠性的消息，RabbitMQ可以将消息、队列和交换器的数据写入本地硬盘。而对于响应时间敏感的消息，RabbitMQ可以不配置持久化机制。</p><p>解决的问题：</p><p>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何防止丢失？</p><p> 2）如何降低发送者和接收者的耦合度？</p><p> 3）如何让Priority高的接收者先接到数据？</p><p> 4）如何做到load balance？有效均衡接收者的负载？</p><p> 5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。</p><p> 6）如何做到可扩展，甚至将这个通信模块发到cluster上？</p><p> 7）如何保证接收者接收到了完整，正确的数据？</p><p> AMQP协议解决了以上的问题，而RabbitMQ实现了AMQP。</p><h5 id="3-2-STOMP协议"><a href="#3-2-STOMP协议" class="headerlink" title=" 3.2 STOMP协议"></a><strong> 3.2 STOMP协议</strong></h5><p>STOMP即Simple (or Streaming) Text Orientated Messaging Protocol，简单(流)文本定向消息协议。</p><p>它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。</p><p>STOMP协议的前身是TTMP协议（一个简单的基于文本的协议），专为消息中间件设计。</p><p>STOMP是一个非常简单和容易实现的协议，其设计灵感源自于HTTP的简单性。尽管STOMP协议在服务器端的实现可能有一定的难度，但客户端的实现却很容易。例如，可以使用Telnet登录到任何的STOMP代理，并与STOMP代理进行交互。</p><p>STOMP是除AMQP开放消息协议之外地另外一个选择, 实现了被用在JMS brokers中特定的有线协议，比如OpenWire。它仅仅是实现通用消息操作中的一部分，并非想要覆盖全面的消息API。</p><p>STOMP server就好像是一系列的目的地, 消息会被发送到这里。STOMP协议把目的地当作不透明的字符串，其语法是服务端具体的实现。 此外STOMP没有定义目的地的交付语义是什么，语义的目的地可以从服务器到服务器，甚至从目的地到目的地。这使得服务器有可创造性的语义，去支持STOMP。</p><p>STOMP client的用户代理可以充当两个角色(可能同时)： </p><ol><li>作为生产者，通过SENDframe发送消息到server</li><li>作为消费者，发送SUBSCRIBEframe到目的地并且通过MESSAGEframe从server获取消息。</li></ol><p>STOMP协议工作于TCP协议之上，使用了下列命令：</p><ul><li><p>SEND 发送</p></li><li><p>SUBSCRIBE 订阅</p></li><li><p>UNSUBSCRIBE 退订</p></li><li><p>BEGIN 开始</p></li><li><p>COMMIT 提交</p></li><li><p>ABORT 取消</p></li><li><p>ACK 确认</p></li><li><p>DISCONNECT 断开</p></li></ul><p>目前最流行的STOMP消息代理是Apache ActiveMQ。</p><h5 id="3-3-JMS协议"><a href="#3-3-JMS协议" class="headerlink" title=" 3.3 JMS协议"></a><strong> 3.3 JMS协议</strong></h5><p>JMS是Java Message Service的缩写，即Java消息服务。</p><p>在大型互联网中，我们采用消息中间件可以进行应用之间的解耦以及操作的异步，这是消息中间件两个最基础的特点，也正是我们所需要的。在此基础上，我们着重思考的是消息的顺序保证、扩展性、可靠性、业务操作与消息发送一致性，以及多集群订阅者等方面的问题。当然，这些我们要思考的东西，JMS都已经想到了，先看下JMS能帮开发者做什么：</p><p><strong>1、定义一组消息公用概念和实用工具</strong></p><p>所有Java应用程序都可以使用JMS中定义的API去完成消息的创建、接收与发送，任何实现了JMS标准的MOM都可以作为消息的中介，完成消息的存储转发</p><p><strong>2、最大化消息应用程序的可移植性</strong></p><p>MOM提供了有保证的消息发送，应用程序开发人员无需了解远程过程调用（RPC）和网络/通信协议的细节，提供了程序的可移植性</p><p><strong>3、最大化降低应用程序与应用程序之间的耦合度</strong></p><p>由于MOM的存在，各个应用程序只关心和MOM之间如何进行消息的接收与发送，而无须关注MOM的另一边，其他程序是如何接收和发送的</p><p>JMS定义了一套通用的接口和相关语义，提供了诸如持久、验证和事务的消息服务，它最主要的目的是允许Java应用程序访问现有的消息中间件。JMS规范没有指定在消息节点间所使用的通讯底层协议，来保证应用开发人员不用与其细节打交道，一个特定的JMS实现可能提供基于TCP/IP、HTTP、UDP或者其它的协议。</p><p>由于没有统一的规范和标准，基于消息中间件的应用不可移植，不同的消息中间件也不能互操作，这大大阻碍了消息中间件的发展。 Java Message Service(JMS, Java消息服务)是SUN及其伙伴公司提出的旨在统一各种消息中间件系统接口的规范。</p><p>目前许多厂商采用并实现了JMS API，现在，JMS产品能够为企业提供一套完整的消息传递功能，目前我们看到的比较流行的JMS商业软件和开源产品：WebLogic、SonicMQ、ActiveMQ、OpenJMS都是基于JMS规范的实现。</p><h4 id="4-JMS介绍"><a href="#4-JMS介绍" class="headerlink" title=" 4 JMS介绍"></a><strong> 4 JMS介绍</strong></h4><p>在 JMS 之前，每一家 MOM 厂商都用专有 API 为应用程序提供对其产品的访问，通常可用于许多种语言，其中包括 Java 语言。JMS 通过 MOM 产品为 Java 程序提供了一个发送和接收消息的标准的、便利的方法。用 JMS 编写的程序可以在任何实现 JMS 标准的 MOM 上运行。</p><p>JMS 可移植性的关键在于：JMS API 是由 Sun 作为一组接口而提供的。提供了 JMS 功能的产品是通过提供一个实现这些接口的提供者来做到这一点的。开发人员可以通过定义一组消息和一组交换这些消息的客户机应用程序建立 JMS 应用程序。</p><p>JMS 支持两种消息类型P2P 和Pub/Sub，在JMS消息模型中，根据点对点模式和发布/订阅模式，这些要素由扩展出了各自的内容：</p><table><br>        <tr><br>            <th>JMS标准</th><br>            <th>点对点模式</th><br> <th>发布/订阅模式</th><br>        </tr><br>        <tr><br>            <th>ConnectionFactory</th><br>            <th>QueueConnectionFactory</th><br> <th>TopicConnectionFactory</th><br>        </tr><br>       <tr><br>            <th>Connection</th><br>            <th>QueueConnection</th><br> <th>TopicConnection</th><br>        </tr><br><tr><br>            <th>Destination</th><br>            <th>Queue</th><br> <th>Topic</th><br>        </tr><br><tr><br>            <th>Session</th><br>            <th>QueueSession</th><br> <th>TopicSession</th><br>        </tr><br><tr><br>            <th>MessageProducer</th><br>            <th>QueueSender</th><br> <th>TopicPublisher</th><br>        </tr><br><tr><br>            <th>MessageConsumer</th><br>            <th>QueueReceiver</th><br> <th>TopicSubscriber</th><br>        </tr><br>    </table><p>JMS为发开者提供了很多的要素，看一下比较重要的几个：</p><table><br>        <tr><br>            <th>要    素</th><br>            <th>作    用</th><br>        </tr><br>        <tr><br>            <th>Destination</th><br>            <th>表示消息所走通道的目标定义，用来定义消息从发送端发出后要走的通道，而不是接收方。Destination属于管理类对象</th><br>        </tr><br>        <tr><br>            <th>ConnectionFactory</th><br>            <th>顾名思义，用于创建连接对象，ConnectionFactory属于管理类的对象</th><br>        </tr><br>        <tr><br>            <th>Connection</th><br>            <th>连接接口，所负责的重要工作时创建Session</th><br>        </tr><br>         <tr><br>            <th>Session</th><br>            <th>会话接口，这是一个非常重要的对象，消息发送者、消息接收者以及消息对象本身，都是通过这个会话对象创建的</th><br>        </tr><br> <tr><br>            <th>MessageConsumer</th><br>            <th>消息的消费者，也就是订阅消息并处理消息的对象</th><br>        </tr><br> <tr><br>            <th>MessageProducer</th><br>            <th>消息的生产者，也就是用来发送消息的对象</th><br>        </tr><br><tr><br>            <th>XXXMessage</th><br>            <th>指各种类型的消息对象，包括ByteMesage、ObjectMessage、StreamMessage和TextMessage这5种</th><br>        </tr><br>    </table><p><strong>JMS消息模型</strong></p><p>JMS 消息由以下几部分组成：消息头，属性，消息体。</p><ol><li>消息头（header）：JMS消息头包含了许多字段，它们是消息发送后由JMS提供者或消息发送者产生，用来表示消息、设置优先权和失效时间等等，并且为消息确定路由。</li><li>属性（property）：由消息发送者产生，用来添加删除消息头以外的附加信息。</li><li>消息体（body）：由消息发送者产生，JMS中定义了5种消息体：ByteMessage、MapMessage、ObjectMessage、StreamMessage和TextMessage。</li></ol><p><strong>JMS编程模型</strong></p><p>一般来说我们在开发基于JMS协议的客户端由一下几部构成：</p><p>1) 用JNDI 得到ConnectionFactory对象；</p><p>2) 用JNDI 得到目标队列或主题对象，即Destination对象；</p><p>3) 用ConnectionFactory创建Connection 对象；</p><p>4) 用Connection对象创建一个或多个JMS Session；</p><p>5) 用Session 和Destination 创建MessageProducer和MessageConsumer；</p><p>6) 通知Connection 开始传递消息。</p><p>因为jms需要使用到J2EE服务器，我们平常用的tomcat属于J2SE类型的服务器，常见的J2EE服务器包括：Geronimo,JBoss 4, GlassFish,WebLogic 。我们在这里使用glassfish 容器。安装和使用有很多教程，在此就不贴了。首先我们进去glassfish的控制台，设置一下我们的发送者和接受者对象：</p><p><img src="http://i.imgur.com/JolUiw6.jpg" alt=""></p><p><img src="http://i.imgur.com/uSYlT5P.jpg" alt=""></p><p>下面我们用oracle提供的jms接口来写一个服务端，我们先来写一个P2P模式的例子：</p><p>MySender.java</p><pre><code>import java.io.BufferedReader;import java.io.InputStreamReader;import javax.naming.*;import javax.jms.*;public class MySender {    public static void main(String[] args) {        try        {   //1)创建一个connection            InitialContext ctx=new InitialContext();            QueueConnectionFactory f=(QueueConnectionFactory)ctx.lookup(&quot;myQueueConnectionFactory&quot;);            QueueConnection con=f.createQueueConnection();            con.start();            //2) 创建一个会话接口            QueueSession ses=con.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);            //3) 获取会话接口对象            Queue t=(Queue)ctx.lookup(&quot;myQueue&quot;);            //4)创建一个发送者对象            QueueSender sender=ses.createSender(t);            //5) 创建一个消息对象            TextMessage msg=ses.createTextMessage();            //6) 把我们的消息写入msg对象中            BufferedReader b=new BufferedReader(new InputStreamReader(System.in));            while(true)            {                System.out.println(&quot;Enter Msg, end to terminate:&quot;);                String s=b.readLine();                if (s.equals(&quot;end&quot;))                    break;                msg.setText(s);                //7) 发送消息                sender.send(msg);                System.out.println(&quot;Message successfully sent.&quot;);            }            //8) 关闭连接            con.close();        }catch(Exception e){System.out.println(e);}    }}</code></pre><p>MyReceiver.java</p><pre><code>import javax.jms.*;import javax.naming.InitialContext;public class MyReceiver {    public static void main(String[] args) {        try{            //1) 创建一个connection            InitialContext ctx=new InitialContext();            QueueConnectionFactory f=(QueueConnectionFactory)ctx.lookup(&quot;myQueueConnectionFactory&quot;);            QueueConnection con=f.createQueueConnection();            con.start();            //2) 创建一个会话接口            QueueSession ses=con.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);            //3) 获取会话接口对象            Queue t=(Queue)ctx.lookup(&quot;myQueue&quot;);            //4)创建一个发送者对象            QueueReceiver receiver=ses.createReceiver(t);            //5) 创建一个消监听对象            MyListener listener=new MyListener();            //6) 将监听器注册到receiver，用来监听receiver            receiver.setMessageListener(listener);            System.out.println(&quot;Receiver1 is ready, waiting for messages...&quot;);            System.out.println(&quot;press Ctrl+c to shutdown...&quot;);            while(true){                Thread.sleep(1000);            }        }catch(Exception e){System.out.println(e);}    }}</code></pre><p>MyListener.java</p><pre><code>import javax.jms.*;public class MyListener implements MessageListener {    public void onMessage(Message m) {        try{            TextMessage msg=(TextMessage)m;            System.out.println(&quot;following message is received:&quot;+msg.getText());        }catch(JMSException e){System.out.println(e);}    }}</code></pre><p>Pub/Sub模式：</p><p>MySender.java</p><pre><code>import javax.jms.*;import javax.naming.InitialContext;import java.io.BufferedReader;import java.io.InputStreamReader;public class MySender {    public static void main(String[] args) {        try        {   //1)创建一个connection            InitialContext ctx=new InitialContext();            TopicConnectionFactory f=(TopicConnectionFactory)ctx.lookup(&quot;myTopicConnectionFactory&quot;);            TopicConnection con=f.createTopicConnection();            con.start();            //2) 创建一个会话接口            TopicSession ses=con.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);            //3) 获取会话接口对象            Topic t=(Topic)ctx.lookup(&quot;myTopic&quot;);            //4)创建一个发送者对象            TopicPublisher publisher=ses.createPublisher(t);            //5) 创建一个消息对象            TextMessage msg=ses.createTextMessage();            //6) 把我们的消息写入msg对象中            BufferedReader b=new BufferedReader(new InputStreamReader(System.in));            while(true)            {                System.out.println(&quot;Enter Msg, end to terminate:&quot;);                String s=b.readLine();                if (s.equals(&quot;end&quot;))                    break;                msg.setText(s);                //7) 发送消息                publisher.publish(msg);                System.out.println(&quot;Message successfully sent.&quot;);            }            //8) 关闭连接            con.close();        }catch(Exception e){System.out.println(e);}    }}</code></pre><p>MyReceiver.java</p><pre><code>import javax.jms.*;import javax.naming.InitialContext;public class MyReceiver {    public static void main(String[] args) {        try{            //1) 创建一个connection            InitialContext ctx=new InitialContext();            TopicConnectionFactory f=(TopicConnectionFactory)ctx.lookup(&quot;myTopicConnectionFactory&quot;);            TopicConnection con=f.createTopicConnection();            //2) 创建一个会话接口            TopicSession ses=con.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);            //3) 获取会话接口对象            Topic t=(Topic)ctx.lookup(&quot;myTopic&quot;);            //4)创建一个发送者对象            TopicSubscriber receiver=ses.createSubscriber(t);            //5) 创建一个消监听对象            MyListener listener=new MyListener();            //6) 将监听器注册到receiver，用来监听receiver            receiver.setMessageListener(listener);            System.out.println(&quot;Receiver1 is ready, waiting for messages...&quot;);            System.out.println(&quot;press Ctrl+c to shutdown...&quot;);            while(true){                Thread.sleep(1000);            }        }catch(Exception e){System.out.println(e);}    }}</code></pre><p>MyListener.java</p><pre><code>import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;public class MyListener implements MessageListener {    public void onMessage(Message m) {        try{            TextMessage msg=(TextMessage)m;            System.out.println(&quot;following message is received:&quot;+msg.getText());        }catch(JMSException e){System.out.println(e);}    }}</code></pre><p>上面两个案例我们运行可以看到消息成功的发送出去了。熟悉了JMS的语法，使用起来还是很简单。</p><p>上面我们介绍到了JMS，JMS是一个用于提供消息服务的技术规范，它制定了在整个消息服务提供过程中的所有数据结构和交互流程。JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API。　Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p><p>下面我们引入另一个概念：MQ（Message Queue）。</p><p>应用程序通过写和检索出入列队的针对应用程序的数据（消息）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。</p><p>MQ和JMS类似，但不同的是JMS是SUN Java消息中间件服务的一个标准和API定义，而MQ则是遵循了AMQP协议的具体实现和产品。JMS是一个用于提供消息服务的技术规范，它制定了在整个消息服务提供过程中的所有数据结构和交互流程。而MQ则是消息队列服务，是面向消息中间件（MOM）的最终实现，是真正的服务提供者；MQ的实现可以基于JMS，也可以基于其他规范或标准。MQ 有很多产品：IBM的，rabbitmq, activemq 等，rabbitmq 只支持点对点的方式。所以没有完全实现JMS的标准，所以说它不是一个JMS产品，而rabitmq 和Jobss JMS 它们实现了JMS的各项标准，是开源的JMS产品。目前完全实现JMS协议的mq是activemq，所以接下来我们先重点看一下activemq。从activemq入手去探索javaEE的世界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个公司创立初期，他可能只有几个应用，系统之间的关联也不是那么大，A系统调用B系统就直接调用B提供的API接口；后来这个公司做大了，他一步步发展有了几十个系统，这时候A系统要调用B系统的接口，但是B系统前几天刚改了一下接口A并不知情。所以A发现调不通于是给B系统管理员打电
      
    
    </summary>
    
      <category term="activeMQ" scheme="https://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq安全机制</title>
    <link href="https://blog.rickiyang.cn/posts/413284da.html"/>
    <id>https://blog.rickiyang.cn/posts/413284da.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.135Z</updated>
    
    <content type="html"><![CDATA[<p>activemq作为消息中间件这样一个独立的个体存在，连通用户和服务器。如果没有一套完备的安全机制去设置用户权限设置消息分发机制可想后果是非常严重。ActiveMQ如果不加入安全机制的话，任何人只要知道消息服务的具体地址(包括ip，端口，消息地址[队列或者主题地址，)，都可以肆无忌惮的发送、接收消息。今天我们就探讨一下他的安全机制。</p><h4 id="1-安全机制介绍"><a href="#1-安全机制介绍" class="headerlink" title="1.安全机制介绍"></a><strong>1.安全机制介绍</strong></h4><p>我们讨论安全机制一般包括两个部分：</p><ol><li>验证(Authentication)：就是要验证一个用户的有效性，即用户名、密码是否正确;</li><li>授权(Authorization)：就是授予用户某种角色，以使用户只能访问具有相应角色的资源。</li></ol><p>activemq考虑到安全方案效率问题，他提供了可插拔的安全机制，你可以使用不同的安全插件灵活为你的系统配置安全访问方式。目前activemq提供两种安全控制插件：</p><ol><li>简单认证插件(Simple authentication plugin-in)</li><li>JAAS认证插件(Java Authentication and Authorization Service)</li></ol><p>下面我们分别就这两种插件的使用做一个说明。</p><h4 id="2-简单认证插件"><a href="#2-简单认证插件" class="headerlink" title="2.简单认证插件"></a><strong>2.简单认证插件</strong></h4><p>简单认证插件的目的就是让用户简单配置。我们打开activemq服务的目录apache-activemq，在 conf目录下找到activemq.xml。进去找到：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shutdownHooks&gt;</span><br><span class="line">    &lt;bean xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.hooks.SpringContextHook"</span> /&gt;</span><br><span class="line">&lt;/shutdownHooks&gt;</span><br></pre></td></tr></table></figure><p>在他下面添加如下即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;simpleAuthenticationPlugin&gt;</span><br><span class="line">        &lt;users&gt;</span><br><span class="line">            &lt;authenticationUser username=<span class="string">"admin"</span> password=<span class="string">"admin"</span> groups=<span class="string">"users,admins"</span>/&gt;</span><br><span class="line">           &lt;authenticationUser username=<span class="string">"user"</span> password=<span class="string">"password"</span> groups=<span class="string">"users"</span>/&gt;     </span><br><span class="line">        &lt;/users&gt;</span><br><span class="line">    &lt;/simpleAuthenticationPlugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>☆注意：<strong>此处添加的用户名和密码要和你在项目中配置的activemq用户名密码是一致的，如果在项目中不是此处已经配置过的用户发送消息的话，activemq客户端不会受理该消息。这样就达到了对非命中用户拦截的目的。</strong></p><p>比如说你有客户端使用的用户是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                           brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                           userName=<span class="string">"admin"</span></span><br><span class="line">                           password=<span class="string">"admin"</span> /&gt;</span><br></pre></td></tr></table></figure><p>那你就把该用户配置到activemq的配置文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;authenticationUser username=<span class="string">"admin"</span> password=<span class="string">"admin"</span> groups=<span class="string">"users,admins"</span>/&gt;</span><br></pre></td></tr></table></figure><p>上面是对用户进行限制，我们也可以对ip进行限制，还是在刚才的配置里面加上下面这一句：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">     &lt;simpleAuthenticationPlugin&gt;</span><br><span class="line">            &lt;users&gt;</span><br><span class="line">                &lt;authenticationUser username=<span class="string">"admin"</span> password=<span class="string">"admin"</span> groups=<span class="string">"users,admins"</span>/&gt;</span><br><span class="line">               &lt;!-- &lt;authenticationUser username=<span class="string">"user"</span> password=<span class="string">"password"</span> groups=<span class="string">"users"</span>/&gt;</span><br><span class="line">                &lt;authenticationUser username=<span class="string">"guest"</span> password=<span class="string">"password"</span> groups=<span class="string">"guests"</span>/&gt;--&gt;</span><br><span class="line">            &lt;/users&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;transportConnectors&gt;</span><br><span class="line">         &lt;transportConnector name=<span class="string">"connection1"</span> uri=<span class="string">"tcp://0.0.0.0:61616"</span> /&gt;</span><br><span class="line">        &lt;/transportConnectors&gt;</span><br><span class="line">    &lt;/simpleAuthenticationPlugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>0.0.0.0代表本网络中的所有主机，意味着该网段的所有主机都是可以通讯的。如果改成localhost或者127.0.0.1这种的那就只有本机了。这样我们就达到了通过IP限制的目的。</p><h4 id="3-JAAS认证插件"><a href="#3-JAAS认证插件" class="headerlink" title="3.JAAS认证插件"></a><strong>3.JAAS认证插件</strong></h4><p>JAAS(Java Authentication and Authorization Service)也就是java的验证Authentication)、授权(Authorization)服务。简单来说，验证Authentication就是要验证一个用户的有效性，即用户名、密码是否正确。授权Authorization就是授予用户某种角色，可以访问哪些资源。JAASAuthentication Plugin依赖标准的JAAS机制来实现认证。通常情况下，你需要通过设置Java.security.auth.login.config系统属性来配置login<br>modules的配置文件。如果没有指定这个系统属性，那么JAAS Authentication Plugin会缺省使用login.config作为文件名。</p><p>首先我们需要编写一个login.config文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">activemq &#123;  </span><br><span class="line">    org.apache.activemq.jaas.PropertiesLoginModule required  </span><br><span class="line">    debug=<span class="keyword">true</span></span><br><span class="line">        org.apache.activemq.jaas.properties.user=<span class="string">"users.properties"</span>  </span><br><span class="line">        org.apache.activemq.jaas.properties.group=<span class="string">"groups.properties"</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>users.properties文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admin=admin  </span><br><span class="line">user=ad1</span><br><span class="line">guest=ad1</span><br></pre></td></tr></table></figure><p>group.properties文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admins=admin  </span><br><span class="line">users=user  </span><br><span class="line">guests=guest</span><br></pre></td></tr></table></figure><p>☆需要注意的是，PropertiesLoginModule使用本地文件的查找方式，而且查找时采用的base directory即login.config文件所在的目录，所以说这三个文件需要在同一个目录里才会找得到。另外，activemq 5.9 默认提供了以上的配置文件，我们来看一下文件目录：</p><p><img src="http://i.imgur.com/AR7vabh.jpg" alt=""></p><p>然后我们还是在activemq.xml配置文件中添加插件。还是上面简单插件添加的位置，添加以下插件即可，只不过你的把之前添加的简单插件注释掉。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;jaasAuthenticationPlugin configuration=<span class="string">"activemq-domain"</span> /&gt;     </span><br><span class="line">    &lt;authorizationPlugin&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;authorizationMap&gt;</span><br><span class="line">                &lt;authorizationEntries&gt;</span><br><span class="line">                 &lt;!-- .表示通配符,例如USERS.&gt;表示以USERS.开头的主题,&gt;表示所有主题,read表示读的权限,write表示写的权限，admin表示角色组--&gt;</span><br><span class="line">                    &lt;authorizationEntry queue=<span class="string">"&gt;"</span> read=<span class="string">"admins,guests"</span> write=<span class="string">"guests"</span> admin=<span class="string">"admins,guests"</span> /&gt;</span><br><span class="line">                    &lt;authorizationEntry queue=<span class="string">"USERS.&gt;"</span> read=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</span><br><span class="line">                    &lt;authorizationEntry queue=<span class="string">"GUEST.&gt;"</span> read=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;authorizationEntry topic=<span class="string">"&gt;"</span> read=<span class="string">"admins"</span> write=<span class="string">"admins"</span> admin=<span class="string">"admins"</span> /&gt;</span><br><span class="line">                    &lt;authorizationEntry topic=<span class="string">"USERS.&gt;"</span> read=<span class="string">"users"</span> write=<span class="string">"users"</span> admin=<span class="string">"users"</span> /&gt;</span><br><span class="line">                    &lt;authorizationEntry topic=<span class="string">"GUEST.&gt;"</span> read=<span class="string">"guests"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span> /&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;authorizationEntry topic=<span class="string">"ActiveMQ.Advisory.&gt;"</span> read=<span class="string">"guests,users"</span> write=<span class="string">"guests,users"</span> admin=<span class="string">"guests,users"</span>/&gt;</span><br><span class="line">                &lt;/authorizationEntries&gt;</span><br><span class="line">            &lt;/authorizationMap&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/authorizationPlugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>添加完以上配置部分，重启avtivemq服务端，就会按照上面配置的用户进行读写的权限配置。</p><p>从上面看JAAS插件的权限分配要比简单插件的权限更加细致，不同的用户可以分别配置读写的权限，admin用户拥有创建topic或是queue的特权等等这样细致的划分，不同的用户各司其职，减少了误操作，或是刻意破换的可能性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;activemq作为消息中间件这样一个独立的个体存在，连通用户和服务器。如果没有一套完备的安全机制去设置用户权限设置消息分发机制可想后果是非常严重。ActiveMQ如果不加入安全机制的话，任何人只要知道消息服务的具体地址(包括ip，端口，消息地址[队列或者主题地址，)，都可
      
    
    </summary>
    
      <category term="activeMQ" scheme="https://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(九)-Netty编解码技术之Marshalling</title>
    <link href="https://blog.rickiyang.cn/posts/ccb5d663.html"/>
    <id>https://blog.rickiyang.cn/posts/ccb5d663.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.166Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们讲过protobuf的使用，主流的编解码框架其实还有很多种：</p><pre><code>①JBoss的Marshalling包②google的Protobuf③基于Protobuf的Kyro④Apache的Thrift</code></pre><p>JBoss Marshalling是一个Java对象的序列化API包，修正了JDK自带的序列化包的很多问题，但又保持跟java.io.Serializable接口的兼容；同时增加了一些可调的参数和附加的特性，并且这些参数和特性可通过工厂类进行配置。</p><p>相比于传统的Java序列化机制，它的优点如下：</p><pre><code>1) 可插拔的类解析器，提供更加便捷的类加载定制策略，通过一个接口即可实现定制；2) 可插拔的对象替换技术，不需要通过继承的方式；3) 可插拔的预定义类缓存表，可以减小序列化的字节数组长度，提升常用类型的对象序列化性能；4) 无须实现java.io.Serializable接口，即可实现Java序列化；5) 通过缓存技术提升对象的序列化性能。</code></pre><p>相比于protobuf和thrift的两种编解码框架，JBoss Marshalling更多是在JBoss内部使用，应用范围有限。</p><p>Protobuf全称Google Protocol Buffers，它由谷歌开源而来，在谷歌内部久经考验。它将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。</p><p>它的特点如下：</p><pre><code>1) 结构化数据存储格式（XML，JSON等）；2) 高效的编解码性能；3) 语言无关、平台无关、扩展性好；4) 官方支持Java、C++和Python三种语言。</code></pre><p>首先我们来看下为什么不使用XML，尽管XML的可读性和可扩展性非常好，也非常适合描述数据结构，但是XML解析的时间开销和XML为了可读性而牺牲的空间开销都非常大，因此不适合做高性能的通信协议。Protobuf使用二进制编码，在空间和性能上具有更大的优势。</p><p>Protobuf另一个比较吸引人的地方就是它的数据描述文件和代码生成机制，利用数据描述文件对数据结构进行说明的优点如下：</p><pre><code>1) 文本化的数据结构描述语言，可以实现语言和平台无关，特别适合异构系统间的集成；2) 通过标识字段的顺序，可以实现协议的前向兼容；3) 自动代码生成，不需要手工编写同样数据结构的C++和Java版本；4) 方便后续的管理和维护。相比于代码，结构化的文档更容易管理和维护。</code></pre><hr><p>Thrift源于Facebook，在2007年Facebook将Thrift作为一个开源项目提交给Apache基金会。对于当时的Facebook来说，创造Thrift是为了解决Facebook各系统间大数据量的传输通信以及系统之间语言环境不同需要跨平台的特性，因此Thrift可以支持多种程序语言，如C++、C#、Cocoa、Erlang、Haskell、Java、Ocami、Perl、PHP、Python、Ruby和Smalltalk。</p><p>在多种不同的语言之间通信，Thrift可以作为高性能的通信中间件使用，它支持数据（对象）序列化和多种类型的RPC服务。Thrift适用于静态的数据交换，需要先确定好它的数据结构，当数据结构发生变化时，必须重新编辑IDL文件，生成代码和编译，这一点跟其他IDL工具相比可以视为是Thrift的弱项。Thrift适用于搭建大型数据交换及存储的通用工具，对于大型系统中的内部数据传输，相对于JSON和XML在性能和传输大小上都有明显的优势。</p><p>Thrift主要由5部分组成：</p><pre><code>1) 语言系统以及IDL编译器：负责由用户给定的IDL文件生成相应语言的接口代码；2) TProtocol：RPC的协议层，可以选择多种不同的对象序列化方式，如JSON和Binary；3) TTransport：RPC的传输层，同样可以选择不同的传输层实现，如socket、NIO、MemoryBuffer等；4) TProcessor：作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口；5) TServer：聚合TProtocol、TTransport和TProcessor等对象。</code></pre><p>我们重点关注的是编解码框架，与之对应的就是TProtocol。由于Thrift的RPC服务调用和编解码框架绑定在一起，所以，通常我们使用Thrift的时候会采取RPC框架的方式。但是，它的TProtocol编解码框架还是可以以类库的方式独立使用的。</p><p>与Protobuf比较类似的是，Thrift通过IDL描述接口和数据结构定义，它支持8种Java基本类型、Map、Set和List，支持可选和必选定义，功能非常强大。因为可以定义数据结构中字段的顺序，所以它也可以支持协议的前向兼容。</p><p>Thrift支持三种比较典型的编解码方式：</p><pre><code>1) 通用的二进制编解码；2) 压缩二进制编解码；3) 优化的可选字段压缩编解码。</code></pre><p>由于支持二进制压缩编解码，Thrift的编解码性能表现也相当优异，远远超过Java序列化和RMI等。</p><p>这一节我们来讲解JBoss的Marshalling的使用。</p><p>和protobuf的使用不同，netty默认支持protobuf，所以为他预设了一个编解码器：ProtobufVarint32LengthFieldPrepender，ProtobufVarint32FrameDecoder。那如果采用jboss-marshalling进行编解码，则没有这么好的运气我们需要自己优先创建一个编解码的工厂类，供信息通讯时候对信息的编解码。</p><p>pom文件如下，需要新增两个jar包：jboss-marshalling，jboss-marshalling-serial。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;cn.edu.hust.netty&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;netty&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;name&gt;netty Maven Webapp&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http:<span class="comment">//maven.apache.org&lt;/url&gt;</span></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.5.Final&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.jboss.marshalling&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jboss-marshalling-river&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.4.10.Final&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.jboss.marshalling&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jboss-marshalling-serial&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.4.11.Final&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;netty&lt;/finalName&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>我们先来写一个工厂类，手动创建编解码器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.handler.codec.marshalling.*;</span><br><span class="line"><span class="keyword">import</span> org.jboss.marshalling.MarshallerFactory;</span><br><span class="line"><span class="keyword">import</span> org.jboss.marshalling.Marshalling;</span><br><span class="line"><span class="keyword">import</span> org.jboss.marshalling.MarshallingConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marshalling工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MarshallingCodeCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Jboss Marshalling解码器MarshallingDecoder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MarshallingDecoder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MarshallingDecoder <span class="title">buildMarshallingDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先通过Marshalling工具类的精通方法获取Marshalling实例对象 参数serial标识创建的是java序列化工厂对象。</span></span><br><span class="line">        <span class="keyword">final</span> MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(<span class="string">"serial"</span>);</span><br><span class="line">        <span class="comment">//创建了MarshallingConfiguration对象，配置了版本号为5 </span></span><br><span class="line">        <span class="keyword">final</span> MarshallingConfiguration configuration = <span class="keyword">new</span> MarshallingConfiguration();</span><br><span class="line">        configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//根据marshallerFactory和configuration创建provider</span></span><br><span class="line">        UnmarshallerProvider provider = <span class="keyword">new</span> DefaultUnmarshallerProvider(marshallerFactory, configuration);</span><br><span class="line">        <span class="comment">//构建Netty的MarshallingDecoder对象，俩个参数分别为provider和单个消息序列化后的最大长度</span></span><br><span class="line">        MarshallingDecoder decoder = <span class="keyword">new</span> MarshallingDecoder(provider, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> decoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Jboss Marshalling编码器MarshallingEncoder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MarshallingEncoder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MarshallingEncoder <span class="title">buildMarshallingEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(<span class="string">"serial"</span>);</span><br><span class="line">        <span class="keyword">final</span> MarshallingConfiguration configuration = <span class="keyword">new</span> MarshallingConfiguration();</span><br><span class="line">        configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">        MarshallerProvider provider = <span class="keyword">new</span> DefaultMarshallerProvider(marshallerFactory, configuration);</span><br><span class="line">        <span class="comment">//构建Netty的MarshallingEncoder对象，MarshallingEncoder用于实现序列化接口的POJO对象序列化为二进制数组</span></span><br><span class="line">        MarshallingEncoder encoder = <span class="keyword">new</span> MarshallingEncoder(provider);</span><br><span class="line">        <span class="keyword">return</span> encoder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWordServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap().group(bossGroup,workGroup)</span><br><span class="line">                                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                                    .childHandler(<span class="keyword">new</span> ServerChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWordServer server = <span class="keyword">new</span> HelloWordServer(<span class="number">7788</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(MarshallingCodeCFactory.buildMarshallingDecoder());</span><br><span class="line">        pipeline.addLast(MarshallingCodeCFactory.buildMarshallingEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的逻辑Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWordServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们在这里加入了刚才我们写的编解码器哈，顺序没有关系。</p><p>服务端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            System.out.println(msg.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="string">"received your msg"</span>);</span><br><span class="line">            Msg m = (Msg)msg;</span><br><span class="line">            System.out.println(<span class="string">"client: "</span>+m.getBody());</span><br><span class="line">            m.setBody(<span class="string">"人生苦短，快用python"</span>);</span><br><span class="line">            ctx.writeAndFlush(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(<span class="keyword">int</span> port,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(address,port).sync();</span><br><span class="line">            future.channel().writeAndFlush(<span class="string">"Hello Netty Server ,I am a common client"</span>);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="number">7788</span>,<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span>  <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pipeline.addLast(MarshallingCodeCFactory.buildMarshallingDecoder());</span><br><span class="line">        pipeline.addLast(MarshallingCodeCFactory.buildMarshallingEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端的逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HelloWorldClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样这里也加入编解码器。</p><p>客户端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Msg m = (Msg)msg;</span><br><span class="line">            System.out.println(<span class="string">"client: "</span>+m.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Msg msg = <span class="keyword">new</span> Msg();</span><br><span class="line">        msg.setHeader((<span class="keyword">byte</span>)<span class="number">0xa</span>);</span><br><span class="line">        msg.setLength(<span class="number">34</span>);</span><br><span class="line">        msg.setBody(<span class="string">"放纵自己，你好兄弟"</span>);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意上面有一个Msg对象，这个就是我们自己定义的一个对象，用于网络传输用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义一个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> header;</span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(<span class="keyword">byte</span> header)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.header = header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBody</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">long</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">byte</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们运行客户端和服务端，可以看到消息已经发出去了：</p><p><img src="http://i.imgur.com/t6Q6bw4.jpg" alt=""></p><p><img src="http://i.imgur.com/QCNI69O.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们讲过protobuf的使用，主流的编解码框架其实还有很多种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;①JBoss的Marshalling包

②google的Protobuf

③基于Protobuf的Kyro

④Apache的Thrift
&lt;/code&gt;&lt;/pre&gt;&lt;p
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(十)-Netty文件上传</title>
    <link href="https://blog.rickiyang.cn/posts/208253d2.html"/>
    <id>https://blog.rickiyang.cn/posts/208253d2.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.379Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来完成一个使用netty进行文件传输的任务。在实际项目中，文件传输通常采用FTP或者HTTP附件的方式。事实上通过TCP Socket+File的方式进行文件传输也有一定的应用场景，尽管不是主流，但是掌握这种文件传输方式还是比较重要的，特别是针对两个跨主机的JVM进程之间进行持久化数据的相互交换。</p><p>而使用netty来进行文件传输也是利用netty天然的优势：零拷贝功能。很多同学都听说过netty的”零拷贝”功能，但是具体体现在哪里又不知道，下面我们就简要介绍下：</p><p>Netty的“零拷贝”主要体现在如下三个方面：</p><p>1) Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p><p>2) Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。</p><p>3) Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</p><p>具体的分析在此就不多做介绍，有兴趣的可以查阅相关文档。我们还是把重点放在文件传输上。Netty作为高性能的服务器端异步IO框架必然也离不开文件读写功能，我们可以使用netty模拟http的形式通过网页上传文件写入服务器，当然要使用http的形式那你也用不着netty！大材小用。netty4中如果想使用http形式上传文件你还得借助第三方jar包：okhttp。使用该jar完成http请求的发送。但是在netty5 中已经为我们写好了，我们可以直接调用netty5的API就可以实现。所以netty4和5的差别还是挺大的，至于使用哪个，那就看你们公司选择哪一个了！本文目前使用netty4来实现文件上传功能。下面我们上代码：</p><p>pom文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.5.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>server端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ClassResolvers;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ObjectDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ObjectEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>).childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.weakCachingConcurrentResolver(<span class="keyword">null</span>))); <span class="comment">// 最大长度</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> FileUploadServerHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                port = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> FileUploadServer().bind(port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> byteRead;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String file_dir = <span class="string">"D:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileUploadFile) &#123;</span><br><span class="line">            FileUploadFile ef = (FileUploadFile) msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = ef.getBytes();</span><br><span class="line">            byteRead = ef.getEndPos();</span><br><span class="line">            String md5 = ef.getFile_md5();<span class="comment">//文件名</span></span><br><span class="line">            String path = file_dir + File.separator + md5;</span><br><span class="line">            File file = <span class="keyword">new</span> File(path);</span><br><span class="line">            RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">            randomAccessFile.seek(start);</span><br><span class="line">            randomAccessFile.write(bytes);</span><br><span class="line">            start = start + byteRead;</span><br><span class="line">            <span class="keyword">if</span> (byteRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ctx.writeAndFlush(start);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                randomAccessFile.close();</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ClassResolvers;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ObjectDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.serialization.ObjectEncoder;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> port, String host, <span class="keyword">final</span> FileUploadFile fileUploadFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(group).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>).handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ObjectDecoder(ClassResolvers.weakCachingConcurrentResolver(<span class="keyword">null</span>)));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> FileUploadClientHandler(fileUploadFile));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                port = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUploadFile uploadFile = <span class="keyword">new</span> FileUploadFile();</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"c:/1.txt"</span>);</span><br><span class="line">            String fileMd5 = file.getName();<span class="comment">// 文件名</span></span><br><span class="line">            uploadFile.setFile(file);</span><br><span class="line">            uploadFile.setFile_md5(fileMd5);</span><br><span class="line">            uploadFile.setStarPos(<span class="number">0</span>);<span class="comment">// 文件开始位置</span></span><br><span class="line">            <span class="keyword">new</span> FileUploadClient().connect(port, <span class="string">"127.0.0.1"</span>, uploadFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> byteRead;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> lastLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> RandomAccessFile randomAccessFile;</span><br><span class="line">    <span class="keyword">private</span> FileUploadFile fileUploadFile;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileUploadClientHandler</span><span class="params">(FileUploadFile ef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ef.getFile().exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ef.getFile().isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Not a file :"</span> + ef.getFile());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.fileUploadFile = ef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            randomAccessFile = <span class="keyword">new</span> RandomAccessFile(fileUploadFile.getFile(), <span class="string">"r"</span>);</span><br><span class="line">            randomAccessFile.seek(fileUploadFile.getStarPos());</span><br><span class="line">            lastLength = (<span class="keyword">int</span>) randomAccessFile.length() / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[lastLength];</span><br><span class="line">            <span class="keyword">if</span> ((byteRead = randomAccessFile.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fileUploadFile.setEndPos(byteRead);</span><br><span class="line">                fileUploadFile.setBytes(bytes);</span><br><span class="line">                ctx.writeAndFlush(fileUploadFile);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件已经读完"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            start = (Integer) msg;</span><br><span class="line">            <span class="keyword">if</span> (start != -<span class="number">1</span>) &#123;</span><br><span class="line">                randomAccessFile = <span class="keyword">new</span> RandomAccessFile(fileUploadFile.getFile(), <span class="string">"r"</span>);</span><br><span class="line">                randomAccessFile.seek(start);</span><br><span class="line">                System.out.println(<span class="string">"块儿长度："</span> + (randomAccessFile.length() / <span class="number">10</span>));</span><br><span class="line">                System.out.println(<span class="string">"长度："</span> + (randomAccessFile.length() - start));</span><br><span class="line">                <span class="keyword">int</span> a = (<span class="keyword">int</span>) (randomAccessFile.length() - start);</span><br><span class="line">                <span class="keyword">int</span> b = (<span class="keyword">int</span>) (randomAccessFile.length() / <span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">                    lastLength = a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[lastLength];</span><br><span class="line">                System.out.println(<span class="string">"-----------------------------"</span> + bytes.length);</span><br><span class="line">                <span class="keyword">if</span> ((byteRead = randomAccessFile.read(bytes)) != -<span class="number">1</span> &amp;&amp; (randomAccessFile.length() - start) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"byte 长度："</span> + bytes.length);</span><br><span class="line">                    fileUploadFile.setEndPos(byteRead);</span><br><span class="line">                    fileUploadFile.setBytes(bytes);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ctx.writeAndFlush(fileUploadFile);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    randomAccessFile.close();</span><br><span class="line">                    ctx.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件已经读完--------"</span> + byteRead);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public void channelRead(ChannelHandlerContext ctx, Object msg) throws</span></span><br><span class="line">    <span class="comment">// Exception &#123;</span></span><br><span class="line">    <span class="comment">// System.out.println("Server is speek ："+msg.toString());</span></span><br><span class="line">    <span class="comment">// FileRegion filer = (FileRegion) msg;</span></span><br><span class="line">    <span class="comment">// String path = "E://Apk//APKMD5.txt";</span></span><br><span class="line">    <span class="comment">// File fl = new File(path);</span></span><br><span class="line">    <span class="comment">// fl.createNewFile();</span></span><br><span class="line">    <span class="comment">// RandomAccessFile rdafile = new RandomAccessFile(path, "rw");</span></span><br><span class="line">    <span class="comment">// FileRegion f = new DefaultFileRegion(rdafile.getChannel(), 0,</span></span><br><span class="line">    <span class="comment">// rdafile.length());</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// System.out.println("This is" + ++counter + "times receive server:["</span></span><br><span class="line">    <span class="comment">// + msg + "]");</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public void channelReadComplete(ChannelHandlerContext ctx) throws</span></span><br><span class="line">    <span class="comment">// Exception &#123;</span></span><br><span class="line">    <span class="comment">// ctx.flush();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// protected void channelRead0(ChannelHandlerContext ctx, String msg)</span></span><br><span class="line">    <span class="comment">// throws Exception &#123;</span></span><br><span class="line">    <span class="comment">// String a = msg;</span></span><br><span class="line">    <span class="comment">// System.out.println("This is"+</span></span><br><span class="line">    <span class="comment">// ++counter+"times receive server:["+msg+"]");</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们还自定义了一个对象，用于统计文件上传进度的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadFile</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> File file;<span class="comment">// 文件</span></span><br><span class="line">    <span class="keyword">private</span> String file_md5;<span class="comment">// 文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> starPos;<span class="comment">// 开始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bytes;<span class="comment">// 文件字节数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> endPos;<span class="comment">// 结尾位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStarPos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> starPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStarPos</span><span class="params">(<span class="keyword">int</span> starPos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.starPos = starPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEndPos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> endPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEndPos</span><span class="params">(<span class="keyword">int</span> endPos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bytes = bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.file = file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFile_md5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_md5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFile_md5</span><span class="params">(String file_md5)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.file_md5 = file_md5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><pre><code>块儿长度：894长度：8052-----------------------------894byte 长度：894块儿长度：894长度：7158-----------------------------894byte 长度：894块儿长度：894长度：6264-----------------------------894byte 长度：894块儿长度：894长度：5370-----------------------------894byte 长度：894块儿长度：894长度：4476-----------------------------894byte 长度：894块儿长度：894长度：3582-----------------------------894byte 长度：894块儿长度：894长度：2688-----------------------------894byte 长度：894块儿长度：894长度：1794-----------------------------894byte 长度：894块儿长度：894长度：900-----------------------------894byte 长度：894块儿长度：894长度：6-----------------------------6byte 长度：6块儿长度：894长度：0-----------------------------0文件已经读完--------0Process finished with exit code 0</code></pre><p>这样就实现了服务器端文件的上传，当然我们也可以使用http的形式。</p><p>server端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpFileServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpFileServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">        serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">        <span class="comment">//serverBootstrap.handler(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">        serverBootstrap.childHandler(<span class="keyword">new</span> HttpChannelInitlalizer());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture f = serverBootstrap.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HttpFileServer b = <span class="keyword">new</span> HttpFileServer(<span class="number">9003</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(b).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server端initializer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpChannelInitlalizer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpChannelHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server端hadler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpHeaders.Names.CONTENT_TYPE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpResponseStatus.FORBIDDEN;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpResponseStatus.NOT_FOUND;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpVersion.HTTP_1_1;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelProgressiveFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelProgressiveFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.DefaultFullHttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.DefaultHttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.FullHttpRequest;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.FullHttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpChunkedInput;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponseStatus;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpVersion;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.LastHttpContent;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedFile;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.SystemPropertyUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.activation.MimetypesFileTypeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpChannelHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">FullHttpRequest</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_DATE_FORMAT = <span class="string">"EEE, dd MMM yyyy HH:mm:ss zzz"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_DATE_GMT_TIMEZONE = <span class="string">"GMT"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_CACHE_SECONDS = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 监测解码情况</span></span><br><span class="line">        <span class="keyword">if</span> (!request.getDecoderResult().isSuccess()) &#123;</span><br><span class="line">            sendError(ctx, BAD_REQUEST);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String uri = request.getUri();</span><br><span class="line">        <span class="keyword">final</span> String path = sanitizeUri(uri);</span><br><span class="line">        System.out.println(<span class="string">"get file："</span>+path);</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sendError(ctx, FORBIDDEN);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取要下载的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (file.isHidden() || !file.exists()) &#123;</span><br><span class="line">            sendError(ctx, NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!file.isFile()) &#123;</span><br><span class="line">            sendError(ctx, FORBIDDEN);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomAccessFile raf;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ignore) &#123;</span><br><span class="line">            sendError(ctx, NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> fileLength = raf.length();</span><br><span class="line">        HttpResponse response = <span class="keyword">new</span> DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);</span><br><span class="line">        HttpHeaders.setContentLength(response, fileLength);</span><br><span class="line">        setContentTypeHeader(response, file);</span><br><span class="line">        <span class="comment">//setDateAndCacheHeaders(response, file);</span></span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.isKeepAlive(request)) &#123;</span><br><span class="line">            response.headers().set(<span class="string">"CONNECTION"</span>, HttpHeaders.Values.KEEP_ALIVE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the initial line and the header.</span></span><br><span class="line">        ctx.write(response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the content.</span></span><br><span class="line">        ChannelFuture sendFileFuture =</span><br><span class="line">        ctx.write(<span class="keyword">new</span> HttpChunkedInput(<span class="keyword">new</span> ChunkedFile(raf, <span class="number">0</span>, fileLength, <span class="number">8192</span>)), ctx.newProgressivePromise());</span><br><span class="line">        <span class="comment">//sendFuture用于监视发送数据的状态</span></span><br><span class="line">        sendFileFuture.addListener(<span class="keyword">new</span> ChannelProgressiveFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationProgressed</span><span class="params">(ChannelProgressiveFuture future, <span class="keyword">long</span> progress, <span class="keyword">long</span> total)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123; <span class="comment">// total unknown</span></span><br><span class="line">                    System.err.println(future.channel() + <span class="string">" Transfer progress: "</span> + progress);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.err.println(future.channel() + <span class="string">" Transfer progress: "</span> + progress + <span class="string">" / "</span> + total);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelProgressiveFuture future)</span> </span>&#123;</span><br><span class="line">                System.err.println(future.channel() + <span class="string">" Transfer complete."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the end marker</span></span><br><span class="line">        ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decide whether to close the connection or not.</span></span><br><span class="line">        <span class="keyword">if</span> (!HttpHeaders.isKeepAlive(request)) &#123;</span><br><span class="line">            <span class="comment">// Close the connection when the whole content is written out.</span></span><br><span class="line">            lastContentFuture.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isActive()) &#123;</span><br><span class="line">            sendError(ctx, INTERNAL_SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern INSECURE_URI = Pattern.compile(<span class="string">".*[&lt;&gt;&amp;\"].*"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">sanitizeUri</span><span class="params">(String uri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decode the path.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            uri = URLDecoder.decode(uri, <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!uri.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert file separators.</span></span><br><span class="line">        uri = uri.replace(<span class="string">'/'</span>, File.separatorChar);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Simplistic dumb security check.</span></span><br><span class="line">        <span class="comment">// You will have to do something serious in the production environment.</span></span><br><span class="line">        <span class="keyword">if</span> (uri.contains(File.separator + <span class="string">'.'</span>) || uri.contains(<span class="string">'.'</span> + File.separator) || uri.startsWith(<span class="string">"."</span>) || uri.endsWith(<span class="string">"."</span>)</span><br><span class="line">                || INSECURE_URI.matcher(uri).matches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert to absolute path.</span></span><br><span class="line">        <span class="keyword">return</span> SystemPropertyUtil.get(<span class="string">"user.dir"</span>) + File.separator + uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(ChannelHandlerContext ctx, HttpResponseStatus status)</span> </span>&#123;</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HTTP_1_1, status, Unpooled.copiedBuffer(<span class="string">"Failure: "</span> + status + <span class="string">"\r\n"</span>, CharsetUtil.UTF_8));</span><br><span class="line">        response.headers().set(CONTENT_TYPE, <span class="string">"text/plain; charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the connection as soon as the error message is sent.</span></span><br><span class="line">        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the content type header for the HTTP Response</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     *            HTTP response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     *            file to extract content type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContentTypeHeader</span><span class="params">(HttpResponse response, File file)</span> </span>&#123;</span><br><span class="line">        MimetypesFileTypeMap m = <span class="keyword">new</span> MimetypesFileTypeMap();</span><br><span class="line">        String contentType = m.getContentType(file.getPath());</span><br><span class="line">        <span class="keyword">if</span> (!contentType.equals(<span class="string">"application/octet-stream"</span>)) &#123;</span><br><span class="line">            contentType += <span class="string">"; charset=utf-8"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.headers().set(CONTENT_TYPE, contentType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.DefaultFullHttpRequest;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpMethod;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpRequestEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponseDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpVersion;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDownloadClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载http资源 向服务器下载直接填写要下载的文件的相对路径</span></span><br><span class="line"><span class="comment">     *        （↑↑↑建议只使用字母和数字对特殊字符对字符进行部分过滤可能导致异常↑↑↑）</span></span><br><span class="line"><span class="comment">     *        向互联网下载输入完整路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host 目的主机ip或域名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port 目标主机端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> local 本地存储路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String host, <span class="keyword">int</span> port, String url, <span class="keyword">final</span> String local)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(workerGroup);</span><br><span class="line">            b.channel(NioSocketChannel.class);</span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            b.handler(<span class="keyword">new</span> ChildChannelHandler(local));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(url);</span><br><span class="line">            DefaultFullHttpRequest request = <span class="keyword">new</span> DefaultFullHttpRequest(</span><br><span class="line">                    HttpVersion.HTTP_1_1, HttpMethod.GET, uri.toASCIIString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建http请求</span></span><br><span class="line">            request.headers().set(HttpHeaders.Names.HOST, host);</span><br><span class="line">            request.headers().set(HttpHeaders.Names.CONNECTION,</span><br><span class="line">                    HttpHeaders.Values.KEEP_ALIVE);</span><br><span class="line">            request.headers().set(HttpHeaders.Names.CONTENT_LENGTH,</span><br><span class="line">                    request.content().readableBytes());</span><br><span class="line">            <span class="comment">// 发送http请求</span></span><br><span class="line">            f.channel().write(request);</span><br><span class="line">            f.channel().flush();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildChannelHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">        String local;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChildChannelHandler</span><span class="params">(String local)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.local = local;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 客户端接收到的是httpResponse响应，所以要使用HttpResponseDecoder进行解码</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> HttpResponseDecoder());</span><br><span class="line">            <span class="comment">// 客户端发送的是httprequest，所以要使用HttpRequestEncoder进行编码</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> HttpRequestEncoder());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> HttpDownloadHandler(local));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpDownloadClient client = <span class="keyword">new</span> HttpDownloadClient();</span><br><span class="line">        <span class="comment">//client.connect("127.0.0.1", 9003,"/file/pppp/1.doc","1.doc");</span></span><br><span class="line"><span class="comment">//        client.connect("zlysix.gree.com", 80, "http://zlysix.gree.com/HelloWeb/download/20m.apk", "20m.apk");</span></span><br><span class="line">        client.connect(<span class="string">"www.ghost64.com"</span>, <span class="number">80</span>, <span class="string">"http://www.ghost64.com/qqtupian/zixunImg/local/2017/05/27/1495855297602.jpg"</span>, <span class="string">"1495855297602.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpContent;</span><br><span class="line"><span class="comment">//import io.netty.handler.codec.http.HttpHeaders;</span></span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.LastHttpContent;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.SystemPropertyUtil;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:yangyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 9:15 on 2017/5/28.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDownloadHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> readingChunks = <span class="keyword">false</span>; <span class="comment">// 分块读取开关</span></span><br><span class="line">    <span class="keyword">private</span> FileOutputStream fOutputStream = <span class="keyword">null</span>;<span class="comment">// 文件输出流</span></span><br><span class="line">    <span class="keyword">private</span> File localfile = <span class="keyword">null</span>;<span class="comment">// 下载文件的本地对象</span></span><br><span class="line">    <span class="keyword">private</span> String local = <span class="keyword">null</span>;<span class="comment">// 待下载文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> succCode;<span class="comment">// 状态码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpDownloadHandler</span><span class="params">(String local)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.local = local;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpResponse) &#123;<span class="comment">// response头信息</span></span><br><span class="line">            HttpResponse response = (HttpResponse) msg;</span><br><span class="line">            succCode = response.getStatus().code();</span><br><span class="line">            <span class="keyword">if</span> (succCode == <span class="number">200</span>) &#123;</span><br><span class="line">                setDownLoadFile();<span class="comment">// 设置下载文件</span></span><br><span class="line">                readingChunks = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println("CONTENT_TYPE:"</span></span><br><span class="line">            <span class="comment">// + response.headers().get(HttpHeaders.Names.CONTENT_TYPE));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpContent) &#123;<span class="comment">// response体信息</span></span><br><span class="line">            HttpContent chunk = (HttpContent) msg;</span><br><span class="line">            <span class="keyword">if</span> (chunk <span class="keyword">instanceof</span> LastHttpContent) &#123;</span><br><span class="line">                readingChunks = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuf buffer = chunk.content();</span><br><span class="line">            <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">            <span class="keyword">if</span> (succCode == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (buffer.isReadable()) &#123;</span><br><span class="line">                    buffer.readBytes(dst);</span><br><span class="line">                    fOutputStream.write(dst);</span><br><span class="line">                    buffer.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != fOutputStream) &#123;</span><br><span class="line">                    fOutputStream.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!readingChunks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fOutputStream) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Download done-&gt;"</span>+ localfile.getAbsolutePath());</span><br><span class="line">                fOutputStream.flush();</span><br><span class="line">                fOutputStream.close();</span><br><span class="line">                localfile = <span class="keyword">null</span>;</span><br><span class="line">                fOutputStream = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置本地参数，准备下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDownLoadFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == fOutputStream) &#123;</span><br><span class="line">            local = SystemPropertyUtil.get(<span class="string">"user.dir"</span>) + File.separator +local;</span><br><span class="line">            <span class="comment">//System.out.println(local);</span></span><br><span class="line">            localfile = <span class="keyword">new</span> File(local);</span><br><span class="line">            <span class="keyword">if</span> (!localfile.exists()) &#123;</span><br><span class="line">                localfile.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            fOutputStream = <span class="keyword">new</span> FileOutputStream(localfile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"管道异常："</span> + cause.getMessage());</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里客户端我放的是网络连接，下载的是一副图片，启动服务端和客户端就可以看到这个图片被下载到了工程的根目录下。</p><p><img src="http://img.blog.csdn.net/20170528141403834?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来完成一个使用netty进行文件传输的任务。在实际项目中，文件传输通常采用FTP或者HTTP附件的方式。事实上通过TCP Socket+File的方式进行文件传输也有一定的应用场景，尽管不是主流，但是掌握这种文件传输方式还是比较重要的，特别是针对两个跨主机的JVM进
      
    
    </summary>
    
      <category term="Netty" scheme="https://blog.rickiyang.cn/categories/Netty/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件-activemq实战之消息持久化(六)</title>
    <link href="https://blog.rickiyang.cn/posts/af8467f6.html"/>
    <id>https://blog.rickiyang.cn/posts/af8467f6.html</id>
    <published>2017-03-16T17:02:00.000Z</published>
    <updated>2018-12-04T09:28:26.147Z</updated>
    
    <content type="html"><![CDATA[<p>对于activemq消息的持久化我们在第二节的时候就简单介绍过，今天我们详细的来分析一下activemq的持久化过程以及持久化插件。在生产环境中为确保消息的可靠性，我们肯定的面临持久化消息的问题，今天就一起来攻克他吧。</p><h4 id="1-持久化方式介绍"><a href="#1-持久化方式介绍" class="headerlink" title="1. 持久化方式介绍"></a><strong>1. 持久化方式介绍</strong></h4><p>前面我们也简单提到了activemq提供的插件式的消息存储，在这里再提一下，主要有以下几种方式：</p><ol><li>AMQ消息存储-基于文件的存储方式，是activemq开始的版本默认的消息存储方式；</li><li>KahaDB消息存储-提供了容量的提升和恢复能力，是现在的默认存储方式；</li><li>JDBC消息存储-消息基于JDBC存储的；</li><li>Memory消息存储-基于内存的消息存储，由于内存不属于持久化范畴，而且如果使用内存队列，可以考虑使用更合适的产品，如ZeroMQ。所以内存存储不在讨论范围内。</li></ol><p>上面几种消息存储方式对于消息存储的逻辑来说并没有什么区别，只是在性能以及存储方式上来说有所不同。但是对于消息发送的方式来说，p2p和Pub/Sub两种类型的消息他们的持久化方式却是不同的：</p><p>对于点对点的消息一旦消费者完成消费这条消息将从broker上删除；对于发布订阅类型的消息，即使所有的订阅者都完成了消费，Broker也不一定会马上删除无用消息，而是保留推送历史，之后会异步清除无用消息。而每个订阅者消费到了哪条消息的offset会记录在Broker，以免下次重复消费。因为消息是顺序消费，先进先出，所以只需要记录上次消息消费到哪里就可以了。</p><p>因为AMQ现在已经被不再使用被KahaDB所替代，所以我们就讲KahaDB，JDBC消息存储在许多对可靠性要求高而对性能要求低一些的大公司还是经常使用的，下面我们就这两种持久化方式的使用做一节专题。</p><h4 id="2-Kahadb"><a href="#2-Kahadb" class="headerlink" title="2. Kahadb"></a><strong>2. Kahadb</strong></h4><p>说到Kahadb之前我们还是得提到他的前身AMQ，AMQ是一种文件存储形式，他具有写入速度快和容易恢复的特点，消息存储在一个个的文件里，文件默认大小为32M，超过这个大小的消息将会存入下一个文件。当一个文件中的消息已经全部消费，那么这个文件将被标志我可删除，在下一个清除阶段这个文件将被删除。</p><p>如果需要使用持久化，则需要在前文中的配置文件applicationContext-ActiveMQ.xml中增加如下配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;</span><br><span class="line">&lt;amqPersistenceAdapterdirectory=<span class="string">"activemq-data"</span>maxFileLength=<span class="string">"32mb"</span>/&gt;</span><br><span class="line">&lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>directory : 指定持久化消息的存储目录<br>journalMaxFileLength : 指定保存消息的日志文件大小，具体根据你的实际应用配置 　</p><p>我们的Kahadb也是基于文件的本地数据库存储形式，他虽然没有AMQ快，但是扩展性很强，从activemq5.4版本之后就把Kahadb作为默认的持久化方式。</p><p>Kahadb的配置方式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;  </span><br><span class="line">   &lt;kahaDB directory=<span class="string">"activemq-data"</span>journalMaxFileLength=<span class="string">"32mb"</span>/&gt;  </span><br><span class="line">&lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>KahaDB的属性件下表格：</p><table><br><tr style="background-color: #737373"><br>    <td>属性名称</td><br>    <td>属性值</td><br>    <td>描述</td><br></tr><br><tr><br>    <td>directory</td><br>    <td>activemq-data</td><br>    <td>消息文件和日志的存储目录</td><br></tr><br><tr><br>    <td>indexWriteBatchSize</td><br>    <td>1000</td><br>    <td>一批索引的大小，当要更新的索引量到达这个值时，更新到消息文件中</td><br></tr><br><tr><br>    <td>indexCacheSize</td><br>    <td>1000</td><br>    <td>内存中，索引的页大小</td><br></tr><br><tr><br>    <td>enableIndexWriteAsync</td><br>    <td>false</td><br>    <td>索引是否异步写到消息文件中</td><br></tr><br><tr><br>    <td>journalMaxFileLength</td><br>    <td>32mb</td><br>    <td>一个消息文件的大小</td><br></tr><br><tr><br>    <td>enableJournalDiskSyncs</td><br>    <td>true</td><br>    <td>是否讲非事务的消息同步写入到磁盘</td><br></tr><br><tr><br>    <td>cleanupInterval</td><br>    <td>30000</td><br>    <td>清除操作周期，单位ms</td><br></tr><br><tr><br>    <td>checkpointInterval</td><br>    <td>5000</td><br>    <td>索引写入到消息文件的周期，单位ms</td><br></tr><br><tr><br>    <td>ignoreMissingJournalfiles</td><br>    <td>false</td><br>    <td>忽略丢失的消息文件，false，当丢失了消息文件，启动异常</td><br></tr><br><tr><br>    <td>checkForCorruptJournalFiles</td><br>    <td>false</td><br>    <td>检查消息文件是否损坏，true，检查发现损坏会尝试修复</td><br></tr><br><tr><br>    <td>checksumJournalFiles</td><br>    <td>false</td><br>    <td>产生一个checksum，以便能够检测journal文件是否损坏。</td><br></tr><br><tr><br>    <td>5.4版本之后有效的属性:</td><br>    <td></td><br>    <td></td><br></tr><br><tr><br>    <td>archiveDataLogs</td><br>    <td>false</td><br>    <td>当为true时，归档的消息文件被移到directoryArchive,而不是直接删除</td><br></tr><br><tr><br>    <td>directoryArchive</td><br>    <td>null</td><br>    <td>存储被归档的消息文件目录</td><br></tr><br><tr><br>    <td>databaseLockedWaitDelay</td><br>    <td>10000</td><br>    <td>在使用负载时，等待获得文件锁的延迟时间，单位ms</td><br></tr><br><tr><br>    <td>maxAsyncJobs</td><br>    <td>10000</td><br>    <td>同个生产者产生等待写入的异步消息最大量</td><br></tr><br><tr><br>    <td>concurrentStoreAndDispatchTopics</td><br>    <td>false</td><br>    <td>当写入消息的时候，是否转发主题消息</td><br></tr><br><tr><br>    <td>concurrentStoreAndDispatchQueues</td><br>    <td>true</td><br>    <td>当写入消息的时候，是否转发队列消息</td><br></tr><br><tr><br>    <td>5.6版本之后有效的属性:</td><br>    <td></td><br>    <td></td><br></tr><br><tr><br>    <td>archiveCorruptedIndex</td><br>    <td>false</td><br>    <td>是否归档错误的索引</td><br></tr><br></table><p>由于在ActiveMQ V5.4+的版本中，KahaDB是默认的持久化存储方案。所以即使你不配置任何的KahaDB参数信息，ActiveMQ也会启动KahaDB。这种情况下，KahaDB文件所在位置是你的ActiveMQ安装路径下的/data/${broker.Name}/KahaDB子目录。其中${broker.Name}代表这个ActiveMQ服务节点的名称。下面我把刚启动服务并发送了消息之后的activemq安装目录打开给大家看看：</p><p><img src="http://img.blog.csdn.net/20170512000936999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>正式的生产环境还是建议在主配置文件中明确设置KahaDB的工作参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"broker"</span> persistent=<span class="string">"true"</span> useShutdownHook=<span class="string">"false"</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;persistenceAdapter&gt;</span><br><span class="line">    &lt;kahaDB directory=<span class="string">"activemq-data"</span></span><br><span class="line">            journalMaxFileLength=<span class="string">"32mb"</span></span><br><span class="line">            concurrentStoreAndDispatchQueues=<span class="string">"false"</span></span><br><span class="line">            concurrentStoreAndDispatchTopics=<span class="string">"false"</span></span><br><span class="line">            /&gt;</span><br><span class="line">  &lt;/persistenceAdapter&gt;</span><br><span class="line">&lt;/broker&gt;</span><br></pre></td></tr></table></figure><h4 id="3-关系型数据库存储方案"><a href="#3-关系型数据库存储方案" class="headerlink" title="3. 关系型数据库存储方案"></a><strong>3. 关系型数据库存储方案</strong></h4><p>从ActiveMQ 4+版本开始，ActiveMQ就支持使用关系型数据库进行持久化存储——通过JDBC实现的数据库连接。可以使用的关系型数据库囊括了目前市面的主流数据库。</p><p>使用JDBC的方式持久化我们就得修改之前的配置文件：</p><p>将其中的这段配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;</span><br><span class="line">    &lt;kahaDB directory=<span class="string">"$&#123;activemq.base&#125;/data/kahadb"</span>/&gt;</span><br><span class="line">&lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>修改为下面这段内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;</span><br><span class="line">       &lt;jdbcPersistenceAdapter  dataSource=<span class="string">"# mysql-ds "</span>/&gt;</span><br><span class="line">&lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>在结点之后，增加数据源的配置,如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MySql DataSource Sample Setup --&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"mysql-ds"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/activemqdb?relaxAutoCommit=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">        </span><br><span class="line">&lt;!-- Oracle DataSource Sample Setup --&gt;        </span><br><span class="line">&lt;bean id=<span class="string">"oracle-ds"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"oracle.jdbc.driver.OracleDriver"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:oracle:thin:@localhost:1521:activemqdb"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- Oracle DataSource Sample Setup --&gt; </span><br><span class="line">&lt;bean id=<span class="string">"db2-ds"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>  destroy-method=<span class="string">"close"</span>&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"com.ibm.db2.jcc.DB2Driver"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:db2://hndb02.bf.ctc.com:50002/activemq"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"maxActive"</span> value=<span class="string">"200"</span>/&gt;  </span><br><span class="line">      &lt;property name=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt; </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">还是在上一篇的实例工程中，我们改变一下applicationContext-ActiveMQ.xml的配置如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:amq=<span class="string">"http://activemq.apache.org/schema/core"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core</span></span><br><span class="line"><span class="string">http://activemq.apache.org/schema/core/activemq-core-5.12.1.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.edu.hust.activemq"</span> /&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;amq:connectionFactory id=<span class="string">"amqConnectionFactory"</span></span><br><span class="line">                           brokerURL=<span class="string">"tcp://127.0.0.1:61616"</span></span><br><span class="line">                           userName=<span class="string">"admin"</span></span><br><span class="line">                           password=<span class="string">"admin"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS连接工厂 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"connectionFactory"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"amqConnectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"sessionCacheSize"</span> value=<span class="string">"100"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义消息队列（Queue） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"demoQueueDestination"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span><br><span class="line">        &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;first-queue&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"jmsTemplate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"defaultDestination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"receiveTimeout"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">        &lt;!-- <span class="keyword">true</span>是topic，<span class="keyword">false</span>是queue，默认是<span class="keyword">false</span>，此处显示写出<span class="keyword">false</span> --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"pubSubDomain"</span> value=<span class="string">"false"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置消息队列监听者（Queue） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueMessageListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.edu.hust.activemq.filter.QueueMessageListener"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 显示注入消息监听容器（Queue），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueListenerContainer"</span></span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"demoQueueDestination"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"queueMessageListener"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> brokerName=<span class="string">"localhost"</span> dataDirectory=<span class="string">"$&#123;activemq.data&#125;"</span> persistent=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;!--&lt;persistenceAdapter&gt;</span><br><span class="line">             &lt;kahaDB directory=<span class="string">"$&#123;activemq.data&#125;/kahadb"</span>/&gt;</span><br><span class="line">         &lt;/persistenceAdapter&gt; --&gt;</span><br><span class="line">        &lt;persistenceAdapter&gt;</span><br><span class="line">            &lt;jdbcPersistenceAdapter dataDirectory=<span class="string">"$&#123;activemq.data&#125;"</span> dataSource=<span class="string">"#mysql-ds"</span>&gt;</span><br><span class="line">            &lt;/jdbcPersistenceAdapter&gt;</span><br><span class="line">        &lt;/persistenceAdapter&gt;</span><br><span class="line">    &lt;/broker&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"mysql-ds"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://127.0.0.1/activemq?relaxAutoCommit=true"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"password"</span> value=<span class="string">"123456"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"maxActive"</span> value=<span class="string">"200"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"poolPreparedStatements"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>此时，重新启动MQ，就会发现db数据库中多了三张表：activemq_acks，activemq_lock，activemq_msgs，OK，说明activemq已经持久化成功啦！</p><p><img src="http://img.blog.csdn.net/20170512001107632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ol><li><p><strong>activemq_acks</strong>：用于存储订阅关系。如果是持久化Topic，订阅者和服务器的订阅关系在这个表保存，主要数据库字段如下：</p><ul><li>container：消息的destination </li><li>sub_dest：如果是使用static集群，这个字段会有集群其他系统的信息 </li><li>client_id：每个订阅者都必须有一个唯一的客户端id用以区分 </li><li>sub_name：订阅者名称 </li><li>selector：选择器，可以选择只消费满足条件的消息。条件可以用自定义属性实现，可支持多属性and和or操作 </li><li>last_acked_id：记录消费过的消息的id</li></ul></li></ol><ol start="2"><li><strong>activemq_lock</strong>：在集群环境中才有用，只有一个Broker可以获得消息，称为Master Broker，其他的只能作为备份等待Master Broker不可用，才可能成为下一个Master Broker。这个表用于记录哪个Broker是当前的Master Broker。</li><li><p><strong>activemq_msgs</strong>：用于存储消息，Queue和Topic都存储在这个表中。主要的数据库字段如下：</p><ul><li>id：自增的数据库主键 </li><li>container：消息的destination </li><li>msgid_prod：消息发送者客户端的主键 </li><li>msg_seq：是发送消息的顺序，msgid_prod+msg_seq可以组成jms的messageid </li><li>expiration：消息的过期时间，存储的是从1970-01-01到现在的毫秒数 </li><li>msg：消息本体的java序列化对象的二进制数据 </li><li>priority：优先级，从0-9，数值越大优先级越高 </li><li>activemq_acks用于存储订阅关系。如果是持久化topic，订阅者和服务器的订阅关系在这个表保存。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于activemq消息的持久化我们在第二节的时候就简单介绍过，今天我们详细的来分析一下activemq的持久化过程以及持久化插件。在生产环境中为确保消息的可靠性，我们肯定的面临持久化消息的问题，今天就一起来攻克他吧。&lt;/p&gt;
&lt;h4 id=&quot;1-持久化方式介绍&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="activeMQ" scheme="https://blog.rickiyang.cn/categories/activeMQ/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（二）----创建并运行java线程</title>
    <link href="https://blog.rickiyang.cn/posts/c845f6f3.html"/>
    <id>https://blog.rickiyang.cn/posts/c845f6f3.html</id>
    <published>2017-03-15T17:02:01.000Z</published>
    <updated>2018-12-04T09:28:26.137Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-实现线程的两种方式"><a href="#1-实现线程的两种方式" class="headerlink" title="1 实现线程的两种方式"></a>1 实现线程的两种方式</h4><p>上一节我们了解了关于线程的一些基本知识，下面我们正式进入多线程的实现环节。实现线程常用的有两种方式，一种是继承Thread类，一种是实现Runnable接口。当然还有第三种方式，那就是通过线程池来生成线程，后面我们还会学习，一步一个脚印打好基础。</p><p>Runnable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();      </span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面为Thread类和Runnable类的源码，我们可以看到Thread类也是实现了Runnable接口，即Thread是Runnable的实现，那么他们到底在实现多线程上有什么区别呢？</p><p>Thread和Runnable解析：</p><p> ①Runnable接口：</p><p>Runnable接口是java中线程的定义类。所有线程都是通过该接口来实现，该接口中的run（）方法为实现方法，即线程所要实现的内容写入该方法里面，当线程启动时会调用该方法。<br>在大多数情况下，如果只想重写run（）方法而不重写其他方法，应使用Runnable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new了两个线程对象——s1和s2</span></span><br><span class="line">        <span class="comment">//其中两个对象各对应一个内存区域。线程运行过程中运行都是自己内存块中的数据</span></span><br><span class="line">        Shop1 s1 = <span class="keyword">new</span> Shop1(<span class="string">"小武"</span>);</span><br><span class="line">        s1.start();</span><br><span class="line">        </span><br><span class="line">        Shop1 s2 = <span class="keyword">new</span> Shop1(<span class="string">"小潘"</span>);</span><br><span class="line">        s2.start();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //实例化了两个线程对象，所以分配了两块内存空间</span></span><br><span class="line"><span class="comment">        //执行过程中操作的是自己的内存空间</span></span><br><span class="line"><span class="comment">        Shop2 s3 = new Shop2("小武");</span></span><br><span class="line"><span class="comment">        s3.run();</span></span><br><span class="line"><span class="comment">        Shop2 s4 = new Shop2("小潘");</span></span><br><span class="line"><span class="comment">        s4.run();</span></span><br><span class="line"><span class="comment">        //实际实例化了两个线程对象</span></span><br><span class="line"><span class="comment">        //所以同样分配两个内存空间</span></span><br><span class="line"><span class="comment">        Thread t1 = new Thread(new Shop2("小武"));</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        Thread t2 = new Thread(new Shop2("小潘"));</span></span><br><span class="line"><span class="comment">        t2.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//创建了两个线程对象，但是使用的是同一个对象——s6</span></span><br><span class="line">        Shop2 s5 = <span class="keyword">new</span> Shop2(<span class="string">"w"</span>);</span><br><span class="line">        Shop1 s6 = <span class="keyword">new</span> Shop1(<span class="string">"T"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(s6);</span><br><span class="line">        t3.start();</span><br><span class="line">        </span><br><span class="line">        Thread t4 =<span class="keyword">new</span> Thread(s6);</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 武大郎卖烧饼（因为业务的拓展，现在可以实现多窗口的出售）</span></span><br><span class="line"><span class="comment"> * 要求：每天只卖10个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shop1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//private int count = 10;</span></span><br><span class="line">    <span class="comment">//使用静态变量可以有效的实现资源共享（因为在内存中只有一份count）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shop1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否已经卖完</span></span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() +<span class="string">"卖出了一个烧饼"</span> + <span class="string">",现在剩余"</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用接口实现上面的代码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shop2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量，存储剩余烧饼的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//存储当前人的姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shop2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name  = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现销售的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否已经卖完</span></span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"、"</span> + <span class="keyword">this</span>.name +<span class="string">"卖出了一个烧饼"</span> + <span class="string">",现在剩余"</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②Thread类：</p><p>Thread类是Runnable接口的实现，jdk给我们提供了一个不用我们去想如何实现线程的方式供我们使用。同样你在继承Thread类的时候也需要重写run()方法来实现你想在线程中实现的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//传统方式——单任务方式</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            SimpleClass sc1 = new SimpleClass();</span></span><br><span class="line"><span class="comment">            sc1.say("Mike");</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            SimpleClass sc2 = new SimpleClass();</span></span><br><span class="line"><span class="comment">            sc2.say("Han Meimei");</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//创建一个线程</span></span><br><span class="line">            ThreadClass tc1 = <span class="keyword">new</span> ThreadClass(<span class="string">"Mike"</span>);</span><br><span class="line">            <span class="comment">//启动线程</span></span><br><span class="line">            tc1.start();</span><br><span class="line">            <span class="comment">//创建一个线程</span></span><br><span class="line">            ThreadClass tc2 = <span class="keyword">new</span> ThreadClass(<span class="string">"Han Meimei"</span>);</span><br><span class="line">            tc2.start();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hi,Im "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadClass</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将父类（Thread）的run()方法进行重写</span></span><br><span class="line"><span class="comment">     * 在run()方法中包含了需要执行的代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hi,Im "</span> + <span class="keyword">this</span>.getName() + <span class="string">"|"</span> + <span class="keyword">this</span>.getId() +    </span><br><span class="line">            <span class="string">"|"</span> + <span class="keyword">this</span>.getStackTrace());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类中常用方法：</p><ol><li>run()：如果该线程时使用独立的Runnable运行对象构造的，则调用该Runnable对象的run方法。否则，该方法不执行任何操作并返回。</li><li>sleep(longmillls):在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</li><li>yield():暂停当前正在执行的线程对象，并执行其他线程  start()：使该线程开始运行，java虚拟机再调用该线程的run方法 。</li><li>join():等待该线程结束。</li></ol><p><strong>对比：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面给出了Thread和Runnable的实现，我们能看到在使用Runnable的方式实现线程的过程中：</span><br><span class="line"></span><br><span class="line">Shop1 s6 = <span class="keyword">new</span> Shop1(<span class="string">"T"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(s6);</span><br><span class="line">t3.start();</span><br></pre></td></tr></table></figure><p>即把Runnable对象（实现了Runnable接口的对象）还是塞进了Thread中让Thread来实现。那么我们可以new 多个Thread来实现同一个Runnbale对象，即实现了资源的共享，比如在售票系统中多名用户对同一种票的抢购。另一方面，java是单继承多实现的，如果我们使用Thread的话意味着该类只能继承Thread，对于程序的扩展不利，而实现Runnbale接口则没有这个顾虑。考虑程序的健壮性，我们应该尽量使用Runnable来实现我们的线程。</p><h4 id="run和start"><a href="#run和start" class="headerlink" title="run和start"></a>run和start</h4><p>初学多线程我们总是分不清楚run()方法和start()方法的区别，其实我们再看一下上面Thread类的源码就不难发现他们的用法是很容易区分的：</p><ol><li><p>run()方法是线程的实现方法，即你需要线程去做什么事情，那么这些实现的内容写在run()里面，当线程启动时就会调用run()方法继而实现run()内部的代码；</p></li><li><p>start()方法是线程的启动方法，即如果你new Thread()这样并不算完。你还得new Thread().start()才算启动这个线程，启动完之后线程内部会主动的调用run()方法执行该线程的业务逻辑代码。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-实现线程的两种方式&quot;&gt;&lt;a href=&quot;#1-实现线程的两种方式&quot; class=&quot;headerlink&quot; title=&quot;1 实现线程的两种方式&quot;&gt;&lt;/a&gt;1 实现线程的两种方式&lt;/h4&gt;&lt;p&gt;上一节我们了解了关于线程的一些基本知识，下面我们正式进入多线程的实现
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://blog.rickiyang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（一）----线程基础知识</title>
    <link href="https://blog.rickiyang.cn/posts/ac18980b.html"/>
    <id>https://blog.rickiyang.cn/posts/ac18980b.html</id>
    <published>2017-03-15T17:02:00.000Z</published>
    <updated>2018-12-05T06:16:19.834Z</updated>
    
    <content type="html"><![CDATA[<p>在任何的生产环境中我们都不可逃避并发这个问题，多线程作为并发问题的技术支持让我们不得不去了解。这一块知识就像一个大蛋糕一样等着我们去分享，抱着学习的心态，记录下自己对并发的认识。</p><p>###1.线程的状态：<br>线程状态图：<br>    <img src="http://img.blog.csdn.net/20161214214726030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTk1MzcxMzQyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="线程状态图"><br>    1、新建状态（New）：新创建了一个线程对象。<br>    2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。<br>    3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。<br>    4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<br>    （一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。<br>    （二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。<br>    （三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。<br>    5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p><p>###2.线程调度<br>2.1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：<br>static int MAX_PRIORITY<br>线程可以具有的最高优先级，取值为10。<br>static int MIN_PRIORITY<br>线程可以具有的最低优先级，取值为1。<br>static int NORM_PRIORITY<br>分配给线程的默认优先级，取值为5。<br>Thread类的<code>setPriority()</code>和<code>getPriority()</code>方法分别用来设置和获取线程的优先级。<br>每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。<br>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。<br>JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。</p><p>###3.线程基本方法使用说明：<br>-线程睡眠：Thread.sleep(longmillis)，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。<br>-线程等待：Object类中的wait()，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。<br>-线程让步：Thread.yield()，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。<br>-线程加入：join()，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。<br>-线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。<br> <strong><em>注意</em></strong>：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p><p><strong>Java 中的线程可以分为<em>守护线程</em>(Daemon Thread) 和<em>用户线程</em>( User Thread) 。用户线程会阻止JVM 的正常停止，即JVM 正常停止前应用程序中的所有用户线程必须先停止完毕,否则JVM 无法停止。而守护线程则不会影响JVM 的正常停止，即应用程序中有守护线程在运行也不影响JVM 的正常停止。因此，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在任何的生产环境中我们都不可逃避并发这个问题，多线程作为并发问题的技术支持让我们不得不去了解。这一块知识就像一个大蛋糕一样等着我们去分享，抱着学习的心态，记录下自己对并发的认识。&lt;/p&gt;
&lt;p&gt;###1.线程的状态：&lt;br&gt;线程状态图：&lt;br&gt;    &lt;img src=&quot;h
      
    
    </summary>
    
      <category term="多线程与并发编程" scheme="https://blog.rickiyang.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="学习" scheme="https://blog.rickiyang.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
